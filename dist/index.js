#!/usr/bin/env node
import * as path3 from 'path';
import { dirname, join } from 'path';
import { fileURLToPath } from 'url';
import { z } from 'zod';
import { randomUUID, createHash } from 'crypto';
import { readFileSync, promises } from 'fs';
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { ListToolsRequestSchema, CallToolRequestSchema } from '@modelcontextprotocol/sdk/types.js';

var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var init_esm_shims = __esm({
  "node_modules/tsup/assets/esm_shims.js"() {
  }
});

// src/tools/thinking.ts
var thinking_exports = {};
__export(thinking_exports, {
  ThinkingToolSchema: () => ThinkingToolSchema,
  thinkingTool: () => thinkingTool
});
var ThinkingToolSchema, thinkingTool;
var init_thinking = __esm({
  "src/tools/thinking.ts"() {
    init_esm_shims();
    ThinkingToolSchema = z.object({
      sessionId: z.string().optional(),
      mode: z.enum(["sequential", "shannon", "mathematics", "physics", "hybrid", "inductive", "deductive", "abductive", "causal", "bayesian", "counterfactual", "analogical", "temporal", "gametheory", "evidential", "firstprinciples", "systemsthinking", "scientificmethod", "optimization", "formallogic"]).default("hybrid"),
      thought: z.string(),
      thoughtNumber: z.number().int().positive(),
      totalThoughts: z.number().int().positive(),
      nextThoughtNeeded: z.boolean(),
      isRevision: z.boolean().optional(),
      revisesThought: z.string().optional(),
      revisionReason: z.string().optional(),
      branchFrom: z.string().optional(),
      branchId: z.string().optional(),
      stage: z.enum(["problem_definition", "constraints", "model", "proof", "implementation"]).optional(),
      uncertainty: z.number().min(0).max(1).optional(),
      dependencies: z.array(z.string()).optional(),
      assumptions: z.array(z.string()).optional(),
      thoughtType: z.string().optional(),
      mathematicalModel: z.object({
        latex: z.string(),
        symbolic: z.string(),
        ascii: z.string().optional()
      }).optional(),
      proofStrategy: z.object({
        type: z.enum(["direct", "contradiction", "induction", "construction", "contrapositive"]),
        steps: z.array(z.string())
      }).optional(),
      tensorProperties: z.object({
        rank: z.tuple([z.number(), z.number()]),
        components: z.string(),
        latex: z.string(),
        symmetries: z.array(z.string()),
        invariants: z.array(z.string()),
        transformation: z.enum(["covariant", "contravariant", "mixed"])
      }).optional(),
      physicalInterpretation: z.object({
        quantity: z.string(),
        units: z.string(),
        conservationLaws: z.array(z.string())
      }).optional(),
      // Inductive reasoning properties (Phase 5, v5.0.0)
      pattern: z.string().optional(),
      generalization: z.string().optional(),
      confidence: z.number().min(0).max(1).optional(),
      counterexamples: z.array(z.string()).optional(),
      sampleSize: z.number().int().min(1).optional(),
      // Deductive reasoning properties (Phase 5, v5.0.0)
      premises: z.array(z.string()).optional(),
      logicForm: z.string().optional(),
      validityCheck: z.boolean().optional(),
      soundnessCheck: z.boolean().optional(),
      // Abductive reasoning properties (v2.0)
      observations: z.union([
        z.array(z.string()),
        // For inductive reasoning - simple strings
        z.array(z.object({
          // For abductive reasoning - structured objects
          id: z.string(),
          description: z.string(),
          confidence: z.number().min(0).max(1)
        }))
      ]).optional(),
      hypotheses: z.array(z.object({
        id: z.string(),
        // Abductive fields
        explanation: z.string().optional(),
        assumptions: z.array(z.string()).optional(),
        predictions: z.array(z.string()).optional(),
        score: z.number().optional(),
        // Evidential fields
        name: z.string().optional(),
        description: z.string().optional(),
        mutuallyExclusive: z.boolean().optional(),
        subsets: z.array(z.string()).optional()
      })).optional(),
      evaluationCriteria: z.object({
        parsimony: z.number(),
        explanatoryPower: z.number(),
        plausibility: z.number(),
        testability: z.boolean()
      }).optional(),
      evidence: z.array(z.object({
        id: z.string(),
        description: z.string(),
        // Abductive fields
        hypothesisId: z.string().optional(),
        type: z.enum(["supporting", "contradicting", "neutral"]).optional(),
        strength: z.number().min(0).max(1).optional(),
        // Evidential fields
        source: z.string().optional(),
        reliability: z.number().min(0).max(1).optional(),
        timestamp: z.number().optional(),
        supports: z.array(z.string()).optional(),
        contradicts: z.array(z.string()).optional()
      })).optional(),
      bestExplanation: z.object({
        id: z.string(),
        explanation: z.string(),
        assumptions: z.array(z.string()),
        predictions: z.array(z.string()),
        score: z.number()
      }).optional(),
      // Causal reasoning properties (v2.0)
      causalGraph: z.object({
        nodes: z.array(z.object({
          id: z.string(),
          name: z.string(),
          type: z.enum(["cause", "effect", "mediator", "confounder"]),
          description: z.string()
        })),
        edges: z.array(z.object({
          from: z.string(),
          to: z.string(),
          strength: z.number(),
          confidence: z.number().min(0).max(1)
        }))
      }).optional(),
      interventions: z.array(z.object({
        nodeId: z.string(),
        action: z.string(),
        expectedEffects: z.array(z.object({
          nodeId: z.string(),
          expectedChange: z.string(),
          confidence: z.number()
        }))
      })).optional(),
      mechanisms: z.array(z.object({
        from: z.string(),
        to: z.string(),
        description: z.string(),
        type: z.enum(["direct", "indirect", "feedback"])
      })).optional(),
      confounders: z.array(z.object({
        nodeId: z.string(),
        affects: z.array(z.string()),
        description: z.string()
      })).optional(),
      // Bayesian reasoning properties (v2.0)
      hypothesis: z.object({
        id: z.string(),
        statement: z.string()
      }).optional(),
      prior: z.object({
        probability: z.number().min(0).max(1),
        justification: z.string()
      }).optional(),
      likelihood: z.object({
        probability: z.number().min(0).max(1),
        description: z.string()
      }).optional(),
      posterior: z.object({
        probability: z.number().min(0).max(1),
        calculation: z.string()
      }).optional(),
      bayesFactor: z.number().optional(),
      // Counterfactual reasoning properties (v2.0)
      actual: z.object({
        id: z.string(),
        name: z.string(),
        description: z.string(),
        conditions: z.array(z.object({
          factor: z.string(),
          value: z.string()
        })),
        outcomes: z.array(z.object({
          description: z.string(),
          impact: z.enum(["positive", "negative", "neutral"]),
          magnitude: z.number().optional()
        }))
      }).optional(),
      counterfactuals: z.array(z.object({
        id: z.string(),
        name: z.string(),
        description: z.string(),
        conditions: z.array(z.object({
          factor: z.string(),
          value: z.string()
        })),
        outcomes: z.array(z.object({
          description: z.string(),
          impact: z.enum(["positive", "negative", "neutral"]),
          magnitude: z.number().optional()
        }))
      })).optional(),
      comparison: z.object({
        differences: z.array(z.object({
          aspect: z.string(),
          actual: z.string(),
          counterfactual: z.string(),
          significance: z.enum(["high", "medium", "low"])
        })),
        insights: z.array(z.string()),
        lessons: z.array(z.string())
      }).optional(),
      interventionPoint: z.object({
        description: z.string(),
        alternatives: z.array(z.string())
      }).optional(),
      causalChains: z.array(z.object({
        intervention: z.string(),
        steps: z.array(z.string()),
        finalOutcome: z.string()
      })).optional(),
      // Analogical reasoning properties (v2.0)
      sourceDomain: z.object({
        id: z.string(),
        name: z.string(),
        description: z.string(),
        entities: z.array(z.object({
          id: z.string(),
          name: z.string(),
          type: z.string()
        })),
        relations: z.array(z.object({
          id: z.string(),
          type: z.string(),
          from: z.string(),
          to: z.string()
        }))
      }).optional(),
      targetDomain: z.object({
        id: z.string(),
        name: z.string(),
        description: z.string(),
        entities: z.array(z.object({
          id: z.string(),
          name: z.string(),
          type: z.string()
        })),
        relations: z.array(z.object({
          id: z.string(),
          type: z.string(),
          from: z.string(),
          to: z.string()
        }))
      }).optional(),
      mapping: z.array(z.object({
        sourceEntityId: z.string(),
        targetEntityId: z.string(),
        justification: z.string(),
        confidence: z.number().min(0).max(1)
      })).optional(),
      insights: z.array(z.object({
        description: z.string(),
        sourceEvidence: z.string(),
        targetApplication: z.string()
      })).optional(),
      inferences: z.array(z.object({
        sourcePattern: z.string(),
        targetPrediction: z.string(),
        confidence: z.number().min(0).max(1),
        needsVerification: z.boolean()
      })).optional(),
      limitations: z.array(z.string()).optional(),
      analogyStrength: z.number().min(0).max(1).optional(),
      // Temporal reasoning properties (Phase 3, v2.1)
      timeline: z.object({
        id: z.string(),
        name: z.string(),
        timeUnit: z.enum(["milliseconds", "seconds", "minutes", "hours", "days", "months", "years"]),
        startTime: z.number().optional(),
        endTime: z.number().optional(),
        events: z.array(z.string())
      }).optional(),
      events: z.array(z.object({
        id: z.string(),
        name: z.string(),
        description: z.string(),
        timestamp: z.number(),
        duration: z.number().optional(),
        type: z.enum(["instant", "interval"]),
        properties: z.record(z.string(), z.any())
      })).optional(),
      intervals: z.array(z.object({
        id: z.string(),
        name: z.string(),
        start: z.number(),
        end: z.number(),
        overlaps: z.array(z.string()).optional(),
        contains: z.array(z.string()).optional()
      })).optional(),
      constraints: z.array(z.object({
        id: z.string(),
        type: z.enum(["before", "after", "during", "overlaps", "meets", "starts", "finishes", "equals"]),
        subject: z.string(),
        object: z.string(),
        confidence: z.number().min(0).max(1)
      })).optional(),
      relations: z.array(z.object({
        id: z.string(),
        from: z.string(),
        to: z.string(),
        relationType: z.enum(["causes", "enables", "prevents", "precedes", "follows"]),
        strength: z.number().min(0).max(1),
        delay: z.number().optional()
      })).optional(),
      // Game theory properties (Phase 3, v2.2)
      game: z.object({
        id: z.string(),
        name: z.string(),
        description: z.string(),
        type: z.enum(["normal_form", "extensive_form", "cooperative", "non_cooperative"]),
        numPlayers: z.number().int().min(2),
        isZeroSum: z.boolean(),
        isPerfectInformation: z.boolean()
      }).optional(),
      players: z.array(z.object({
        id: z.string(),
        name: z.string(),
        role: z.string().optional(),
        isRational: z.boolean(),
        availableStrategies: z.array(z.string())
      })).optional(),
      strategies: z.array(z.object({
        id: z.string(),
        playerId: z.string(),
        name: z.string(),
        description: z.string(),
        isPure: z.boolean(),
        probability: z.number().min(0).max(1).optional()
      })).optional(),
      payoffMatrix: z.object({
        players: z.array(z.string()),
        dimensions: z.array(z.number()),
        payoffs: z.array(z.object({
          strategyProfile: z.array(z.string()),
          payoffs: z.array(z.number())
        }))
      }).optional(),
      nashEquilibria: z.array(z.object({
        id: z.string(),
        strategyProfile: z.array(z.string()),
        payoffs: z.array(z.number()),
        type: z.enum(["pure", "mixed"]),
        isStrict: z.boolean(),
        stability: z.number().min(0).max(1)
      })).optional(),
      dominantStrategies: z.array(z.object({
        playerId: z.string(),
        strategyId: z.string(),
        type: z.enum(["strictly_dominant", "weakly_dominant"]),
        dominatesStrategies: z.array(z.string()),
        justification: z.string()
      })).optional(),
      gameTree: z.object({
        rootNode: z.string(),
        nodes: z.array(z.object({
          id: z.string(),
          type: z.enum(["decision", "chance", "terminal"]),
          playerId: z.string().optional(),
          parentNode: z.string().optional(),
          childNodes: z.array(z.string()),
          action: z.string().optional(),
          probability: z.number().min(0).max(1).optional(),
          payoffs: z.array(z.number()).optional()
        })),
        informationSets: z.array(z.object({
          id: z.string(),
          playerId: z.string(),
          nodes: z.array(z.string()),
          availableActions: z.array(z.string())
        })).optional()
      }).optional(),
      // Evidential properties (Phase 3, v2.3)
      frameOfDiscernment: z.array(z.string()).optional(),
      beliefFunctions: z.array(z.object({
        id: z.string(),
        source: z.string(),
        massAssignments: z.array(z.object({
          hypothesisSet: z.array(z.string()),
          mass: z.number().min(0).max(1),
          justification: z.string()
        })),
        conflictMass: z.number().optional()
      })).optional(),
      combinedBelief: z.object({
        id: z.string(),
        source: z.string(),
        massAssignments: z.array(z.object({
          hypothesisSet: z.array(z.string()),
          mass: z.number().min(0).max(1),
          justification: z.string()
        })),
        conflictMass: z.number().optional()
      }).optional(),
      plausibility: z.object({
        id: z.string(),
        assignments: z.array(z.object({
          hypothesisSet: z.array(z.string()),
          plausibility: z.number().min(0).max(1),
          belief: z.number().min(0).max(1),
          uncertaintyInterval: z.tuple([z.number(), z.number()])
        }))
      }).optional(),
      decisions: z.array(z.object({
        id: z.string(),
        name: z.string(),
        selectedHypothesis: z.array(z.string()),
        confidence: z.number().min(0).max(1),
        reasoning: z.string(),
        alternatives: z.array(z.object({
          hypothesis: z.array(z.string()),
          expectedUtility: z.number(),
          risk: z.number()
        }))
      })).optional(),
      // First-Principles properties (Phase 3, v3.1.0)
      question: z.string().optional(),
      principles: z.array(z.object({
        id: z.string(),
        type: z.enum(["axiom", "definition", "observation", "logical_inference", "assumption"]),
        statement: z.string(),
        justification: z.string(),
        dependsOn: z.array(z.string()).optional(),
        confidence: z.number().min(0).max(1).optional()
      })).optional(),
      derivationSteps: z.array(z.object({
        stepNumber: z.number().int().positive(),
        principle: z.string(),
        inference: z.string(),
        logicalForm: z.string().optional(),
        confidence: z.number().min(0).max(1)
      })).optional(),
      conclusion: z.union([
        z.string(),
        // For deductive reasoning - simple conclusion
        z.object({
          // For first-principles reasoning - structured conclusion
          statement: z.string(),
          derivationChain: z.array(z.number()),
          certainty: z.number().min(0).max(1),
          limitations: z.array(z.string()).optional()
        })
      ]).optional(),
      alternativeInterpretations: z.array(z.string()).optional(),
      // Systems Thinking properties (Phase 4, v3.2.0)
      system: z.object({
        id: z.string(),
        name: z.string(),
        description: z.string(),
        boundary: z.string(),
        purpose: z.string(),
        timeHorizon: z.string().optional()
      }).optional(),
      components: z.array(z.object({
        id: z.string(),
        name: z.string(),
        type: z.enum(["stock", "flow", "variable", "parameter", "delay"]),
        description: z.string(),
        unit: z.string().optional(),
        initialValue: z.number().optional(),
        formula: z.string().optional(),
        influencedBy: z.array(z.string()).optional()
      })).optional(),
      feedbackLoops: z.array(z.object({
        id: z.string(),
        name: z.string(),
        type: z.enum(["reinforcing", "balancing"]),
        description: z.string(),
        components: z.array(z.string()),
        polarity: z.enum(["+", "-"]),
        strength: z.number().min(0).max(1),
        delay: z.number().optional(),
        dominance: z.enum(["early", "middle", "late"]).optional()
      })).optional(),
      leveragePoints: z.array(z.object({
        id: z.string(),
        name: z.string(),
        location: z.string(),
        description: z.string(),
        effectiveness: z.number().min(0).max(1),
        difficulty: z.number().min(0).max(1),
        type: z.enum(["parameter", "feedback", "structure", "goal", "paradigm"]),
        interventionExamples: z.array(z.string())
      })).optional(),
      behaviors: z.array(z.object({
        id: z.string(),
        name: z.string(),
        description: z.string(),
        pattern: z.enum(["growth", "decline", "oscillation", "equilibrium", "chaos", "overshoot_collapse"]),
        causes: z.array(z.string()),
        timeframe: z.string(),
        unintendedConsequences: z.array(z.string()).optional()
      })).optional(),
      // Scientific Method properties (Phase 4, v3.2.0)
      researchQuestion: z.object({
        id: z.string(),
        question: z.string(),
        background: z.string(),
        rationale: z.string(),
        significance: z.string(),
        variables: z.object({
          independent: z.array(z.string()),
          dependent: z.array(z.string()),
          control: z.array(z.string())
        })
      }).optional(),
      scientificHypotheses: z.array(z.object({
        id: z.string(),
        type: z.enum(["null", "alternative", "directional", "non_directional"]),
        statement: z.string(),
        prediction: z.string(),
        rationale: z.string(),
        testable: z.boolean(),
        falsifiable: z.boolean()
      })).optional(),
      experiment: z.object({
        id: z.string(),
        type: z.enum(["experimental", "quasi_experimental", "observational", "correlational"]),
        design: z.string(),
        sampleSize: z.number().int().positive(),
        sampleSizeJustification: z.string().optional(),
        randomization: z.boolean(),
        blinding: z.enum(["none", "single", "double", "triple"]).optional(),
        controls: z.array(z.string()),
        procedure: z.array(z.string()),
        materials: z.array(z.string()).optional(),
        duration: z.string().optional(),
        ethicalConsiderations: z.array(z.string()).optional()
      }).optional(),
      dataCollection: z.object({
        id: z.string(),
        method: z.array(z.string()),
        instruments: z.array(z.string()),
        dataQuality: z.object({
          completeness: z.number().min(0).max(1),
          reliability: z.number().min(0).max(1),
          validity: z.number().min(0).max(1)
        }),
        limitations: z.array(z.string()).optional()
      }).optional(),
      statisticalAnalysis: z.object({
        id: z.string(),
        tests: z.array(z.object({
          id: z.string(),
          name: z.string(),
          hypothesisTested: z.string(),
          testStatistic: z.number(),
          pValue: z.number().min(0).max(1),
          confidenceInterval: z.tuple([z.number(), z.number()]).optional(),
          alpha: z.number().min(0).max(1),
          result: z.enum(["reject_null", "fail_to_reject_null"]),
          interpretation: z.string()
        })),
        summary: z.string(),
        effectSize: z.object({
          type: z.string(),
          value: z.number(),
          interpretation: z.string()
        }).optional(),
        powerAnalysis: z.object({
          power: z.number().min(0).max(1),
          alpha: z.number().min(0).max(1),
          interpretation: z.string()
        }).optional()
      }).optional(),
      scientificConclusion: z.object({
        id: z.string(),
        statement: z.string(),
        supportedHypotheses: z.array(z.string()),
        rejectedHypotheses: z.array(z.string()),
        confidence: z.number().min(0).max(1),
        limitations: z.array(z.string()),
        alternativeExplanations: z.array(z.string()).optional(),
        futureDirections: z.array(z.string()),
        replicationConsiderations: z.array(z.string()),
        practicalImplications: z.array(z.string()).optional(),
        theoreticalImplications: z.array(z.string()).optional()
      }).optional(),
      // Optimization properties (Phase 4, v3.2.0)
      optimizationProblem: z.object({
        id: z.string(),
        name: z.string(),
        description: z.string(),
        type: z.enum(["linear", "nonlinear", "integer", "mixed_integer", "constraint_satisfaction", "multi_objective"]),
        approach: z.enum(["exact", "heuristic", "metaheuristic", "approximation"]).optional(),
        complexity: z.string().optional()
      }).optional(),
      decisionVariables: z.array(z.object({
        id: z.string(),
        name: z.string(),
        description: z.string(),
        type: z.enum(["continuous", "integer", "binary", "categorical"]),
        unit: z.string().optional(),
        semantics: z.string()
      })).optional(),
      optimizationConstraints: z.array(z.object({
        id: z.string(),
        name: z.string(),
        description: z.string(),
        type: z.enum(["hard", "soft"]),
        formula: z.string(),
        variables: z.array(z.string()),
        penalty: z.number().optional(),
        rationale: z.string(),
        priority: z.number().optional()
      })).optional(),
      objectives: z.array(z.object({
        id: z.string(),
        name: z.string(),
        description: z.string(),
        type: z.enum(["minimize", "maximize"]),
        formula: z.string(),
        variables: z.array(z.string()),
        weight: z.number().min(0).max(1).optional(),
        units: z.string().optional(),
        idealValue: z.number().optional(),
        acceptableRange: z.tuple([z.number(), z.number()]).optional()
      })).optional(),
      solution: z.object({
        id: z.string(),
        type: z.enum(["optimal", "feasible", "infeasible", "unbounded", "approximate"]),
        variableValues: z.record(z.string(), z.union([z.number(), z.string()])),
        objectiveValues: z.record(z.string(), z.number()),
        quality: z.number().min(0).max(1),
        computationTime: z.number().optional(),
        iterations: z.number().optional(),
        method: z.string().optional(),
        guarantees: z.array(z.string()).optional()
      }).optional(),
      sensitivityAnalysis: z.object({
        id: z.string(),
        robustness: z.number().min(0).max(1),
        criticalConstraints: z.array(z.string()),
        shadowPrices: z.record(z.string(), z.number()).optional(),
        recommendations: z.array(z.string())
      }).optional(),
      // Formal Logic properties (Phase 4, v3.2.0)
      propositions: z.array(z.object({
        id: z.string(),
        symbol: z.string(),
        statement: z.string(),
        truthValue: z.boolean().optional(),
        type: z.enum(["atomic", "compound"]),
        formula: z.string().optional()
      })).optional(),
      logicalInferences: z.array(z.object({
        id: z.string(),
        rule: z.enum(["modus_ponens", "modus_tollens", "hypothetical_syllogism", "disjunctive_syllogism", "conjunction", "simplification", "addition", "resolution", "contradiction", "excluded_middle"]),
        premises: z.array(z.string()),
        conclusion: z.string(),
        justification: z.string(),
        valid: z.boolean()
      })).optional(),
      logicalProof: z.object({
        id: z.string(),
        theorem: z.string(),
        technique: z.enum(["direct", "contradiction", "contrapositive", "cases", "induction", "natural_deduction", "resolution", "semantic_tableaux"]),
        steps: z.array(z.object({
          stepNumber: z.number().int().positive(),
          statement: z.string(),
          formula: z.string().optional(),
          justification: z.string(),
          rule: z.enum(["modus_ponens", "modus_tollens", "hypothetical_syllogism", "disjunctive_syllogism", "conjunction", "simplification", "addition", "resolution", "contradiction", "excluded_middle"]).optional(),
          referencesSteps: z.array(z.number()).optional(),
          isAssumption: z.boolean().optional(),
          dischargesAssumption: z.number().optional()
        })),
        conclusion: z.string(),
        valid: z.boolean(),
        completeness: z.number().min(0).max(1),
        assumptions: z.array(z.string()).optional()
      }).optional(),
      truthTable: z.object({
        id: z.string(),
        propositions: z.array(z.string()),
        formula: z.string().optional(),
        rows: z.array(z.object({
          rowNumber: z.number().int().positive(),
          assignments: z.record(z.string(), z.boolean()),
          result: z.boolean()
        })),
        isTautology: z.boolean(),
        isContradiction: z.boolean(),
        isContingent: z.boolean()
      }).optional(),
      satisfiability: z.object({
        id: z.string(),
        formula: z.string(),
        satisfiable: z.boolean(),
        model: z.record(z.string(), z.boolean()).optional(),
        method: z.enum(["dpll", "cdcl", "resolution", "truth_table", "other"]),
        complexity: z.string().optional(),
        explanation: z.string()
      }).optional(),
      action: z.enum(["add_thought", "summarize", "export", "switch_mode", "get_session", "recommend_mode", "delete_session"]).default("add_thought"),
      exportFormat: z.enum(["markdown", "latex", "json", "html", "jupyter", "mermaid", "dot", "ascii"]).optional(),
      newMode: z.enum(["sequential", "shannon", "mathematics", "physics", "hybrid", "inductive", "deductive", "abductive", "causal", "bayesian", "counterfactual", "analogical", "temporal", "gametheory", "evidential", "firstprinciples", "systemsthinking", "scientificmethod", "optimization", "formallogic"]).optional(),
      // Mode recommendation parameters (v2.4)
      problemType: z.string().optional(),
      problemCharacteristics: z.object({
        domain: z.string(),
        complexity: z.enum(["low", "medium", "high"]),
        uncertainty: z.enum(["low", "medium", "high"]),
        timeDependent: z.boolean(),
        multiAgent: z.boolean(),
        requiresProof: z.boolean(),
        requiresQuantification: z.boolean(),
        hasIncompleteInfo: z.boolean(),
        requiresExplanation: z.boolean(),
        hasAlternatives: z.boolean()
      }).optional(),
      includeCombinations: z.boolean().optional()
    });
    thinkingTool = {
      name: "deepthinking",
      description: "[DEPRECATED] Use deepthinking_* tools instead. Legacy tool supporting 18 reasoning modes with auto-routing to focused tools.",
      inputSchema: {
        type: "object",
        properties: {
          sessionId: { type: "string" },
          mode: {
            type: "string",
            enum: ["sequential", "shannon", "mathematics", "physics", "hybrid", "inductive", "deductive", "abductive", "causal", "bayesian", "counterfactual", "analogical", "temporal", "gametheory", "evidential", "firstprinciples", "systemsthinking", "scientificmethod", "optimization", "formallogic"],
            default: "hybrid"
          },
          thought: { type: "string", minLength: 1 },
          thoughtNumber: { type: "integer", minimum: 1 },
          totalThoughts: { type: "integer", minimum: 1 },
          nextThoughtNeeded: { type: "boolean" },
          isRevision: { type: "boolean" },
          revisesThought: { type: "string" },
          revisionReason: { type: "string" },
          branchFrom: { type: "string" },
          branchId: { type: "string" },
          stage: {
            type: "string",
            enum: ["problem_definition", "constraints", "model", "proof", "implementation"]
          },
          uncertainty: { type: "number", minimum: 0, maximum: 1 },
          dependencies: { type: "array", items: { type: "string" } },
          assumptions: { type: "array", items: { type: "string" } },
          thoughtType: { type: "string" },
          // Math/Physics properties
          mathematicalModel: {
            type: "object",
            properties: {
              latex: { type: "string" },
              symbolic: { type: "string" },
              ascii: { type: "string" }
            },
            additionalProperties: false
          },
          proofStrategy: {
            type: "object",
            properties: {
              type: { type: "string", enum: ["direct", "contradiction", "induction", "construction", "contrapositive"] },
              steps: { type: "array", items: { type: "string" } }
            },
            additionalProperties: false
          },
          tensorProperties: {
            type: "object",
            properties: {
              rank: { type: "array", items: { type: "number" }, minItems: 2, maxItems: 2 },
              components: { type: "string" },
              latex: { type: "string" },
              symmetries: { type: "array", items: { type: "string" } },
              invariants: { type: "array", items: { type: "string" } },
              transformation: { type: "string", enum: ["covariant", "contravariant", "mixed"] }
            },
            additionalProperties: false
          }
          // All other optional properties from various modes (simplified for legacy compatibility)
          // Most users should migrate to focused tools for full schema validation
        },
        required: ["thought", "thoughtNumber", "totalThoughts", "nextThoughtNeeded"],
        additionalProperties: true
        // Allow extra properties for backward compatibility
      }
    };
  }
});

// src/types/core.ts
function isFullyImplemented(mode) {
  return FULLY_IMPLEMENTED_MODES.includes(mode);
}
function isMetaReasoningThought(thought) {
  return thought.mode === "metareasoning" /* METAREASONING */;
}
function isTemporalThought(thought) {
  return thought.mode === "temporal" /* TEMPORAL */;
}
function isGameTheoryThought(thought) {
  return thought.mode === "gametheory" /* GAMETHEORY */;
}
function isEvidentialThought(thought) {
  return thought.mode === "evidential" /* EVIDENTIAL */;
}
var ThinkingMode, FULLY_IMPLEMENTED_MODES;
var init_core = __esm({
  "src/types/core.ts"() {
    init_esm_shims();
    ThinkingMode = /* @__PURE__ */ ((ThinkingMode2) => {
      ThinkingMode2["SEQUENTIAL"] = "sequential";
      ThinkingMode2["SHANNON"] = "shannon";
      ThinkingMode2["MATHEMATICS"] = "mathematics";
      ThinkingMode2["PHYSICS"] = "physics";
      ThinkingMode2["HYBRID"] = "hybrid";
      ThinkingMode2["ENGINEERING"] = "engineering";
      ThinkingMode2["COMPUTABILITY"] = "computability";
      ThinkingMode2["CRYPTANALYTIC"] = "cryptanalytic";
      ThinkingMode2["ALGORITHMIC"] = "algorithmic";
      ThinkingMode2["METAREASONING"] = "metareasoning";
      ThinkingMode2["RECURSIVE"] = "recursive";
      ThinkingMode2["MODAL"] = "modal";
      ThinkingMode2["STOCHASTIC"] = "stochastic";
      ThinkingMode2["CONSTRAINT"] = "constraint";
      ThinkingMode2["OPTIMIZATION"] = "optimization";
      ThinkingMode2["INDUCTIVE"] = "inductive";
      ThinkingMode2["DEDUCTIVE"] = "deductive";
      ThinkingMode2["ABDUCTIVE"] = "abductive";
      ThinkingMode2["CAUSAL"] = "causal";
      ThinkingMode2["BAYESIAN"] = "bayesian";
      ThinkingMode2["COUNTERFACTUAL"] = "counterfactual";
      ThinkingMode2["TEMPORAL"] = "temporal";
      ThinkingMode2["GAMETHEORY"] = "gametheory";
      ThinkingMode2["EVIDENTIAL"] = "evidential";
      ThinkingMode2["ANALOGICAL"] = "analogical";
      ThinkingMode2["FIRSTPRINCIPLES"] = "firstprinciples";
      ThinkingMode2["SYSTEMSTHINKING"] = "systemsthinking";
      ThinkingMode2["SCIENTIFICMETHOD"] = "scientificmethod";
      ThinkingMode2["FORMALLOGIC"] = "formallogic";
      ThinkingMode2["SYNTHESIS"] = "synthesis";
      ThinkingMode2["ARGUMENTATION"] = "argumentation";
      ThinkingMode2["CRITIQUE"] = "critique";
      ThinkingMode2["ANALYSIS"] = "analysis";
      ThinkingMode2["CUSTOM"] = "custom";
      return ThinkingMode2;
    })(ThinkingMode || {});
    FULLY_IMPLEMENTED_MODES = [
      // Core modes
      "sequential" /* SEQUENTIAL */,
      "shannon" /* SHANNON */,
      "mathematics" /* MATHEMATICS */,
      "physics" /* PHYSICS */,
      "hybrid" /* HYBRID */,
      // Engineering modes
      "engineering" /* ENGINEERING */,
      "computability" /* COMPUTABILITY */,
      "cryptanalytic" /* CRYPTANALYTIC */,
      "algorithmic" /* ALGORITHMIC */,
      // Advanced runtime modes
      "metareasoning" /* METAREASONING */,
      "recursive" /* RECURSIVE */,
      "modal" /* MODAL */,
      "stochastic" /* STOCHASTIC */,
      "constraint" /* CONSTRAINT */,
      "optimization" /* OPTIMIZATION */,
      // Fundamental reasoning modes
      "inductive" /* INDUCTIVE */,
      "deductive" /* DEDUCTIVE */,
      "abductive" /* ABDUCTIVE */,
      // Causal/Temporal modes
      "causal" /* CAUSAL */,
      "counterfactual" /* COUNTERFACTUAL */,
      "temporal" /* TEMPORAL */,
      // Probabilistic modes
      "bayesian" /* BAYESIAN */,
      "evidential" /* EVIDENTIAL */,
      // Strategic modes
      "gametheory" /* GAMETHEORY */,
      // Analytical modes
      "analogical" /* ANALOGICAL */,
      "firstprinciples" /* FIRSTPRINCIPLES */,
      // Scientific modes
      "systemsthinking" /* SYSTEMSTHINKING */,
      "scientificmethod" /* SCIENTIFICMETHOD */,
      "formallogic" /* FORMALLOGIC */,
      // Academic research modes
      "synthesis" /* SYNTHESIS */,
      "argumentation" /* ARGUMENTATION */,
      "critique" /* CRITIQUE */,
      "analysis" /* ANALYSIS */
    ];
  }
});

// src/types/session.ts
var init_session = __esm({
  "src/types/session.ts"() {
    init_esm_shims();
  }
});

// src/modes/handlers/ModeHandler.ts
function validationSuccess(warnings = []) {
  return {
    valid: true,
    errors: [],
    warnings
  };
}
function validationFailure(errors, warnings = []) {
  return {
    valid: false,
    errors,
    warnings
  };
}
function createValidationError(field, message, code) {
  return { field, message, code };
}
function createValidationWarning(field, message, suggestion) {
  return { field, message, suggestion };
}
var init_ModeHandler = __esm({
  "src/modes/handlers/ModeHandler.ts"() {
    init_esm_shims();
  }
});

// src/types/modes/recommendations.ts
var ModeRecommender;
var init_recommendations = __esm({
  "src/types/modes/recommendations.ts"() {
    init_esm_shims();
    ModeRecommender = class {
      /**
       * Recommends reasoning modes based on problem characteristics
       * Returns modes ranked by suitability score
       */
      recommendModes(characteristics) {
        const recommendations = [];
        const isPhilosophical = characteristics.domain.toLowerCase().includes("metaphysics") || characteristics.domain.toLowerCase().includes("theology") || characteristics.domain.toLowerCase().includes("philosophy") || characteristics.domain.toLowerCase().includes("epistemology") || characteristics.domain.toLowerCase().includes("ethics");
        if (characteristics.complexity === "high" && (characteristics.requiresExplanation || characteristics.hasAlternatives || isPhilosophical)) {
          recommendations.push({
            mode: "hybrid" /* HYBRID */,
            score: 0.92,
            reasoning: "Complex problem benefits from multi-modal synthesis combining inductive, deductive, and abductive reasoning",
            strengths: ["Comprehensive analysis", "Combines empirical and logical approaches", "Maximum evidential strength", "Convergent validation"],
            limitations: ["Time-intensive", "Requires understanding of multiple reasoning types"],
            examples: ["Philosophical arguments", "Scientific theories", "Complex decision-making", "Metaphysical questions"]
          });
        }
        if (!characteristics.requiresProof && (characteristics.requiresQuantification || characteristics.hasIncompleteInfo || isPhilosophical)) {
          recommendations.push({
            mode: "inductive" /* INDUCTIVE */,
            score: isPhilosophical ? 0.85 : 0.8,
            reasoning: "Problem requires pattern recognition and generalization from observations",
            strengths: ["Empirical grounding", "Pattern detection", "Probabilistic reasoning", "Scientific discovery"],
            limitations: ["Cannot prove with certainty", "Vulnerable to black swans", "Sample size dependent"],
            examples: ["Scientific hypotheses", "Trend analysis", "Empirical arguments", "Data-driven insights"]
          });
        }
        if (characteristics.requiresProof || isPhilosophical) {
          recommendations.push({
            mode: "deductive" /* DEDUCTIVE */,
            score: characteristics.requiresProof ? 0.9 : 0.75,
            reasoning: "Problem requires logical derivation from general principles to specific conclusions",
            strengths: ["Logical validity", "Rigorous inference", "Exposes contradictions", "Formal reasoning"],
            limitations: ["Soundness depends on premise truth", "Vulnerable to definitional disputes", "May not handle uncertainty well"],
            examples: ["Logical proofs", "Mathematical theorems", "Philosophical arguments", "Formal verification"]
          });
        }
        if (characteristics.requiresExplanation || isPhilosophical) {
          recommendations.push({
            mode: "abductive" /* ABDUCTIVE */,
            score: isPhilosophical ? 0.9 : 0.87,
            reasoning: "Problem requires finding best explanations through comparative hypothesis evaluation",
            strengths: ["Hypothesis generation", "Comparative evaluation", "Explanatory power assessment", "Handles competing theories"],
            limitations: ["May miss non-obvious explanations", "Explanatory power is subjective"],
            examples: ["Scientific explanation", "Debugging", "Diagnosis", "Theory selection", "Metaphysical arguments"]
          });
        }
        if (characteristics.complexity === "high" || characteristics.hasAlternatives && characteristics.uncertainty === "high") {
          recommendations.push({
            mode: "metareasoning" /* METAREASONING */,
            score: characteristics.complexity === "high" ? 0.88 : 0.82,
            reasoning: "Complex or uncertain problems benefit from strategic monitoring and adaptive reasoning",
            strengths: ["Strategy evaluation", "Mode switching recommendations", "Quality monitoring", "Resource allocation", "Self-reflection"],
            limitations: ["Meta-level overhead", "Requires understanding of other modes", "May not directly solve the problem"],
            examples: ["Strategy selection", "Debugging stuck reasoning", "Quality assessment", "Adaptive problem-solving"]
          });
        }
        if (characteristics.timeDependent) {
          recommendations.push({
            mode: "temporal" /* TEMPORAL */,
            score: 0.9,
            reasoning: "Problem involves time-dependent events and sequences",
            strengths: ["Event sequencing", "Temporal causality", "Timeline construction"],
            limitations: ["Limited strategic reasoning"],
            examples: ["Process modeling", "Event correlation", "Timeline debugging"]
          });
        }
        if (characteristics.multiAgent) {
          recommendations.push({
            mode: "gametheory" /* GAMETHEORY */,
            score: 0.85,
            reasoning: "Problem involves strategic interactions between agents",
            strengths: ["Equilibrium analysis", "Strategic reasoning", "Multi-agent dynamics"],
            limitations: ["Assumes rationality", "Complex computations"],
            examples: ["Competitive analysis", "Auction design", "Negotiation"]
          });
        }
        if (characteristics.hasIncompleteInfo && characteristics.uncertainty === "high" && !isPhilosophical) {
          recommendations.push({
            mode: "evidential" /* EVIDENTIAL */,
            score: 0.82,
            reasoning: "Problem has incomplete information and high uncertainty requiring Dempster-Shafer belief functions",
            strengths: ["Handles ignorance", "Evidence combination", "Uncertainty intervals"],
            limitations: ["Computational complexity", "Requires careful mass assignment", "Better for sensor fusion than philosophical reasoning"],
            examples: ["Sensor fusion", "Diagnostic reasoning", "Intelligence analysis"]
          });
        }
        if (characteristics.timeDependent && characteristics.requiresExplanation) {
          recommendations.push({
            mode: "causal" /* CAUSAL */,
            score: 0.86,
            reasoning: "Problem requires understanding cause-effect relationships",
            strengths: ["Intervention analysis", "Causal graphs", "Impact assessment"],
            limitations: ["Requires domain knowledge", "Difficult to identify confounders"],
            examples: ["Impact analysis", "System design", "Policy evaluation"]
          });
        }
        if (characteristics.requiresQuantification && characteristics.uncertainty !== "low") {
          recommendations.push({
            mode: "bayesian" /* BAYESIAN */,
            score: 0.84,
            reasoning: "Problem requires probabilistic reasoning with evidence updates",
            strengths: ["Principled uncertainty", "Evidence integration", "Prior knowledge"],
            limitations: ["Requires probability estimates", "Computationally intensive"],
            examples: ["A/B testing", "Risk assessment", "Predictive modeling"]
          });
        }
        if (characteristics.hasAlternatives) {
          recommendations.push({
            mode: "counterfactual" /* COUNTERFACTUAL */,
            score: 0.82,
            reasoning: "Problem benefits from analyzing alternative scenarios",
            strengths: ["What-if analysis", "Post-mortem insights", "Decision comparison"],
            limitations: ["Speculative", "Difficult to validate"],
            examples: ["Post-mortems", "Strategic planning", "Architecture decisions"]
          });
        }
        if (characteristics.complexity === "high" && characteristics.requiresExplanation) {
          recommendations.push({
            mode: "analogical" /* ANALOGICAL */,
            score: 0.8,
            reasoning: "Problem can benefit from cross-domain analogies",
            strengths: ["Creative insights", "Knowledge transfer", "Pattern recognition"],
            limitations: ["Analogies may be superficial", "Requires diverse knowledge"],
            examples: ["Novel problem solving", "Design thinking", "Innovation"]
          });
        }
        if (characteristics.requiresProof) {
          recommendations.push({
            mode: "mathematics" /* MATHEMATICS */,
            score: 0.95,
            reasoning: "Problem requires formal proofs and symbolic reasoning",
            strengths: ["Rigorous proofs", "Symbolic computation", "Theorem proving"],
            limitations: ["Limited to mathematical domains"],
            examples: ["Algorithm correctness", "Complexity analysis", "Formal verification"]
          });
        }
        if (characteristics.domain === "physics" || characteristics.domain === "engineering") {
          recommendations.push({
            mode: "physics" /* PHYSICS */,
            score: 0.9,
            reasoning: "Problem involves physical systems or tensor mathematics",
            strengths: ["Field theory", "Conservation laws", "Tensor analysis"],
            limitations: ["Specialized to physics domains"],
            examples: ["Physical modeling", "System dynamics", "Engineering analysis"]
          });
        }
        if (characteristics.complexity === "high" && characteristics.requiresProof) {
          recommendations.push({
            mode: "shannon" /* SHANNON */,
            score: 0.88,
            reasoning: "Complex problem requiring systematic decomposition",
            strengths: ["Systematic approach", "Problem decomposition", "Rigorous analysis"],
            limitations: ["Time-intensive", "Requires discipline"],
            examples: ["Complex system design", "Research problems", "Novel algorithms"]
          });
        }
        if (characteristics.domain === "engineering" || characteristics.domain === "software" || characteristics.domain === "systems" || characteristics.requiresQuantification && !characteristics.requiresProof) {
          recommendations.push({
            mode: "engineering" /* ENGINEERING */,
            score: characteristics.domain === "engineering" ? 0.92 : 0.85,
            reasoning: "Problem requires systematic engineering analysis with trade-offs and constraints",
            strengths: ["Requirements analysis", "Trade-off evaluation", "System design", "Failure mode analysis", "Implementation planning"],
            limitations: ["May over-engineer simple problems", "Requires domain expertise"],
            examples: ["System architecture", "Design decisions", "Performance optimization", "Reliability analysis", "Technical debt assessment"]
          });
        }
        if (characteristics.domain === "computer science" || characteristics.domain === "computation" || characteristics.requiresProof && characteristics.domain.includes("algorithm")) {
          recommendations.push({
            mode: "computability" /* COMPUTABILITY */,
            score: 0.88,
            reasoning: "Problem involves computational complexity, decidability, or algorithmic analysis",
            strengths: ["Turing machine analysis", "Decidability proofs", "Complexity classification", "Halting problem variants"],
            limitations: ["Highly theoretical", "Requires formal CS background"],
            examples: ["Algorithm decidability", "Complexity bounds", "Reduction proofs", "Computational limits"]
          });
        }
        if (characteristics.domain === "security" || characteristics.domain === "cryptography" || characteristics.domain.includes("crypto")) {
          recommendations.push({
            mode: "cryptanalytic" /* CRYPTANALYTIC */,
            score: 0.9,
            reasoning: "Problem involves cryptographic analysis, security assessment, or information-theoretic reasoning",
            strengths: ["Statistical analysis", "Pattern detection", "Deciban calculations", "Key space analysis", "Attack surface evaluation"],
            limitations: ["Specialized domain", "Requires mathematical background"],
            examples: ["Cipher analysis", "Protocol security", "Key management", "Attack vectors", "Information leakage"]
          });
        }
        if (characteristics.complexity === "high" && (characteristics.hasAlternatives || characteristics.requiresExplanation)) {
          recommendations.push({
            mode: "recursive" /* RECURSIVE */,
            score: 0.82,
            reasoning: "Problem has recursive structure or can be decomposed into smaller similar subproblems",
            strengths: ["Problem decomposition", "Self-similar analysis", "Base case identification", "Recursive patterns"],
            limitations: ["Stack overflow risk in deep recursion", "May miss non-recursive solutions"],
            examples: ["Divide and conquer", "Tree traversal", "Fractal analysis", "Self-referential problems"]
          });
        }
        if (characteristics.hasAlternatives && characteristics.uncertainty === "high") {
          recommendations.push({
            mode: "modal" /* MODAL */,
            score: 0.8,
            reasoning: "Problem involves possibility, necessity, or reasoning about alternative scenarios",
            strengths: ["Possible worlds analysis", "Necessity vs possibility", "Epistemic reasoning", "Deontic analysis"],
            limitations: ["Abstract and theoretical", "May overcomplicate simple choices"],
            examples: ["Modal logic proofs", "Necessity analysis", "Epistemic uncertainty", "Deontic obligations"]
          });
        }
        if (characteristics.uncertainty === "high" && characteristics.requiresQuantification) {
          recommendations.push({
            mode: "stochastic" /* STOCHASTIC */,
            score: 0.84,
            reasoning: "Problem involves random processes, probabilistic transitions, or stochastic modeling",
            strengths: ["Markov chains", "Random process modeling", "Probabilistic state transitions", "Monte Carlo methods"],
            limitations: ["Requires probability theory", "Computationally intensive"],
            examples: ["Queueing systems", "Random walks", "Stochastic optimization", "Process simulation"]
          });
        }
        if (characteristics.hasAlternatives && characteristics.requiresQuantification) {
          recommendations.push({
            mode: "constraint" /* CONSTRAINT */,
            score: 0.83,
            reasoning: "Problem involves multiple constraints that must be satisfied simultaneously",
            strengths: ["Constraint propagation", "Feasibility analysis", "SAT solving", "CSP formulation"],
            limitations: ["NP-hard in general", "May have no solution"],
            examples: ["Scheduling", "Resource allocation", "Configuration", "Puzzle solving"]
          });
        }
        if (characteristics.requiresQuantification && characteristics.hasAlternatives) {
          recommendations.push({
            mode: "optimization" /* OPTIMIZATION */,
            score: 0.86,
            reasoning: "Problem requires finding optimal or near-optimal solutions from alternatives",
            strengths: ["Objective function formulation", "Gradient methods", "Convex optimization", "Meta-heuristics"],
            limitations: ["Local optima", "Computational complexity", "May require relaxation"],
            examples: ["Resource optimization", "Parameter tuning", "Portfolio optimization", "Route planning"]
          });
        }
        if (isPhilosophical || characteristics.complexity === "high" && characteristics.requiresExplanation) {
          recommendations.push({
            mode: "firstprinciples" /* FIRSTPRINCIPLES */,
            score: isPhilosophical ? 0.88 : 0.82,
            reasoning: "Problem benefits from breaking down to fundamental truths and building up from there",
            strengths: ["Assumption identification", "Foundational analysis", "Novel solutions", "Deep understanding"],
            limitations: ["Time-intensive", "May rediscover known solutions", "Requires broad knowledge"],
            examples: ["Innovation challenges", "Paradigm shifts", "Root cause analysis", "Foundational questions"]
          });
        }
        if (characteristics.complexity === "high" && (characteristics.timeDependent || characteristics.multiAgent)) {
          recommendations.push({
            mode: "systemsthinking" /* SYSTEMSTHINKING */,
            score: 0.85,
            reasoning: "Problem involves complex systems with interconnected components and feedback loops",
            strengths: ["Holistic view", "Feedback loop analysis", "Emergence detection", "Leverage point identification"],
            limitations: ["Can be overwhelming", "Requires system boundaries definition"],
            examples: ["Organizational change", "Ecosystem analysis", "Market dynamics", "Social systems"]
          });
        }
        if (characteristics.hasIncompleteInfo && (characteristics.requiresExplanation || characteristics.requiresQuantification)) {
          recommendations.push({
            mode: "scientificmethod" /* SCIENTIFICMETHOD */,
            score: 0.84,
            reasoning: "Problem requires systematic empirical investigation and hypothesis testing",
            strengths: ["Hypothesis formulation", "Experimental design", "Falsification", "Reproducibility"],
            limitations: ["Requires data collection", "Time for experiments", "May not apply to all domains"],
            examples: ["Research questions", "A/B testing", "Empirical studies", "Data-driven decisions"]
          });
        }
        if (characteristics.requiresProof && !characteristics.requiresQuantification) {
          recommendations.push({
            mode: "formallogic" /* FORMALLOGIC */,
            score: 0.87,
            reasoning: "Problem requires rigorous formal logical analysis and proof construction",
            strengths: ["Propositional logic", "Predicate logic", "Proof systems", "Logical completeness"],
            limitations: ["May be overly formal", "Limited expressiveness for some domains"],
            examples: ["Formal verification", "Logical puzzles", "Argument validity", "Theorem proving"]
          });
        }
        if (characteristics.domain === "computer science" || characteristics.domain === "algorithms" || characteristics.domain === "data structures" || characteristics.domain === "software" || characteristics.requiresProof && characteristics.requiresQuantification) {
          recommendations.push({
            mode: "algorithmic" /* ALGORITHMIC */,
            score: characteristics.domain === "algorithms" ? 0.95 : 0.88,
            reasoning: "Problem involves algorithm design, complexity analysis, or data structure optimization",
            strengths: [
              "Algorithm design patterns (divide-and-conquer, DP, greedy)",
              "Complexity analysis (time, space, amortized)",
              "Correctness proofs (loop invariants, induction)",
              "Data structure selection and analysis",
              "Graph algorithms and optimization"
            ],
            limitations: ["Focused on computational problems", "Requires algorithmic thinking"],
            examples: [
              "Sorting and searching",
              "Graph traversal (BFS, DFS)",
              "Dynamic programming formulation",
              "Shortest path algorithms",
              "NP-completeness proofs"
            ]
          });
        }
        if (characteristics.domain === "research" || characteristics.domain === "academic" || characteristics.domain === "literature" || characteristics.hasIncompleteInfo && characteristics.requiresExplanation && !characteristics.requiresProof) {
          recommendations.push({
            mode: "synthesis" /* SYNTHESIS */,
            score: characteristics.domain === "research" || characteristics.domain === "academic" ? 0.92 : 0.85,
            reasoning: "Problem requires integrating knowledge from multiple sources and identifying themes",
            strengths: [
              "Literature integration",
              "Theme extraction",
              "Gap identification",
              "Cross-source analysis",
              "Knowledge synthesis"
            ],
            limitations: ["Requires access to multiple sources", "Time-intensive", "May miss emerging research"],
            examples: [
              "Literature reviews",
              "Systematic reviews",
              "Meta-analyses",
              "Research synthesis",
              "State-of-the-art surveys"
            ]
          });
        }
        if (characteristics.requiresExplanation && (characteristics.hasAlternatives || characteristics.domain === "academic" || characteristics.domain === "philosophy")) {
          recommendations.push({
            mode: "argumentation" /* ARGUMENTATION */,
            score: characteristics.domain === "academic" ? 0.9 : 0.84,
            reasoning: "Problem requires structured argumentation with claims, evidence, and warrants",
            strengths: [
              "Toulmin model support",
              "Claim-evidence structure",
              "Warrant articulation",
              "Rebuttal handling",
              "Qualifier specification"
            ],
            limitations: ["Formal structure may feel rigid", "Requires clear claim formulation"],
            examples: [
              "Academic papers",
              "Thesis arguments",
              "Policy proposals",
              "Debate preparation",
              "Position papers"
            ]
          });
        }
        if (characteristics.requiresExplanation && (characteristics.domain === "academic" || characteristics.domain === "research" || characteristics.domain === "review")) {
          recommendations.push({
            mode: "critique" /* CRITIQUE */,
            score: characteristics.domain === "review" ? 0.92 : 0.86,
            reasoning: "Problem requires critical evaluation of methodology, validity, and limitations",
            strengths: [
              "Methodology assessment",
              "Validity evaluation",
              "Limitation identification",
              "Strength recognition",
              "Constructive feedback"
            ],
            limitations: ["Requires domain expertise", "May seem overly critical"],
            examples: [
              "Peer review",
              "Paper critiques",
              "Methodology evaluation",
              "Research assessment",
              "Quality analysis"
            ]
          });
        }
        if (characteristics.hasIncompleteInfo && characteristics.requiresExplanation && (characteristics.domain === "research" || characteristics.domain === "qualitative" || characteristics.domain === "social science")) {
          recommendations.push({
            mode: "analysis" /* ANALYSIS */,
            score: characteristics.domain === "qualitative" ? 0.93 : 0.85,
            reasoning: "Problem requires systematic qualitative analysis using established methods",
            strengths: [
              "Thematic analysis",
              "Grounded theory",
              "Discourse analysis",
              "Content analysis",
              "Code development"
            ],
            limitations: ["Subjective interpretation", "Time-intensive coding", "Requires methodological rigor"],
            examples: [
              "Interview analysis",
              "Document analysis",
              "Ethnographic research",
              "Case study analysis",
              "Narrative analysis"
            ]
          });
        }
        if (recommendations.length === 0) {
          recommendations.push({
            mode: "sequential" /* SEQUENTIAL */,
            score: 0.7,
            reasoning: "General-purpose iterative reasoning",
            strengths: ["Flexible", "Adaptable", "Iterative refinement"],
            limitations: ["May lack structure for complex problems"],
            examples: ["General problem solving", "Exploration", "Brainstorming"]
          });
        }
        return recommendations.sort((a, b) => b.score - a.score);
      }
      /**
       * Recommends combinations of reasoning modes that work well together
       */
      recommendCombinations(characteristics) {
        const combinations = [];
        const isPhilosophical = characteristics.domain.toLowerCase().includes("metaphysics") || characteristics.domain.toLowerCase().includes("theology") || characteristics.domain.toLowerCase().includes("philosophy") || characteristics.domain.toLowerCase().includes("epistemology") || characteristics.domain.toLowerCase().includes("ethics");
        if (isPhilosophical || characteristics.complexity === "high" && characteristics.requiresExplanation && characteristics.hasAlternatives) {
          combinations.push({
            modes: ["inductive" /* INDUCTIVE */, "deductive" /* DEDUCTIVE */, "abductive" /* ABDUCTIVE */],
            sequence: "hybrid",
            rationale: "Synthesize empirical patterns, logical derivations, and explanatory hypotheses for maximum evidential strength",
            benefits: ["Convergent validation from three independent methods", "Empirical grounding + logical rigor + explanatory power", "Highest achievable confidence through multi-modal synthesis", "Exposes both empirical patterns and logical contradictions"],
            synergies: ["Inductive patterns inform abductive hypotheses", "Deductive logic tests hypothesis validity", "Abductive explanations guide inductive search", "All three methods converge on same conclusion"]
          });
        }
        if (characteristics.timeDependent && characteristics.requiresExplanation) {
          combinations.push({
            modes: ["temporal" /* TEMPORAL */, "causal" /* CAUSAL */],
            sequence: "sequential",
            rationale: "Build timeline first, then analyze causal relationships",
            benefits: ["Complete temporal-causal model", "Root cause with timeline context"],
            synergies: ["Temporal events inform causal nodes", "Causal edges explain temporal sequences"]
          });
        }
        if (characteristics.requiresExplanation && characteristics.requiresQuantification) {
          combinations.push({
            modes: ["abductive" /* ABDUCTIVE */, "bayesian" /* BAYESIAN */],
            sequence: "sequential",
            rationale: "Generate hypotheses, then quantify with probabilities",
            benefits: ["Systematic hypothesis generation", "Quantified belief updates"],
            synergies: ["Abductive hypotheses become Bayesian hypotheses", "Bayesian updates refine explanations"]
          });
        }
        if (characteristics.multiAgent && characteristics.hasAlternatives) {
          combinations.push({
            modes: ["gametheory" /* GAMETHEORY */, "counterfactual" /* COUNTERFACTUAL */],
            sequence: "hybrid",
            rationale: "Analyze equilibria, then explore alternative strategies",
            benefits: ["Strategic analysis + scenario exploration", "Robustness testing"],
            synergies: ["Equilibria as actual scenarios", "Strategy changes as interventions"]
          });
        }
        if (characteristics.hasIncompleteInfo && characteristics.timeDependent) {
          combinations.push({
            modes: ["evidential" /* EVIDENTIAL */, "causal" /* CAUSAL */],
            sequence: "parallel",
            rationale: "Combine uncertain evidence while modeling causal structure",
            benefits: ["Handles uncertainty and causality", "Evidence fusion with causal reasoning"],
            synergies: ["Belief functions inform causal strengths", "Causal structure guides evidence combination"]
          });
        }
        if (characteristics.timeDependent && characteristics.multiAgent) {
          combinations.push({
            modes: ["temporal" /* TEMPORAL */, "gametheory" /* GAMETHEORY */],
            sequence: "sequential",
            rationale: "Model event sequences, then analyze strategic interactions over time",
            benefits: ["Dynamic game analysis", "Time-dependent strategies"],
            synergies: ["Temporal events as game stages", "Strategies evolve over timeline"]
          });
        }
        if (characteristics.requiresProof && characteristics.complexity === "high") {
          combinations.push({
            modes: ["shannon" /* SHANNON */, "mathematics" /* MATHEMATICS */],
            sequence: "hybrid",
            rationale: "Use Shannon methodology to structure complex mathematical proofs",
            benefits: ["Systematic proof construction", "Clear problem decomposition"],
            synergies: ["Shannon stages guide proof strategy", "Mathematical rigor validates each stage"]
          });
        }
        if ((characteristics.domain === "engineering" || characteristics.domain === "software") && characteristics.hasAlternatives) {
          combinations.push({
            modes: ["engineering" /* ENGINEERING */, "optimization" /* OPTIMIZATION */],
            sequence: "sequential",
            rationale: "Design system architecture, then optimize for performance/cost",
            benefits: ["Structured design", "Optimal trade-offs", "Measurable improvements"],
            synergies: ["Engineering constraints feed optimization", "Optimization validates design choices"]
          });
        }
        if (characteristics.requiresQuantification && characteristics.hasAlternatives && (characteristics.domain === "engineering" || characteristics.domain === "software")) {
          combinations.push({
            modes: ["constraint" /* CONSTRAINT */, "engineering" /* ENGINEERING */],
            sequence: "sequential",
            rationale: "Identify constraints first, then design within those boundaries",
            benefits: ["Feasibility guaranteed", "Requirements satisfaction", "Clear boundaries"],
            synergies: ["Constraints define engineering solution space", "Engineering validates constraint satisfaction"]
          });
        }
        if (characteristics.complexity === "high" && characteristics.requiresExplanation) {
          combinations.push({
            modes: ["firstprinciples" /* FIRSTPRINCIPLES */, "systemsthinking" /* SYSTEMSTHINKING */],
            sequence: "sequential",
            rationale: "Build from fundamental truths, then analyze systemic interactions",
            benefits: ["Deep understanding", "Holistic view", "Novel insights"],
            synergies: ["First principles reveal core elements", "Systems thinking shows interconnections"]
          });
        }
        if (characteristics.hasIncompleteInfo && characteristics.requiresQuantification) {
          combinations.push({
            modes: ["scientificmethod" /* SCIENTIFICMETHOD */, "bayesian" /* BAYESIAN */],
            sequence: "hybrid",
            rationale: "Design experiments and update beliefs with Bayesian inference",
            benefits: ["Rigorous methodology", "Quantified uncertainty", "Evidence integration"],
            synergies: ["Experiments generate evidence", "Bayesian updates refine hypotheses"]
          });
        }
        if (characteristics.requiresProof && !characteristics.hasIncompleteInfo) {
          combinations.push({
            modes: ["formallogic" /* FORMALLOGIC */, "deductive" /* DEDUCTIVE */],
            sequence: "hybrid",
            rationale: "Use formal logic systems with deductive derivation",
            benefits: ["Maximum rigor", "Logically valid conclusions", "Formal verification"],
            synergies: ["Formal logic provides structure", "Deduction ensures valid inference"]
          });
        }
        if (characteristics.complexity === "high" && characteristics.hasAlternatives) {
          combinations.push({
            modes: ["recursive" /* RECURSIVE */, "optimization" /* OPTIMIZATION */],
            sequence: "hybrid",
            rationale: "Decompose problem recursively, optimize at each level",
            benefits: ["Scalable solutions", "Local and global optimization", "Manageable complexity"],
            synergies: ["Recursion breaks down problem", "Optimization solves subproblems optimally"]
          });
        }
        if (characteristics.uncertainty === "high" && characteristics.requiresQuantification) {
          combinations.push({
            modes: ["stochastic" /* STOCHASTIC */, "bayesian" /* BAYESIAN */],
            sequence: "parallel",
            rationale: "Model random processes while updating beliefs probabilistically",
            benefits: ["Complete uncertainty model", "Dynamic belief updates", "Probabilistic predictions"],
            synergies: ["Stochastic models generate distributions", "Bayesian reasoning integrates evidence"]
          });
        }
        if (characteristics.domain === "computer science" && characteristics.requiresProof) {
          combinations.push({
            modes: ["computability" /* COMPUTABILITY */, "formallogic" /* FORMALLOGIC */],
            sequence: "hybrid",
            rationale: "Analyze computational limits with formal logical proofs",
            benefits: ["Decidability analysis", "Rigorous complexity proofs", "Theoretical foundations"],
            synergies: ["Computability defines limits", "Formal logic proves properties"]
          });
        }
        if (characteristics.domain === "security" && characteristics.uncertainty === "high") {
          combinations.push({
            modes: ["cryptanalytic" /* CRYPTANALYTIC */, "stochastic" /* STOCHASTIC */],
            sequence: "parallel",
            rationale: "Analyze cryptographic systems with probabilistic attack modeling",
            benefits: ["Security assessment", "Attack probability estimation", "Key space analysis"],
            synergies: ["Cryptanalysis identifies vulnerabilities", "Stochastic models attack success rates"]
          });
        }
        if (characteristics.complexity === "high" && (characteristics.multiAgent || characteristics.timeDependent)) {
          combinations.push({
            modes: ["systemsthinking" /* SYSTEMSTHINKING */, "engineering" /* ENGINEERING */],
            sequence: "sequential",
            rationale: "Understand system dynamics holistically, then engineer solutions",
            benefits: ["Holistic design", "Feedback-aware engineering", "Emergent behavior consideration"],
            synergies: ["Systems view informs design", "Engineering implements systemic solutions"]
          });
        }
        if (characteristics.hasAlternatives && characteristics.uncertainty === "high") {
          combinations.push({
            modes: ["modal" /* MODAL */, "counterfactual" /* COUNTERFACTUAL */],
            sequence: "parallel",
            rationale: "Analyze possible worlds and counterfactual scenarios together",
            benefits: ["Complete possibility space", "What-if analysis", "Robust decision making"],
            synergies: ["Modal logic structures possibilities", "Counterfactuals explore specific alternatives"]
          });
        }
        if (characteristics.complexity === "high" && characteristics.hasAlternatives) {
          combinations.push({
            modes: ["metareasoning" /* METAREASONING */, "optimization" /* OPTIMIZATION */],
            sequence: "hybrid",
            rationale: "Monitor reasoning strategies and optimize approach selection",
            benefits: ["Adaptive reasoning", "Resource optimization", "Strategy refinement"],
            synergies: ["Metareasoning evaluates strategies", "Optimization selects best approach"]
          });
        }
        if (characteristics.requiresExplanation && characteristics.hasAlternatives) {
          combinations.push({
            modes: ["metareasoning" /* METAREASONING */, "formallogic" /* FORMALLOGIC */, "abductive" /* ABDUCTIVE */],
            sequence: "sequential",
            rationale: "Detect cognitive biases through meta-analysis, identify logical fallacies, and generate alternative explanations as counter-arguments",
            benefits: ["Comprehensive bias detection", "Fallacy identification", "Counter-argument generation", "Critical analysis"],
            synergies: ["Metareasoning identifies reasoning flaws", "Formal logic validates argument structure", "Abductive generates alternative explanations"]
          });
        }
        if (characteristics.hasAlternatives && characteristics.uncertainty !== "low") {
          combinations.push({
            modes: ["metareasoning" /* METAREASONING */, "counterfactual" /* COUNTERFACTUAL */],
            sequence: "parallel",
            rationale: "Self-reflect on reasoning while exploring alternative scenarios to counter biases",
            benefits: ["Bias awareness", "Alternative perspective generation", "Decision robustness"],
            synergies: ["Metareasoning detects bias patterns", "Counterfactual explores what-if scenarios"]
          });
        }
        if (characteristics.domain === "computer science" && characteristics.requiresProof) {
          combinations.push({
            modes: ["algorithmic" /* ALGORITHMIC */, "computability" /* COMPUTABILITY */],
            sequence: "hybrid",
            rationale: "Combine algorithm design with computability analysis for theoretical completeness",
            benefits: ["Algorithm correctness proofs", "Complexity class analysis", "Decidability bounds"],
            synergies: ["Algorithmic design informs complexity", "Computability proves fundamental limits"]
          });
        }
        if (characteristics.hasAlternatives && characteristics.requiresQuantification) {
          combinations.push({
            modes: ["algorithmic" /* ALGORITHMIC */, "optimization" /* OPTIMIZATION */],
            sequence: "sequential",
            rationale: "Design algorithm first, then optimize for performance",
            benefits: ["Correct-by-construction", "Performance optimization", "Trade-off analysis"],
            synergies: ["Algorithm provides baseline", "Optimization improves constants and bounds"]
          });
        }
        if (characteristics.requiresProof && characteristics.domain !== "philosophy") {
          combinations.push({
            modes: ["algorithmic" /* ALGORITHMIC */, "mathematics" /* MATHEMATICS */],
            sequence: "hybrid",
            rationale: "Combine algorithm design with mathematical proof techniques",
            benefits: ["Rigorous correctness proofs", "Loop invariant verification", "Inductive reasoning"],
            synergies: ["Algorithmic structures guide proof strategy", "Mathematical rigor ensures correctness"]
          });
        }
        if (characteristics.complexity === "high" && characteristics.hasAlternatives) {
          combinations.push({
            modes: ["algorithmic" /* ALGORITHMIC */, "recursive" /* RECURSIVE */],
            sequence: "parallel",
            rationale: "Apply divide-and-conquer paradigm with recursive decomposition",
            benefits: ["Natural problem decomposition", "Recurrence solving", "Subproblem identification"],
            synergies: ["Algorithmic patterns guide recursion", "Recursive structure enables Master Theorem"]
          });
        }
        if (characteristics.uncertainty !== "low" && characteristics.requiresQuantification) {
          combinations.push({
            modes: ["algorithmic" /* ALGORITHMIC */, "stochastic" /* STOCHASTIC */],
            sequence: "parallel",
            rationale: "Design randomized algorithms with probabilistic analysis",
            benefits: ["Expected-case analysis", "Monte Carlo methods", "Las Vegas algorithms"],
            synergies: ["Algorithmic framework structures randomization", "Stochastic analysis proves bounds"]
          });
        }
        if (characteristics.domain === "research" || characteristics.domain === "academic") {
          combinations.push({
            modes: ["synthesis" /* SYNTHESIS */, "critique" /* CRITIQUE */],
            sequence: "sequential",
            rationale: "Synthesize literature first, then critically evaluate the synthesized findings",
            benefits: ["Comprehensive review", "Critical evaluation", "Research gap identification"],
            synergies: ["Synthesis identifies patterns", "Critique validates findings"]
          });
        }
        if (characteristics.hasIncompleteInfo && characteristics.requiresExplanation) {
          combinations.push({
            modes: ["synthesis" /* SYNTHESIS */, "analysis" /* ANALYSIS */],
            sequence: "hybrid",
            rationale: "Combine literature synthesis with qualitative analysis methods",
            benefits: ["Multi-source integration", "Thematic consistency", "Methodological rigor"],
            synergies: ["Synthesis provides sources", "Analysis extracts themes"]
          });
        }
        if (characteristics.requiresExplanation && characteristics.hasAlternatives) {
          combinations.push({
            modes: ["argumentation" /* ARGUMENTATION */, "critique" /* CRITIQUE */],
            sequence: "parallel",
            rationale: "Build arguments while critically evaluating opposing views",
            benefits: ["Strong arguments", "Addressed weaknesses", "Robust conclusions"],
            synergies: ["Argumentation structures claims", "Critique strengthens rebuttals"]
          });
        }
        if (characteristics.requiresProof && characteristics.requiresExplanation) {
          combinations.push({
            modes: ["argumentation" /* ARGUMENTATION */, "deductive" /* DEDUCTIVE */],
            sequence: "hybrid",
            rationale: "Combine Toulmin argumentation with deductive logical rigor",
            benefits: ["Structured arguments", "Logical validity", "Academic rigor"],
            synergies: ["Toulmin provides structure", "Deduction ensures validity"]
          });
        }
        if (characteristics.hasIncompleteInfo && !characteristics.requiresProof) {
          combinations.push({
            modes: ["analysis" /* ANALYSIS */, "inductive" /* INDUCTIVE */],
            sequence: "sequential",
            rationale: "Apply qualitative analysis then generalize through inductive reasoning",
            benefits: ["Grounded findings", "Pattern generalization", "Theory building"],
            synergies: ["Analysis identifies codes", "Induction builds theory"]
          });
        }
        if (characteristics.complexity === "high" && characteristics.requiresExplanation) {
          combinations.push({
            modes: ["critique" /* CRITIQUE */, "metareasoning" /* METAREASONING */],
            sequence: "parallel",
            rationale: "Critically analyze while monitoring own biases and reasoning quality",
            benefits: ["Self-aware critique", "Bias mitigation", "Improved objectivity"],
            synergies: ["Critique evaluates content", "Metareasoning evaluates process"]
          });
        }
        if (characteristics.requiresQuantification && characteristics.hasIncompleteInfo) {
          combinations.push({
            modes: ["synthesis" /* SYNTHESIS */, "bayesian" /* BAYESIAN */],
            sequence: "hybrid",
            rationale: "Synthesize literature while quantifying evidence strength",
            benefits: ["Quantified synthesis", "Evidence weighting", "Probabilistic conclusions"],
            synergies: ["Synthesis gathers evidence", "Bayesian weights findings"]
          });
        }
        return combinations;
      }
      /**
       * Get a simple mode recommendation based on a few key characteristics
       * Simplified version for quick recommendations
       * Supports all 28 reasoning modes (v7.2.0)
       */
      quickRecommend(problemType) {
        const typeMap = {
          // Core reasoning modes
          "explanation": "abductive" /* ABDUCTIVE */,
          "hypothesis": "abductive" /* ABDUCTIVE */,
          "inference": "abductive" /* ABDUCTIVE */,
          "pattern": "inductive" /* INDUCTIVE */,
          "generalization": "inductive" /* INDUCTIVE */,
          "empirical": "inductive" /* INDUCTIVE */,
          "logic": "deductive" /* DEDUCTIVE */,
          "proof": "deductive" /* DEDUCTIVE */,
          "derivation": "deductive" /* DEDUCTIVE */,
          "complex": "hybrid" /* HYBRID */,
          "philosophical": "hybrid" /* HYBRID */,
          "metaphysical": "hybrid" /* HYBRID */,
          // Meta-reasoning
          "meta": "metareasoning" /* METAREASONING */,
          "strategy-selection": "metareasoning" /* METAREASONING */,
          "quality-assessment": "metareasoning" /* METAREASONING */,
          "reflection": "metareasoning" /* METAREASONING */,
          "self-evaluation": "metareasoning" /* METAREASONING */,
          // Specialized modes
          "debugging": "abductive" /* ABDUCTIVE */,
          "mathematical": "mathematics" /* MATHEMATICS */,
          "timeline": "temporal" /* TEMPORAL */,
          "strategy": "gametheory" /* GAMETHEORY */,
          "uncertainty": "evidential" /* EVIDENTIAL */,
          "causality": "causal" /* CAUSAL */,
          "probability": "bayesian" /* BAYESIAN */,
          "what-if": "counterfactual" /* COUNTERFACTUAL */,
          "analogy": "analogical" /* ANALOGICAL */,
          "physics": "physics" /* PHYSICS */,
          "systematic": "shannon" /* SHANNON */,
          // ===== NEW MODES (v7.2.0) =====
          // Engineering reasoning
          "engineering": "engineering" /* ENGINEERING */,
          "design": "engineering" /* ENGINEERING */,
          "architecture": "engineering" /* ENGINEERING */,
          "trade-off": "engineering" /* ENGINEERING */,
          "tradeoff": "engineering" /* ENGINEERING */,
          "system-design": "engineering" /* ENGINEERING */,
          "implementation": "engineering" /* ENGINEERING */,
          "reliability": "engineering" /* ENGINEERING */,
          "scalability": "engineering" /* ENGINEERING */,
          "performance": "engineering" /* ENGINEERING */,
          // Computability reasoning
          "computability": "computability" /* COMPUTABILITY */,
          "decidability": "computability" /* COMPUTABILITY */,
          "turing": "computability" /* COMPUTABILITY */,
          "halting": "computability" /* COMPUTABILITY */,
          "complexity-class": "computability" /* COMPUTABILITY */,
          "undecidable": "computability" /* COMPUTABILITY */,
          // Cryptanalytic reasoning
          "cryptanalysis": "cryptanalytic" /* CRYPTANALYTIC */,
          "cryptography": "cryptanalytic" /* CRYPTANALYTIC */,
          "security": "cryptanalytic" /* CRYPTANALYTIC */,
          "cipher": "cryptanalytic" /* CRYPTANALYTIC */,
          "encryption": "cryptanalytic" /* CRYPTANALYTIC */,
          "decryption": "cryptanalytic" /* CRYPTANALYTIC */,
          "attack-vector": "cryptanalytic" /* CRYPTANALYTIC */,
          "key-analysis": "cryptanalytic" /* CRYPTANALYTIC */,
          "protocol-security": "cryptanalytic" /* CRYPTANALYTIC */,
          // Recursive reasoning
          "recursive": "recursive" /* RECURSIVE */,
          "recursion": "recursive" /* RECURSIVE */,
          "divide-conquer": "recursive" /* RECURSIVE */,
          "self-similar": "recursive" /* RECURSIVE */,
          "decomposition": "recursive" /* RECURSIVE */,
          "fractal": "recursive" /* RECURSIVE */,
          "tree-traversal": "recursive" /* RECURSIVE */,
          // Modal reasoning
          "modal": "modal" /* MODAL */,
          "possibility": "modal" /* MODAL */,
          "necessity": "modal" /* MODAL */,
          "possible-worlds": "modal" /* MODAL */,
          "epistemic": "modal" /* MODAL */,
          "deontic": "modal" /* MODAL */,
          "alethic": "modal" /* MODAL */,
          // Stochastic reasoning
          "stochastic": "stochastic" /* STOCHASTIC */,
          "random-process": "stochastic" /* STOCHASTIC */,
          "markov": "stochastic" /* STOCHASTIC */,
          "monte-carlo": "stochastic" /* STOCHASTIC */,
          "probabilistic-process": "stochastic" /* STOCHASTIC */,
          "queueing": "stochastic" /* STOCHASTIC */,
          "random-walk": "stochastic" /* STOCHASTIC */,
          // Constraint reasoning
          "constraint": "constraint" /* CONSTRAINT */,
          "constraints": "constraint" /* CONSTRAINT */,
          "csp": "constraint" /* CONSTRAINT */,
          "sat": "constraint" /* CONSTRAINT */,
          "scheduling": "constraint" /* CONSTRAINT */,
          "allocation": "constraint" /* CONSTRAINT */,
          "feasibility": "constraint" /* CONSTRAINT */,
          "satisfiability": "constraint" /* CONSTRAINT */,
          // Optimization reasoning
          "optimization": "optimization" /* OPTIMIZATION */,
          "optimize": "optimization" /* OPTIMIZATION */,
          "optimal": "optimization" /* OPTIMIZATION */,
          "minimize": "optimization" /* OPTIMIZATION */,
          "maximize": "optimization" /* OPTIMIZATION */,
          "gradient": "optimization" /* OPTIMIZATION */,
          "convex": "optimization" /* OPTIMIZATION */,
          "heuristic": "optimization" /* OPTIMIZATION */,
          "search": "optimization" /* OPTIMIZATION */,
          // First Principles reasoning
          "first-principles": "firstprinciples" /* FIRSTPRINCIPLES */,
          "fundamental": "firstprinciples" /* FIRSTPRINCIPLES */,
          "foundational": "firstprinciples" /* FIRSTPRINCIPLES */,
          "axiom": "firstprinciples" /* FIRSTPRINCIPLES */,
          "ground-truth": "firstprinciples" /* FIRSTPRINCIPLES */,
          "from-scratch": "firstprinciples" /* FIRSTPRINCIPLES */,
          "basic-principles": "firstprinciples" /* FIRSTPRINCIPLES */,
          "root-cause": "firstprinciples" /* FIRSTPRINCIPLES */,
          // Systems Thinking reasoning
          "systems-thinking": "systemsthinking" /* SYSTEMSTHINKING */,
          "systems": "systemsthinking" /* SYSTEMSTHINKING */,
          "holistic": "systemsthinking" /* SYSTEMSTHINKING */,
          "feedback-loop": "systemsthinking" /* SYSTEMSTHINKING */,
          "emergence": "systemsthinking" /* SYSTEMSTHINKING */,
          "interconnected": "systemsthinking" /* SYSTEMSTHINKING */,
          "ecosystem": "systemsthinking" /* SYSTEMSTHINKING */,
          "leverage-point": "systemsthinking" /* SYSTEMSTHINKING */,
          // Scientific Method reasoning
          "scientific": "scientificmethod" /* SCIENTIFICMETHOD */,
          "experiment": "scientificmethod" /* SCIENTIFICMETHOD */,
          "research": "scientificmethod" /* SCIENTIFICMETHOD */,
          "falsification": "scientificmethod" /* SCIENTIFICMETHOD */,
          "hypothesis-testing": "scientificmethod" /* SCIENTIFICMETHOD */,
          "a/b-testing": "scientificmethod" /* SCIENTIFICMETHOD */,
          "reproducibility": "scientificmethod" /* SCIENTIFICMETHOD */,
          "control-group": "scientificmethod" /* SCIENTIFICMETHOD */,
          // Formal Logic reasoning
          "formal-logic": "formallogic" /* FORMALLOGIC */,
          "propositional": "formallogic" /* FORMALLOGIC */,
          "predicate": "formallogic" /* FORMALLOGIC */,
          "theorem-proving": "formallogic" /* FORMALLOGIC */,
          "formal-proof": "formallogic" /* FORMALLOGIC */,
          "validity": "formallogic" /* FORMALLOGIC */,
          "soundness": "formallogic" /* FORMALLOGIC */,
          "completeness": "formallogic" /* FORMALLOGIC */,
          // Bias detection and critical analysis
          "bias": "metareasoning" /* METAREASONING */,
          "bias-detection": "metareasoning" /* METAREASONING */,
          "cognitive-bias": "metareasoning" /* METAREASONING */,
          "fallacy": "formallogic" /* FORMALLOGIC */,
          "fallacies": "formallogic" /* FORMALLOGIC */,
          "logical-fallacy": "formallogic" /* FORMALLOGIC */,
          "counter-argument": "counterfactual" /* COUNTERFACTUAL */,
          "counterargument": "counterfactual" /* COUNTERFACTUAL */,
          "fact-check": "evidential" /* EVIDENTIAL */,
          "misinformation": "evidential" /* EVIDENTIAL */,
          "disinformation": "evidential" /* EVIDENTIAL */,
          "reasoning-flaw": "metareasoning" /* METAREASONING */,
          "argument-analysis": "formallogic" /* FORMALLOGIC */,
          // ===== ALGORITHMIC REASONING (v7.3.0) - CLRS Coverage =====
          // General algorithm terms
          "algorithm": "algorithmic" /* ALGORITHMIC */,
          "algorithms": "algorithmic" /* ALGORITHMIC */,
          "algorithmic": "algorithmic" /* ALGORITHMIC */,
          "data-structure": "algorithmic" /* ALGORITHMIC */,
          "data-structures": "algorithmic" /* ALGORITHMIC */,
          "complexity": "algorithmic" /* ALGORITHMIC */,
          "time-complexity": "algorithmic" /* ALGORITHMIC */,
          "space-complexity": "algorithmic" /* ALGORITHMIC */,
          "big-o": "algorithmic" /* ALGORITHMIC */,
          "asymptotic": "algorithmic" /* ALGORITHMIC */,
          "correctness-proof": "algorithmic" /* ALGORITHMIC */,
          "loop-invariant": "algorithmic" /* ALGORITHMIC */,
          "invariant": "algorithmic" /* ALGORITHMIC */,
          // Design patterns
          "divide-and-conquer": "algorithmic" /* ALGORITHMIC */,
          "dynamic-programming": "algorithmic" /* ALGORITHMIC */,
          "dp": "algorithmic" /* ALGORITHMIC */,
          "memoization": "algorithmic" /* ALGORITHMIC */,
          "greedy-algorithm": "algorithmic" /* ALGORITHMIC */,
          "backtracking": "algorithmic" /* ALGORITHMIC */,
          "branch-and-bound": "algorithmic" /* ALGORITHMIC */,
          "amortized": "algorithmic" /* ALGORITHMIC */,
          "amortized-analysis": "algorithmic" /* ALGORITHMIC */,
          // Sorting algorithms
          "sorting": "algorithmic" /* ALGORITHMIC */,
          "sort": "algorithmic" /* ALGORITHMIC */,
          "insertion-sort": "algorithmic" /* ALGORITHMIC */,
          "merge-sort": "algorithmic" /* ALGORITHMIC */,
          "mergesort": "algorithmic" /* ALGORITHMIC */,
          "quicksort": "algorithmic" /* ALGORITHMIC */,
          "quick-sort": "algorithmic" /* ALGORITHMIC */,
          "heapsort": "algorithmic" /* ALGORITHMIC */,
          "heap-sort": "algorithmic" /* ALGORITHMIC */,
          "counting-sort": "algorithmic" /* ALGORITHMIC */,
          "radix-sort": "algorithmic" /* ALGORITHMIC */,
          "bucket-sort": "algorithmic" /* ALGORITHMIC */,
          "comparison-sort": "algorithmic" /* ALGORITHMIC */,
          // Searching and selection
          "binary-search": "algorithmic" /* ALGORITHMIC */,
          "linear-search": "algorithmic" /* ALGORITHMIC */,
          "selection-algorithm": "algorithmic" /* ALGORITHMIC */,
          "median-of-medians": "algorithmic" /* ALGORITHMIC */,
          "order-statistics": "algorithmic" /* ALGORITHMIC */,
          // Data structures
          "heap": "algorithmic" /* ALGORITHMIC */,
          "binary-heap": "algorithmic" /* ALGORITHMIC */,
          "priority-queue": "algorithmic" /* ALGORITHMIC */,
          "hash-table": "algorithmic" /* ALGORITHMIC */,
          "hashing": "algorithmic" /* ALGORITHMIC */,
          "binary-search-tree": "algorithmic" /* ALGORITHMIC */,
          "bst": "algorithmic" /* ALGORITHMIC */,
          "red-black-tree": "algorithmic" /* ALGORITHMIC */,
          "avl-tree": "algorithmic" /* ALGORITHMIC */,
          "b-tree": "algorithmic" /* ALGORITHMIC */,
          "fibonacci-heap": "algorithmic" /* ALGORITHMIC */,
          "union-find": "algorithmic" /* ALGORITHMIC */,
          "disjoint-set": "algorithmic" /* ALGORITHMIC */,
          "trie": "algorithmic" /* ALGORITHMIC */,
          "segment-tree": "algorithmic" /* ALGORITHMIC */,
          "fenwick-tree": "algorithmic" /* ALGORITHMIC */,
          // Graph algorithms
          "graph-algorithm": "algorithmic" /* ALGORITHMIC */,
          "bfs": "algorithmic" /* ALGORITHMIC */,
          "breadth-first": "algorithmic" /* ALGORITHMIC */,
          "dfs": "algorithmic" /* ALGORITHMIC */,
          "depth-first": "algorithmic" /* ALGORITHMIC */,
          "topological-sort": "algorithmic" /* ALGORITHMIC */,
          "strongly-connected": "algorithmic" /* ALGORITHMIC */,
          "scc": "algorithmic" /* ALGORITHMIC */,
          "minimum-spanning-tree": "algorithmic" /* ALGORITHMIC */,
          "mst": "algorithmic" /* ALGORITHMIC */,
          "kruskal": "algorithmic" /* ALGORITHMIC */,
          "prim": "algorithmic" /* ALGORITHMIC */,
          "dijkstra": "algorithmic" /* ALGORITHMIC */,
          "bellman-ford": "algorithmic" /* ALGORITHMIC */,
          "floyd-warshall": "algorithmic" /* ALGORITHMIC */,
          "shortest-path": "algorithmic" /* ALGORITHMIC */,
          "max-flow": "algorithmic" /* ALGORITHMIC */,
          "ford-fulkerson": "algorithmic" /* ALGORITHMIC */,
          "edmonds-karp": "algorithmic" /* ALGORITHMIC */,
          "bipartite-matching": "algorithmic" /* ALGORITHMIC */,
          // Dynamic programming problems
          "lcs": "algorithmic" /* ALGORITHMIC */,
          "longest-common-subsequence": "algorithmic" /* ALGORITHMIC */,
          "edit-distance": "algorithmic" /* ALGORITHMIC */,
          "levenshtein": "algorithmic" /* ALGORITHMIC */,
          "knapsack": "algorithmic" /* ALGORITHMIC */,
          "matrix-chain": "algorithmic" /* ALGORITHMIC */,
          "optimal-bst": "algorithmic" /* ALGORITHMIC */,
          "rod-cutting": "algorithmic" /* ALGORITHMIC */,
          "coin-change": "algorithmic" /* ALGORITHMIC */,
          // String algorithms
          "string-matching": "algorithmic" /* ALGORITHMIC */,
          "pattern-matching": "algorithmic" /* ALGORITHMIC */,
          "kmp": "algorithmic" /* ALGORITHMIC */,
          "knuth-morris-pratt": "algorithmic" /* ALGORITHMIC */,
          "rabin-karp": "algorithmic" /* ALGORITHMIC */,
          "boyer-moore": "algorithmic" /* ALGORITHMIC */,
          "suffix-array": "algorithmic" /* ALGORITHMIC */,
          "suffix-tree": "algorithmic" /* ALGORITHMIC */,
          // Computational geometry
          "convex-hull": "algorithmic" /* ALGORITHMIC */,
          "graham-scan": "algorithmic" /* ALGORITHMIC */,
          "jarvis-march": "algorithmic" /* ALGORITHMIC */,
          "closest-pair": "algorithmic" /* ALGORITHMIC */,
          "line-intersection": "algorithmic" /* ALGORITHMIC */,
          // Number theory algorithms
          "gcd": "algorithmic" /* ALGORITHMIC */,
          "euclidean": "algorithmic" /* ALGORITHMIC */,
          "modular-arithmetic": "algorithmic" /* ALGORITHMIC */,
          "primality": "algorithmic" /* ALGORITHMIC */,
          "miller-rabin": "algorithmic" /* ALGORITHMIC */,
          "rsa": "algorithmic" /* ALGORITHMIC */,
          // Matrix algorithms
          "strassen": "algorithmic" /* ALGORITHMIC */,
          "matrix-multiplication": "algorithmic" /* ALGORITHMIC */,
          "matrix-exponentiation": "algorithmic" /* ALGORITHMIC */,
          // Advanced topics
          "fft": "algorithmic" /* ALGORITHMIC */,
          "fast-fourier": "algorithmic" /* ALGORITHMIC */,
          "polynomial-multiplication": "algorithmic" /* ALGORITHMIC */,
          "linear-programming": "algorithmic" /* ALGORITHMIC */,
          "simplex": "algorithmic" /* ALGORITHMIC */,
          "approximation-algorithm": "algorithmic" /* ALGORITHMIC */,
          "np-hard": "algorithmic" /* ALGORITHMIC */,
          "np-complete": "algorithmic" /* ALGORITHMIC */,
          // Recurrences and analysis
          "recurrence": "algorithmic" /* ALGORITHMIC */,
          "master-theorem": "algorithmic" /* ALGORITHMIC */,
          "recursion-tree": "algorithmic" /* ALGORITHMIC */,
          "substitution-method": "algorithmic" /* ALGORITHMIC */,
          // ===== ACADEMIC RESEARCH MODES (v7.4.0) =====
          // Synthesis mode - literature review and knowledge integration
          "synthesis": "synthesis" /* SYNTHESIS */,
          "literature-review": "synthesis" /* SYNTHESIS */,
          "literature-synthesis": "synthesis" /* SYNTHESIS */,
          "systematic-review": "synthesis" /* SYNTHESIS */,
          "meta-analysis": "synthesis" /* SYNTHESIS */,
          "knowledge-integration": "synthesis" /* SYNTHESIS */,
          "research-synthesis": "synthesis" /* SYNTHESIS */,
          "state-of-the-art": "synthesis" /* SYNTHESIS */,
          "survey-paper": "synthesis" /* SYNTHESIS */,
          "theme-extraction": "synthesis" /* SYNTHESIS */,
          "gap-analysis": "synthesis" /* SYNTHESIS */,
          "cross-study": "synthesis" /* SYNTHESIS */,
          // Argumentation mode - academic argumentation and Toulmin model
          "argumentation": "argumentation" /* ARGUMENTATION */,
          "argument": "argumentation" /* ARGUMENTATION */,
          "toulmin": "argumentation" /* ARGUMENTATION */,
          "toulmin-model": "argumentation" /* ARGUMENTATION */,
          "claim-evidence": "argumentation" /* ARGUMENTATION */,
          "warrant": "argumentation" /* ARGUMENTATION */,
          "backing": "argumentation" /* ARGUMENTATION */,
          "qualifier": "argumentation" /* ARGUMENTATION */,
          "rebuttal": "argumentation" /* ARGUMENTATION */,
          "thesis-argument": "argumentation" /* ARGUMENTATION */,
          "position-paper": "argumentation" /* ARGUMENTATION */,
          "debate": "argumentation" /* ARGUMENTATION */,
          "persuasion": "argumentation" /* ARGUMENTATION */,
          "dialectic": "argumentation" /* ARGUMENTATION */,
          "rhetorical": "argumentation" /* ARGUMENTATION */,
          // Critique mode - critical analysis and peer review
          "critique": "critique" /* CRITIQUE */,
          "critical-analysis": "critique" /* CRITIQUE */,
          "peer-review": "critique" /* CRITIQUE */,
          "paper-review": "critique" /* CRITIQUE */,
          "methodology-critique": "critique" /* CRITIQUE */,
          "validity-assessment": "critique" /* CRITIQUE */,
          "limitation-analysis": "critique" /* CRITIQUE */,
          "strength-weakness": "critique" /* CRITIQUE */,
          "constructive-feedback": "critique" /* CRITIQUE */,
          "research-critique": "critique" /* CRITIQUE */,
          "evaluation": "critique" /* CRITIQUE */,
          // Analysis mode - qualitative analysis methods
          "qualitative-analysis": "analysis" /* ANALYSIS */,
          "thematic-analysis": "analysis" /* ANALYSIS */,
          "grounded-theory": "analysis" /* ANALYSIS */,
          "discourse-analysis": "analysis" /* ANALYSIS */,
          "content-analysis": "analysis" /* ANALYSIS */,
          "narrative-analysis": "analysis" /* ANALYSIS */,
          "phenomenological": "analysis" /* ANALYSIS */,
          "ethnographic": "analysis" /* ANALYSIS */,
          "coding": "analysis" /* ANALYSIS */,
          "interview-analysis": "analysis" /* ANALYSIS */,
          "document-analysis": "analysis" /* ANALYSIS */,
          "case-study": "analysis" /* ANALYSIS */,
          "qualitative": "analysis" /* ANALYSIS */
        };
        return typeMap[problemType.toLowerCase()] || "sequential" /* SEQUENTIAL */;
      }
    };
  }
});

// src/types/modes/cryptanalytic.ts
function toDecibans(likelihoodRatio) {
  return 10 * Math.log10(likelihoodRatio);
}
function fromDecibans(decibans) {
  return Math.pow(10, decibans / 10);
}
function decibansToProbability(decibans, priorProbability = 0.5) {
  const priorOdds = priorProbability / (1 - priorProbability);
  const posteriorOdds = priorOdds * fromDecibans(decibans);
  return posteriorOdds / (1 + posteriorOdds);
}
var init_cryptanalytic = __esm({
  "src/types/modes/cryptanalytic.ts"() {
    init_esm_shims();
  }
});

// src/types/index.ts
var init_types = __esm({
  "src/types/index.ts"() {
    init_esm_shims();
    init_core();
    init_session();
    init_recommendations();
  }
});

// src/utils/type-guards.ts
function isExtendedThoughtType(value) {
  return typeof value === "string" && VALID_THOUGHT_TYPES.includes(value);
}
function toExtendedThoughtType(value, fallback) {
  if (isExtendedThoughtType(value)) {
    return value;
  }
  if (fallback !== void 0) {
    return fallback;
  }
  throw new Error(
    `Invalid ExtendedThoughtType: ${value}. Must be one of: ${VALID_THOUGHT_TYPES.join(", ")}`
  );
}
var VALID_THOUGHT_TYPES;
var init_type_guards = __esm({
  "src/utils/type-guards.ts"() {
    init_esm_shims();
    VALID_THOUGHT_TYPES = [
      "problem_definition",
      "constraints",
      "model",
      "proof",
      "implementation",
      "axiom_definition",
      "theorem_statement",
      "proof_construction",
      "lemma_derivation",
      "corollary",
      "counterexample",
      "algebraic_manipulation",
      "symbolic_computation",
      "numerical_analysis",
      "symmetry_analysis",
      "gauge_theory",
      "field_equations",
      "lagrangian",
      "hamiltonian",
      "conservation_law",
      "dimensional_analysis",
      "tensor_formulation",
      "differential_geometry",
      "decomposition",
      "synthesis",
      "abstraction",
      "analogy",
      "metacognition",
      // Phase 8: Proof Decomposition Types
      "proof_decomposition",
      "dependency_analysis",
      "consistency_check",
      "gap_identification",
      "assumption_trace"
    ];
  }
});
var GenericModeHandler;
var init_GenericModeHandler = __esm({
  "src/modes/handlers/GenericModeHandler.ts"() {
    init_esm_shims();
    init_core();
    init_ModeHandler();
    init_type_guards();
    GenericModeHandler = class {
      mode;
      modeName;
      description;
      constructor(mode, modeName, description) {
        this.mode = mode;
        this.modeName = modeName || this.getDefaultModeName(mode);
        this.description = description || this.getDefaultDescription(mode);
      }
      /**
       * Create a thought object from input
       *
       * This replicates the logic from ThoughtFactory.createThought()
       * for the mode this handler is configured for.
       */
      createThought(input, sessionId) {
        const baseThought = this.createBaseThought(input, sessionId);
        return this.createModeSpecificThought(input, baseThought);
      }
      /**
       * Create the base thought structure common to all modes
       */
      createBaseThought(input, sessionId) {
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          isRevision: input.isRevision,
          revisesThought: input.revisesThought
        };
      }
      /**
       * Create mode-specific thought structure
       *
       * Override this method in specialized handlers to add
       * mode-specific logic and validation.
       */
      createModeSpecificThought(input, baseThought) {
        const mode = input.mode || this.mode;
        switch (mode) {
          case "sequential" /* SEQUENTIAL */:
            return {
              ...baseThought,
              mode: "sequential" /* SEQUENTIAL */,
              revisionReason: input.revisionReason,
              branchFrom: input.branchFrom,
              branchId: input.branchId
            };
          case "shannon" /* SHANNON */:
            return {
              ...baseThought,
              mode: "shannon" /* SHANNON */,
              stage: input.stage || "problem_definition" /* PROBLEM_DEFINITION */,
              uncertainty: input.uncertainty || 0.5,
              dependencies: input.dependencies || [],
              assumptions: input.assumptions || []
            };
          case "mathematics" /* MATHEMATICS */:
            return {
              ...baseThought,
              mode: "mathematics" /* MATHEMATICS */,
              thoughtType: toExtendedThoughtType(input.thoughtType, "model"),
              mathematicalModel: input.mathematicalModel,
              proofStrategy: input.proofStrategy,
              dependencies: input.dependencies || [],
              assumptions: input.assumptions || [],
              uncertainty: input.uncertainty || 0.5
            };
          case "physics" /* PHYSICS */:
            return {
              ...baseThought,
              mode: "physics" /* PHYSICS */,
              thoughtType: toExtendedThoughtType(input.thoughtType, "model"),
              tensorProperties: input.tensorProperties,
              physicalInterpretation: input.physicalInterpretation,
              dependencies: input.dependencies || [],
              assumptions: input.assumptions || [],
              uncertainty: input.uncertainty || 0.5
            };
          case "inductive" /* INDUCTIVE */:
            return {
              ...baseThought,
              mode: "inductive" /* INDUCTIVE */,
              observations: input.observations || [],
              pattern: input.pattern,
              generalization: input.generalization || "",
              confidence: input.confidence ?? 0.5,
              counterexamples: input.counterexamples || [],
              sampleSize: input.sampleSize
            };
          case "deductive" /* DEDUCTIVE */:
            return {
              ...baseThought,
              mode: "deductive" /* DEDUCTIVE */,
              premises: input.premises || [],
              conclusion: input.conclusion || "",
              logicForm: input.logicForm,
              validityCheck: input.validityCheck ?? false,
              soundnessCheck: input.soundnessCheck
            };
          case "abductive" /* ABDUCTIVE */:
            return {
              ...baseThought,
              mode: "abductive" /* ABDUCTIVE */,
              thoughtType: toExtendedThoughtType(input.thoughtType, "problem_definition"),
              observations: input.observations || [],
              hypotheses: input.hypotheses || [],
              evaluationCriteria: input.evaluationCriteria,
              evidence: input.evidence || [],
              bestExplanation: input.bestExplanation
            };
          case "causal" /* CAUSAL */:
            return this.createCausalThought(input, baseThought);
          case "hybrid" /* HYBRID */:
          default:
            return this.createHybridThought(input, baseThought);
        }
      }
      /**
       * Create a causal thought with graph handling
       */
      createCausalThought(input, baseThought) {
        const inputAny = input;
        const causalGraph = input.causalGraph || {
          nodes: inputAny.nodes || [],
          edges: inputAny.edges || []
        };
        return {
          ...baseThought,
          mode: "causal" /* CAUSAL */,
          thoughtType: toExtendedThoughtType(input.thoughtType, "problem_definition"),
          causalGraph,
          interventions: input.interventions || [],
          mechanisms: input.mechanisms || [],
          confounders: input.confounders || []
        };
      }
      /**
       * Create a hybrid thought (default fallback)
       */
      createHybridThought(input, baseThought) {
        return {
          ...baseThought,
          mode: "hybrid" /* HYBRID */,
          thoughtType: toExtendedThoughtType(input.thoughtType, "synthesis"),
          stage: input.stage,
          uncertainty: input.uncertainty,
          dependencies: input.dependencies,
          assumptions: input.assumptions,
          mathematicalModel: input.mathematicalModel,
          tensorProperties: input.tensorProperties,
          physicalInterpretation: input.physicalInterpretation,
          primaryMode: input.mode || "hybrid" /* HYBRID */,
          secondaryFeatures: []
        };
      }
      /**
       * Validate mode-specific input
       *
       * The generic handler performs basic validation.
       * Specialized handlers should override for deeper validation.
       */
      validate(input) {
        const warnings = [];
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        const mode = input.mode || "hybrid" /* HYBRID */;
        if (!isFullyImplemented(mode)) {
          warnings.push(
            createValidationWarning(
              "mode",
              `Mode '${mode}' is experimental with limited runtime implementation`,
              "Consider using a fully implemented mode for production use"
            )
          );
        }
        return validationSuccess(warnings);
      }
      /**
       * Get mode-specific enhancements
       *
       * The generic handler returns minimal enhancements.
       * Specialized handlers can provide richer context.
       */
      getEnhancements(thought) {
        return {
          suggestions: [],
          relatedModes: this.getRelatedModes(thought.mode)
        };
      }
      /**
       * Get mode status information
       */
      getModeStatus() {
        return {
          mode: this.mode,
          isFullyImplemented: isFullyImplemented(this.mode),
          hasSpecializedHandler: false,
          // GenericHandler is not specialized
          note: isFullyImplemented(this.mode) ? void 0 : "This mode is experimental with limited runtime implementation"
        };
      }
      /**
       * Get related modes for suggestions
       */
      getRelatedModes(mode) {
        const relatedModes = {
          ["sequential" /* SEQUENTIAL */]: ["hybrid" /* HYBRID */, "shannon" /* SHANNON */],
          ["shannon" /* SHANNON */]: ["sequential" /* SEQUENTIAL */, "mathematics" /* MATHEMATICS */],
          ["mathematics" /* MATHEMATICS */]: ["physics" /* PHYSICS */, "algorithmic" /* ALGORITHMIC */],
          ["physics" /* PHYSICS */]: ["mathematics" /* MATHEMATICS */, "engineering" /* ENGINEERING */],
          ["hybrid" /* HYBRID */]: ["sequential" /* SEQUENTIAL */, "metareasoning" /* METAREASONING */],
          ["causal" /* CAUSAL */]: ["bayesian" /* BAYESIAN */, "counterfactual" /* COUNTERFACTUAL */],
          ["bayesian" /* BAYESIAN */]: ["causal" /* CAUSAL */, "evidential" /* EVIDENTIAL */],
          ["inductive" /* INDUCTIVE */]: ["deductive" /* DEDUCTIVE */, "abductive" /* ABDUCTIVE */],
          ["deductive" /* DEDUCTIVE */]: ["inductive" /* INDUCTIVE */, "formallogic" /* FORMALLOGIC */],
          ["abductive" /* ABDUCTIVE */]: ["inductive" /* INDUCTIVE */, "causal" /* CAUSAL */],
          ["counterfactual" /* COUNTERFACTUAL */]: ["causal" /* CAUSAL */, "gametheory" /* GAMETHEORY */],
          ["analogical" /* ANALOGICAL */]: ["inductive" /* INDUCTIVE */, "firstprinciples" /* FIRSTPRINCIPLES */],
          ["temporal" /* TEMPORAL */]: ["causal" /* CAUSAL */, "sequential" /* SEQUENTIAL */],
          ["gametheory" /* GAMETHEORY */]: ["optimization" /* OPTIMIZATION */, "counterfactual" /* COUNTERFACTUAL */],
          ["evidential" /* EVIDENTIAL */]: ["bayesian" /* BAYESIAN */, "scientificmethod" /* SCIENTIFICMETHOD */],
          ["firstprinciples" /* FIRSTPRINCIPLES */]: ["deductive" /* DEDUCTIVE */, "analogical" /* ANALOGICAL */],
          ["systemsthinking" /* SYSTEMSTHINKING */]: ["causal" /* CAUSAL */, "optimization" /* OPTIMIZATION */],
          ["scientificmethod" /* SCIENTIFICMETHOD */]: ["evidential" /* EVIDENTIAL */, "synthesis" /* SYNTHESIS */],
          ["formallogic" /* FORMALLOGIC */]: ["deductive" /* DEDUCTIVE */, "mathematics" /* MATHEMATICS */],
          ["metareasoning" /* METAREASONING */]: ["hybrid" /* HYBRID */, "critique" /* CRITIQUE */],
          ["recursive" /* RECURSIVE */]: ["algorithmic" /* ALGORITHMIC */, "mathematics" /* MATHEMATICS */],
          ["modal" /* MODAL */]: ["formallogic" /* FORMALLOGIC */, "counterfactual" /* COUNTERFACTUAL */],
          ["stochastic" /* STOCHASTIC */]: ["bayesian" /* BAYESIAN */, "optimization" /* OPTIMIZATION */],
          ["constraint" /* CONSTRAINT */]: ["optimization" /* OPTIMIZATION */, "formallogic" /* FORMALLOGIC */],
          ["optimization" /* OPTIMIZATION */]: ["constraint" /* CONSTRAINT */, "gametheory" /* GAMETHEORY */],
          ["engineering" /* ENGINEERING */]: ["optimization" /* OPTIMIZATION */, "systemsthinking" /* SYSTEMSTHINKING */],
          ["computability" /* COMPUTABILITY */]: ["algorithmic" /* ALGORITHMIC */, "formallogic" /* FORMALLOGIC */],
          ["cryptanalytic" /* CRYPTANALYTIC */]: ["bayesian" /* BAYESIAN */, "algorithmic" /* ALGORITHMIC */],
          ["algorithmic" /* ALGORITHMIC */]: ["mathematics" /* MATHEMATICS */, "optimization" /* OPTIMIZATION */],
          ["synthesis" /* SYNTHESIS */]: ["critique" /* CRITIQUE */, "analysis" /* ANALYSIS */],
          ["argumentation" /* ARGUMENTATION */]: ["critique" /* CRITIQUE */, "formallogic" /* FORMALLOGIC */],
          ["critique" /* CRITIQUE */]: ["argumentation" /* ARGUMENTATION */, "synthesis" /* SYNTHESIS */],
          ["analysis" /* ANALYSIS */]: ["synthesis" /* SYNTHESIS */, "scientificmethod" /* SCIENTIFICMETHOD */],
          ["custom" /* CUSTOM */]: ["hybrid" /* HYBRID */]
        };
        return relatedModes[mode] || ["hybrid" /* HYBRID */];
      }
      /**
       * Get default mode name
       */
      getDefaultModeName(mode) {
        const names = {
          ["sequential" /* SEQUENTIAL */]: "Sequential Thinking",
          ["shannon" /* SHANNON */]: "Shannon Problem-Solving",
          ["mathematics" /* MATHEMATICS */]: "Mathematical Reasoning",
          ["physics" /* PHYSICS */]: "Physics Modeling",
          ["hybrid" /* HYBRID */]: "Hybrid Mode",
          ["inductive" /* INDUCTIVE */]: "Inductive Reasoning",
          ["deductive" /* DEDUCTIVE */]: "Deductive Reasoning",
          ["abductive" /* ABDUCTIVE */]: "Abductive Reasoning",
          ["causal" /* CAUSAL */]: "Causal Analysis",
          ["bayesian" /* BAYESIAN */]: "Bayesian Inference",
          ["counterfactual" /* COUNTERFACTUAL */]: "Counterfactual Reasoning",
          ["analogical" /* ANALOGICAL */]: "Analogical Reasoning",
          ["temporal" /* TEMPORAL */]: "Temporal Reasoning",
          ["gametheory" /* GAMETHEORY */]: "Game Theory",
          ["evidential" /* EVIDENTIAL */]: "Evidential Reasoning",
          ["firstprinciples" /* FIRSTPRINCIPLES */]: "First Principles",
          ["systemsthinking" /* SYSTEMSTHINKING */]: "Systems Thinking",
          ["scientificmethod" /* SCIENTIFICMETHOD */]: "Scientific Method",
          ["formallogic" /* FORMALLOGIC */]: "Formal Logic",
          ["metareasoning" /* METAREASONING */]: "Meta-Reasoning",
          ["recursive" /* RECURSIVE */]: "Recursive Reasoning",
          ["modal" /* MODAL */]: "Modal Logic",
          ["stochastic" /* STOCHASTIC */]: "Stochastic Reasoning",
          ["constraint" /* CONSTRAINT */]: "Constraint Satisfaction",
          ["optimization" /* OPTIMIZATION */]: "Optimization",
          ["engineering" /* ENGINEERING */]: "Engineering Analysis",
          ["computability" /* COMPUTABILITY */]: "Computability Theory",
          ["cryptanalytic" /* CRYPTANALYTIC */]: "Cryptanalysis",
          ["algorithmic" /* ALGORITHMIC */]: "Algorithm Design",
          ["synthesis" /* SYNTHESIS */]: "Literature Synthesis",
          ["argumentation" /* ARGUMENTATION */]: "Academic Argumentation",
          ["critique" /* CRITIQUE */]: "Critical Analysis",
          ["analysis" /* ANALYSIS */]: "Qualitative Analysis",
          ["custom" /* CUSTOM */]: "Custom Mode"
        };
        return names[mode] || "Unknown Mode";
      }
      /**
       * Get default mode description
       */
      getDefaultDescription(mode) {
        const descriptions = {
          ["sequential" /* SEQUENTIAL */]: "Step-by-step logical reasoning",
          ["shannon" /* SHANNON */]: "Claude Shannon's 5-stage problem-solving methodology",
          ["mathematics" /* MATHEMATICS */]: "Mathematical proofs and formal reasoning",
          ["physics" /* PHYSICS */]: "Physical modeling with tensors and conservation laws",
          ["hybrid" /* HYBRID */]: "Flexible combination of multiple reasoning modes",
          ["inductive" /* INDUCTIVE */]: "Reasoning from specific cases to general principles",
          ["deductive" /* DEDUCTIVE */]: "Reasoning from general principles to specific conclusions",
          ["abductive" /* ABDUCTIVE */]: "Inference to the best explanation",
          ["causal" /* CAUSAL */]: "Causal graph analysis and intervention reasoning",
          ["bayesian" /* BAYESIAN */]: "Probabilistic reasoning with prior updates",
          ["counterfactual" /* COUNTERFACTUAL */]: "What-if scenario analysis",
          ["analogical" /* ANALOGICAL */]: "Reasoning by structural similarity",
          ["temporal" /* TEMPORAL */]: "Temporal logic and event sequencing",
          ["gametheory" /* GAMETHEORY */]: "Strategic interaction and Nash equilibria",
          ["evidential" /* EVIDENTIAL */]: "Dempster-Shafer evidence theory",
          ["firstprinciples" /* FIRSTPRINCIPLES */]: "Reasoning from fundamental truths",
          ["systemsthinking" /* SYSTEMSTHINKING */]: "Feedback loops and system dynamics",
          ["scientificmethod" /* SCIENTIFICMETHOD */]: "Hypothesis testing and experimentation",
          ["formallogic" /* FORMALLOGIC */]: "Propositional and predicate logic",
          ["metareasoning" /* METAREASONING */]: "Reasoning about reasoning strategies",
          ["recursive" /* RECURSIVE */]: "Self-similar problem decomposition",
          ["modal" /* MODAL */]: "Possibility and necessity reasoning",
          ["stochastic" /* STOCHASTIC */]: "Probabilistic state transitions",
          ["constraint" /* CONSTRAINT */]: "Constraint satisfaction problems",
          ["optimization" /* OPTIMIZATION */]: "Objective function optimization",
          ["engineering" /* ENGINEERING */]: "Requirements, trade studies, and FMEA",
          ["computability" /* COMPUTABILITY */]: "Turing machines and decidability",
          ["cryptanalytic" /* CRYPTANALYTIC */]: "Cryptanalysis with deciban evidence",
          ["algorithmic" /* ALGORITHMIC */]: "CLRS algorithm design and analysis",
          ["synthesis" /* SYNTHESIS */]: "Literature review and integration",
          ["argumentation" /* ARGUMENTATION */]: "Toulmin model academic arguments",
          ["critique" /* CRITIQUE */]: "Critical evaluation of scholarly work",
          ["analysis" /* ANALYSIS */]: "Qualitative data analysis methods",
          ["custom" /* CUSTOM */]: "User-defined reasoning mode"
        };
        return descriptions[mode] || "Unknown reasoning mode";
      }
    };
  }
});
var SequentialHandler;
var init_SequentialHandler = __esm({
  "src/modes/handlers/SequentialHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    SequentialHandler = class {
      mode = "sequential" /* SEQUENTIAL */;
      modeName = "Sequential Thinking";
      description = "Step-by-step logical reasoning with revision and branching support";
      /**
       * Supported thought types for sequential mode
       */
      supportedThoughtTypes = [
        "initial",
        "continuation",
        "revision",
        "branch",
        "conclusion"
      ];
      /**
       * Create a sequential thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          mode: "sequential" /* SEQUENTIAL */,
          // Revision tracking
          isRevision: input.isRevision,
          revisesThought: input.revisesThought,
          revisionReason: input.revisionReason,
          // Dependency tracking
          dependencies: input.dependencies || [],
          buildUpon: inputAny.buildUpon || [],
          // Branching support
          branchFrom: input.branchFrom,
          branchId: input.branchId,
          branchFromThought: inputAny.branchFromThought,
          // Iteration control
          needsMoreThoughts: input.nextThoughtNeeded
        };
      }
      /**
       * Validate sequential-specific input
       */
      validate(input) {
        const warnings = [];
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        if (input.isRevision && !input.revisesThought) {
          warnings.push(
            createValidationWarning(
              "revisesThought",
              "Revision marked but no thought ID specified to revise",
              "Specify which thought this revises using revisesThought field"
            )
          );
        }
        if (input.revisesThought && !input.isRevision) {
          warnings.push(
            createValidationWarning(
              "isRevision",
              "revisesThought specified but isRevision is not set",
              "Set isRevision: true when revising a previous thought"
            )
          );
        }
        if (input.branchFrom && !input.branchId) {
          warnings.push(
            createValidationWarning(
              "branchId",
              "Branching from a thought but no branch ID specified",
              "Provide a branchId to identify this reasoning branch"
            )
          );
        }
        if (input.isRevision && !input.revisionReason) {
          warnings.push(
            createValidationWarning(
              "revisionReason",
              "Revision without a stated reason",
              "Explain why this revision is being made for better tracking"
            )
          );
        }
        return validationSuccess(warnings);
      }
      /**
       * Get sequential-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["hybrid" /* HYBRID */, "shannon" /* SHANNON */, "metareasoning" /* METAREASONING */],
          guidingQuestions: [],
          warnings: [],
          metrics: {
            thoughtNumber: thought.thoughtNumber,
            totalThoughts: thought.totalThoughts,
            progress: thought.thoughtNumber / thought.totalThoughts
          },
          mentalModels: [
            "Iterative Refinement",
            "Step-by-Step Analysis",
            "Progressive Elaboration"
          ]
        };
        const progress = thought.thoughtNumber / thought.totalThoughts;
        if (progress < 0.3) {
          enhancements.guidingQuestions.push(
            "What are the key elements to explore in this problem?"
          );
          enhancements.suggestions.push(
            "Focus on understanding the problem space before diving into solutions"
          );
        } else if (progress < 0.7) {
          enhancements.guidingQuestions.push(
            "Are there alternative approaches worth considering?"
          );
          if (!thought.branchId) {
            enhancements.suggestions.push(
              "Consider branching to explore alternative reasoning paths"
            );
          }
        } else {
          enhancements.guidingQuestions.push(
            "What conclusions can be drawn from the reasoning so far?"
          );
          enhancements.suggestions.push(
            "Start synthesizing findings into actionable conclusions"
          );
        }
        if (thought.isRevision) {
          enhancements.metrics.isRevision = 1;
          if (!thought.revisionReason) {
            enhancements.warnings.push(
              "This revision lacks a documented reason - consider adding one for clarity"
            );
          }
        }
        if (thought.branchId) {
          enhancements.metrics.hasBranch = 1;
          enhancements.suggestions.push(
            `Currently on branch: ${thought.branchId}`
          );
        }
        if (thought.dependencies && thought.dependencies.length > 0) {
          enhancements.metrics.dependencyCount = thought.dependencies.length;
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
    };
  }
});
var STAGE_ORDER, ShannonHandler;
var init_ShannonHandler = __esm({
  "src/modes/handlers/ShannonHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    STAGE_ORDER = [
      "problem_definition" /* PROBLEM_DEFINITION */,
      "constraints" /* CONSTRAINTS */,
      "model" /* MODEL */,
      "proof" /* PROOF */,
      "implementation" /* IMPLEMENTATION */
    ];
    ShannonHandler = class {
      mode = "shannon" /* SHANNON */;
      modeName = "Shannon Problem-Solving";
      description = "Claude Shannon's 5-stage systematic problem-solving methodology";
      /**
       * Supported thought types for Shannon mode
       */
      supportedThoughtTypes = [
        "problem_definition",
        "constraint_identification",
        "model_construction",
        "proof_development",
        "implementation_planning",
        "recheck",
        "refinement"
      ];
      /**
       * Create a Shannon thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const stage = this.resolveStage(input.stage);
        const confidenceFactors = inputAny.confidenceFactors || this.calculateConfidenceFactors(inputAny);
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          mode: "shannon" /* SHANNON */,
          // Core Shannon fields
          stage,
          uncertainty: input.uncertainty ?? 0.5,
          dependencies: input.dependencies || [],
          assumptions: input.assumptions || [],
          // Revision tracking
          isRevision: input.isRevision,
          revisesThought: input.revisesThought,
          // Extended Shannon fields
          recheckStep: inputAny.recheckStep,
          confidenceFactors,
          alternativeApproaches: inputAny.alternativeApproaches || [],
          knownLimitations: inputAny.knownLimitations || []
        };
      }
      /**
       * Validate Shannon-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        if (input.stage) {
          if (!STAGE_ORDER.includes(input.stage)) {
            errors.push(
              createValidationError(
                "stage",
                `Invalid Shannon stage: ${input.stage}. Valid stages: ${STAGE_ORDER.join(", ")}`,
                "INVALID_SHANNON_STAGE"
              )
            );
          }
        } else {
          warnings.push(
            createValidationWarning(
              "stage",
              "No stage specified - defaulting to problem_definition",
              "Specify a stage to track methodology progression"
            )
          );
        }
        if (input.uncertainty !== void 0) {
          if (input.uncertainty < 0 || input.uncertainty > 1) {
            errors.push(
              createValidationError(
                "uncertainty",
                `Uncertainty (${input.uncertainty}) must be between 0 and 1`,
                "UNCERTAINTY_OUT_OF_RANGE"
              )
            );
          }
        }
        if (inputAny.confidenceFactors) {
          const cf = inputAny.confidenceFactors;
          const cfFields = ["dataQuality", "methodologyRobustness", "assumptionValidity"];
          for (const field of cfFields) {
            if (cf[field] !== void 0 && (cf[field] < 0 || cf[field] > 1)) {
              warnings.push(
                createValidationWarning(
                  `confidenceFactors.${field}`,
                  `${field} (${cf[field]}) should be between 0 and 1`,
                  "Normalize confidence factors to [0, 1] range"
                )
              );
            }
          }
        }
        if (!input.assumptions || input.assumptions.length === 0) {
          const stage = input.stage;
          if (stage === "problem_definition" /* PROBLEM_DEFINITION */ || stage === "constraints" /* CONSTRAINTS */) {
            warnings.push(
              createValidationWarning(
                "assumptions",
                "No assumptions stated in early stage",
                "Document assumptions early to improve clarity and validation"
              )
            );
          }
        }
        if (inputAny.recheckStep) {
          if (!inputAny.recheckStep.stepToRecheck || !inputAny.recheckStep.reason) {
            warnings.push(
              createValidationWarning(
                "recheckStep",
                "Recheck step missing required fields",
                "Include stepToRecheck and reason for proper tracking"
              )
            );
          }
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get Shannon-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["sequential" /* SEQUENTIAL */, "mathematics" /* MATHEMATICS */, "engineering" /* ENGINEERING */],
          guidingQuestions: [],
          warnings: [],
          metrics: {
            stageIndex: STAGE_ORDER.indexOf(thought.stage),
            uncertainty: thought.uncertainty,
            dependencyCount: thought.dependencies?.length || 0,
            assumptionCount: thought.assumptions?.length || 0
          },
          mentalModels: [
            "Shannon's Problem-Solving",
            "Systematic Decomposition",
            "Constraint-Based Design",
            "Proof-First Development"
          ]
        };
        switch (thought.stage) {
          case "problem_definition" /* PROBLEM_DEFINITION */:
            enhancements.guidingQuestions.push(
              "What is the essential problem we are trying to solve?",
              "What would a solution look like?",
              "What are the inputs and outputs?"
            );
            enhancements.suggestions.push(
              "Focus on clearly stating what success looks like before moving to constraints"
            );
            break;
          case "constraints" /* CONSTRAINTS */:
            enhancements.guidingQuestions.push(
              "What are the hard constraints that cannot be violated?",
              "What are the soft constraints we should optimize for?",
              "Are there any hidden constraints we might be missing?"
            );
            enhancements.suggestions.push(
              "Document all constraints explicitly - implicit constraints often cause problems later"
            );
            break;
          case "model" /* MODEL */:
            enhancements.guidingQuestions.push(
              "Does the model capture all essential aspects of the problem?",
              "Is the model simple enough to reason about formally?",
              "What assumptions does the model make?"
            );
            enhancements.suggestions.push(
              "Consider creating multiple models and comparing their trade-offs"
            );
            break;
          case "proof" /* PROOF */:
            enhancements.guidingQuestions.push(
              "What property are we trying to prove?",
              "What technique is most appropriate for this proof?",
              "Are there edge cases we need to handle?"
            );
            enhancements.suggestions.push(
              "Start with the simplest case and build up to the general proof"
            );
            enhancements.relatedModes = ["mathematics" /* MATHEMATICS */, "formallogic" /* FORMALLOGIC */, "deductive" /* DEDUCTIVE */];
            break;
          case "implementation" /* IMPLEMENTATION */:
            enhancements.guidingQuestions.push(
              "How does the implementation map to the formal model?",
              "What practical constraints affect the implementation?",
              "How will we verify the implementation matches the proof?"
            );
            enhancements.suggestions.push(
              "Create a clear mapping between model elements and implementation components"
            );
            enhancements.relatedModes = ["engineering" /* ENGINEERING */, "algorithmic" /* ALGORITHMIC */];
            break;
        }
        if (thought.uncertainty > 0.7) {
          enhancements.warnings.push(
            "High uncertainty detected - consider revisiting assumptions or gathering more information"
          );
        } else if (thought.uncertainty < 0.2) {
          enhancements.suggestions.push(
            "Low uncertainty suggests good progress - consider moving to the next stage"
          );
        }
        if (thought.confidenceFactors) {
          const cf = thought.confidenceFactors;
          enhancements.metrics.dataQuality = cf.dataQuality;
          enhancements.metrics.methodologyRobustness = cf.methodologyRobustness;
          enhancements.metrics.assumptionValidity = cf.assumptionValidity;
          const avgConfidence = (cf.dataQuality + cf.methodologyRobustness + cf.assumptionValidity) / 3;
          enhancements.metrics.overallConfidence = avgConfidence;
          if (cf.assumptionValidity < 0.5) {
            enhancements.warnings.push(
              "Low assumption validity - validate assumptions before proceeding"
            );
          }
        }
        if (thought.alternativeApproaches && thought.alternativeApproaches.length > 0) {
          enhancements.metrics.alternativeCount = thought.alternativeApproaches.length;
        } else if (thought.stage !== "implementation" /* IMPLEMENTATION */) {
          enhancements.suggestions.push(
            "Consider documenting alternative approaches for comparison"
          );
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Resolve stage from input
       */
      resolveStage(stage) {
        if (!stage) {
          return "problem_definition" /* PROBLEM_DEFINITION */;
        }
        const stageMap = {
          problem_definition: "problem_definition" /* PROBLEM_DEFINITION */,
          constraints: "constraints" /* CONSTRAINTS */,
          model: "model" /* MODEL */,
          proof: "proof" /* PROOF */,
          implementation: "implementation" /* IMPLEMENTATION */
        };
        return stageMap[stage.toLowerCase()] || "problem_definition" /* PROBLEM_DEFINITION */;
      }
      /**
       * Calculate confidence factors from input if not provided
       */
      calculateConfidenceFactors(input) {
        if (!input.assumptions && !input.dependencies) {
          return void 0;
        }
        const assumptionCount = input.assumptions?.length || 0;
        const dependencyCount = input.dependencies?.length || 0;
        return {
          dataQuality: Math.max(0.3, 1 - (input.uncertainty || 0.5)),
          methodologyRobustness: Math.min(0.9, 0.5 + dependencyCount * 0.1),
          assumptionValidity: assumptionCount > 0 ? 0.7 : 0.5
        };
      }
    };
  }
});
var VALID_THOUGHT_TYPES2, VALID_PROOF_TYPES, MathematicsHandler;
var init_MathematicsHandler = __esm({
  "src/modes/handlers/MathematicsHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    VALID_THOUGHT_TYPES2 = [
      "axiom_definition",
      "theorem_statement",
      "proof_construction",
      "lemma_derivation",
      "corollary",
      "counterexample",
      "algebraic_manipulation",
      "symbolic_computation",
      "numerical_analysis",
      "proof_decomposition",
      "dependency_analysis",
      "consistency_check",
      "gap_identification",
      "assumption_trace"
    ];
    VALID_PROOF_TYPES = ["direct", "contradiction", "induction", "construction", "contrapositive"];
    MathematicsHandler = class {
      mode = "mathematics" /* MATHEMATICS */;
      modeName = "Mathematical Reasoning";
      description = "Formal mathematical proofs, theorems, and symbolic computation";
      /**
       * Create a mathematics thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const thoughtType = this.resolveThoughtType(inputAny.thoughtType);
        const mathematicalModel = this.normalizeModel(input.mathematicalModel);
        const proofStrategy = this.normalizeProofStrategy(input.proofStrategy);
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          mode: "mathematics" /* MATHEMATICS */,
          // Core mathematics fields
          thoughtType,
          mathematicalModel,
          proofStrategy,
          dependencies: input.dependencies || [],
          assumptions: input.assumptions || [],
          uncertainty: input.uncertainty ?? 0.5,
          // Extended fields
          theorems: inputAny.theorems || [],
          logicalForm: inputAny.logicalForm,
          references: inputAny.references || [],
          // Proof analysis fields (populated by external engine)
          decomposition: inputAny.decomposition,
          consistencyReport: inputAny.consistencyReport,
          gapAnalysis: inputAny.gapAnalysis,
          assumptionAnalysis: inputAny.assumptionAnalysis,
          // Revision tracking
          isRevision: input.isRevision,
          revisesThought: input.revisesThought
        };
      }
      /**
       * Validate mathematics-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        if (inputAny.thoughtType && !VALID_THOUGHT_TYPES2.includes(inputAny.thoughtType)) {
          warnings.push(
            createValidationWarning(
              "thoughtType",
              `Unknown thought type: ${inputAny.thoughtType}`,
              `Valid types: ${VALID_THOUGHT_TYPES2.join(", ")}`
            )
          );
        }
        if (input.uncertainty !== void 0) {
          if (input.uncertainty < 0 || input.uncertainty > 1) {
            errors.push(
              createValidationError(
                "uncertainty",
                `Uncertainty (${input.uncertainty}) must be between 0 and 1`,
                "UNCERTAINTY_OUT_OF_RANGE"
              )
            );
          }
        }
        if (input.mathematicalModel) {
          const modelValidation = this.validateModel(input.mathematicalModel);
          errors.push(...modelValidation.errors);
          warnings.push(...modelValidation.warnings);
        }
        if (input.proofStrategy) {
          const strategyValidation = this.validateProofStrategy(input.proofStrategy);
          errors.push(...strategyValidation.errors);
          warnings.push(...strategyValidation.warnings);
        }
        if (inputAny.thoughtType === "theorem_statement" && (!input.assumptions || input.assumptions.length === 0)) {
          warnings.push(
            createValidationWarning(
              "assumptions",
              "Theorem stated without explicit assumptions",
              "Document assumptions to ensure the theorem is well-defined"
            )
          );
        }
        if (inputAny.thoughtType === "proof_construction" && !input.proofStrategy) {
          warnings.push(
            createValidationWarning(
              "proofStrategy",
              "Proof construction without explicit strategy",
              "Specify the proof approach (direct, contradiction, induction, etc.)"
            )
          );
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get mathematics-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["physics" /* PHYSICS */, "formallogic" /* FORMALLOGIC */, "deductive" /* DEDUCTIVE */],
          guidingQuestions: [],
          warnings: [],
          metrics: {
            dependencyCount: thought.dependencies?.length || 0,
            assumptionCount: thought.assumptions?.length || 0,
            uncertainty: thought.uncertainty
          },
          mentalModels: [
            "Axiomatic Reasoning",
            "Proof by Induction",
            "Proof by Contradiction",
            "Constructive Proof",
            "Symbolic Manipulation"
          ]
        };
        switch (thought.thoughtType) {
          case "axiom_definition":
            enhancements.guidingQuestions.push(
              "Is this axiom consistent with existing axioms?",
              "Is this axiom independent from other axioms?"
            );
            break;
          case "theorem_statement":
            enhancements.guidingQuestions.push(
              "What is the simplest case of this theorem?",
              "Are there known counterexamples to consider?"
            );
            enhancements.suggestions.push(
              "State the theorem precisely with all quantifiers explicit"
            );
            break;
          case "proof_construction":
            if (thought.proofStrategy) {
              enhancements.suggestions.push(
                `Using ${thought.proofStrategy.type} proof strategy`
              );
              if (thought.proofStrategy.completeness < 0.5) {
                enhancements.warnings.push(
                  "Proof is less than 50% complete - continue developing steps"
                );
              }
            }
            enhancements.guidingQuestions.push(
              "What is the key insight that makes this proof work?"
            );
            break;
          case "lemma_derivation":
            enhancements.suggestions.push(
              "Ensure the lemma is general enough to be reusable"
            );
            enhancements.guidingQuestions.push(
              "Is this lemma necessary, or can it be simplified?"
            );
            break;
          case "counterexample":
            enhancements.guidingQuestions.push(
              "Does this counterexample apply to the general case?",
              "What conditions would make the original statement true?"
            );
            break;
          case "proof_decomposition":
            enhancements.relatedModes = ["algorithmic" /* ALGORITHMIC */, "formallogic" /* FORMALLOGIC */];
            enhancements.suggestions.push(
              "Break the proof into atomic, independently verifiable steps"
            );
            break;
          case "consistency_check":
            enhancements.guidingQuestions.push(
              "Are there any hidden assumptions?",
              "Do all definitions agree with standard usage?"
            );
            break;
          case "gap_identification":
            enhancements.suggestions.push(
              "Document each gap with its severity and suggested fix"
            );
            break;
        }
        if (thought.mathematicalModel) {
          enhancements.metrics.hasModel = 1;
          if (thought.mathematicalModel.validated) {
            enhancements.metrics.modelValidated = 1;
          } else {
            enhancements.suggestions.push(
              "Consider validating the mathematical model"
            );
          }
        }
        if (thought.proofStrategy) {
          enhancements.metrics.proofType = thought.proofStrategy.type;
          enhancements.metrics.proofCompleteness = thought.proofStrategy.completeness;
          if (thought.proofStrategy.type === "induction") {
            if (!thought.proofStrategy.baseCase) {
              enhancements.warnings.push("Induction proof missing base case");
            }
            if (!thought.proofStrategy.inductiveStep) {
              enhancements.warnings.push("Induction proof missing inductive step");
            }
          }
        }
        if (thought.decomposition) {
          enhancements.metrics.atomCount = thought.decomposition.atomCount;
          enhancements.metrics.completeness = thought.decomposition.completeness;
          enhancements.metrics.rigorLevel = thought.decomposition.rigorLevel;
        }
        if (thought.consistencyReport) {
          if (!thought.consistencyReport.isConsistent) {
            enhancements.warnings.push(
              `Inconsistency detected: ${thought.consistencyReport.inconsistencies.length} issue(s)`
            );
          }
          enhancements.metrics.consistencyScore = thought.consistencyReport.overallScore;
        }
        if (thought.gapAnalysis) {
          if (thought.gapAnalysis.gaps.length > 0) {
            enhancements.warnings.push(
              `${thought.gapAnalysis.gaps.length} gap(s) identified in reasoning`
            );
          }
          enhancements.metrics.gapCount = thought.gapAnalysis.gaps.length;
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return VALID_THOUGHT_TYPES2.includes(thoughtType);
      }
      /**
       * Resolve thought type
       */
      resolveThoughtType(inputType) {
        if (inputType && VALID_THOUGHT_TYPES2.includes(inputType)) {
          return inputType;
        }
        return "axiom_definition";
      }
      /**
       * Normalize mathematical model
       */
      normalizeModel(model) {
        if (!model) return void 0;
        return {
          latex: model.latex || "",
          symbolic: model.symbolic || "",
          ascii: model.ascii,
          tensorRank: model.tensorRank,
          dimensions: model.dimensions,
          invariants: model.invariants || [],
          symmetries: model.symmetries || [],
          complexity: model.complexity,
          stabilityNotes: model.stabilityNotes,
          validated: model.validated ?? false,
          validationMethod: model.validationMethod
        };
      }
      /**
       * Normalize proof strategy
       */
      normalizeProofStrategy(strategy) {
        if (!strategy || !strategy.type) return void 0;
        return {
          type: VALID_PROOF_TYPES.includes(strategy.type) ? strategy.type : "direct",
          steps: strategy.steps || [],
          baseCase: strategy.baseCase,
          inductiveStep: strategy.inductiveStep,
          completeness: strategy.completeness ?? 0
        };
      }
      /**
       * Validate mathematical model
       */
      validateModel(model) {
        const warnings = [];
        if (!model.latex && !model.symbolic) {
          warnings.push(
            createValidationWarning(
              "mathematicalModel",
              "Model has no LaTeX or symbolic representation",
              "Provide at least one formal representation"
            )
          );
        }
        return validationSuccess(warnings);
      }
      /**
       * Validate proof strategy
       */
      validateProofStrategy(strategy) {
        const errors = [];
        const warnings = [];
        if (!VALID_PROOF_TYPES.includes(strategy.type)) {
          errors.push(
            createValidationError(
              "proofStrategy.type",
              `Invalid proof type: ${strategy.type}. Valid types: ${VALID_PROOF_TYPES.join(", ")}`,
              "INVALID_PROOF_TYPE"
            )
          );
        }
        if (strategy.type === "induction") {
          if (!strategy.baseCase) {
            warnings.push(
              createValidationWarning(
                "proofStrategy.baseCase",
                "Induction proof should specify base case",
                "Add baseCase field for clarity"
              )
            );
          }
          if (!strategy.inductiveStep) {
            warnings.push(
              createValidationWarning(
                "proofStrategy.inductiveStep",
                "Induction proof should specify inductive step",
                "Add inductiveStep field for clarity"
              )
            );
          }
        }
        if (strategy.completeness !== void 0 && (strategy.completeness < 0 || strategy.completeness > 1)) {
          warnings.push(
            createValidationWarning(
              "proofStrategy.completeness",
              `Completeness (${strategy.completeness}) should be between 0 and 1`,
              "Normalize completeness to [0, 1] range"
            )
          );
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
    };
  }
});
var VALID_THOUGHT_TYPES3, VALID_TRANSFORMATIONS, PhysicsHandler;
var init_PhysicsHandler = __esm({
  "src/modes/handlers/PhysicsHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    VALID_THOUGHT_TYPES3 = [
      "symmetry_analysis",
      "gauge_theory",
      "field_equations",
      "lagrangian",
      "hamiltonian",
      "conservation_law",
      "dimensional_analysis",
      "tensor_formulation",
      "differential_geometry"
    ];
    VALID_TRANSFORMATIONS = ["covariant", "contravariant", "mixed"];
    PhysicsHandler = class {
      mode = "physics" /* PHYSICS */;
      modeName = "Physics Modeling";
      description = "Physical modeling with tensor mathematics, conservation laws, and field theory";
      /**
       * Create a physics thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const thoughtType = this.resolveThoughtType(inputAny.thoughtType);
        const tensorProperties = this.normalizeTensor(input.tensorProperties);
        const physicalInterpretation = this.normalizeInterpretation(input.physicalInterpretation);
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          mode: "physics" /* PHYSICS */,
          // Core physics fields
          thoughtType,
          tensorProperties,
          physicalInterpretation,
          dependencies: input.dependencies || [],
          assumptions: input.assumptions || [],
          uncertainty: input.uncertainty ?? 0.5,
          // Extended fields
          fieldTheoryContext: inputAny.fieldTheoryContext,
          // Revision tracking
          isRevision: input.isRevision,
          revisesThought: input.revisesThought
        };
      }
      /**
       * Validate physics-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        if (inputAny.thoughtType && !VALID_THOUGHT_TYPES3.includes(inputAny.thoughtType)) {
          warnings.push(
            createValidationWarning(
              "thoughtType",
              `Unknown thought type: ${inputAny.thoughtType}`,
              `Valid types: ${VALID_THOUGHT_TYPES3.join(", ")}`
            )
          );
        }
        if (input.uncertainty !== void 0) {
          if (input.uncertainty < 0 || input.uncertainty > 1) {
            errors.push(
              createValidationError(
                "uncertainty",
                `Uncertainty (${input.uncertainty}) must be between 0 and 1`,
                "UNCERTAINTY_OUT_OF_RANGE"
              )
            );
          }
        }
        if (input.tensorProperties) {
          const tensorValidation = this.validateTensor(input.tensorProperties);
          errors.push(...tensorValidation.errors);
          warnings.push(...tensorValidation.warnings);
        }
        if (input.physicalInterpretation) {
          const interpValidation = this.validateInterpretation(input.physicalInterpretation);
          errors.push(...interpValidation.errors);
          warnings.push(...interpValidation.warnings);
        }
        if (inputAny.fieldTheoryContext) {
          const fieldValidation = this.validateFieldTheory(inputAny.fieldTheoryContext);
          errors.push(...fieldValidation.errors);
          warnings.push(...fieldValidation.warnings);
        }
        if (!input.tensorProperties) {
          const tensorTypes = ["tensor_formulation", "gauge_theory", "differential_geometry"];
          if (tensorTypes.includes(inputAny.thoughtType)) {
            warnings.push(
              createValidationWarning(
                "tensorProperties",
                `${inputAny.thoughtType} typically involves tensor mathematics`,
                "Consider adding tensorProperties for formal representation"
              )
            );
          }
        }
        if (input.physicalInterpretation && (!input.physicalInterpretation.conservationLaws || input.physicalInterpretation.conservationLaws.length === 0)) {
          warnings.push(
            createValidationWarning(
              "physicalInterpretation.conservationLaws",
              "No conservation laws specified",
              "Document relevant conservation laws (energy, momentum, charge, etc.)"
            )
          );
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get physics-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["mathematics" /* MATHEMATICS */, "engineering" /* ENGINEERING */, "systemsthinking" /* SYSTEMSTHINKING */],
          guidingQuestions: [],
          warnings: [],
          metrics: {
            dependencyCount: thought.dependencies?.length || 0,
            assumptionCount: thought.assumptions?.length || 0,
            uncertainty: thought.uncertainty
          },
          mentalModels: [
            "Tensor Analysis",
            "Conservation Principles",
            "Symmetry and Invariance",
            "Dimensional Analysis",
            "Lagrangian Mechanics"
          ]
        };
        switch (thought.thoughtType) {
          case "symmetry_analysis":
            enhancements.guidingQuestions.push(
              "What symmetries are present in the system?",
              "What conservation laws follow from these symmetries (Noether)?"
            );
            enhancements.suggestions.push(
              "Apply Noether's theorem to derive conservation laws from symmetries"
            );
            break;
          case "gauge_theory":
            enhancements.guidingQuestions.push(
              "What is the gauge group?",
              "What are the gauge fields and their transformations?"
            );
            enhancements.relatedModes = ["mathematics" /* MATHEMATICS */, "formallogic" /* FORMALLOGIC */];
            break;
          case "field_equations":
            enhancements.guidingQuestions.push(
              "What are the sources in these field equations?",
              "Are the equations linear or nonlinear?"
            );
            break;
          case "lagrangian":
            enhancements.guidingQuestions.push(
              "What are the generalized coordinates?",
              "Are there any constraints on the system?"
            );
            enhancements.suggestions.push(
              "Derive equations of motion using Euler-Lagrange equations"
            );
            break;
          case "hamiltonian":
            enhancements.guidingQuestions.push(
              "What are the canonical coordinates and momenta?",
              "Is the Hamiltonian time-independent (energy conserved)?"
            );
            break;
          case "conservation_law":
            enhancements.guidingQuestions.push(
              "What quantity is conserved?",
              "What symmetry gives rise to this conservation law?"
            );
            enhancements.suggestions.push(
              "Express the conservation law in both differential and integral forms"
            );
            break;
          case "dimensional_analysis":
            enhancements.guidingQuestions.push(
              "What are the fundamental dimensions involved?",
              "Are all terms dimensionally consistent?"
            );
            enhancements.suggestions.push(
              "Use the Buckingham \u03C0 theorem for non-dimensionalization"
            );
            break;
          case "tensor_formulation":
            enhancements.guidingQuestions.push(
              "What is the tensor rank and index structure?",
              "Is the tensor covariant under the required transformations?"
            );
            break;
          case "differential_geometry":
            enhancements.guidingQuestions.push(
              "What is the manifold structure?",
              "What are the relevant curvature invariants?"
            );
            enhancements.relatedModes = ["mathematics" /* MATHEMATICS */];
            break;
        }
        if (thought.tensorProperties) {
          const tp = thought.tensorProperties;
          enhancements.metrics.tensorRank = tp.rank[0] + tp.rank[1];
          enhancements.metrics.symmetryCount = tp.symmetries?.length || 0;
          enhancements.metrics.invariantCount = tp.invariants?.length || 0;
          if (tp.symmetries && tp.symmetries.length > 0) {
            enhancements.suggestions.push(
              `Tensor has ${tp.symmetries.length} symmetr${tp.symmetries.length > 1 ? "ies" : "y"}: ${tp.symmetries.slice(0, 3).join(", ")}`
            );
          }
        }
        if (thought.physicalInterpretation) {
          const pi = thought.physicalInterpretation;
          enhancements.metrics.conservationLawCount = pi.conservationLaws?.length || 0;
          if (pi.conservationLaws && pi.conservationLaws.length > 0) {
            enhancements.suggestions.push(
              `Conservation laws: ${pi.conservationLaws.join(", ")}`
            );
          }
          if (pi.constraints && pi.constraints.length > 0) {
            enhancements.metrics.constraintCount = pi.constraints.length;
          }
        }
        if (thought.fieldTheoryContext) {
          const ft = thought.fieldTheoryContext;
          enhancements.metrics.fieldCount = ft.fields?.length || 0;
          enhancements.metrics.interactionCount = ft.interactions?.length || 0;
          if (ft.symmetryGroup) {
            enhancements.suggestions.push(`Symmetry group: ${ft.symmetryGroup}`);
          }
        }
        if (thought.uncertainty > 0.7) {
          enhancements.warnings.push(
            "High uncertainty - consider reviewing assumptions or adding constraints"
          );
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return VALID_THOUGHT_TYPES3.includes(thoughtType);
      }
      /**
       * Resolve thought type
       */
      resolveThoughtType(inputType) {
        if (inputType && VALID_THOUGHT_TYPES3.includes(inputType)) {
          return inputType;
        }
        return "symmetry_analysis";
      }
      /**
       * Normalize tensor properties
       */
      normalizeTensor(tensor) {
        if (!tensor) return void 0;
        return {
          rank: tensor.rank || [0, 0],
          components: tensor.components || "",
          latex: tensor.latex || "",
          symmetries: tensor.symmetries || [],
          invariants: tensor.invariants || [],
          transformation: VALID_TRANSFORMATIONS.includes(tensor.transformation) ? tensor.transformation : "mixed",
          indexStructure: tensor.indexStructure,
          coordinateSystem: tensor.coordinateSystem
        };
      }
      /**
       * Normalize physical interpretation
       */
      normalizeInterpretation(interp) {
        if (!interp) return void 0;
        return {
          quantity: interp.quantity || "",
          units: interp.units || "",
          conservationLaws: interp.conservationLaws || [],
          constraints: interp.constraints,
          observables: interp.observables
        };
      }
      /**
       * Validate tensor properties
       */
      validateTensor(tensor) {
        const errors = [];
        const warnings = [];
        if (!tensor.rank || !Array.isArray(tensor.rank) || tensor.rank.length !== 2) {
          errors.push(
            createValidationError(
              "tensorProperties.rank",
              "Tensor rank must be a tuple [contravariant, covariant]",
              "INVALID_TENSOR_RANK"
            )
          );
        } else {
          if (tensor.rank[0] < 0 || tensor.rank[1] < 0) {
            errors.push(
              createValidationError(
                "tensorProperties.rank",
                "Tensor rank indices must be non-negative",
                "NEGATIVE_TENSOR_RANK"
              )
            );
          }
        }
        if (tensor.transformation && !VALID_TRANSFORMATIONS.includes(tensor.transformation)) {
          warnings.push(
            createValidationWarning(
              "tensorProperties.transformation",
              `Unknown transformation type: ${tensor.transformation}`,
              `Valid types: ${VALID_TRANSFORMATIONS.join(", ")}`
            )
          );
        }
        if (!tensor.latex) {
          warnings.push(
            createValidationWarning(
              "tensorProperties.latex",
              "No LaTeX representation provided",
              "Add LaTeX for clear mathematical presentation"
            )
          );
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Validate physical interpretation
       */
      validateInterpretation(interp) {
        const warnings = [];
        if (!interp.quantity) {
          warnings.push(
            createValidationWarning(
              "physicalInterpretation.quantity",
              "No physical quantity specified",
              "Identify what physical quantity this represents"
            )
          );
        }
        if (!interp.units) {
          warnings.push(
            createValidationWarning(
              "physicalInterpretation.units",
              "No units specified",
              "Specify units for dimensional consistency"
            )
          );
        }
        return validationSuccess(warnings);
      }
      /**
       * Validate field theory context
       */
      validateFieldTheory(context) {
        const warnings = [];
        if (!context.fields || context.fields.length === 0) {
          warnings.push(
            createValidationWarning(
              "fieldTheoryContext.fields",
              "No fields specified",
              "List the fields involved in the theory"
            )
          );
        }
        if (!context.symmetryGroup) {
          warnings.push(
            createValidationWarning(
              "fieldTheoryContext.symmetryGroup",
              "No symmetry group specified",
              "Identify the symmetry group (e.g., U(1), SU(2), etc.)"
            )
          );
        }
        return validationSuccess(warnings);
      }
    };
  }
});
var VALID_THOUGHT_TYPES4, VALID_STRATEGIES, TARGET_CONFIDENCE, HybridHandler;
var init_HybridHandler = __esm({
  "src/modes/handlers/HybridHandler.ts"() {
    init_esm_shims();
    init_recommendations();
    init_ModeHandler();
    VALID_THOUGHT_TYPES4 = [
      "mode_selection",
      "parallel_analysis",
      "sequential_analysis",
      "convergence_check",
      "synthesis",
      "confidence_assessment",
      "mode_switching"
    ];
    VALID_STRATEGIES = ["parallel", "sequential", "weighted"];
    TARGET_CONFIDENCE = 0.97;
    HybridHandler = class {
      mode = "hybrid" /* HYBRID */;
      modeName = "Hybrid Multi-Mode Reasoning";
      description = "Combines top 3 recommended modes for 97% confidence through multi-modal synthesis";
      recommender;
      /**
       * Supported thought types for hybrid mode
       */
      supportedThoughtTypes = [...VALID_THOUGHT_TYPES4];
      constructor() {
        this.recommender = new ModeRecommender();
      }
      /**
       * Create a hybrid thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const problemCharacteristics = inputAny.problemCharacteristics ? this.normalizeProblemCharacteristics(inputAny.problemCharacteristics) : this.inferCharacteristics(input);
        const recommendations = this.recommender.recommendModes(problemCharacteristics);
        const topModes = recommendations.slice(0, 3);
        const activeModes = inputAny.activeModes ? inputAny.activeModes.map((m) => this.resolveMode(m)) : topModes.map((r) => r.mode);
        const modeContributions = inputAny.modeContributions ? inputAny.modeContributions.map((c) => this.normalizeContribution(c)) : this.initializeContributions(activeModes);
        const convergenceStatus = this.calculateConvergence(modeContributions, inputAny.convergenceStatus);
        const synthesisStrategy = this.resolveSynthesisStrategy(inputAny.synthesisStrategy);
        const overallConfidence = this.calculateOverallConfidence(
          modeContributions,
          convergenceStatus,
          inputAny.overallConfidence
        );
        const primaryMode = this.resolvePrimaryMode(modeContributions, activeModes);
        const secondaryFeatures = inputAny.secondaryFeatures || activeModes.filter((m) => m !== primaryMode).map((m) => `${m} reasoning`);
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          mode: "hybrid" /* HYBRID */,
          // Base hybrid fields
          primaryMode: this.mapToPrimaryMode(primaryMode),
          secondaryFeatures,
          switchReason: inputAny.switchReason,
          thoughtType: inputAny.thoughtType,
          stage: inputAny.stage,
          uncertainty: inputAny.uncertainty ?? 1 - overallConfidence,
          dependencies: inputAny.dependencies,
          assumptions: inputAny.assumptions,
          mathematicalModel: inputAny.mathematicalModel,
          tensorProperties: inputAny.tensorProperties,
          physicalInterpretation: inputAny.physicalInterpretation,
          // Extended hybrid fields
          activeModes,
          modeContributions,
          convergenceStatus,
          problemCharacteristics,
          selectedRecommendations: topModes,
          synthesisStrategy,
          overallConfidence,
          // Revision tracking
          isRevision: input.isRevision,
          revisesThought: input.revisesThought
        };
      }
      /**
       * Validate hybrid-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        if (inputAny.thoughtType && !VALID_THOUGHT_TYPES4.includes(inputAny.thoughtType)) {
          warnings.push(
            createValidationWarning(
              "thoughtType",
              `Unknown thought type: ${inputAny.thoughtType}`,
              `Valid types: ${VALID_THOUGHT_TYPES4.join(", ")}`
            )
          );
        }
        if (inputAny.synthesisStrategy && !VALID_STRATEGIES.includes(inputAny.synthesisStrategy)) {
          warnings.push(
            createValidationWarning(
              "synthesisStrategy",
              `Unknown strategy: ${inputAny.synthesisStrategy}`,
              `Valid strategies: ${VALID_STRATEGIES.join(", ")}`
            )
          );
        }
        if (inputAny.activeModes) {
          if (inputAny.activeModes.length < 2) {
            warnings.push(
              createValidationWarning(
                "activeModes",
                "Hybrid mode typically uses 2+ modes",
                "Add more modes for multi-modal synthesis"
              )
            );
          }
          if (inputAny.activeModes.length > 5) {
            warnings.push(
              createValidationWarning(
                "activeModes",
                `Many active modes (${inputAny.activeModes.length})`,
                "Consider focusing on 3-4 most relevant modes"
              )
            );
          }
        }
        if (inputAny.modeContributions) {
          for (let i = 0; i < inputAny.modeContributions.length; i++) {
            const c = inputAny.modeContributions[i];
            if (c.confidence !== void 0 && (c.confidence < 0 || c.confidence > 1)) {
              warnings.push(
                createValidationWarning(
                  `modeContributions[${i}].confidence`,
                  `Confidence ${c.confidence} out of range`,
                  "Confidence should be between 0 and 1"
                )
              );
            }
          }
        }
        if (inputAny.convergenceStatus) {
          if (inputAny.convergenceStatus.currentConfidence < TARGET_CONFIDENCE && inputAny.convergenceStatus.modesAgreeing < 2) {
            warnings.push(
              createValidationWarning(
                "convergenceStatus",
                "Low convergence - modes are not agreeing",
                "Review insights from each mode for consistency"
              )
            );
          }
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get hybrid-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: thought.activeModes.filter((m) => m !== "hybrid" /* HYBRID */),
          guidingQuestions: [],
          warnings: [],
          metrics: {
            activeModeCount: thought.activeModes.length,
            overallConfidence: thought.overallConfidence,
            targetConfidence: TARGET_CONFIDENCE,
            convergenceScore: thought.convergenceStatus.convergenceScore,
            modesAgreeing: thought.convergenceStatus.modesAgreeing
          },
          mentalModels: [
            "Convergent Validation",
            "Multi-Modal Synthesis",
            "Triangulation",
            "Complementary Reasoning",
            "Confidence Aggregation"
          ]
        };
        enhancements.suggestions.push(
          `Active modes: ${thought.activeModes.join(", ")}`
        );
        enhancements.suggestions.push(
          `Strategy: ${thought.synthesisStrategy}`
        );
        const confidencePercent = (thought.overallConfidence * 100).toFixed(1);
        const targetPercent = (TARGET_CONFIDENCE * 100).toFixed(0);
        enhancements.suggestions.push(
          `Confidence: ${confidencePercent}% / ${targetPercent}% target`
        );
        if (thought.convergenceStatus.achieved) {
          enhancements.suggestions.push(
            `Convergence achieved (${thought.convergenceStatus.modesAgreeing}/${thought.convergenceStatus.totalModes} modes agree)`
          );
        } else {
          enhancements.warnings.push(
            `Convergence not yet achieved (${thought.convergenceStatus.modesAgreeing}/${thought.convergenceStatus.totalModes} modes agree)`
          );
        }
        for (const contrib of thought.modeContributions) {
          if (contrib.confidence > 0.7) {
            enhancements.suggestions.push(
              `${contrib.mode}: high confidence (${(contrib.confidence * 100).toFixed(0)}%)`
            );
          } else if (contrib.confidence < 0.4) {
            enhancements.warnings.push(
              `${contrib.mode}: low confidence (${(contrib.confidence * 100).toFixed(0)}%)`
            );
          }
        }
        switch (thought.thoughtType) {
          case "mode_selection":
            enhancements.guidingQuestions.push(
              "Which modes are most relevant for this problem?",
              "Are there complementary reasoning approaches to combine?",
              "What are the problem characteristics?"
            );
            if (thought.selectedRecommendations) {
              for (const rec of thought.selectedRecommendations.slice(0, 3)) {
                enhancements.suggestions.push(
                  `Recommended: ${rec.mode} (score: ${(rec.score * 100).toFixed(0)}%)`
                );
              }
            }
            break;
          case "parallel_analysis":
            enhancements.guidingQuestions.push(
              "What does each mode contribute?",
              "Are there conflicting conclusions?",
              "Which mode has the strongest evidence?"
            );
            break;
          case "sequential_analysis":
            enhancements.guidingQuestions.push(
              "What order should modes be applied?",
              "How does each mode build on previous insights?",
              "Are there dependencies between modes?"
            );
            break;
          case "convergence_check":
            enhancements.guidingQuestions.push(
              "Do multiple modes reach the same conclusion?",
              "Where do the modes disagree?",
              "What would increase confidence?"
            );
            break;
          case "synthesis":
            enhancements.guidingQuestions.push(
              "How can insights be combined?",
              "What is the synthesized conclusion?",
              "Does the synthesis preserve key insights from each mode?"
            );
            break;
          case "confidence_assessment":
            enhancements.guidingQuestions.push(
              "What is the overall confidence level?",
              "Which mode contributes most to confidence?",
              "Are there gaps that reduce confidence?"
            );
            break;
          case "mode_switching":
            enhancements.guidingQuestions.push(
              "Should we add or remove a mode?",
              "Is the current combination optimal?",
              "What would improve the analysis?"
            );
            break;
        }
        if (thought.synthesisStrategy === "parallel") {
          enhancements.mentalModels.push("Independence", "Ensemble Methods");
        } else if (thought.synthesisStrategy === "sequential") {
          enhancements.mentalModels.push("Bayesian Updating", "Evidence Chain");
        } else if (thought.synthesisStrategy === "weighted") {
          enhancements.mentalModels.push("Expert Aggregation", "Delphi Method");
        }
        if (thought.overallConfidence < TARGET_CONFIDENCE) {
          const gap = TARGET_CONFIDENCE - thought.overallConfidence;
          if (gap > 0.2) {
            enhancements.suggestions.push("Consider adding another complementary mode");
          } else if (gap > 0.1) {
            enhancements.suggestions.push("Focus on resolving mode disagreements");
          } else {
            enhancements.suggestions.push("Strengthen evidence in highest-contributing mode");
          }
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Normalize problem characteristics
       */
      normalizeProblemCharacteristics(chars) {
        return {
          domain: chars.domain || "general",
          complexity: chars.complexity || "medium",
          uncertainty: chars.uncertainty || "medium",
          timeDependent: chars.timeDependent ?? false,
          multiAgent: chars.multiAgent ?? false,
          requiresProof: chars.requiresProof ?? false,
          requiresQuantification: chars.requiresQuantification ?? false,
          hasIncompleteInfo: chars.hasIncompleteInfo ?? false,
          requiresExplanation: chars.requiresExplanation ?? true,
          hasAlternatives: chars.hasAlternatives ?? true
        };
      }
      /**
       * Infer problem characteristics from input
       */
      inferCharacteristics(input) {
        const content = input.thought.toLowerCase();
        return {
          domain: "general",
          complexity: input.totalThoughts > 5 ? "high" : "medium",
          uncertainty: "medium",
          timeDependent: content.includes("time") || content.includes("sequence"),
          multiAgent: content.includes("agent") || content.includes("player"),
          requiresProof: content.includes("proof") || content.includes("prove"),
          requiresQuantification: content.includes("number") || content.includes("calculate"),
          hasIncompleteInfo: content.includes("unknown") || content.includes("unclear"),
          requiresExplanation: true,
          hasAlternatives: true
        };
      }
      /**
       * Resolve mode from string
       */
      resolveMode(mode) {
        const modeMap = {
          sequential: "sequential" /* SEQUENTIAL */,
          shannon: "shannon" /* SHANNON */,
          mathematics: "mathematics" /* MATHEMATICS */,
          physics: "physics" /* PHYSICS */,
          hybrid: "hybrid" /* HYBRID */,
          inductive: "inductive" /* INDUCTIVE */,
          deductive: "deductive" /* DEDUCTIVE */,
          abductive: "abductive" /* ABDUCTIVE */,
          causal: "causal" /* CAUSAL */,
          bayesian: "bayesian" /* BAYESIAN */,
          counterfactual: "counterfactual" /* COUNTERFACTUAL */,
          temporal: "temporal" /* TEMPORAL */,
          gametheory: "gametheory" /* GAMETHEORY */,
          evidential: "evidential" /* EVIDENTIAL */,
          analogical: "analogical" /* ANALOGICAL */,
          firstprinciples: "firstprinciples" /* FIRSTPRINCIPLES */,
          systemsthinking: "systemsthinking" /* SYSTEMSTHINKING */,
          scientificmethod: "scientificmethod" /* SCIENTIFICMETHOD */,
          formallogic: "formallogic" /* FORMALLOGIC */,
          metareasoning: "metareasoning" /* METAREASONING */,
          optimization: "optimization" /* OPTIMIZATION */,
          engineering: "engineering" /* ENGINEERING */,
          algorithmic: "algorithmic" /* ALGORITHMIC */,
          computability: "computability" /* COMPUTABILITY */,
          cryptanalytic: "cryptanalytic" /* CRYPTANALYTIC */,
          synthesis: "synthesis" /* SYNTHESIS */,
          argumentation: "argumentation" /* ARGUMENTATION */,
          critique: "critique" /* CRITIQUE */,
          analysis: "analysis" /* ANALYSIS */
        };
        return modeMap[mode.toLowerCase()] || "sequential" /* SEQUENTIAL */;
      }
      /**
       * Normalize mode contribution
       */
      normalizeContribution(contrib) {
        return {
          mode: this.resolveMode(contrib.mode || "sequential"),
          confidence: Math.max(0, Math.min(1, contrib.confidence ?? 0.5)),
          insights: contrib.insights || [],
          evidence: contrib.evidence || [],
          agreementWithOthers: Math.max(0, Math.min(1, contrib.agreementWithOthers ?? 0.5))
        };
      }
      /**
       * Initialize contributions for active modes
       */
      initializeContributions(activeModes) {
        return activeModes.map((mode) => ({
          mode,
          confidence: 0.5,
          insights: [],
          evidence: [],
          agreementWithOthers: 0.5
        }));
      }
      /**
       * Calculate convergence status
       */
      calculateConvergence(contributions, explicit) {
        const agreementScores = contributions.map((c) => c.agreementWithOthers);
        const avgAgreement = agreementScores.length > 0 ? agreementScores.reduce((a, b) => a + b, 0) / agreementScores.length : 0;
        const modesAgreeing = contributions.filter((c) => c.agreementWithOthers > 0.7).length;
        const confidenceFromAgreement = Math.min(
          avgAgreement * 0.5 + modesAgreeing / contributions.length * 0.5,
          1
        );
        const avgConfidence = contributions.length > 0 ? contributions.reduce((a, b) => a + b.confidence, 0) / contributions.length : 0;
        const currentConfidence = explicit?.currentConfidence ?? Math.min(confidenceFromAgreement * 0.6 + avgConfidence * 0.4, 1);
        return {
          achieved: currentConfidence >= TARGET_CONFIDENCE,
          targetConfidence: TARGET_CONFIDENCE,
          currentConfidence,
          modesAgreeing: explicit?.modesAgreeing ?? modesAgreeing,
          totalModes: contributions.length,
          convergenceScore: explicit?.convergenceScore ?? avgAgreement
        };
      }
      /**
       * Calculate overall confidence from contributions and convergence
       */
      calculateOverallConfidence(contributions, convergence, explicit) {
        if (explicit !== void 0) {
          return Math.max(0, Math.min(1, explicit));
        }
        let weightedSum = 0;
        let weightTotal = 0;
        for (const contrib of contributions) {
          const weight = 0.5 + contrib.agreementWithOthers * 0.5;
          weightedSum += contrib.confidence * weight;
          weightTotal += weight;
        }
        const baseConfidence = weightTotal > 0 ? weightedSum / weightTotal : 0.5;
        const convergenceBoost = convergence.convergenceScore * 0.2;
        const modeBonus = Math.min(0.1, (contributions.length - 1) * 0.03);
        return Math.min(1, baseConfidence + convergenceBoost + modeBonus);
      }
      /**
       * Resolve primary mode from contributions
       */
      resolvePrimaryMode(contributions, activeModes) {
        if (contributions.length === 0) {
          return activeModes[0] || "sequential" /* SEQUENTIAL */;
        }
        let bestMode = contributions[0].mode;
        let bestScore = 0;
        for (const contrib of contributions) {
          const score = contrib.confidence * (0.5 + contrib.agreementWithOthers * 0.5);
          if (score > bestScore) {
            bestScore = score;
            bestMode = contrib.mode;
          }
        }
        return bestMode;
      }
      /**
       * Map to base hybrid primary mode type
       */
      mapToPrimaryMode(mode) {
        switch (mode) {
          case "shannon" /* SHANNON */:
            return "shannon";
          case "mathematics" /* MATHEMATICS */:
            return "mathematics";
          case "physics" /* PHYSICS */:
            return "physics";
          default:
            return "sequential";
        }
      }
      /**
       * Resolve synthesis strategy
       */
      resolveSynthesisStrategy(strategy) {
        if (strategy && VALID_STRATEGIES.includes(strategy)) {
          return strategy;
        }
        return "parallel";
      }
    };
  }
});
var InductiveHandler;
var init_InductiveHandler = __esm({
  "src/modes/handlers/InductiveHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    InductiveHandler = class {
      mode = "inductive" /* INDUCTIVE */;
      modeName = "Inductive Reasoning";
      description = "Reasoning from specific observations to general principles with confidence tracking";
      /**
       * Supported thought types for inductive mode
       */
      supportedThoughtTypes = [
        "observation",
        "pattern_identification",
        "generalization",
        "counterexample_analysis",
        "confidence_assessment",
        "refinement"
      ];
      /**
       * Create an inductive thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const confidence = this.calculateConfidence(inputAny);
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          mode: "inductive" /* INDUCTIVE */,
          // Core inductive fields
          observations: inputAny.observations || [],
          pattern: inputAny.pattern,
          generalization: inputAny.generalization || "",
          confidence,
          counterexamples: inputAny.counterexamples || [],
          sampleSize: inputAny.sampleSize,
          // Revision tracking
          isRevision: input.isRevision,
          revisesThought: input.revisesThought
        };
      }
      /**
       * Validate inductive-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        if (inputAny.confidence !== void 0) {
          if (inputAny.confidence < 0 || inputAny.confidence > 1) {
            errors.push(
              createValidationError(
                "confidence",
                `Confidence (${inputAny.confidence}) must be between 0 and 1`,
                "CONFIDENCE_OUT_OF_RANGE"
              )
            );
          }
        }
        if (!inputAny.observations || inputAny.observations.length === 0) {
          warnings.push(
            createValidationWarning(
              "observations",
              "No observations provided for inductive reasoning",
              "Add specific observations to form the basis of generalization"
            )
          );
        } else if (inputAny.observations.length < 3) {
          warnings.push(
            createValidationWarning(
              "observations",
              `Only ${inputAny.observations.length} observation(s) provided`,
              "More observations typically lead to stronger generalizations"
            )
          );
        }
        if (inputAny.generalization && (!inputAny.observations || inputAny.observations.length === 0)) {
          warnings.push(
            createValidationWarning(
              "generalization",
              "Generalization stated without supporting observations",
              "Ensure observations support the generalization"
            )
          );
        }
        if (inputAny.sampleSize !== void 0 && inputAny.observations) {
          if (inputAny.sampleSize !== inputAny.observations.length) {
            warnings.push(
              createValidationWarning(
                "sampleSize",
                `Sample size (${inputAny.sampleSize}) differs from observation count (${inputAny.observations.length})`,
                "Ensure sample size accurately reflects your observations"
              )
            );
          }
        }
        if (inputAny.confidence > 0.8 && inputAny.counterexamples && inputAny.counterexamples.length > 0) {
          warnings.push(
            createValidationWarning(
              "confidence",
              "High confidence despite known counterexamples",
              "Consider whether counterexamples require adjusting confidence"
            )
          );
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get inductive-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["deductive" /* DEDUCTIVE */, "abductive" /* ABDUCTIVE */, "scientificmethod" /* SCIENTIFICMETHOD */],
          guidingQuestions: [],
          warnings: [],
          metrics: {
            observationCount: thought.observations?.length || 0,
            confidence: thought.confidence,
            counterexampleCount: thought.counterexamples?.length || 0
          },
          mentalModels: [
            "Pattern Recognition",
            "Enumeration Induction",
            "Statistical Generalization",
            "Analogical Reasoning",
            "Mill's Methods"
          ]
        };
        const obsCount = thought.observations?.length || 0;
        const counterCount = thought.counterexamples?.length || 0;
        if (obsCount === 0) {
          enhancements.suggestions.push(
            "Start by collecting specific observations or examples"
          );
          enhancements.guidingQuestions.push(
            "What specific instances or cases have you observed?"
          );
        } else if (obsCount < 5) {
          enhancements.suggestions.push(
            "Consider gathering more observations to strengthen the induction"
          );
          enhancements.guidingQuestions.push(
            "Are there other examples that could confirm or challenge the pattern?"
          );
        }
        if (obsCount >= 3 && !thought.pattern) {
          enhancements.suggestions.push(
            "Look for common features or relationships among observations"
          );
          enhancements.guidingQuestions.push(
            "What do all these observations have in common?"
          );
        }
        if (thought.pattern && !thought.generalization) {
          enhancements.suggestions.push(
            "Formulate a general principle from the identified pattern"
          );
          enhancements.guidingQuestions.push(
            "What general rule or principle does this pattern suggest?"
          );
        }
        if (counterCount > 0) {
          enhancements.warnings.push(
            `${counterCount} counterexample(s) exist - consider refining the generalization`
          );
          enhancements.guidingQuestions.push(
            "Can the generalization be modified to account for counterexamples?"
          );
          const suggestedConfidence = Math.max(0.3, thought.confidence - counterCount * 0.1);
          if (thought.confidence > suggestedConfidence + 0.2) {
            enhancements.warnings.push(
              `Consider lowering confidence given counterexamples (suggested: ${suggestedConfidence.toFixed(2)})`
            );
          }
        }
        if (thought.confidence > 0.9 && obsCount < 10) {
          enhancements.warnings.push(
            "Very high confidence with limited sample size - consider more evidence"
          );
        } else if (thought.confidence < 0.3 && obsCount > 10 && counterCount === 0) {
          enhancements.suggestions.push(
            "Low confidence despite good sample size and no counterexamples - pattern may be stronger than assessed"
          );
        }
        if (thought.sampleSize) {
          enhancements.metrics.sampleSize = thought.sampleSize;
          if (thought.sampleSize >= 30) {
            enhancements.suggestions.push(
              "Sample size sufficient for statistical analysis - consider calculating significance"
            );
          }
        }
        if (thought.generalization && thought.confidence > 0.7) {
          enhancements.suggestions.push(
            "Consider testing this generalization deductively on new cases"
          );
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Calculate confidence based on observations and counterexamples
       */
      calculateConfidence(input) {
        if (input.confidence !== void 0) {
          return Math.max(0, Math.min(1, input.confidence));
        }
        const obsCount = input.observations?.length || 0;
        const counterCount = input.counterexamples?.length || 0;
        if (obsCount === 0) return 0.3;
        let baseConfidence = Math.min(0.9, 0.4 + obsCount * 0.05);
        baseConfidence -= counterCount * 0.15;
        return Math.max(0.1, Math.min(0.95, baseConfidence));
      }
    };
  }
});
var VALID_LOGIC_FORMS, DeductiveHandler;
var init_DeductiveHandler = __esm({
  "src/modes/handlers/DeductiveHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    VALID_LOGIC_FORMS = [
      "modus_ponens",
      "modus_tollens",
      "hypothetical_syllogism",
      "disjunctive_syllogism",
      "constructive_dilemma",
      "destructive_dilemma",
      "universal_instantiation",
      "existential_generalization",
      "categorical_syllogism",
      "reductio_ad_absurdum",
      "proof_by_contradiction",
      "proof_by_cases",
      "conditional_proof"
    ];
    DeductiveHandler = class {
      mode = "deductive" /* DEDUCTIVE */;
      modeName = "Deductive Reasoning";
      description = "Reasoning from general principles to specific conclusions with validity checking";
      /**
       * Supported thought types for deductive mode
       */
      supportedThoughtTypes = [
        "premise_statement",
        "inference",
        "conclusion",
        "validity_check",
        "soundness_check",
        "fallacy_identification"
      ];
      /**
       * Create a deductive thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const validityCheck = this.assessValidity(inputAny);
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          mode: "deductive" /* DEDUCTIVE */,
          // Core deductive fields
          premises: inputAny.premises || [],
          conclusion: inputAny.conclusion || "",
          logicForm: inputAny.logicForm,
          validityCheck,
          soundnessCheck: inputAny.soundnessCheck,
          // Revision tracking
          isRevision: input.isRevision,
          revisesThought: input.revisesThought
        };
      }
      /**
       * Validate deductive-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        if (!inputAny.premises || inputAny.premises.length === 0) {
          warnings.push(
            createValidationWarning(
              "premises",
              "No premises provided for deductive reasoning",
              "State the general principles from which to derive the conclusion"
            )
          );
        } else if (inputAny.premises.length === 1) {
          warnings.push(
            createValidationWarning(
              "premises",
              "Only one premise provided",
              "Most deductive arguments require at least two premises"
            )
          );
        }
        if (!inputAny.conclusion || inputAny.conclusion.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              "conclusion",
              "No conclusion specified",
              "State the specific conclusion derived from the premises"
            )
          );
        }
        if (inputAny.logicForm) {
          const normalizedForm = inputAny.logicForm.toLowerCase().replace(/\s+/g, "_");
          if (!VALID_LOGIC_FORMS.includes(normalizedForm)) {
            warnings.push(
              createValidationWarning(
                "logicForm",
                `Unknown logical form: ${inputAny.logicForm}`,
                `Common forms: ${VALID_LOGIC_FORMS.slice(0, 5).join(", ")}, ...`
              )
            );
          }
        }
        if (!inputAny.logicForm && inputAny.premises?.length >= 2 && inputAny.conclusion) {
          warnings.push(
            createValidationWarning(
              "logicForm",
              "No logical form specified",
              "Identify the logical form to verify validity"
            )
          );
        }
        if (inputAny.validityCheck === true && inputAny.soundnessCheck === void 0) {
          warnings.push(
            createValidationWarning(
              "soundnessCheck",
              "Validity checked but soundness not assessed",
              "Valid arguments need true premises to be sound"
            )
          );
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get deductive-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["inductive" /* INDUCTIVE */, "formallogic" /* FORMALLOGIC */, "mathematics" /* MATHEMATICS */],
          guidingQuestions: [],
          warnings: [],
          metrics: {
            premiseCount: thought.premises?.length || 0,
            isValid: thought.validityCheck ? 1 : 0,
            isSound: thought.soundnessCheck ? 1 : 0
          },
          mentalModels: [
            "Syllogistic Logic",
            "Propositional Logic",
            "Predicate Logic",
            "Formal Proof",
            "Logical Implication"
          ]
        };
        const premiseCount = thought.premises?.length || 0;
        if (premiseCount === 0) {
          enhancements.suggestions.push(
            "State the general principles or axioms from which to reason"
          );
          enhancements.guidingQuestions.push(
            "What general truths or established facts can serve as premises?"
          );
        } else if (premiseCount === 1) {
          enhancements.suggestions.push(
            "Consider whether a second premise is needed for the inference"
          );
          enhancements.guidingQuestions.push(
            "What additional premise connects this to the conclusion?"
          );
        }
        if (!thought.conclusion && premiseCount >= 2) {
          enhancements.suggestions.push(
            "Derive the conclusion that logically follows from the premises"
          );
          enhancements.guidingQuestions.push(
            "What necessarily follows from these premises?"
          );
        }
        if (thought.logicForm) {
          enhancements.metrics.logicForm = thought.logicForm;
          enhancements.suggestions.push(`Using ${thought.logicForm} argument form`);
          switch (thought.logicForm.toLowerCase().replace(/\s+/g, "_")) {
            case "modus_ponens":
              enhancements.suggestions.push(
                "Structure: P \u2192 Q, P, therefore Q"
              );
              break;
            case "modus_tollens":
              enhancements.suggestions.push(
                "Structure: P \u2192 Q, \xACQ, therefore \xACP"
              );
              break;
            case "hypothetical_syllogism":
              enhancements.suggestions.push(
                "Structure: P \u2192 Q, Q \u2192 R, therefore P \u2192 R"
              );
              break;
            case "disjunctive_syllogism":
              enhancements.suggestions.push(
                "Structure: P \u2228 Q, \xACP, therefore Q"
              );
              break;
            case "reductio_ad_absurdum":
              enhancements.suggestions.push(
                "Assume the negation, derive a contradiction"
              );
              break;
          }
        }
        if (thought.validityCheck) {
          enhancements.suggestions.push(
            "\u2713 Argument is logically valid - conclusion follows from premises"
          );
          if (thought.soundnessCheck) {
            enhancements.suggestions.push(
              "\u2713 Argument is sound - premises are true and conclusion follows"
            );
          } else if (thought.soundnessCheck === false) {
            enhancements.warnings.push(
              "Argument is valid but NOT sound - one or more premises may be false"
            );
            enhancements.guidingQuestions.push(
              "Which premise(s) might be false or questionable?"
            );
          } else {
            enhancements.guidingQuestions.push(
              "Are all the premises actually true?"
            );
          }
        } else if (thought.validityCheck === false) {
          enhancements.warnings.push(
            "Argument is NOT valid - conclusion does not follow from premises"
          );
          enhancements.guidingQuestions.push(
            "What hidden premise would make this argument valid?",
            "Is there a logical fallacy in the reasoning?"
          );
        }
        if (thought.premises?.length >= 2 && thought.conclusion && !thought.validityCheck) {
          enhancements.suggestions.push(
            "Check for common fallacies: affirming the consequent, denying the antecedent"
          );
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Assess validity of the argument structure
       *
       * This is a heuristic assessment - full validity checking would require
       * symbolic logic parsing.
       */
      assessValidity(input) {
        if (input.validityCheck !== void 0) {
          return input.validityCheck;
        }
        const premises = input.premises || [];
        const conclusion = input.conclusion || "";
        const logicForm = input.logicForm?.toLowerCase().replace(/\s+/g, "_");
        if (premises.length === 0 || !conclusion) {
          return false;
        }
        if (logicForm && VALID_LOGIC_FORMS.includes(logicForm)) {
          return true;
        }
        return false;
      }
    };
  }
});
var AbductiveHandler;
var init_AbductiveHandler = __esm({
  "src/modes/handlers/AbductiveHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    AbductiveHandler = class {
      mode = "abductive" /* ABDUCTIVE */;
      modeName = "Abductive Reasoning";
      description = "Inference to best explanation with hypothesis evaluation and evidence coverage";
      /**
       * Create an abductive thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const observations = this.processObservations(inputAny.observations || []);
        const hypotheses = this.processHypotheses(inputAny.hypotheses || []);
        if (observations.length > 0 && hypotheses.length > 0) {
          this.scoreHypotheses(hypotheses, observations);
        }
        const bestExplanation = inputAny.bestExplanation ? this.processHypothesis(inputAny.bestExplanation) : this.selectBestExplanation(hypotheses);
        const evidence = this.processEvidence(inputAny.evidence || []);
        const evaluationCriteria = inputAny.evaluationCriteria ? this.processEvaluationCriteria(inputAny.evaluationCriteria) : this.getDefaultCriteria();
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          isRevision: input.isRevision,
          revisesThought: input.revisesThought,
          mode: "abductive" /* ABDUCTIVE */,
          observations,
          hypotheses,
          currentHypothesis: hypotheses[0],
          evaluationCriteria,
          evidence,
          bestExplanation
        };
      }
      /**
       * Validate abductive-specific input
       */
      validate(input) {
        const warnings = [];
        const inputAny = input;
        if (!inputAny.observations || inputAny.observations.length === 0) {
          warnings.push(
            createValidationWarning(
              "observations",
              "No observations provided",
              "Add observations to ground hypothesis generation"
            )
          );
        }
        if (inputAny.hypotheses) {
          const incompleteHypotheses = inputAny.hypotheses.filter(
            (h) => !h.explanation || h.explanation.trim() === ""
          );
          if (incompleteHypotheses.length > 0) {
            warnings.push(
              createValidationWarning(
                "hypotheses",
                `${incompleteHypotheses.length} hypothesis/hypotheses lack explanations`,
                "Provide clear explanations for each hypothesis"
              )
            );
          }
        }
        if (inputAny.hypotheses && inputAny.hypotheses.length === 1) {
          warnings.push(
            createValidationWarning(
              "hypotheses",
              "Only one hypothesis provided",
              "Consider alternative explanations for robust abductive reasoning"
            )
          );
        }
        return validationSuccess(warnings);
      }
      /**
       * Get mode-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["inductive" /* INDUCTIVE */, "bayesian" /* BAYESIAN */, "causal" /* CAUSAL */],
          metrics: {},
          guidingQuestions: [],
          mentalModels: [
            "Occam's Razor - prefer simpler explanations",
            "Inference to Best Explanation (IBE)",
            "Peirce's abductive logic",
            "Consilience of inductions"
          ]
        };
        const hypotheses = thought.hypotheses || [];
        const observations = thought.observations || [];
        const evidence = thought.evidence || [];
        enhancements.metrics = {
          hypothesisCount: hypotheses.length,
          observationCount: observations.length,
          evidenceCount: evidence.length,
          avgScore: this.calculateAverageScore(hypotheses),
          parsimony: thought.evaluationCriteria?.parsimony || 0,
          explanatoryPower: thought.evaluationCriteria?.explanatoryPower || 0
        };
        if (hypotheses.length < 2) {
          enhancements.suggestions.push("Generate alternative hypotheses to compare explanatory power");
        }
        if (observations.length < 3) {
          enhancements.suggestions.push("Gather more observations to differentiate between hypotheses");
        }
        if (evidence.length === 0) {
          enhancements.suggestions.push("Collect evidence to support or refute hypotheses");
        }
        enhancements.guidingQuestions = [
          "Which hypothesis best explains ALL observations?",
          "Are there observations that rule out any hypothesis?",
          "What additional evidence would differentiate the hypotheses?",
          "Is the simplest explanation sufficient, or is complexity warranted?",
          "Could multiple hypotheses be combined into a unified explanation?"
        ];
        return enhancements;
      }
      /**
       * Process raw observations into Observation[] format
       */
      processObservations(raw) {
        return raw.map((obs, index) => {
          if (typeof obs === "string") {
            return {
              id: `obs-${index}`,
              description: obs,
              confidence: 1
            };
          }
          return {
            id: obs.id || `obs-${index}`,
            description: obs.description || obs.content || String(obs),
            timestamp: obs.timestamp,
            confidence: obs.confidence ?? 1
          };
        });
      }
      /**
       * Process a single hypothesis
       */
      processHypothesis(raw) {
        return {
          id: raw.id || randomUUID(),
          explanation: raw.explanation || raw.description || "",
          assumptions: raw.assumptions || [],
          predictions: raw.predictions || [],
          score: raw.score ?? raw.plausibility ?? 0.5
        };
      }
      /**
       * Process raw hypotheses into Hypothesis[] format
       */
      processHypotheses(raw) {
        return raw.map((h) => this.processHypothesis(h));
      }
      /**
       * Process raw evidence into Evidence[] format
       */
      processEvidence(raw) {
        return raw.map((e) => ({
          hypothesisId: e.hypothesisId || e.hypothesis || "",
          type: e.type || "neutral",
          description: e.description || e.content || "",
          strength: e.strength ?? 0.5
        }));
      }
      /**
       * Process or create evaluation criteria
       */
      processEvaluationCriteria(raw) {
        if (Array.isArray(raw)) {
          return this.getDefaultCriteria();
        }
        return {
          parsimony: raw.parsimony ?? 0.5,
          explanatoryPower: raw.explanatoryPower ?? 0.5,
          plausibility: raw.plausibility ?? 0.5,
          testability: raw.testability ?? true
        };
      }
      /**
       * Score hypotheses based on observations
       */
      scoreHypotheses(hypotheses, observations) {
        for (const h of hypotheses) {
          const coverage = this.calculateCoverage(h, observations);
          const complexity = this.estimateComplexity(h);
          h.score = coverage * (1 - complexity / 2);
        }
      }
      /**
       * Calculate how well a hypothesis covers observations
       */
      calculateCoverage(hypothesis, observations) {
        if (observations.length === 0) return 0;
        const explanation = hypothesis.explanation.toLowerCase();
        let covered = 0;
        for (const obs of observations) {
          const terms = obs.description.toLowerCase().split(/\s+/);
          if (terms.some((term) => term.length > 3 && explanation.includes(term))) {
            covered++;
          }
        }
        return covered / observations.length;
      }
      /**
       * Estimate hypothesis complexity (Occam's razor)
       */
      estimateComplexity(hypothesis) {
        const wordCount = hypothesis.explanation.split(/\s+/).length;
        const assumptionCount = hypothesis.assumptions.length;
        return Math.min(wordCount / 100 + assumptionCount * 0.1, 1);
      }
      /**
       * Select the best explanation based on scores
       */
      selectBestExplanation(hypotheses) {
        if (hypotheses.length === 0) return void 0;
        return hypotheses.reduce((a, b) => a.score > b.score ? a : b);
      }
      /**
       * Calculate average score across hypotheses
       */
      calculateAverageScore(hypotheses) {
        if (hypotheses.length === 0) return 0;
        const sum = hypotheses.reduce((acc, h) => acc + h.score, 0);
        return sum / hypotheses.length;
      }
      /**
       * Get default evaluation criteria
       */
      getDefaultCriteria() {
        return {
          parsimony: 0.5,
          explanatoryPower: 0.5,
          plausibility: 0.5,
          testability: true
        };
      }
    };
  }
});
var CausalHandler;
var init_CausalHandler = __esm({
  "src/modes/handlers/CausalHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    init_type_guards();
    CausalHandler = class {
      mode = "causal" /* CAUSAL */;
      modeName = "Causal Analysis";
      description = "Causal graph analysis with intervention reasoning and cycle detection";
      /**
       * Supported thought types for causal mode
       */
      supportedThoughtTypes = [
        "problem_definition",
        "causal_graph_construction",
        "intervention_analysis",
        "counterfactual_analysis",
        "confounder_identification",
        "mechanism_discovery"
      ];
      /**
       * Create a causal thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const causalGraph = input.causalGraph || {
          nodes: inputAny.nodes || [],
          edges: inputAny.edges || []
        };
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          isRevision: input.isRevision,
          revisesThought: input.revisesThought,
          mode: "causal" /* CAUSAL */,
          thoughtType: toExtendedThoughtType(input.thoughtType, "problem_definition"),
          causalGraph,
          interventions: input.interventions || [],
          mechanisms: input.mechanisms || [],
          confounders: input.confounders || []
        };
      }
      /**
       * Validate causal-specific input
       *
       * Performs semantic validation:
       * 1. Basic input validation
       * 2. Causal graph structure validation
       * 3. Cycle detection (warns, doesn't fail - cycles may be intentional feedback loops)
       * 4. Intervention target validation
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        const causalGraph = input.causalGraph || {
          nodes: inputAny.nodes || [],
          edges: inputAny.edges || []
        };
        if (causalGraph.nodes.length > 0 || causalGraph.edges.length > 0) {
          const graphValidation = this.validateCausalGraph(causalGraph);
          errors.push(...graphValidation.errors);
          warnings.push(...graphValidation.warnings);
        }
        if (input.interventions && input.interventions.length > 0) {
          const interventionValidation = this.validateInterventions(
            input.interventions,
            causalGraph
          );
          errors.push(...interventionValidation.errors);
          warnings.push(...interventionValidation.warnings);
        }
        if (causalGraph.edges.length > 0) {
          const cycles = this.detectCycles(causalGraph);
          if (cycles.length > 0) {
            warnings.push(
              createValidationWarning(
                "causalGraph",
                `Detected ${cycles.length} cycle(s) in causal graph: ${cycles.map((c) => c.join(" -> ")).join("; ")}`,
                "Cycles may indicate feedback loops. Verify this is intentional."
              )
            );
          }
        }
        if ((!input.confounders || input.confounders.length === 0) && causalGraph.nodes.length >= 3) {
          warnings.push(
            createValidationWarning(
              "confounders",
              "No confounders specified in the causal model",
              "Consider identifying potential confounders that might affect multiple nodes"
            )
          );
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get causal-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["bayesian" /* BAYESIAN */, "counterfactual" /* COUNTERFACTUAL */],
          guidingQuestions: [],
          warnings: [],
          mentalModels: ["Causal Diagrams", "Do-Calculus", "Structural Equation Models"]
        };
        if (thought.causalGraph) {
          const nodeCount = thought.causalGraph.nodes.length;
          const edgeCount = thought.causalGraph.edges.length;
          if (nodeCount > 0 && edgeCount === 0) {
            enhancements.suggestions.push(
              "Add causal edges to connect your nodes and establish causal relationships"
            );
          }
          if (edgeCount > nodeCount * 2) {
            enhancements.suggestions.push(
              "Graph is densely connected. Consider identifying the most significant causal paths"
            );
          }
          enhancements.metrics = {
            nodeCount,
            edgeCount,
            density: nodeCount > 1 ? edgeCount / (nodeCount * (nodeCount - 1)) : 0
          };
          const entryNodes = this.findEntryNodes(thought.causalGraph);
          const exitNodes = this.findExitNodes(thought.causalGraph);
          if (entryNodes.length > 0) {
            enhancements.guidingQuestions.push(
              `What external factors influence the root causes: ${entryNodes.join(", ")}?`
            );
          }
          if (exitNodes.length > 0) {
            enhancements.guidingQuestions.push(
              `What are the downstream consequences of ${exitNodes.join(", ")}?`
            );
          }
        }
        if (!thought.interventions || thought.interventions.length === 0) {
          enhancements.guidingQuestions.push(
            "What interventions could be tested to verify causal relationships?"
          );
        }
        if (!thought.confounders || thought.confounders.length === 0) {
          enhancements.guidingQuestions.push(
            "Are there any hidden common causes (confounders) that might affect multiple variables?"
          );
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Validate causal graph structure
       */
      validateCausalGraph(graph) {
        const errors = [];
        const warnings = [];
        const nodeIds = new Set(graph.nodes.map((n) => n.id));
        if (nodeIds.size !== graph.nodes.length) {
          errors.push(
            createValidationError(
              "causalGraph.nodes",
              "Duplicate node IDs detected in causal graph",
              "DUPLICATE_NODE_IDS"
            )
          );
        }
        for (const edge of graph.edges) {
          if (!nodeIds.has(edge.from)) {
            errors.push(
              createValidationError(
                "causalGraph.edges",
                `Edge references non-existent source node: ${edge.from}`,
                "INVALID_EDGE_SOURCE"
              )
            );
          }
          if (!nodeIds.has(edge.to)) {
            errors.push(
              createValidationError(
                "causalGraph.edges",
                `Edge references non-existent target node: ${edge.to}`,
                "INVALID_EDGE_TARGET"
              )
            );
          }
          if (edge.strength !== void 0 && (edge.strength < -1 || edge.strength > 1)) {
            warnings.push(
              createValidationWarning(
                "causalGraph.edges",
                `Edge strength ${edge.strength} is outside [-1, 1] range`,
                "Normalize edge strength to [-1, 1] where negative indicates inhibitory effects"
              )
            );
          }
          if (edge.confidence !== void 0 && (edge.confidence < 0 || edge.confidence > 1)) {
            warnings.push(
              createValidationWarning(
                "causalGraph.edges",
                `Edge confidence ${edge.confidence} is outside [0, 1] range`,
                "Confidence should be a probability between 0 and 1"
              )
            );
          }
        }
        const selfLoops = graph.edges.filter((e) => e.from === e.to);
        if (selfLoops.length > 0) {
          warnings.push(
            createValidationWarning(
              "causalGraph.edges",
              `${selfLoops.length} self-loop(s) detected: ${selfLoops.map((e) => e.from).join(", ")}`,
              "Self-loops may indicate self-reinforcing effects. Verify this is intentional."
            )
          );
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Validate interventions reference existing nodes
       */
      validateInterventions(interventions, graph) {
        const errors = [];
        const warnings = [];
        const nodeIds = new Set(graph.nodes.map((n) => n.id));
        for (const intervention of interventions) {
          if (!nodeIds.has(intervention.nodeId)) {
            errors.push(
              createValidationError(
                "interventions",
                `Intervention targets non-existent node: ${intervention.nodeId}`,
                "INVALID_INTERVENTION_TARGET"
              )
            );
          }
          if (intervention.expectedEffects) {
            for (const effect of intervention.expectedEffects) {
              if (!nodeIds.has(effect.nodeId)) {
                warnings.push(
                  createValidationWarning(
                    "interventions.expectedEffects",
                    `Expected effect references non-existent node: ${effect.nodeId}`,
                    "Ensure all expected effect nodes are in the causal graph"
                  )
                );
              }
              if (effect.confidence !== void 0 && (effect.confidence < 0 || effect.confidence > 1)) {
                warnings.push(
                  createValidationWarning(
                    "interventions.expectedEffects",
                    `Effect confidence ${effect.confidence} is outside [0, 1] range`,
                    "Confidence should be a probability between 0 and 1"
                  )
                );
              }
            }
          }
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Detect cycles in the causal graph using DFS
       *
       * Returns list of cycles found, where each cycle is a list of node IDs
       */
      detectCycles(graph) {
        const cycles = [];
        const visited = /* @__PURE__ */ new Set();
        const recursionStack = /* @__PURE__ */ new Set();
        const path4 = [];
        const adjacencyList = /* @__PURE__ */ new Map();
        for (const node of graph.nodes) {
          adjacencyList.set(node.id, []);
        }
        for (const edge of graph.edges) {
          const neighbors = adjacencyList.get(edge.from);
          if (neighbors) {
            neighbors.push(edge.to);
          }
        }
        const dfs = (nodeId) => {
          visited.add(nodeId);
          recursionStack.add(nodeId);
          path4.push(nodeId);
          const neighbors = adjacencyList.get(nodeId) || [];
          for (const neighbor of neighbors) {
            if (!visited.has(neighbor)) {
              dfs(neighbor);
            } else if (recursionStack.has(neighbor)) {
              const cycleStart = path4.indexOf(neighbor);
              const cycle = path4.slice(cycleStart);
              cycle.push(neighbor);
              cycles.push(cycle);
            }
          }
          path4.pop();
          recursionStack.delete(nodeId);
        };
        for (const node of graph.nodes) {
          if (!visited.has(node.id)) {
            dfs(node.id);
          }
        }
        return cycles;
      }
      /**
       * Find entry nodes (nodes with no incoming edges)
       */
      findEntryNodes(graph) {
        const hasIncoming = new Set(graph.edges.map((e) => e.to));
        return graph.nodes.filter((n) => !hasIncoming.has(n.id)).map((n) => n.name || n.id);
      }
      /**
       * Find exit nodes (nodes with no outgoing edges)
       */
      findExitNodes(graph) {
        const hasOutgoing = new Set(graph.edges.map((e) => e.from));
        return graph.nodes.filter((n) => !hasOutgoing.has(n.id)).map((n) => n.name || n.id);
      }
    };
  }
});
var BayesianHandler;
var init_BayesianHandler = __esm({
  "src/modes/handlers/BayesianHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    BayesianHandler = class {
      mode = "bayesian" /* BAYESIAN */;
      modeName = "Bayesian Inference";
      description = "Probabilistic reasoning with Bayes theorem and evidence updates";
      /**
       * Supported thought types for Bayesian mode
       */
      supportedThoughtTypes = [
        "prior_elicitation",
        "likelihood_assessment",
        "posterior_update",
        "evidence_evaluation",
        "sensitivity_analysis",
        "hypothesis_comparison"
      ];
      /**
       * Create a Bayesian thought from input
       *
       * Automatically calculates posterior if prior and likelihood are provided
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const hypothesis = inputAny.hypothesis || {
          id: randomUUID(),
          statement: input.thought,
          alternatives: []
        };
        const prior = {
          probability: inputAny.priorProbability ?? 0.5,
          justification: inputAny.priorJustification || "Default prior"
        };
        const likelihood = {
          probability: inputAny.likelihood ?? 0.5,
          description: inputAny.likelihoodDescription || "Default likelihood"
        };
        const evidence = inputAny.evidence || [];
        const posterior = this.calculatePosterior(prior, likelihood, evidence, inputAny);
        const bayesFactor = this.calculateBayesFactor(evidence);
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          isRevision: input.isRevision,
          revisesThought: input.revisesThought,
          mode: "bayesian" /* BAYESIAN */,
          hypothesis,
          prior,
          likelihood,
          evidence,
          posterior,
          bayesFactor,
          sensitivity: inputAny.sensitivity
        };
      }
      /**
       * Validate Bayesian-specific input
       *
       * Performs semantic validation:
       * 1. Basic input validation
       * 2. Probability value range validation
       * 3. Evidence likelihood ratio validation
       * 4. Consistency checks
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        const priorProb = inputAny.priorProbability;
        if (priorProb !== void 0) {
          const priorValidation = this.validateProbability(priorProb, "priorProbability");
          if (!priorValidation.valid) {
            errors.push(...priorValidation.errors);
          }
          warnings.push(...priorValidation.warnings);
        }
        const likelihoodProb = inputAny.likelihood;
        if (likelihoodProb !== void 0) {
          const likelihoodValidation = this.validateProbability(likelihoodProb, "likelihood");
          if (!likelihoodValidation.valid) {
            errors.push(...likelihoodValidation.errors);
          }
          warnings.push(...likelihoodValidation.warnings);
        }
        const posteriorProb = inputAny.posteriorProbability;
        if (posteriorProb !== void 0) {
          const posteriorValidation = this.validateProbability(posteriorProb, "posteriorProbability");
          if (!posteriorValidation.valid) {
            errors.push(...posteriorValidation.errors);
          }
          warnings.push(...posteriorValidation.warnings);
        }
        if (inputAny.evidence && Array.isArray(inputAny.evidence)) {
          for (let i = 0; i < inputAny.evidence.length; i++) {
            const evidenceItem = inputAny.evidence[i];
            const evidenceValidation = this.validateEvidence(evidenceItem, i);
            if (!evidenceValidation.valid) {
              errors.push(...evidenceValidation.errors);
            }
            warnings.push(...evidenceValidation.warnings);
          }
        }
        if (inputAny.hypothesis?.alternatives) {
          const numAlternatives = inputAny.hypothesis.alternatives.length;
          if (numAlternatives > 0 && priorProb !== void 0) {
            if (priorProb > 0.9 && numAlternatives > 2) {
              warnings.push(
                createValidationWarning(
                  "priorProbability",
                  `High prior probability (${priorProb}) with ${numAlternatives} alternatives`,
                  "Consider whether prior properly reflects uncertainty across alternatives"
                )
              );
            }
          }
        }
        if (!inputAny.evidence || inputAny.evidence.length === 0) {
          warnings.push(
            createValidationWarning(
              "evidence",
              "No evidence provided for Bayesian update",
              "Add evidence with likelihood ratios to update the posterior"
            )
          );
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get Bayesian-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["causal" /* CAUSAL */, "evidential" /* EVIDENTIAL */],
          guidingQuestions: [],
          warnings: [],
          metrics: {},
          mentalModels: ["Bayes Theorem", "Prior Updating", "Likelihood Ratio", "Base Rate Fallacy"]
        };
        enhancements.metrics = {
          priorProbability: thought.prior.probability,
          likelihoodProbability: thought.likelihood.probability,
          posteriorProbability: thought.posterior.probability,
          evidenceCount: thought.evidence.length
        };
        if (thought.bayesFactor !== void 0) {
          enhancements.metrics.bayesFactor = thought.bayesFactor;
          const bf = thought.bayesFactor;
          let strength;
          if (bf < 1) {
            strength = bf < 0.1 ? "Strong evidence against" : bf < 0.33 ? "Moderate evidence against" : "Weak evidence against";
          } else {
            strength = bf > 10 ? "Strong evidence for" : bf > 3 ? "Moderate evidence for" : "Weak evidence for";
          }
          enhancements.suggestions.push(`Bayes factor (${bf.toFixed(2)}) indicates: ${strength} the hypothesis`);
        }
        const shift = Math.abs(thought.posterior.probability - thought.prior.probability);
        if (shift < 0.05) {
          enhancements.suggestions.push(
            "Small prior-to-posterior shift. Consider seeking more diagnostic evidence."
          );
        } else if (shift > 0.4) {
          enhancements.warnings.push(
            "Large belief update. Verify evidence quality and likelihood estimates."
          );
        }
        if (thought.posterior.probability > 0.9) {
          enhancements.guidingQuestions.push(
            "What evidence could potentially disconfirm this high-confidence belief?"
          );
        } else if (thought.posterior.probability < 0.1) {
          enhancements.guidingQuestions.push(
            "What new evidence would be needed to revive this hypothesis?"
          );
        } else {
          enhancements.guidingQuestions.push(
            "What additional evidence could help resolve the remaining uncertainty?"
          );
        }
        if (!thought.sensitivity) {
          enhancements.guidingQuestions.push(
            "How sensitive is the posterior to changes in the prior probability?"
          );
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Calculate posterior probability using Bayes' theorem
       *
       * P(H|E) = P(E|H) * P(H) / P(E)
       * where P(E) = P(E|H) * P(H) + P(E|~H) * P(~H)
       */
      calculatePosterior(prior, likelihood, evidence, inputAny) {
        if (inputAny.posteriorProbability !== void 0) {
          return {
            probability: inputAny.posteriorProbability,
            calculation: "Provided directly",
            confidence: inputAny.posteriorConfidence ?? 0.8
          };
        }
        let currentPosterior = prior.probability;
        if (evidence.length > 0) {
          for (const ev of evidence) {
            const pEgivenH = ev.likelihoodGivenHypothesis;
            const pEgivenNotH = ev.likelihoodGivenNotHypothesis;
            const pE = pEgivenH * currentPosterior + pEgivenNotH * (1 - currentPosterior);
            if (pE > 0) {
              currentPosterior = pEgivenH * currentPosterior / pE;
            }
          }
        } else {
          const pEgivenH = likelihood.probability;
          const pEgivenNotH = 1 - likelihood.probability;
          const pE = pEgivenH * prior.probability + pEgivenNotH * (1 - prior.probability);
          if (pE > 0) {
            currentPosterior = pEgivenH * prior.probability / pE;
          }
        }
        const calculation = evidence.length > 0 ? `Updated through ${evidence.length} evidence items using Bayes theorem` : `P(H|E) = P(E|H)P(H) / [P(E|H)P(H) + P(E|~H)P(~H)]`;
        return {
          probability: Math.max(0, Math.min(1, currentPosterior)),
          // Clamp to [0, 1]
          calculation,
          confidence: this.estimatePosteriorConfidence(evidence)
        };
      }
      /**
       * Calculate Bayes factor from evidence
       *
       * BF =  P(E_i|H) / P(E_i|~H)
       */
      calculateBayesFactor(evidence) {
        if (evidence.length === 0) {
          return void 0;
        }
        let bayesFactor = 1;
        for (const ev of evidence) {
          if (ev.likelihoodGivenNotHypothesis > 0) {
            bayesFactor *= ev.likelihoodGivenHypothesis / ev.likelihoodGivenNotHypothesis;
          }
        }
        return bayesFactor;
      }
      /**
       * Estimate confidence in posterior calculation
       */
      estimatePosteriorConfidence(evidence) {
        if (evidence.length === 0) {
          return 0.5;
        }
        const evidenceContribution = Math.min(0.4, evidence.length * 0.1);
        let qualityScore = 0;
        for (const ev of evidence) {
          const ratio = ev.likelihoodGivenHypothesis / (ev.likelihoodGivenNotHypothesis || 0.01);
          if (ratio > 100 || ratio < 0.01) {
            qualityScore += 0.05;
          } else {
            qualityScore += 0.1;
          }
        }
        const avgQuality = qualityScore / evidence.length;
        return Math.min(0.95, 0.5 + evidenceContribution + avgQuality);
      }
      /**
       * Validate a probability value
       */
      validateProbability(value, field) {
        const errors = [];
        const warnings = [];
        if (typeof value !== "number" || isNaN(value)) {
          errors.push(
            createValidationError(
              field,
              `${field} must be a valid number`,
              "INVALID_PROBABILITY_TYPE"
            )
          );
        } else if (value < 0 || value > 1) {
          errors.push(
            createValidationError(
              field,
              `${field} (${value}) must be between 0 and 1`,
              "PROBABILITY_OUT_OF_RANGE"
            )
          );
        } else if (value === 0 || value === 1) {
          warnings.push(
            createValidationWarning(
              field,
              `Extreme probability value (${value}) leaves no room for updating`,
              "Consider using values slightly away from 0 and 1 (e.g., 0.01 or 0.99)"
            )
          );
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Validate an evidence item
       */
      validateEvidence(evidence, index) {
        const errors = [];
        const warnings = [];
        const prefix = `evidence[${index}]`;
        if (!evidence.id || !evidence.description) {
          warnings.push(
            createValidationWarning(
              prefix,
              "Evidence item missing id or description",
              "Add descriptive id and description for better tracking"
            )
          );
        }
        const pEH = evidence.likelihoodGivenHypothesis;
        if (pEH !== void 0) {
          if (typeof pEH !== "number" || isNaN(pEH)) {
            errors.push(
              createValidationError(
                `${prefix}.likelihoodGivenHypothesis`,
                "Likelihood given hypothesis must be a valid number",
                "INVALID_LIKELIHOOD_TYPE"
              )
            );
          } else if (pEH < 0 || pEH > 1) {
            errors.push(
              createValidationError(
                `${prefix}.likelihoodGivenHypothesis`,
                `Likelihood given hypothesis (${pEH}) must be between 0 and 1`,
                "LIKELIHOOD_OUT_OF_RANGE"
              )
            );
          }
        }
        const pEnH = evidence.likelihoodGivenNotHypothesis;
        if (pEnH !== void 0) {
          if (typeof pEnH !== "number" || isNaN(pEnH)) {
            errors.push(
              createValidationError(
                `${prefix}.likelihoodGivenNotHypothesis`,
                "Likelihood given not hypothesis must be a valid number",
                "INVALID_LIKELIHOOD_TYPE"
              )
            );
          } else if (pEnH < 0 || pEnH > 1) {
            errors.push(
              createValidationError(
                `${prefix}.likelihoodGivenNotHypothesis`,
                `Likelihood given not hypothesis (${pEnH}) must be between 0 and 1`,
                "LIKELIHOOD_OUT_OF_RANGE"
              )
            );
          }
        }
        if (pEH !== void 0 && pEnH !== void 0 && Math.abs(pEH - pEnH) < 0.1) {
          warnings.push(
            createValidationWarning(
              prefix,
              `Evidence has low diagnostic value (P(E|H)=${pEH}, P(E|~H)=${pEnH})`,
              "Evidence is more useful when likelihood ratios differ significantly"
            )
          );
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
    };
  }
});
var CounterfactualHandler;
var init_CounterfactualHandler = __esm({
  "src/modes/handlers/CounterfactualHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    CounterfactualHandler = class {
      mode = "counterfactual" /* COUNTERFACTUAL */;
      modeName = "Counterfactual Analysis";
      description = "What-if analysis with world state tracking and divergence point identification";
      /**
       * Supported thought types for counterfactual mode
       */
      supportedThoughtTypes = [
        "problem_definition",
        "scenario_construction",
        "divergence_analysis",
        "outcome_comparison",
        "intervention_identification",
        "causal_chain_analysis"
      ];
      /**
       * Create a counterfactual thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const actual = inputAny.actual || {
          id: randomUUID().slice(0, 8),
          name: "Actual Scenario",
          description: "",
          conditions: inputAny.actualConditions || [],
          outcomes: inputAny.actualOutcomes || []
        };
        const counterfactuals = inputAny.counterfactuals || [];
        const comparison = inputAny.comparison || {
          differences: [],
          insights: [],
          lessons: []
        };
        const interventionPoint = inputAny.interventionPoint || {
          description: "",
          timing: "",
          feasibility: 0.5,
          expectedImpact: 0.5
        };
        const thought = {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          isRevision: input.isRevision,
          revisesThought: input.revisesThought,
          mode: "counterfactual" /* COUNTERFACTUAL */,
          actual,
          counterfactuals,
          comparison,
          interventionPoint,
          causalChains: inputAny.causalChains || []
        };
        return thought;
      }
      /**
       * Validate counterfactual-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        if (inputAny.actual) {
          const actualValidation = this.validateScenario(inputAny.actual, "actual");
          errors.push(...actualValidation.errors);
          warnings.push(...actualValidation.warnings);
        }
        if (inputAny.counterfactuals && Array.isArray(inputAny.counterfactuals)) {
          for (let i = 0; i < inputAny.counterfactuals.length; i++) {
            const cf = inputAny.counterfactuals[i];
            const cfValidation = this.validateScenario(cf, `counterfactuals[${i}]`);
            errors.push(...cfValidation.errors);
            warnings.push(...cfValidation.warnings);
            if (cf.conditions && Array.isArray(cf.conditions)) {
              const hasIntervention = cf.conditions.some((c) => c.isIntervention === true);
              if (!hasIntervention) {
                warnings.push(
                  createValidationWarning(
                    `counterfactuals[${i}]`,
                    "Counterfactual scenario has no conditions marked as interventions",
                    "Mark changed conditions with isIntervention: true to track divergence points"
                  )
                );
              }
            }
          }
          if (inputAny.counterfactuals.length === 0 && inputAny.actual) {
            warnings.push(
              createValidationWarning(
                "counterfactuals",
                "No counterfactual scenarios provided",
                "Add alternative scenarios to explore what-if possibilities"
              )
            );
          }
        }
        if (inputAny.interventionPoint) {
          const ipValidation = this.validateInterventionPoint(inputAny.interventionPoint);
          errors.push(...ipValidation.errors);
          warnings.push(...ipValidation.warnings);
        }
        if (inputAny.causalChains && Array.isArray(inputAny.causalChains)) {
          for (let i = 0; i < inputAny.causalChains.length; i++) {
            const chain = inputAny.causalChains[i];
            const chainValidation = this.validateCausalChain(chain, i);
            errors.push(...chainValidation.errors);
            warnings.push(...chainValidation.warnings);
          }
        }
        if (inputAny.comparison) {
          const compValidation = this.validateComparison(inputAny.comparison);
          warnings.push(...compValidation.warnings);
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get counterfactual-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["causal" /* CAUSAL */, "bayesian" /* BAYESIAN */, "temporal" /* TEMPORAL */],
          guidingQuestions: [],
          warnings: [],
          mentalModels: ["Possible Worlds", "Nearest World Semantics", "Intervention Calculus"]
        };
        const actualConditions = thought.actual?.conditions?.length || 0;
        const counterfactualCount = thought.counterfactuals?.length || 0;
        const totalInterventions = this.countInterventions(thought);
        enhancements.metrics = {
          actualConditions,
          counterfactualCount,
          totalInterventions,
          comparisonDepth: this.calculateComparisonDepth(thought.comparison)
        };
        if (counterfactualCount === 0) {
          enhancements.suggestions.push(
            "Define at least one counterfactual scenario to explore alternatives"
          );
        } else if (counterfactualCount === 1) {
          enhancements.suggestions.push(
            "Consider adding more counterfactual scenarios to explore the decision space"
          );
        }
        if (totalInterventions === 0 && counterfactualCount > 0) {
          enhancements.suggestions.push(
            "Mark which conditions were changed from actual using isIntervention: true"
          );
        }
        if (thought.actual && thought.actual.outcomes && thought.actual.outcomes.length > 0) {
          enhancements.guidingQuestions.push(
            "What single change would have most altered the actual outcome?"
          );
        }
        if (thought.interventionPoint && thought.interventionPoint.description) {
          enhancements.guidingQuestions.push(
            `Is the intervention point "${thought.interventionPoint.description}" the earliest possible point of change?`
          );
        }
        if (!thought.causalChains || thought.causalChains.length === 0) {
          enhancements.guidingQuestions.push(
            "What causal chain led from conditions to outcome?"
          );
        }
        if (thought.comparison) {
          if (thought.comparison.insights.length === 0) {
            enhancements.warnings.push(
              "No insights extracted from comparison. What did the counterfactual analysis reveal?"
            );
          }
          if (thought.comparison.lessons.length === 0) {
            enhancements.guidingQuestions.push(
              "What actionable lessons can be drawn from this counterfactual analysis?"
            );
          }
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Validate a scenario
       */
      validateScenario(scenario, path4) {
        const errors = [];
        const warnings = [];
        if (!scenario.name || scenario.name.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              `${path4}.name`,
              "Scenario has no name",
              "Add a descriptive name to identify the scenario"
            )
          );
        }
        if (scenario.conditions && Array.isArray(scenario.conditions)) {
          for (let i = 0; i < scenario.conditions.length; i++) {
            const condition = scenario.conditions[i];
            if (!condition.factor || condition.factor.trim().length === 0) {
              warnings.push(
                createValidationWarning(
                  `${path4}.conditions[${i}].factor`,
                  "Condition has no factor specified",
                  "Each condition should identify what factor is being set"
                )
              );
            }
          }
        }
        if (scenario.outcomes && scenario.outcomes.length > 0) {
          for (let i = 0; i < scenario.outcomes.length; i++) {
            const outcome = scenario.outcomes[i];
            if (outcome.magnitude !== void 0) {
              const magnitude = outcome.magnitude;
              if (magnitude < 0 || magnitude > 1) {
                warnings.push(
                  createValidationWarning(
                    `${path4}.outcomes[${i}].magnitude`,
                    `Outcome magnitude ${magnitude} is outside [0, 1] range`,
                    "Magnitude should be normalized to [0, 1]"
                  )
                );
              }
            }
          }
        }
        if (scenario.likelihood !== void 0) {
          if (scenario.likelihood < 0 || scenario.likelihood > 1) {
            warnings.push(
              createValidationWarning(
                `${path4}.likelihood`,
                `Scenario likelihood ${scenario.likelihood} is outside [0, 1] range`,
                "Likelihood must be between 0 and 1"
              )
            );
          }
        }
        return errors.length > 0 ? validationFailure(errors, warnings) : validationSuccess(warnings);
      }
      /**
       * Validate intervention point
       */
      validateInterventionPoint(ip) {
        const warnings = [];
        if (ip.feasibility !== void 0) {
          if (ip.feasibility < 0 || ip.feasibility > 1) {
            warnings.push(
              createValidationWarning(
                "interventionPoint.feasibility",
                `Feasibility ${ip.feasibility} is outside [0, 1] range`,
                "Feasibility should be a probability between 0 and 1"
              )
            );
          }
        }
        if (ip.expectedImpact !== void 0) {
          if (ip.expectedImpact < 0 || ip.expectedImpact > 1) {
            warnings.push(
              createValidationWarning(
                "interventionPoint.expectedImpact",
                `Expected impact ${ip.expectedImpact} is outside [0, 1] range`,
                "Expected impact should be normalized to [0, 1]"
              )
            );
          }
        }
        if (!ip.description || ip.description.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              "interventionPoint.description",
              "Intervention point has no description",
              "Describe what intervention would be made at this point"
            )
          );
        }
        if (!ip.timing || ip.timing.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              "interventionPoint.timing",
              "Intervention point has no timing specified",
              "Specify when the intervention would occur"
            )
          );
        }
        return validationSuccess(warnings);
      }
      /**
       * Validate causal chain
       */
      validateCausalChain(chain, index) {
        const errors = [];
        const warnings = [];
        if (!chain.id || chain.id.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              `causalChains[${index}].id`,
              "Causal chain has no ID",
              "Add an ID to track the causal chain"
            )
          );
        }
        if (!chain.events || chain.events.length === 0) {
          warnings.push(
            createValidationWarning(
              `causalChains[${index}].events`,
              "Causal chain has no events",
              "Add events to show the causal sequence"
            )
          );
        } else if (chain.events.length < 2) {
          warnings.push(
            createValidationWarning(
              `causalChains[${index}].events`,
              "Causal chain has only one event",
              "A causal chain should have at least two events to show causation"
            )
          );
        }
        if (!chain.branchingPoint || chain.branchingPoint.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              `causalChains[${index}].branchingPoint`,
              "Causal chain has no branching point",
              "Identify where actual and counterfactual paths diverge"
            )
          );
        }
        return errors.length > 0 ? validationFailure(errors, warnings) : validationSuccess(warnings);
      }
      /**
       * Validate comparison
       */
      validateComparison(comparison) {
        const warnings = [];
        if (!comparison.differences || comparison.differences.length === 0) {
          warnings.push(
            createValidationWarning(
              "comparison.differences",
              "No differences identified between scenarios",
              "List key differences between actual and counterfactual scenarios"
            )
          );
        }
        return validationSuccess(warnings);
      }
      /**
       * Count total interventions across all counterfactual scenarios
       */
      countInterventions(thought) {
        let count = 0;
        if (thought.counterfactuals) {
          for (const cf of thought.counterfactuals) {
            if (cf.conditions) {
              count += cf.conditions.filter((c) => c.isIntervention === true).length;
            }
          }
        }
        return count;
      }
      /**
       * Calculate comparison depth based on fields populated
       */
      calculateComparisonDepth(comparison) {
        if (!comparison) return 0;
        let depth = 0;
        if (comparison.differences && comparison.differences.length > 0) depth++;
        if (comparison.insights && comparison.insights.length > 0) depth++;
        if (comparison.lessons && comparison.lessons.length > 0) depth++;
        return depth;
      }
    };
  }
});
var TemporalHandler;
var init_TemporalHandler = __esm({
  "src/modes/handlers/TemporalHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    TemporalHandler = class {
      mode = "temporal" /* TEMPORAL */;
      modeName = "Temporal Reasoning";
      description = "Timeline analysis with Allen's interval algebra and event sequencing";
      supportedThoughtTypes = [
        "event_definition",
        "interval_analysis",
        "temporal_constraint",
        "sequence_construction",
        "causality_timeline"
      ];
      /**
       * Create a temporal thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const thoughtType = this.resolveThoughtType(inputAny.thoughtType);
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          isRevision: input.isRevision,
          revisesThought: input.revisesThought,
          mode: "temporal" /* TEMPORAL */,
          thoughtType,
          timeline: inputAny.timeline,
          events: inputAny.events || [],
          intervals: inputAny.intervals || [],
          constraints: inputAny.constraints || [],
          relations: inputAny.relations || []
        };
      }
      /**
       * Validate temporal-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (inputAny.relations && inputAny.events) {
          const eventIds = new Set((inputAny.events || []).map((e) => e.id));
          for (const rel of inputAny.relations) {
            if (!eventIds.has(rel.from)) {
              errors.push(
                createValidationError(
                  "relations",
                  `Relation references unknown event: ${rel.from}`,
                  "INVALID_EVENT_REF"
                )
              );
            }
            if (!eventIds.has(rel.to)) {
              errors.push(
                createValidationError(
                  "relations",
                  `Relation references unknown event: ${rel.to}`,
                  "INVALID_EVENT_REF"
                )
              );
            }
          }
        }
        const inconsistencies = this.detectInconsistencies(inputAny.relations || []);
        for (const inc of inconsistencies) {
          warnings.push(
            createValidationWarning(
              "relations",
              `Potential temporal inconsistency: ${inc}`,
              "Review temporal constraints for contradictions"
            )
          );
        }
        if (!inputAny.events || inputAny.events.length === 0) {
          warnings.push(
            createValidationWarning(
              "events",
              "No events defined",
              "Add events to construct a timeline"
            )
          );
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get mode-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["causal" /* CAUSAL */, "sequential" /* SEQUENTIAL */, "counterfactual" /* COUNTERFACTUAL */],
          metrics: {},
          guidingQuestions: [],
          mentalModels: [
            "Allen's Interval Algebra",
            "Timeline Visualization",
            "Temporal Constraint Propagation",
            "Event Calculus",
            "Point vs. Interval Semantics"
          ]
        };
        const events = thought.events || [];
        const relations = thought.relations || [];
        enhancements.metrics = {
          eventCount: events.length,
          relationCount: relations.length,
          constraintDensity: events.length > 1 ? relations.length / (events.length * (events.length - 1) / 2) : 0,
          instantEvents: events.filter((e) => e.type === "instant").length,
          intervalEvents: events.filter((e) => e.type === "interval").length
        };
        if (events.length > 1 && relations.length === 0) {
          enhancements.suggestions.push("Define temporal relations between events");
        }
        const expectedRelations = events.length * (events.length - 1) / 2;
        if (relations.length < expectedRelations * 0.3 && events.length > 2) {
          enhancements.suggestions.push("Timeline may be under-constrained - consider adding more relations");
        }
        enhancements.guidingQuestions = [
          "Which events must occur before others?",
          "Are there events that can overlap or must be disjoint?",
          "What are the duration constraints on intervals?",
          "Are there causal dependencies implied by the temporal order?",
          "What happens if the timeline constraints are violated?"
        ];
        return enhancements;
      }
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Resolve thought type to valid TemporalThoughtType
       */
      resolveThoughtType(inputType) {
        if (inputType && this.supportedThoughtTypes.includes(inputType)) {
          return inputType;
        }
        return "event_definition";
      }
      /**
       * Detect temporal inconsistencies
       */
      detectInconsistencies(relations) {
        const inconsistencies = [];
        const beforeSet = /* @__PURE__ */ new Map();
        for (const r of relations) {
          if (r.relationType === "precedes" || r.relationType === "causes") {
            if (!beforeSet.has(r.from)) beforeSet.set(r.from, /* @__PURE__ */ new Set());
            beforeSet.get(r.from).add(r.to);
          }
        }
        for (const [from, toSet] of beforeSet) {
          for (const to of toSet) {
            if (beforeSet.get(to)?.has(from)) {
              inconsistencies.push(`${from} precedes ${to} and ${to} precedes ${from}`);
            }
          }
        }
        return inconsistencies;
      }
    };
  }
});
var GameTheoryHandler;
var init_GameTheoryHandler = __esm({
  "src/modes/handlers/GameTheoryHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    GameTheoryHandler = class {
      mode = "gametheory" /* GAMETHEORY */;
      modeName = "Game Theory";
      description = "Strategic interaction analysis with Nash equilibria and payoff matrices";
      /**
       * Supported thought types for game theory mode
       */
      supportedThoughtTypes = [
        "game_definition",
        "strategy_analysis",
        "equilibrium_finding",
        "payoff_computation",
        "dominance_analysis",
        "minimax_analysis",
        "cooperative_analysis",
        "coalition_formation",
        "shapley_value",
        "core_analysis"
      ];
      /**
       * Create a game theory thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const game = inputAny.game;
        const players = inputAny.players || [];
        const strategies = inputAny.strategies || [];
        const payoffMatrix = inputAny.payoffMatrix;
        let nashEquilibria = inputAny.nashEquilibria;
        if (!nashEquilibria && payoffMatrix && players.length > 0) {
          nashEquilibria = this.findPureStrategyNashEquilibria(payoffMatrix, players, strategies);
        }
        let dominantStrategies = inputAny.dominantStrategies;
        if (!dominantStrategies && payoffMatrix && players.length > 0) {
          dominantStrategies = this.findDominantStrategies(payoffMatrix, players, strategies);
        }
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          isRevision: input.isRevision,
          revisesThought: input.revisesThought,
          mode: "gametheory" /* GAMETHEORY */,
          thoughtType: this.resolveThoughtType(input.thoughtType),
          game,
          players,
          strategies,
          payoffMatrix,
          nashEquilibria,
          dominantStrategies,
          gameTree: inputAny.gameTree,
          minimaxAnalysis: inputAny.minimaxAnalysis,
          cooperativeGame: inputAny.cooperativeGame,
          coalitionAnalysis: inputAny.coalitionAnalysis
        };
      }
      /**
       * Validate game theory-specific input
       *
       * Performs semantic validation:
       * 1. Basic input validation
       * 2. Payoff matrix dimension validation
       * 3. Player-strategy consistency
       * 4. Payoff value validation
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        const players = inputAny.players || [];
        const strategies = inputAny.strategies || [];
        const payoffMatrix = inputAny.payoffMatrix;
        if (players.length > 0) {
          const playerValidation = this.validatePlayers(players, strategies);
          if (!playerValidation.valid) {
            errors.push(...playerValidation.errors);
          }
          warnings.push(...playerValidation.warnings);
        }
        if (strategies.length > 0) {
          const strategyValidation = this.validateStrategies(strategies, players);
          if (!strategyValidation.valid) {
            errors.push(...strategyValidation.errors);
          }
          warnings.push(...strategyValidation.warnings);
        }
        if (payoffMatrix) {
          const matrixValidation = this.validatePayoffMatrix(payoffMatrix, players, strategies);
          if (!matrixValidation.valid) {
            errors.push(...matrixValidation.errors);
          }
          warnings.push(...matrixValidation.warnings);
        }
        if (players.length === 0 && !payoffMatrix) {
          warnings.push(
            createValidationWarning(
              "players",
              "No players or payoff matrix defined",
              "Define players and their strategies for game theory analysis"
            )
          );
        }
        const game = inputAny.game;
        if (!game && players.length > 0) {
          warnings.push(
            createValidationWarning(
              "game",
              "No formal game definition provided",
              "Consider adding a Game object with type, name, and properties"
            )
          );
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get game theory-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["optimization" /* OPTIMIZATION */, "counterfactual" /* COUNTERFACTUAL */],
          guidingQuestions: [],
          warnings: [],
          metrics: {},
          mentalModels: [
            "Nash Equilibrium",
            "Dominant Strategy",
            "Pareto Efficiency",
            "Minimax Theorem",
            "Prisoner's Dilemma"
          ]
        };
        if (thought.players) {
          enhancements.metrics.playerCount = thought.players.length;
        }
        if (thought.strategies) {
          enhancements.metrics.strategyCount = thought.strategies.length;
        }
        if (thought.payoffMatrix) {
          enhancements.metrics.payoffEntries = thought.payoffMatrix.payoffs.length;
          const isZeroSum = this.isZeroSumGame(thought.payoffMatrix);
          enhancements.metrics.isZeroSum = isZeroSum ? 1 : 0;
          if (isZeroSum) {
            enhancements.suggestions.push(
              "This is a zero-sum game. Consider minimax strategies."
            );
            enhancements.relatedModes.unshift("optimization" /* OPTIMIZATION */);
          }
        }
        if (thought.nashEquilibria && thought.nashEquilibria.length > 0) {
          enhancements.metrics.nashEquilibriaCount = thought.nashEquilibria.length;
          if (thought.nashEquilibria.length > 1) {
            enhancements.suggestions.push(
              `Multiple Nash equilibria found (${thought.nashEquilibria.length}). Consider coordination mechanisms or focal points.`
            );
            enhancements.guidingQuestions.push(
              "Which equilibrium is most likely to emerge? Are there Schelling focal points?"
            );
          }
          const paretoOptimal = this.checkParetoOptimality(thought.nashEquilibria, thought.payoffMatrix);
          if (!paretoOptimal) {
            enhancements.warnings.push(
              "Nash equilibrium may not be Pareto optimal (like in Prisoner's Dilemma)"
            );
            enhancements.guidingQuestions.push(
              "Is there a mechanism to achieve a Pareto-superior outcome through cooperation?"
            );
          }
        } else if (thought.payoffMatrix) {
          enhancements.suggestions.push(
            "No pure strategy Nash equilibria found. Consider mixed strategies."
          );
          enhancements.guidingQuestions.push(
            "What are the optimal mixed strategy probabilities for each player?"
          );
        }
        if (thought.dominantStrategies && thought.dominantStrategies.length > 0) {
          enhancements.metrics.dominantStrategyCount = thought.dominantStrategies.length;
          enhancements.suggestions.push(
            `${thought.dominantStrategies.length} dominant strategy(ies) identified. These simplify equilibrium analysis.`
          );
        }
        if (thought.game) {
          if (thought.game.type === "cooperative") {
            enhancements.guidingQuestions.push(
              "What coalitions might form? How should payoffs be divided fairly?"
            );
            enhancements.mentalModels.push("Shapley Value", "Core", "Coalition Formation");
          } else if (thought.game.type === "extensive_form") {
            enhancements.guidingQuestions.push(
              "What is the subgame perfect equilibrium? Use backward induction."
            );
            enhancements.mentalModels.push("Backward Induction", "Subgame Perfect Equilibrium");
          }
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Resolve input thought type to valid GameTheory thought type
       */
      resolveThoughtType(inputType) {
        if (inputType && this.supportedThoughtTypes.includes(inputType)) {
          return inputType;
        }
        return "game_definition";
      }
      /**
       * Validate players array
       */
      validatePlayers(players, strategies) {
        const errors = [];
        const warnings = [];
        const playerIds = /* @__PURE__ */ new Set();
        for (const player of players) {
          if (playerIds.has(player.id)) {
            errors.push(
              createValidationError(
                "players",
                `Duplicate player ID: ${player.id}`,
                "DUPLICATE_PLAYER_ID"
              )
            );
          }
          playerIds.add(player.id);
          if (!player.availableStrategies || player.availableStrategies.length === 0) {
            warnings.push(
              createValidationWarning(
                `players.${player.id}`,
                `Player ${player.name || player.id} has no available strategies`,
                "Define available strategies for meaningful game analysis"
              )
            );
          } else {
            for (const stratId of player.availableStrategies) {
              const strategyExists = strategies.some((s) => s.id === stratId);
              if (!strategyExists && strategies.length > 0) {
                errors.push(
                  createValidationError(
                    `players.${player.id}.availableStrategies`,
                    `Player references non-existent strategy: ${stratId}`,
                    "INVALID_STRATEGY_REFERENCE"
                  )
                );
              }
            }
          }
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Validate strategies array
       */
      validateStrategies(strategies, players) {
        const errors = [];
        const warnings = [];
        const strategyIds = /* @__PURE__ */ new Set();
        const playerIds = new Set(players.map((p) => p.id));
        for (const strategy of strategies) {
          if (strategyIds.has(strategy.id)) {
            errors.push(
              createValidationError(
                "strategies",
                `Duplicate strategy ID: ${strategy.id}`,
                "DUPLICATE_STRATEGY_ID"
              )
            );
          }
          strategyIds.add(strategy.id);
          if (strategy.playerId && !playerIds.has(strategy.playerId) && players.length > 0) {
            errors.push(
              createValidationError(
                `strategies.${strategy.id}`,
                `Strategy references non-existent player: ${strategy.playerId}`,
                "INVALID_PLAYER_REFERENCE"
              )
            );
          }
          if (!strategy.isPure && strategy.probability !== void 0) {
            if (strategy.probability < 0 || strategy.probability > 1) {
              errors.push(
                createValidationError(
                  `strategies.${strategy.id}.probability`,
                  `Mixed strategy probability (${strategy.probability}) must be between 0 and 1`,
                  "INVALID_PROBABILITY"
                )
              );
            }
          }
        }
        for (const player of players) {
          const playerStrategies = strategies.filter((s) => s.playerId === player.id && !s.isPure);
          if (playerStrategies.length > 0) {
            const probSum = playerStrategies.reduce((sum, s) => sum + (s.probability || 0), 0);
            if (Math.abs(probSum - 1) > 1e-3) {
              warnings.push(
                createValidationWarning(
                  `strategies`,
                  `Mixed strategy probabilities for player ${player.id} sum to ${probSum.toFixed(3)}, not 1`,
                  "Ensure mixed strategy probabilities sum to exactly 1"
                )
              );
            }
          }
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Validate payoff matrix
       */
      validatePayoffMatrix(matrix, _players, strategies) {
        const errors = [];
        const warnings = [];
        if (matrix.players.length !== matrix.dimensions.length) {
          errors.push(
            createValidationError(
              "payoffMatrix",
              `Player count (${matrix.players.length}) doesn't match dimension count (${matrix.dimensions.length})`,
              "DIMENSION_MISMATCH"
            )
          );
        }
        const expectedEntries = matrix.dimensions.reduce((a, b) => a * b, 1);
        if (matrix.payoffs.length !== expectedEntries) {
          warnings.push(
            createValidationWarning(
              "payoffMatrix.payoffs",
              `Expected ${expectedEntries} payoff entries based on dimensions, got ${matrix.payoffs.length}`,
              "Ensure all strategy combinations have payoff entries"
            )
          );
        }
        for (let i = 0; i < matrix.payoffs.length; i++) {
          const entry = matrix.payoffs[i];
          if (entry.strategyProfile.length !== matrix.players.length) {
            errors.push(
              createValidationError(
                `payoffMatrix.payoffs[${i}]`,
                `Strategy profile has ${entry.strategyProfile.length} strategies, expected ${matrix.players.length}`,
                "INVALID_STRATEGY_PROFILE"
              )
            );
          }
          if (entry.payoffs.length !== matrix.players.length) {
            errors.push(
              createValidationError(
                `payoffMatrix.payoffs[${i}]`,
                `Payoff entry has ${entry.payoffs.length} values, expected ${matrix.players.length}`,
                "INVALID_PAYOFF_COUNT"
              )
            );
          }
          for (const stratId of entry.strategyProfile) {
            const strategyExists = strategies.some((s) => s.id === stratId);
            if (!strategyExists && strategies.length > 0) {
              errors.push(
                createValidationError(
                  `payoffMatrix.payoffs[${i}].strategyProfile`,
                  `Payoff entry references non-existent strategy: ${stratId}`,
                  "INVALID_STRATEGY_REFERENCE"
                )
              );
            }
          }
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Find pure strategy Nash equilibria
       *
       * A strategy profile is a Nash equilibrium if no player can
       * improve their payoff by unilaterally changing their strategy.
       */
      findPureStrategyNashEquilibria(matrix, players, strategies) {
        const equilibria = [];
        if (matrix.players.length !== 2 || matrix.dimensions.length !== 2) {
          return equilibria;
        }
        for (const entry of matrix.payoffs) {
          if (this.isNashEquilibrium(entry, matrix, players, strategies)) {
            equilibria.push({
              id: randomUUID(),
              strategyProfile: entry.strategyProfile,
              payoffs: entry.payoffs,
              type: "pure",
              isStrict: this.isStrictEquilibrium(entry, matrix, players, strategies),
              stability: this.calculateEquilibriumStability(entry, matrix, players, strategies)
            });
          }
        }
        return equilibria;
      }
      /**
       * Check if a strategy profile is a Nash equilibrium
       */
      isNashEquilibrium(entry, matrix, _players, _strategies) {
        for (let playerIdx = 0; playerIdx < matrix.players.length; playerIdx++) {
          const currentPayoff = entry.payoffs[playerIdx];
          for (const altEntry of matrix.payoffs) {
            let onlyThisPlayerDiffers = true;
            for (let i = 0; i < matrix.players.length; i++) {
              if (i === playerIdx) {
                if (altEntry.strategyProfile[i] === entry.strategyProfile[i]) {
                  onlyThisPlayerDiffers = false;
                  break;
                }
              } else {
                if (altEntry.strategyProfile[i] !== entry.strategyProfile[i]) {
                  onlyThisPlayerDiffers = false;
                  break;
                }
              }
            }
            if (onlyThisPlayerDiffers && altEntry.payoffs[playerIdx] > currentPayoff) {
              return false;
            }
          }
        }
        return true;
      }
      /**
       * Check if equilibrium is strict (strictly better than all deviations)
       */
      isStrictEquilibrium(entry, matrix, _players, _strategies) {
        for (let playerIdx = 0; playerIdx < matrix.players.length; playerIdx++) {
          const currentPayoff = entry.payoffs[playerIdx];
          for (const altEntry of matrix.payoffs) {
            let onlyThisPlayerDiffers = true;
            for (let i = 0; i < matrix.players.length; i++) {
              if (i === playerIdx) {
                if (altEntry.strategyProfile[i] === entry.strategyProfile[i]) {
                  onlyThisPlayerDiffers = false;
                  break;
                }
              } else {
                if (altEntry.strategyProfile[i] !== entry.strategyProfile[i]) {
                  onlyThisPlayerDiffers = false;
                  break;
                }
              }
            }
            if (onlyThisPlayerDiffers && altEntry.payoffs[playerIdx] >= currentPayoff) {
              return false;
            }
          }
        }
        return true;
      }
      /**
       * Calculate equilibrium stability score
       */
      calculateEquilibriumStability(entry, matrix, _players, _strategies) {
        let totalPenalty = 0;
        let deviationCount = 0;
        for (let playerIdx = 0; playerIdx < matrix.players.length; playerIdx++) {
          const currentPayoff = entry.payoffs[playerIdx];
          for (const altEntry of matrix.payoffs) {
            let onlyThisPlayerDiffers = true;
            for (let i = 0; i < matrix.players.length; i++) {
              if (i === playerIdx) {
                if (altEntry.strategyProfile[i] === entry.strategyProfile[i]) {
                  onlyThisPlayerDiffers = false;
                  break;
                }
              } else {
                if (altEntry.strategyProfile[i] !== entry.strategyProfile[i]) {
                  onlyThisPlayerDiffers = false;
                  break;
                }
              }
            }
            if (onlyThisPlayerDiffers) {
              totalPenalty += currentPayoff - altEntry.payoffs[playerIdx];
              deviationCount++;
            }
          }
        }
        const avgPenalty = deviationCount > 0 ? totalPenalty / deviationCount : 0;
        return Math.min(1, Math.max(0, 0.5 + avgPenalty / 10));
      }
      /**
       * Find dominant strategies
       */
      findDominantStrategies(matrix, players, strategies) {
        const dominantStrategies = [];
        if (matrix.players.length !== 2) {
          return dominantStrategies;
        }
        for (let playerIdx = 0; playerIdx < players.length; playerIdx++) {
          const player = players[playerIdx];
          const playerStrategies = strategies.filter((s) => s.playerId === player.id);
          for (const strategy of playerStrategies) {
            const dominates = this.checkDominance(strategy, playerIdx, matrix, playerStrategies);
            if (dominates.length > 0) {
              dominantStrategies.push({
                playerId: player.id,
                strategyId: strategy.id,
                type: dominates.length === playerStrategies.length - 1 ? "strictly_dominant" : "weakly_dominant",
                dominatesStrategies: dominates,
                justification: `Strategy ${strategy.name || strategy.id} dominates: ${dominates.join(", ")}`
              });
            }
          }
        }
        return dominantStrategies;
      }
      /**
       * Check which strategies a given strategy dominates
       */
      checkDominance(strategy, playerIdx, matrix, playerStrategies) {
        const dominates = [];
        for (const otherStrategy of playerStrategies) {
          if (otherStrategy.id === strategy.id) continue;
          let dominatesAll = true;
          const strategyPayoffs = /* @__PURE__ */ new Map();
          const otherPayoffs = /* @__PURE__ */ new Map();
          for (const entry of matrix.payoffs) {
            const key = entry.strategyProfile.filter((_, i) => i !== playerIdx).join("-");
            if (entry.strategyProfile[playerIdx] === strategy.id) {
              strategyPayoffs.set(key, entry.payoffs[playerIdx]);
            }
            if (entry.strategyProfile[playerIdx] === otherStrategy.id) {
              otherPayoffs.set(key, entry.payoffs[playerIdx]);
            }
          }
          for (const [key, payoff] of strategyPayoffs) {
            const otherPayoff = otherPayoffs.get(key);
            if (otherPayoff !== void 0 && payoff <= otherPayoff) {
              dominatesAll = false;
              break;
            }
          }
          if (dominatesAll && strategyPayoffs.size > 0) {
            dominates.push(otherStrategy.id);
          }
        }
        return dominates;
      }
      /**
       * Check if game is zero-sum
       */
      isZeroSumGame(matrix) {
        if (matrix.players.length !== 2) {
          return false;
        }
        for (const entry of matrix.payoffs) {
          const sum = entry.payoffs.reduce((a, b) => a + b, 0);
          if (Math.abs(sum) > 1e-3) {
            return false;
          }
        }
        return true;
      }
      /**
       * Check if Nash equilibria are Pareto optimal
       */
      checkParetoOptimality(equilibria, matrix) {
        if (!matrix || equilibria.length === 0) {
          return true;
        }
        for (const eq of equilibria) {
          for (const entry of matrix.payoffs) {
            let paretoDominates = true;
            let strictlyBetter = false;
            for (let i = 0; i < entry.payoffs.length; i++) {
              if (entry.payoffs[i] < eq.payoffs[i]) {
                paretoDominates = false;
                break;
              }
              if (entry.payoffs[i] > eq.payoffs[i]) {
                strictlyBetter = true;
              }
            }
            if (paretoDominates && strictlyBetter) {
              return false;
            }
          }
        }
        return true;
      }
    };
  }
});
var EvidentialHandler;
var init_EvidentialHandler = __esm({
  "src/modes/handlers/EvidentialHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    EvidentialHandler = class {
      mode = "evidential" /* EVIDENTIAL */;
      modeName = "Evidential Reasoning";
      description = "Dempster-Shafer belief functions with uncertainty quantification";
      supportedThoughtTypes = [
        "hypothesis_definition",
        "evidence_collection",
        "belief_assignment",
        "evidence_combination",
        "decision_analysis"
      ];
      /**
       * Create an evidential thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const thoughtType = this.resolveThoughtType(inputAny.thoughtType);
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          isRevision: input.isRevision,
          revisesThought: input.revisesThought,
          mode: "evidential" /* EVIDENTIAL */,
          thoughtType,
          frameOfDiscernment: inputAny.frameOfDiscernment || [],
          hypotheses: inputAny.hypotheses || [],
          evidence: inputAny.evidence || [],
          beliefFunctions: inputAny.beliefFunctions || [],
          combinedBelief: inputAny.combinedBelief,
          plausibility: inputAny.plausibility,
          decisions: inputAny.decisions || []
        };
      }
      /**
       * Validate evidential-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (inputAny.beliefFunctions) {
          for (const bf of inputAny.beliefFunctions) {
            if (bf.massAssignments) {
              const sum = bf.massAssignments.reduce((acc, ma) => acc + (ma.mass || 0), 0);
              if (Math.abs(sum - 1) > 1e-3) {
                errors.push(
                  createValidationError(
                    "beliefFunctions",
                    `Mass function must sum to 1 (currently ${sum.toFixed(3)})`,
                    "INVALID_MASS_SUM"
                  )
                );
              }
            }
          }
        }
        if (!inputAny.frameOfDiscernment || inputAny.frameOfDiscernment.length === 0) {
          warnings.push(
            createValidationWarning(
              "frameOfDiscernment",
              "Frame of discernment is empty",
              "Define the possible hypotheses in the frame"
            )
          );
        }
        if (inputAny.evidence) {
          const unreliableEvidence = inputAny.evidence.filter((e) => e.reliability === void 0);
          if (unreliableEvidence.length > 0) {
            warnings.push(
              createValidationWarning(
                "evidence",
                `${unreliableEvidence.length} evidence items lack reliability scores`,
                "Assign reliability scores for proper belief combination"
              )
            );
          }
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get mode-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["bayesian" /* BAYESIAN */, "abductive" /* ABDUCTIVE */],
          metrics: {},
          guidingQuestions: [],
          mentalModels: [
            "Dempster-Shafer Theory",
            "Belief vs. Plausibility",
            "Mass Function Assignment",
            "Evidence Combination",
            "Uncertainty Intervals [Bel, Pls]"
          ]
        };
        const frame = thought.frameOfDiscernment || [];
        const evidence = thought.evidence || [];
        const beliefFunctions = thought.beliefFunctions || [];
        const hypotheses = thought.hypotheses || [];
        enhancements.metrics = {
          frameSize: frame.length,
          hypothesisCount: hypotheses.length,
          evidenceCount: evidence.length,
          beliefFunctionCount: beliefFunctions.length,
          hasCombinedBelief: thought.combinedBelief ? 1 : 0
        };
        if (hypotheses.length === 0) {
          enhancements.suggestions.push("Define hypotheses in the frame of discernment");
        }
        if (evidence.length === 0) {
          enhancements.suggestions.push("Collect evidence supporting or contradicting hypotheses");
        }
        if (evidence.length > 0 && beliefFunctions.length === 0) {
          enhancements.suggestions.push("Assign belief functions based on evidence");
        }
        if (beliefFunctions.length > 1 && !thought.combinedBelief) {
          enhancements.suggestions.push("Combine belief functions using Dempster's rule");
        }
        enhancements.guidingQuestions = [
          "What evidence supports each hypothesis?",
          "How reliable is each piece of evidence?",
          "Can evidence from different sources be combined using Dempster's rule?",
          "What is the uncertainty interval [Bel(H), Pls(H)] for each hypothesis?",
          "Is the conflict between evidence sources acceptable?"
        ];
        return enhancements;
      }
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Resolve thought type to valid EvidentialThoughtType
       */
      resolveThoughtType(inputType) {
        if (inputType && this.supportedThoughtTypes.includes(inputType)) {
          return inputType;
        }
        return "hypothesis_definition";
      }
    };
  }
});
var AnalogicalHandler;
var init_AnalogicalHandler = __esm({
  "src/modes/handlers/AnalogicalHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    AnalogicalHandler = class {
      mode = "analogical" /* ANALOGICAL */;
      modeName = "Analogical Reasoning";
      description = "Cross-domain reasoning through structural mapping and analogy transfer";
      /**
       * Create an analogical thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const sourceDomain = this.processDomain(
          inputAny.sourceDomain || inputAny.sourceAnalogy,
          "source"
        );
        const targetDomain = this.processDomain(
          inputAny.targetDomain || inputAny.targetAnalogy,
          "target"
        );
        const mapping = this.processMappings(inputAny.mapping || inputAny.mappings || []);
        const insights = this.processInsights(inputAny.insights || inputAny.inferredProperties || []);
        const inferences = this.processInferences(inputAny.inferences || []);
        const limitations = inputAny.limitations || this.identifyLimitations(mapping);
        const analogyStrength = inputAny.analogyStrength ?? this.calculateAnalogyStrength(
          sourceDomain,
          targetDomain,
          mapping
        );
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          isRevision: input.isRevision,
          revisesThought: input.revisesThought,
          mode: "analogical" /* ANALOGICAL */,
          sourceDomain,
          targetDomain,
          mapping,
          insights,
          inferences,
          limitations,
          analogyStrength
        };
      }
      /**
       * Validate analogical-specific input
       */
      validate(input) {
        const warnings = [];
        const inputAny = input;
        const source = inputAny.sourceDomain || inputAny.sourceAnalogy;
        if (!source || !source.name) {
          warnings.push(
            createValidationWarning(
              "sourceDomain",
              "Source domain not fully specified",
              "Define the source domain with name, entities, and relations"
            )
          );
        }
        const target = inputAny.targetDomain || inputAny.targetAnalogy;
        if (!target || !target.name) {
          warnings.push(
            createValidationWarning(
              "targetDomain",
              "Target domain not fully specified",
              "Define the target domain with name, entities, and relations"
            )
          );
        }
        const mappings = inputAny.mapping || inputAny.mappings;
        if (!mappings || mappings.length === 0) {
          warnings.push(
            createValidationWarning(
              "mapping",
              "No explicit mappings provided",
              "Specify mappings between source and target entities"
            )
          );
        }
        if (mappings) {
          const lowConfidence = mappings.filter((m) => (m.confidence || 0) < 0.5);
          if (lowConfidence.length > 0) {
            warnings.push(
              createValidationWarning(
                "mapping",
                `${lowConfidence.length} mapping(s) have low confidence`,
                "Review and strengthen weak mappings or acknowledge limitations"
              )
            );
          }
        }
        return validationSuccess(warnings);
      }
      /**
       * Get mode-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["abductive" /* ABDUCTIVE */, "inductive" /* INDUCTIVE */, "causal" /* CAUSAL */],
          metrics: {},
          guidingQuestions: [],
          mentalModels: [
            "Structure Mapping Theory (Gentner)",
            "Analogical Transfer",
            "Surface vs. Structural Similarity",
            "Negative Transfer Awareness",
            "Multi-constraint Theory"
          ]
        };
        const mapping = thought.mapping || [];
        const sourceDomain = thought.sourceDomain;
        const targetDomain = thought.targetDomain;
        enhancements.metrics = {
          mappingCount: mapping.length,
          avgConfidence: this.calculateAverageConfidence(mapping),
          sourceEntityCount: sourceDomain?.entities?.length || 0,
          targetEntityCount: targetDomain?.entities?.length || 0,
          insightCount: thought.insights?.length || 0,
          inferenceCount: thought.inferences?.length || 0,
          analogyStrength: thought.analogyStrength || 0
        };
        if (sourceDomain?.entities && targetDomain?.entities) {
          const unmappedSource = this.findUnmappedEntities(sourceDomain.entities, mapping, "source");
          const unmappedTarget = this.findUnmappedEntities(targetDomain.entities, mapping, "target");
          if (unmappedSource.length > 0) {
            enhancements.suggestions.push(
              `Consider mapping source entities: ${unmappedSource.slice(0, 3).join(", ")}`
            );
          }
          if (unmappedTarget.length > 0) {
            enhancements.suggestions.push(
              `Target entities without mappings: ${unmappedTarget.slice(0, 3).join(", ")}`
            );
          }
        }
        if ((thought.analogyStrength || 0) < 0.5) {
          enhancements.warnings = ["Low analogy strength - potential for negative transfer"];
        }
        enhancements.guidingQuestions = [
          "What structural relations are preserved across domains?",
          "Are there systematic mappings or just surface similarities?",
          "What aspects of the source domain DON'T transfer?",
          "What new inferences can be drawn from the analogy?",
          "Are there competing analogies that might be more appropriate?"
        ];
        return enhancements;
      }
      /**
       * Process a domain from input
       */
      processDomain(raw, type) {
        if (!raw) {
          return {
            id: `${type}-domain`,
            name: "",
            description: "",
            entities: [],
            relations: [],
            properties: []
          };
        }
        return {
          id: raw.id || `${type}-domain`,
          name: raw.name || raw.domain || "",
          description: raw.description || "",
          entities: this.processEntities(raw.entities || raw.elements || []),
          relations: this.processRelations(raw.relations || []),
          properties: this.processProperties(raw.properties || [])
        };
      }
      /**
       * Process entities
       */
      processEntities(raw) {
        return raw.map((e, index) => {
          if (typeof e === "string") {
            return {
              id: `entity-${index}`,
              name: e,
              type: "unknown",
              description: ""
            };
          }
          return {
            id: e.id || `entity-${index}`,
            name: e.name || "",
            type: e.type || "unknown",
            description: e.description || ""
          };
        });
      }
      /**
       * Process relations
       */
      processRelations(raw) {
        return raw.map((r, index) => {
          if (typeof r === "string") {
            return {
              id: `relation-${index}`,
              type: r,
              from: "",
              to: "",
              description: ""
            };
          }
          return {
            id: r.id || `relation-${index}`,
            type: r.type || "related",
            from: r.from || "",
            to: r.to || "",
            description: r.description || ""
          };
        });
      }
      /**
       * Process properties
       */
      processProperties(raw) {
        return raw.map((p) => ({
          entityId: p.entityId || "",
          name: p.name || "",
          value: p.value || ""
        }));
      }
      /**
       * Process mappings
       */
      processMappings(raw) {
        return raw.map((m) => ({
          sourceEntityId: m.sourceEntityId || m.source || "",
          targetEntityId: m.targetEntityId || m.target || "",
          justification: m.justification || "",
          confidence: m.confidence ?? 0.5
        }));
      }
      /**
       * Process insights
       */
      processInsights(raw) {
        return raw.map((i) => {
          if (typeof i === "string") {
            return {
              description: i,
              sourceEvidence: "",
              targetApplication: "",
              novelty: 0.5
            };
          }
          return {
            description: i.description || "",
            sourceEvidence: i.sourceEvidence || "",
            targetApplication: i.targetApplication || "",
            novelty: i.novelty ?? 0.5
          };
        });
      }
      /**
       * Process inferences (using core.ts Inference type)
       */
      processInferences(raw) {
        return raw.map((inf) => ({
          sourcePattern: inf.sourcePattern || inf.description || "",
          targetPrediction: inf.targetPrediction || inf.basedOn || "",
          confidence: inf.confidence ?? 0.5,
          needsVerification: inf.needsVerification ?? (inf.testability ? true : false)
        }));
      }
      /**
       * Calculate analogy strength based on mappings
       */
      calculateAnalogyStrength(source, target, mappings) {
        if (mappings.length === 0) return 0;
        const sourceCount = source.entities?.length || 1;
        const targetCount = target.entities?.length || 1;
        const coverage = mappings.length / Math.max(sourceCount, targetCount);
        const avgConfidence = this.calculateAverageConfidence(mappings);
        return Math.min(coverage * avgConfidence * 1.2, 1);
      }
      /**
       * Calculate average confidence of mappings
       */
      calculateAverageConfidence(mappings) {
        if (mappings.length === 0) return 0;
        const sum = mappings.reduce((acc, m) => acc + (m.confidence || 0.5), 0);
        return sum / mappings.length;
      }
      /**
       * Find entities not yet mapped
       */
      findUnmappedEntities(entities, mappings, side) {
        const mappedIds = new Set(
          mappings.map((m) => side === "source" ? m.sourceEntityId : m.targetEntityId)
        );
        return entities.filter((e) => !mappedIds.has(e.id)).map((e) => e.name);
      }
      /**
       * Identify potential limitations of the analogy
       */
      identifyLimitations(mappings) {
        const limitations = [];
        const lowConfidence = mappings.filter((m) => m.confidence < 0.5);
        if (lowConfidence.length > 0) {
          limitations.push("Some mappings have low confidence");
        }
        if (mappings.length === 0) {
          limitations.push("No mappings defined - analogy is undefined");
        }
        return limitations;
      }
    };
  }
});
var FirstPrinciplesHandler;
var init_FirstPrinciplesHandler = __esm({
  "src/modes/handlers/FirstPrinciplesHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    FirstPrinciplesHandler = class {
      mode = "firstprinciples" /* FIRSTPRINCIPLES */;
      modeName = "First Principles Reasoning";
      description = "Bottom-up reasoning from fundamental truths with derivation chains";
      /**
       * Create a first principles thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          isRevision: input.isRevision,
          revisesThought: input.revisesThought,
          mode: "firstprinciples" /* FIRSTPRINCIPLES */,
          question: inputAny.question || "",
          principles: inputAny.principles || [],
          derivationSteps: inputAny.derivationSteps || [],
          conclusion: inputAny.conclusion || {
            statement: "",
            derivationChain: [],
            certainty: 0
          },
          alternativeInterpretations: inputAny.alternativeInterpretations || []
        };
      }
      /**
       * Validate first principles-specific input
       */
      validate(input) {
        const warnings = [];
        const inputAny = input;
        if (!inputAny.question || inputAny.question.trim() === "") {
          warnings.push(
            createValidationWarning(
              "question",
              "No question specified",
              "Define the fundamental question you are trying to answer"
            )
          );
        }
        if (!inputAny.principles || inputAny.principles.length === 0) {
          warnings.push(
            createValidationWarning(
              "principles",
              "No foundational principles identified",
              "Identify the basic truths or axioms underlying your reasoning"
            )
          );
        }
        if (inputAny.principles) {
          const unjustified = inputAny.principles.filter((p) => !p.justification || p.justification.trim() === "");
          if (unjustified.length > 0) {
            warnings.push(
              createValidationWarning(
                "principles",
                `${unjustified.length} principles lack justification`,
                "Provide justification for each foundational principle"
              )
            );
          }
        }
        if (inputAny.derivationSteps && inputAny.derivationSteps.length > 0) {
          const principleIds = new Set((inputAny.principles || []).map((p) => p.id));
          for (const step of inputAny.derivationSteps) {
            if (step.principle && !principleIds.has(step.principle)) {
              warnings.push(
                createValidationWarning(
                  "derivationSteps",
                  `Step references unknown principle: ${step.principle}`,
                  "Ensure all derivation steps reference defined principles"
                )
              );
            }
          }
        }
        return validationSuccess(warnings);
      }
      /**
       * Get mode-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["deductive" /* DEDUCTIVE */, "abductive" /* ABDUCTIVE */, "formallogic" /* FORMALLOGIC */],
          metrics: {},
          guidingQuestions: [],
          mentalModels: [
            "Elon Musk's First Principles Method",
            "Socratic Questioning",
            "Aristotelian Axioms",
            "Foundationalism",
            "Decomposition and Reconstruction"
          ]
        };
        const principles = thought.principles || [];
        const derivationSteps = thought.derivationSteps || [];
        enhancements.metrics = {
          principleCount: principles.length,
          derivationStepCount: derivationSteps.length,
          conclusionCertainty: thought.conclusion?.certainty || 0,
          alternativeCount: thought.alternativeInterpretations?.length || 0
        };
        if (principles.length === 0) {
          enhancements.suggestions.push('Start by asking "What do we know for certain?"');
        }
        if (principles.length > 0 && derivationSteps.length === 0) {
          enhancements.suggestions.push("Build up from principles to derive new insights");
        }
        if (!thought.question) {
          enhancements.suggestions.push("Define the fundamental question you are investigating");
        }
        if (!thought.conclusion || !thought.conclusion.statement) {
          enhancements.suggestions.push("Formulate a conclusion based on your derivation");
        }
        enhancements.guidingQuestions = [
          "What is the most fundamental truth here?",
          "What assumptions am I making that could be wrong?",
          "Can this be broken down further?",
          "What would have to be true for this to work?",
          "Am I reasoning from facts or from analogy/convention?",
          "What would someone with no prior knowledge need to understand this?"
        ];
        return enhancements;
      }
      supportsThoughtType(_thoughtType) {
        return true;
      }
    };
  }
});
var SYSTEMS_ARCHETYPES, SystemsThinkingHandler;
var init_SystemsThinkingHandler = __esm({
  "src/modes/handlers/SystemsThinkingHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    SYSTEMS_ARCHETYPES = [
      {
        name: "Fixes that Fail",
        description: "A quick fix creates unintended consequences that make the problem worse",
        pattern: "Solution \u2192 Short-term relief \u2192 Unintended consequences \u2192 Original problem worsened",
        warningSigns: [
          "Quick fixes that keep recurring",
          "Side effects appearing after solution",
          "Escalating interventions required"
        ],
        interventions: [
          "Address root cause instead of symptoms",
          "Consider long-term consequences before acting",
          "Monitor for unintended side effects"
        ],
        loopSignature: { reinforcingCount: 1, balancingCount: 1, hasDelay: true }
      },
      {
        name: "Shifting the Burden",
        description: "A symptomatic solution undermines the fundamental solution",
        pattern: "Symptom \u2192 Quick fix AND Fundamental solution, Quick fix erodes capacity for fundamental solution",
        warningSigns: [
          "Increasing dependence on quick fixes",
          "Atrophying fundamental capabilities",
          "Growing gap between symptoms and root causes"
        ],
        interventions: [
          "Strengthen the fundamental solution",
          "Reduce reliance on symptomatic solutions",
          "Build capacity while managing symptoms"
        ],
        loopSignature: { reinforcingCount: 1, balancingCount: 2, hasDelay: true }
      },
      {
        name: "Limits to Growth",
        description: "Growth approaches a limit which slows or stops further growth",
        pattern: "Growth process \u2192 Success \u2192 Limiting condition activated \u2192 Growth slows/stops",
        warningSigns: [
          "Initial rapid growth",
          "Gradual slowdown despite continued effort",
          "Diminishing returns on investment"
        ],
        interventions: [
          "Identify and address limiting factors early",
          "Prepare for growth constraints",
          "Shift focus from pushing growth to removing limits"
        ],
        loopSignature: { reinforcingCount: 1, balancingCount: 1, hasDelay: false }
      },
      {
        name: "Success to the Successful",
        description: "Success breeds more success, starving other activities",
        pattern: "Initial advantage \u2192 More resources allocated \u2192 Greater success \u2192 Competitors starved",
        warningSigns: [
          "Winner-take-all dynamics",
          "Declining diversity of options",
          "Concentration of resources"
        ],
        interventions: [
          "Ensure fair resource allocation",
          "Support weaker parties",
          "Maintain diverse options"
        ],
        loopSignature: { reinforcingCount: 2, balancingCount: 0, hasDelay: false }
      },
      {
        name: "Tragedy of the Commons",
        description: "Individual overuse depletes a shared resource",
        pattern: "Shared resource \u2192 Individual exploitation \u2192 Resource depletion \u2192 Harm to all",
        warningSigns: [
          "Declining shared resource",
          "Increasing individual consumption",
          "Rational individual behavior leading to collective harm"
        ],
        interventions: [
          "Establish governance mechanisms",
          "Create feedback on individual impact",
          "Align individual incentives with collective good"
        ],
        loopSignature: { reinforcingCount: 1, balancingCount: 1, hasDelay: true }
      },
      {
        name: "Escalation",
        description: "Two parties compete, each responding to the other's actions",
        pattern: "Party A acts \u2192 Party B perceives threat \u2192 Party B responds \u2192 Party A perceives threat \u2192 Cycle",
        warningSigns: [
          "Competitive actions and reactions",
          "Each side feeling justified",
          "Escalating intensity over time"
        ],
        interventions: [
          "Break the cycle unilaterally",
          "Establish communication channels",
          "Find mutual benefit solutions"
        ],
        loopSignature: { reinforcingCount: 2, balancingCount: 0, hasDelay: false }
      },
      {
        name: "Growth and Underinvestment",
        description: "Growth is limited by underinvestment in capacity",
        pattern: "Demand grows \u2192 Capacity stretched \u2192 Performance drops \u2192 Investment deferred \u2192 Limits growth",
        warningSigns: [
          "Quality declining with growth",
          "Deferred investment in capacity",
          "Performance standards lowered"
        ],
        interventions: [
          "Invest in capacity ahead of demand",
          "Maintain performance standards",
          "Plan for growth requirements"
        ],
        loopSignature: { reinforcingCount: 1, balancingCount: 2, hasDelay: true }
      },
      {
        name: "Eroding Goals",
        description: "Under pressure, goals are lowered rather than addressing the gap",
        pattern: "Gap between goals and reality \u2192 Pressure \u2192 Goals lowered \u2192 Gap closed artificially",
        warningSigns: [
          "Gradual lowering of standards",
          "Rationalization of declining performance",
          "Short-term pressure driving decisions"
        ],
        interventions: [
          "Hold firm on essential goals",
          "Address root causes of gaps",
          "Distinguish essential from negotiable goals"
        ],
        loopSignature: { reinforcingCount: 1, balancingCount: 1, hasDelay: false }
      }
    ];
    SystemsThinkingHandler = class {
      mode = "systemsthinking" /* SYSTEMSTHINKING */;
      modeName = "Systems Thinking";
      description = "Systems analysis with archetype detection, feedback loops, and leverage point identification";
      /**
       * Supported thought types for systems thinking mode
       */
      supportedThoughtTypes = [
        "system_definition",
        "component_analysis",
        "feedback_identification",
        "leverage_analysis",
        "behavior_prediction"
      ];
      /**
       * Create a systems thinking thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const thoughtType = this.resolveThoughtType(inputAny.thoughtType);
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          isRevision: input.isRevision,
          revisesThought: input.revisesThought,
          mode: "systemsthinking" /* SYSTEMSTHINKING */,
          thoughtType,
          system: inputAny.system,
          components: inputAny.components || [],
          feedbackLoops: inputAny.feedbackLoops || [],
          leveragePoints: inputAny.leveragePoints || [],
          behaviors: inputAny.behaviors || []
        };
      }
      /**
       * Validate systems thinking-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        const componentIds = /* @__PURE__ */ new Set();
        if (inputAny.components && Array.isArray(inputAny.components)) {
          for (const component of inputAny.components) {
            if (component.id) componentIds.add(component.id);
          }
          for (let i = 0; i < inputAny.components.length; i++) {
            const component = inputAny.components[i];
            const compValidation = this.validateComponent(component, i, componentIds);
            errors.push(...compValidation.errors);
            warnings.push(...compValidation.warnings);
          }
        }
        if (inputAny.feedbackLoops && Array.isArray(inputAny.feedbackLoops)) {
          for (let i = 0; i < inputAny.feedbackLoops.length; i++) {
            const loop = inputAny.feedbackLoops[i];
            const loopValidation = this.validateFeedbackLoop(loop, i, componentIds);
            errors.push(...loopValidation.errors);
            warnings.push(...loopValidation.warnings);
          }
        }
        if (inputAny.leveragePoints && Array.isArray(inputAny.leveragePoints)) {
          for (let i = 0; i < inputAny.leveragePoints.length; i++) {
            const lp = inputAny.leveragePoints[i];
            const lpValidation = this.validateLeveragePoint(lp, i, componentIds);
            errors.push(...lpValidation.errors);
            warnings.push(...lpValidation.warnings);
          }
        }
        if (inputAny.system) {
          const sysValidation = this.validateSystem(inputAny.system);
          warnings.push(...sysValidation.warnings);
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get systems thinking-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["causal" /* CAUSAL */, "optimization" /* OPTIMIZATION */, "scientificmethod" /* SCIENTIFICMETHOD */],
          guidingQuestions: [],
          warnings: [],
          mentalModels: [
            "Feedback Loops",
            "Stock and Flow",
            "Systems Archetypes",
            "Leverage Points",
            "Emergence"
          ]
        };
        const componentCount = thought.components?.length || 0;
        const feedbackLoopCount = thought.feedbackLoops?.length || 0;
        const leveragePointCount = thought.leveragePoints?.length || 0;
        const behaviorCount = thought.behaviors?.length || 0;
        const reinforcingLoops = (thought.feedbackLoops || []).filter((l) => l.type === "reinforcing").length;
        const balancingLoops = (thought.feedbackLoops || []).filter((l) => l.type === "balancing").length;
        enhancements.metrics = {
          componentCount,
          feedbackLoopCount,
          reinforcingLoops,
          balancingLoops,
          leveragePointCount,
          behaviorCount
        };
        const detectedArchetypesResult = this.detectArchetypes(thought);
        if (detectedArchetypesResult.length > 0) {
          enhancements.detectedArchetypes = detectedArchetypesResult.map((a) => ({
            name: a.name,
            confidence: a.confidence,
            matchedPatterns: a.archetype.warningSigns
          }));
          for (const detected of detectedArchetypesResult) {
            if (detected.confidence > 0.5) {
              enhancements.warnings.push(
                `Potential "${detected.name}" archetype detected. Watch for: ${detected.archetype.warningSigns[0]}`
              );
            }
          }
        }
        if (componentCount === 0) {
          enhancements.suggestions.push(
            "Define system components (stocks, flows, variables) to model the system"
          );
        }
        if (componentCount >= 2 && feedbackLoopCount === 0) {
          enhancements.suggestions.push(
            "Identify feedback loops connecting your components"
          );
        }
        if (reinforcingLoops > 0 && balancingLoops === 0) {
          enhancements.warnings.push(
            "Only reinforcing loops detected. System may be unstable without balancing feedback."
          );
        }
        if (feedbackLoopCount >= 2 && leveragePointCount === 0) {
          enhancements.suggestions.push(
            "Identify leverage points where small changes could have large effects"
          );
        }
        if (thought.system) {
          enhancements.guidingQuestions.push(
            "What is the system optimizing for? Is that the intended goal?"
          );
        }
        if (feedbackLoopCount > 0) {
          enhancements.guidingQuestions.push(
            "Which feedback loop is currently dominant in the system behavior?"
          );
        }
        const delayedLoops = (thought.feedbackLoops || []).filter((l) => l.delay && l.delay > 0);
        if (delayedLoops.length > 0) {
          enhancements.guidingQuestions.push(
            "How do delays in feedback affect system predictability?"
          );
        }
        if (componentCount >= 3 && behaviorCount === 0) {
          enhancements.guidingQuestions.push(
            "What emergent behaviors arise from the interaction of these components?"
          );
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Resolve thought type to valid SystemsThinkingThoughtType
       */
      resolveThoughtType(inputType) {
        if (inputType && this.supportedThoughtTypes.includes(inputType)) {
          return inputType;
        }
        return "system_definition";
      }
      /**
       * Validate a system component
       */
      validateComponent(component, index, existingIds) {
        const errors = [];
        const warnings = [];
        if (!component.id || component.id.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              `components[${index}].id`,
              "Component has no ID",
              "Add an ID to reference this component in loops"
            )
          );
        }
        if (!component.name || component.name.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              `components[${index}].name`,
              "Component has no name",
              "Add a descriptive name"
            )
          );
        }
        if (component.influencedBy) {
          for (const refId of component.influencedBy) {
            if (!existingIds.has(refId)) {
              warnings.push(
                createValidationWarning(
                  `components[${index}].influencedBy`,
                  `References non-existent component: ${refId}`,
                  "Ensure all component references exist"
                )
              );
            }
          }
        }
        return errors.length > 0 ? validationFailure(errors, warnings) : validationSuccess(warnings);
      }
      /**
       * Validate a feedback loop
       */
      validateFeedbackLoop(loop, index, componentIds) {
        const errors = [];
        const warnings = [];
        if (!loop.id || loop.id.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              `feedbackLoops[${index}].id`,
              "Feedback loop has no ID",
              "Add an ID to track this loop"
            )
          );
        }
        if (loop.components && loop.components.length > 0) {
          for (const compId of loop.components) {
            if (!componentIds.has(compId)) {
              warnings.push(
                createValidationWarning(
                  `feedbackLoops[${index}].components`,
                  `Loop references non-existent component: ${compId}`,
                  "Ensure all components in the loop exist"
                )
              );
            }
          }
          if (loop.components.length < 2) {
            warnings.push(
              createValidationWarning(
                `feedbackLoops[${index}].components`,
                "Feedback loop has fewer than 2 components",
                "A feedback loop needs at least 2 components to form a cycle"
              )
            );
          }
        } else {
          warnings.push(
            createValidationWarning(
              `feedbackLoops[${index}].components`,
              "Feedback loop has no components",
              "Add components that form the feedback loop"
            )
          );
        }
        if (loop.strength !== void 0 && (loop.strength < 0 || loop.strength > 1)) {
          warnings.push(
            createValidationWarning(
              `feedbackLoops[${index}].strength`,
              `Loop strength (${loop.strength}) is outside [0, 1] range`,
              "Strength should be normalized to [0, 1]"
            )
          );
        }
        return errors.length > 0 ? validationFailure(errors, warnings) : validationSuccess(warnings);
      }
      /**
       * Validate a leverage point
       */
      validateLeveragePoint(lp, index, componentIds) {
        const warnings = [];
        if (!lp.location || lp.location.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              `leveragePoints[${index}].location`,
              "Leverage point has no location",
              "Specify which component or loop this leverage point targets"
            )
          );
        } else if (!componentIds.has(lp.location)) {
          warnings.push(
            createValidationWarning(
              `leveragePoints[${index}].location`,
              `Leverage point location "${lp.location}" not found in components`,
              "Ensure the location references an existing component or loop"
            )
          );
        }
        if (lp.effectiveness !== void 0 && (lp.effectiveness < 0 || lp.effectiveness > 1)) {
          warnings.push(
            createValidationWarning(
              `leveragePoints[${index}].effectiveness`,
              `Effectiveness (${lp.effectiveness}) is outside [0, 1] range`,
              "Effectiveness should be normalized to [0, 1]"
            )
          );
        }
        if (lp.difficulty !== void 0 && (lp.difficulty < 0 || lp.difficulty > 1)) {
          warnings.push(
            createValidationWarning(
              `leveragePoints[${index}].difficulty`,
              `Difficulty (${lp.difficulty}) is outside [0, 1] range`,
              "Difficulty should be normalized to [0, 1]"
            )
          );
        }
        return validationSuccess(warnings);
      }
      /**
       * Validate system definition
       */
      validateSystem(system) {
        const warnings = [];
        if (!system.boundary || system.boundary.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              "system.boundary",
              "System has no boundary defined",
              "Define what is inside and outside the system"
            )
          );
        }
        if (!system.purpose || system.purpose.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              "system.purpose",
              "System has no purpose defined",
              "Define what the system is designed to achieve"
            )
          );
        }
        return validationSuccess(warnings);
      }
      /**
       * Detect systems archetypes based on structure
       */
      detectArchetypes(thought) {
        const detected = [];
        const loops = thought.feedbackLoops || [];
        const reinforcingCount = loops.filter((l) => l.type === "reinforcing").length;
        const balancingCount = loops.filter((l) => l.type === "balancing").length;
        const hasDelay = loops.some((l) => l.delay && l.delay > 0);
        for (const archetype of SYSTEMS_ARCHETYPES) {
          let confidence = 0;
          const sig = archetype.loopSignature;
          if (sig.reinforcingCount !== void 0) {
            if (reinforcingCount === sig.reinforcingCount) {
              confidence += 0.4;
            } else if (Math.abs(reinforcingCount - sig.reinforcingCount) === 1) {
              confidence += 0.2;
            }
          }
          if (sig.balancingCount !== void 0) {
            if (balancingCount === sig.balancingCount) {
              confidence += 0.4;
            } else if (Math.abs(balancingCount - sig.balancingCount) === 1) {
              confidence += 0.2;
            }
          }
          if (sig.hasDelay !== void 0) {
            if (hasDelay === sig.hasDelay) {
              confidence += 0.2;
            }
          }
          if (confidence >= 0.4) {
            detected.push({
              name: archetype.name,
              confidence: Math.min(confidence, 1),
              archetype
            });
          }
        }
        detected.sort((a, b) => b.confidence - a.confidence);
        return detected.slice(0, 3);
      }
    };
  }
});
var ScientificMethodHandler;
var init_ScientificMethodHandler = __esm({
  "src/modes/handlers/ScientificMethodHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    ScientificMethodHandler = class {
      mode = "scientificmethod" /* SCIENTIFICMETHOD */;
      modeName = "Scientific Method";
      description = "Hypothesis testing with experimental design and falsifiability analysis";
      supportedThoughtTypes = [
        "question_formulation",
        "hypothesis_generation",
        "experiment_design",
        "data_collection",
        "analysis",
        "conclusion"
      ];
      /**
       * Create a scientific method thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const thoughtType = this.resolveThoughtType(inputAny.thoughtType);
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          isRevision: input.isRevision,
          revisesThought: input.revisesThought,
          mode: "scientificmethod" /* SCIENTIFICMETHOD */,
          thoughtType,
          researchQuestion: inputAny.researchQuestion,
          scientificHypotheses: inputAny.scientificHypotheses || [],
          experiment: inputAny.experiment,
          data: inputAny.data,
          analysis: inputAny.analysis,
          conclusion: inputAny.conclusion
        };
      }
      /**
       * Validate scientific method-specific input
       */
      validate(input) {
        const warnings = [];
        const inputAny = input;
        if (!inputAny.researchQuestion) {
          warnings.push(
            createValidationWarning(
              "researchQuestion",
              "No research question defined",
              "Formulate a clear research question"
            )
          );
        }
        if (inputAny.scientificHypotheses && inputAny.scientificHypotheses.length > 0) {
          for (const hyp of inputAny.scientificHypotheses) {
            if (!hyp.testable) {
              warnings.push(
                createValidationWarning(
                  "scientificHypotheses",
                  `Hypothesis "${hyp.statement?.slice(0, 30)}..." may not be testable`,
                  "Ensure hypotheses are empirically testable"
                )
              );
            }
            if (!hyp.falsifiable) {
              warnings.push(
                createValidationWarning(
                  "scientificHypotheses",
                  `Hypothesis "${hyp.statement?.slice(0, 30)}..." may not be falsifiable`,
                  "Ensure hypotheses can be proven false"
                )
              );
            }
          }
        } else {
          warnings.push(
            createValidationWarning(
              "scientificHypotheses",
              "No hypotheses defined",
              "Formulate testable hypotheses based on your research question"
            )
          );
        }
        if (inputAny.experiment) {
          if (!inputAny.experiment.controls || inputAny.experiment.controls.length === 0) {
            warnings.push(
              createValidationWarning(
                "experiment.controls",
                "No control conditions specified",
                "Define control conditions for valid comparison"
              )
            );
          }
          if (!inputAny.experiment.sampleSize || inputAny.experiment.sampleSize < 10) {
            warnings.push(
              createValidationWarning(
                "experiment.sampleSize",
                "Sample size may be insufficient",
                "Consider power analysis for adequate sample size"
              )
            );
          }
        }
        return validationSuccess(warnings);
      }
      /**
       * Get mode-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["abductive" /* ABDUCTIVE */, "inductive" /* INDUCTIVE */, "bayesian" /* BAYESIAN */],
          metrics: {},
          guidingQuestions: [],
          mentalModels: [
            "Popperian Falsificationism",
            "Hypothetico-Deductive Method",
            "Control Variables",
            "Reproducibility",
            "Statistical Significance",
            "Null Hypothesis Testing"
          ]
        };
        const hypotheses = thought.scientificHypotheses || [];
        const hasExperiment = !!thought.experiment;
        const hasData = !!thought.data;
        const hasAnalysis = !!thought.analysis;
        const hasConclusion = !!thought.conclusion;
        enhancements.metrics = {
          hypothesisCount: hypotheses.length,
          hasResearchQuestion: thought.researchQuestion ? 1 : 0,
          hasExperiment: hasExperiment ? 1 : 0,
          hasData: hasData ? 1 : 0,
          hasAnalysis: hasAnalysis ? 1 : 0,
          hasConclusion: hasConclusion ? 1 : 0
        };
        if (!thought.researchQuestion) {
          enhancements.suggestions.push("Start by formulating a clear research question");
        } else if (hypotheses.length === 0) {
          enhancements.suggestions.push("Derive specific, testable hypotheses from your research question");
        } else if (!hasExperiment) {
          enhancements.suggestions.push("Design an experiment to test your hypotheses");
        } else if (!hasData) {
          enhancements.suggestions.push("Collect data according to your experimental design");
        } else if (!hasAnalysis) {
          enhancements.suggestions.push("Analyze data using appropriate statistical methods");
        } else if (!hasConclusion) {
          enhancements.suggestions.push("Draw conclusions based on your analysis results");
        }
        enhancements.guidingQuestions = [
          "What would falsify this hypothesis?",
          "Are there confounding variables to control for?",
          "Is the experiment reproducible by others?",
          "What is the null hypothesis?",
          "How large a sample size is needed for significance?",
          "Are there alternative hypotheses that explain the same observations?"
        ];
        return enhancements;
      }
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Resolve thought type to valid ScientificMethodThoughtType
       */
      resolveThoughtType(inputType) {
        if (inputType && this.supportedThoughtTypes.includes(inputType)) {
          return inputType;
        }
        return "question_formulation";
      }
    };
  }
});
var FormalLogicHandler;
var init_FormalLogicHandler = __esm({
  "src/modes/handlers/FormalLogicHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    FormalLogicHandler = class {
      mode = "formallogic" /* FORMALLOGIC */;
      modeName = "Formal Logic";
      description = "Propositional and predicate logic with inference validation";
      supportedThoughtTypes = [
        "proposition_definition",
        "inference_derivation",
        "proof_construction",
        "satisfiability_check",
        "validity_verification"
      ];
      /**
       * Create a formal logic thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const thoughtType = this.resolveThoughtType(inputAny.thoughtType);
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          isRevision: input.isRevision,
          revisesThought: input.revisesThought,
          mode: "formallogic" /* FORMALLOGIC */,
          thoughtType,
          propositions: inputAny.propositions || [],
          logicalInferences: inputAny.logicalInferences || [],
          proof: inputAny.proof,
          truthTable: inputAny.truthTable,
          satisfiability: inputAny.satisfiability
        };
      }
      /**
       * Validate formal logic-specific input
       */
      validate(input) {
        const warnings = [];
        const inputAny = input;
        if (!inputAny.propositions || inputAny.propositions.length === 0) {
          warnings.push(
            createValidationWarning(
              "propositions",
              "No propositions defined",
              "Define the atomic propositions for your logical argument"
            )
          );
        }
        if (inputAny.logicalInferences) {
          for (const inf of inputAny.logicalInferences) {
            if (inf.valid === false) {
              warnings.push(
                createValidationWarning(
                  "logicalInferences",
                  `Inference "${inf.id}" is marked as invalid`,
                  "Review the inference rule application"
                )
              );
            }
          }
        }
        if (inputAny.proof) {
          if (inputAny.proof.completeness !== void 0 && inputAny.proof.completeness < 1) {
            warnings.push(
              createValidationWarning(
                "proof",
                `Proof is ${(inputAny.proof.completeness * 100).toFixed(0)}% complete`,
                "Add missing proof steps to complete the derivation"
              )
            );
          }
          if (inputAny.proof.valid === false) {
            warnings.push(
              createValidationWarning(
                "proof",
                "Proof is marked as invalid",
                "Review the logical steps for errors"
              )
            );
          }
        }
        return validationSuccess(warnings);
      }
      /**
       * Get mode-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["deductive" /* DEDUCTIVE */, "mathematics" /* MATHEMATICS */, "firstprinciples" /* FIRSTPRINCIPLES */],
          metrics: {},
          guidingQuestions: [],
          mentalModels: [
            "Propositional Logic",
            "Predicate Logic",
            "Natural Deduction",
            "Truth Tables",
            "Proof by Contradiction",
            "Logical Equivalences"
          ]
        };
        const propositions = thought.propositions || [];
        const inferences = thought.logicalInferences || [];
        const proof = thought.proof;
        enhancements.metrics = {
          propositionCount: propositions.length,
          inferenceCount: inferences.length,
          validInferences: inferences.filter((i) => i.valid).length,
          proofStepCount: proof?.steps?.length || 0,
          proofCompleteness: proof?.completeness || 0
        };
        if (propositions.length === 0) {
          enhancements.suggestions.push("Start by defining atomic propositions");
        } else if (inferences.length === 0 && !proof) {
          enhancements.suggestions.push("Apply inference rules to derive new conclusions");
        } else if (proof && proof.completeness < 1) {
          enhancements.suggestions.push("Continue building the proof with additional steps");
        }
        enhancements.guidingQuestions = [
          "Are all propositions clearly stated?",
          "Which inference rule justifies each step?",
          "Can the argument be formalized in symbolic logic?",
          "Is the proof complete and valid?",
          "What are the truth conditions for the conclusion?"
        ];
        enhancements.suggestions.push(
          "Available inference rules: modus_ponens, modus_tollens, hypothetical_syllogism, disjunctive_syllogism, conjunction, simplification, addition, resolution"
        );
        return enhancements;
      }
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Resolve thought type to valid FormalLogicThoughtType
       */
      resolveThoughtType(inputType) {
        if (inputType && this.supportedThoughtTypes.includes(inputType)) {
          return inputType;
        }
        return "proposition_definition";
      }
    };
  }
});
var SynthesisHandler;
var init_SynthesisHandler = __esm({
  "src/modes/handlers/SynthesisHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    SynthesisHandler = class {
      mode = "synthesis" /* SYNTHESIS */;
      modeName = "Literature Synthesis";
      description = "Multi-source synthesis with theme extraction, contradiction detection, and gap analysis";
      /**
       * Supported thought types for synthesis mode
       */
      supportedThoughtTypes = [
        "source_identification",
        "source_evaluation",
        "theme_extraction",
        "pattern_integration",
        "gap_identification",
        "synthesis_construction",
        "framework_development"
      ];
      /**
       * Create a synthesis thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const thoughtType = this.resolveThoughtType(inputAny.thoughtType);
        let contradictions = inputAny.contradictions || [];
        if (contradictions.length === 0 && inputAny.sources && inputAny.sources.length > 1) {
          contradictions = this.detectPotentialContradictions(inputAny.sources, inputAny.themes);
        }
        const sourceCoverage = this.calculateSourceCoverage(
          inputAny.sources || [],
          inputAny.themes || []
        );
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          isRevision: input.isRevision,
          revisesThought: input.revisesThought,
          mode: "synthesis" /* SYNTHESIS */,
          thoughtType,
          sources: inputAny.sources || [],
          reviewMetadata: inputAny.reviewMetadata,
          concepts: inputAny.concepts || [],
          themes: inputAny.themes || [],
          findings: inputAny.findings || [],
          patterns: inputAny.patterns || [],
          relations: inputAny.relations || [],
          gaps: inputAny.gaps || [],
          contradictions,
          framework: inputAny.framework,
          conclusions: inputAny.conclusions || [],
          dependencies: inputAny.dependencies || [],
          assumptions: inputAny.assumptions || [],
          uncertainty: inputAny.uncertainty ?? 0.5,
          keyInsight: inputAny.keyInsight,
          // Store calculated metrics in a way accessible to enhancements
          _sourceCoverage: sourceCoverage
        };
      }
      /**
       * Validate synthesis-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        if (inputAny.sources && Array.isArray(inputAny.sources)) {
          const sourceIds = /* @__PURE__ */ new Set();
          for (let i = 0; i < inputAny.sources.length; i++) {
            const source = inputAny.sources[i];
            const sourceValidation = this.validateSource(source, i, sourceIds);
            errors.push(...sourceValidation.errors);
            warnings.push(...sourceValidation.warnings);
            if (source.id) sourceIds.add(source.id);
          }
          if (sourceIds.size !== inputAny.sources.filter((s) => s.id).length) {
            errors.push(
              createValidationError(
                "sources",
                "Duplicate source IDs detected",
                "DUPLICATE_SOURCE_IDS"
              )
            );
          }
          if (inputAny.themes && Array.isArray(inputAny.themes)) {
            for (let i = 0; i < inputAny.themes.length; i++) {
              const theme = inputAny.themes[i];
              const themeValidation = this.validateTheme(theme, i, sourceIds);
              errors.push(...themeValidation.errors);
              warnings.push(...themeValidation.warnings);
            }
          }
          if (inputAny.contradictions && Array.isArray(inputAny.contradictions)) {
            for (let i = 0; i < inputAny.contradictions.length; i++) {
              const contradiction = inputAny.contradictions[i];
              const contValidation = this.validateContradiction(contradiction, i, sourceIds);
              errors.push(...contValidation.errors);
              warnings.push(...contValidation.warnings);
            }
          }
          if (inputAny.sources.length === 1) {
            warnings.push(
              createValidationWarning(
                "sources",
                "Only one source provided",
                "Synthesis typically requires multiple sources for meaningful integration"
              )
            );
          }
        }
        if (inputAny.gaps && Array.isArray(inputAny.gaps) && inputAny.themes) {
          const themeIds = new Set(inputAny.themes.map((t) => t.id).filter(Boolean));
          for (let i = 0; i < inputAny.gaps.length; i++) {
            const gap = inputAny.gaps[i];
            if (gap.relatedThemes) {
              for (const themeId of gap.relatedThemes) {
                if (!themeIds.has(themeId)) {
                  warnings.push(
                    createValidationWarning(
                      `gaps[${i}].relatedThemes`,
                      `Gap references non-existent theme: ${themeId}`,
                      "Ensure all gap theme references exist in themes array"
                    )
                  );
                }
              }
            }
          }
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get synthesis-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["critique" /* CRITIQUE */, "argumentation" /* ARGUMENTATION */, "analysis" /* ANALYSIS */],
          guidingQuestions: [],
          warnings: [],
          mentalModels: [
            "Thematic Analysis",
            "Systematic Review",
            "Conceptual Framework",
            "Evidence Synthesis"
          ]
        };
        const sourceCount = thought.sources?.length || 0;
        const themeCount = thought.themes?.length || 0;
        const contradictionCount = thought.contradictions?.length || 0;
        const gapCount = thought.gaps?.length || 0;
        const coverage = this.calculateSourceCoverage(
          thought.sources || [],
          thought.themes || []
        );
        enhancements.metrics = {
          sourceCount,
          themeCount,
          contradictionCount,
          gapCount,
          sourceCoverage: coverage.coverageRatio,
          uncoveredSources: coverage.uncoveredSources.length
        };
        if (sourceCount === 0) {
          enhancements.suggestions.push(
            "Add sources to synthesize. Include bibliographic details and quality assessments."
          );
        } else if (sourceCount < 5) {
          enhancements.suggestions.push(
            "Consider adding more sources for comprehensive synthesis (typically 10+ for reviews)"
          );
        }
        if (sourceCount >= 2 && themeCount === 0) {
          enhancements.suggestions.push(
            "Extract common themes across your sources to begin synthesis"
          );
        }
        if (coverage.uncoveredSources.length > 0) {
          enhancements.warnings.push(
            `${coverage.uncoveredSources.length} source(s) not referenced in any theme: consider their contribution`
          );
        }
        if (sourceCount >= 3 && contradictionCount === 0) {
          enhancements.guidingQuestions.push(
            "Are there any disagreements or contradictions between sources?"
          );
        }
        if (themeCount >= 2 && gapCount === 0) {
          enhancements.guidingQuestions.push(
            "What gaps exist in the current literature? What questions remain unanswered?"
          );
        }
        const weakConsensus = (thought.themes || []).filter(
          (t) => t.consensus === "weak" || t.consensus === "contested"
        );
        if (weakConsensus.length > 0) {
          enhancements.warnings.push(
            `${weakConsensus.length} theme(s) have weak/contested consensus. Consider exploring why.`
          );
        }
        if (themeCount >= 3 && !thought.framework) {
          enhancements.suggestions.push(
            "Consider developing a conceptual framework to organize themes and relationships"
          );
        }
        if (themeCount >= 2 && (!thought.conclusions || thought.conclusions.length === 0)) {
          enhancements.guidingQuestions.push(
            "What synthesized conclusions can you draw from the themes identified?"
          );
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Resolve thought type to valid SynthesisThoughtType
       */
      resolveThoughtType(inputType) {
        if (inputType && this.supportedThoughtTypes.includes(inputType)) {
          return inputType;
        }
        return "source_identification";
      }
      /**
       * Validate a source
       */
      validateSource(source, index, existingIds) {
        const errors = [];
        const warnings = [];
        if (!source.id || source.id.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              `sources[${index}].id`,
              "Source has no ID",
              "Add an ID to reference this source in themes and contradictions"
            )
          );
        } else if (existingIds.has(source.id)) {
          errors.push(
            createValidationError(
              `sources[${index}].id`,
              `Duplicate source ID: ${source.id}`,
              "DUPLICATE_SOURCE_ID"
            )
          );
        }
        if (!source.title || source.title.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              `sources[${index}].title`,
              "Source has no title",
              "Add a title to identify the source"
            )
          );
        }
        if (source.quality) {
          const qualityFields = [
            "methodologicalRigor",
            "relevance",
            "recency",
            "authorCredibility",
            "overallQuality"
          ];
          for (const field of qualityFields) {
            const value = source.quality[field];
            if (value !== void 0 && (value < 0 || value > 1)) {
              warnings.push(
                createValidationWarning(
                  `sources[${index}].quality.${field}`,
                  `Quality metric ${field} (${value}) is outside [0, 1] range`,
                  "Quality metrics should be normalized to [0, 1]"
                )
              );
            }
          }
        }
        return errors.length > 0 ? validationFailure(errors, warnings) : validationSuccess(warnings);
      }
      /**
       * Validate a theme
       */
      validateTheme(theme, index, sourceIds) {
        const warnings = [];
        if (!theme.id || theme.id.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              `themes[${index}].id`,
              "Theme has no ID",
              "Add an ID to track this theme"
            )
          );
        }
        if (!theme.name || theme.name.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              `themes[${index}].name`,
              "Theme has no name",
              "Add a descriptive name for the theme"
            )
          );
        }
        if (theme.sourceIds && theme.sourceIds.length > 0) {
          for (const sourceId of theme.sourceIds) {
            if (!sourceIds.has(sourceId)) {
              warnings.push(
                createValidationWarning(
                  `themes[${index}].sourceIds`,
                  `Theme references non-existent source: ${sourceId}`,
                  "Ensure all source references exist in sources array"
                )
              );
            }
          }
        } else {
          warnings.push(
            createValidationWarning(
              `themes[${index}].sourceIds`,
              "Theme has no source references",
              "Link the theme to supporting sources"
            )
          );
        }
        if (theme.strength !== void 0 && (theme.strength < 0 || theme.strength > 1)) {
          warnings.push(
            createValidationWarning(
              `themes[${index}].strength`,
              `Theme strength (${theme.strength}) is outside [0, 1] range`,
              "Strength should be normalized to [0, 1]"
            )
          );
        }
        return validationSuccess(warnings);
      }
      /**
       * Validate a contradiction
       */
      validateContradiction(contradiction, index, sourceIds) {
        const warnings = [];
        if (contradiction.position1?.sourceIds) {
          for (const sourceId of contradiction.position1.sourceIds) {
            if (!sourceIds.has(sourceId)) {
              warnings.push(
                createValidationWarning(
                  `contradictions[${index}].position1.sourceIds`,
                  `Position 1 references non-existent source: ${sourceId}`,
                  "Ensure source references exist"
                )
              );
            }
          }
        }
        if (contradiction.position2?.sourceIds) {
          for (const sourceId of contradiction.position2.sourceIds) {
            if (!sourceIds.has(sourceId)) {
              warnings.push(
                createValidationWarning(
                  `contradictions[${index}].position2.sourceIds`,
                  `Position 2 references non-existent source: ${sourceId}`,
                  "Ensure source references exist"
                )
              );
            }
          }
        }
        return validationSuccess(warnings);
      }
      /**
       * Calculate source coverage by themes
       */
      calculateSourceCoverage(sources, themes) {
        const sourceIds = new Set(sources.map((s) => s.id).filter(Boolean));
        const coveredSourceIds = /* @__PURE__ */ new Set();
        for (const theme of themes) {
          if (theme.sourceIds) {
            for (const sourceId of theme.sourceIds) {
              coveredSourceIds.add(sourceId);
            }
          }
        }
        const coveredSources = Array.from(coveredSourceIds).filter((id) => sourceIds.has(id));
        const uncoveredSources = Array.from(sourceIds).filter((id) => !coveredSourceIds.has(id));
        return {
          coverageRatio: sourceIds.size > 0 ? coveredSources.length / sourceIds.size : 0,
          uncoveredSources,
          coveredSources
        };
      }
      /**
       * Detect potential contradictions between sources based on themes
       *
       * Simple heuristic: sources in themes with 'contested' consensus might contradict
       */
      detectPotentialContradictions(_sources, themes) {
        const contradictions = [];
        if (!themes || themes.length === 0) return contradictions;
        const contestedThemes = themes.filter((t) => t.consensus === "contested");
        for (const theme of contestedThemes) {
          if (theme.sourceIds && theme.sourceIds.length >= 2) {
            const sourceA = theme.sourceIds[0];
            const sourceB = theme.sourceIds[1];
            contradictions.push({
              id: `auto-${randomUUID().slice(0, 8)}`,
              description: `Potential contradiction in contested theme: ${theme.name}`,
              position1: {
                statement: `View from source ${sourceA}`,
                sourceIds: [sourceA],
                reasoning: "Auto-detected from contested theme consensus"
              },
              position2: {
                statement: `View from source ${sourceB}`,
                sourceIds: [sourceB],
                reasoning: "Auto-detected from contested theme consensus"
              },
              possibleResolution: "Requires further investigation"
            });
          }
        }
        return contradictions;
      }
    };
  }
});
var COMMON_FALLACIES, ArgumentationHandler;
var init_ArgumentationHandler = __esm({
  "src/modes/handlers/ArgumentationHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    COMMON_FALLACIES = [
      { name: "Ad Hominem", category: "informal", patterns: ["attacks the person", "character of"] },
      { name: "Straw Man", category: "informal", patterns: ["misrepresents", "exaggerated version"] },
      { name: "False Dilemma", category: "informal", patterns: ["either/or", "only two options"] },
      { name: "Circular Reasoning", category: "formal", patterns: ["because it is", "self-evident"] },
      { name: "Appeal to Authority", category: "informal", patterns: ["expert says", "authority claims"] },
      { name: "Hasty Generalization", category: "informal", patterns: ["always", "never", "all", "none"] },
      { name: "Red Herring", category: "informal", patterns: ["but what about", "changing subject"] },
      { name: "Slippery Slope", category: "informal", patterns: ["will lead to", "eventually"] },
      { name: "Appeal to Emotion", category: "informal", patterns: ["feel", "fear", "outrage"] },
      { name: "False Cause", category: "formal", patterns: ["caused by", "therefore"] }
    ];
    ArgumentationHandler = class {
      mode = "argumentation" /* ARGUMENTATION */;
      modeName = "Academic Argumentation";
      description = "Toulmin model argumentation with dialectic analysis and fallacy detection";
      supportedThoughtTypes = [
        "claim_formulation",
        "grounds_identification",
        "warrant_construction",
        "backing_provision",
        "rebuttal_anticipation",
        "qualifier_specification",
        "argument_assembly",
        "dialectic_analysis"
      ];
      /**
       * Create an argumentation thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const thoughtType = this.resolveThoughtType(inputAny.thoughtType);
        const arguments_ = this.processArguments(inputAny.arguments || []);
        const argumentStrength = this.calculateOverallStrength(arguments_, inputAny);
        const detectedFallacies = inputAny.fallacies || this.detectFallacies(inputAny);
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          isRevision: input.isRevision,
          revisesThought: input.revisesThought,
          mode: "argumentation" /* ARGUMENTATION */,
          thoughtType,
          claims: inputAny.claims || [],
          currentClaim: inputAny.currentClaim,
          grounds: inputAny.grounds || [],
          warrants: inputAny.warrants || [],
          backings: inputAny.backings || [],
          qualifiers: inputAny.qualifiers || [],
          rebuttals: inputAny.rebuttals || [],
          arguments: arguments_,
          currentArgument: inputAny.currentArgument,
          argumentChain: inputAny.argumentChain,
          dialectic: inputAny.dialectic,
          rhetoricalStrategies: inputAny.rhetoricalStrategies || [],
          audienceConsideration: inputAny.audienceConsideration,
          fallacies: detectedFallacies,
          argumentStrength,
          dependencies: inputAny.dependencies || [],
          assumptions: input.assumptions || [],
          uncertainty: inputAny.uncertainty ?? 0.5,
          keyInsight: inputAny.keyInsight
        };
      }
      /**
       * Validate argumentation-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if ((!inputAny.claims || inputAny.claims.length === 0) && !inputAny.currentClaim) {
          warnings.push(
            createValidationWarning(
              "claims",
              "No claims specified",
              "Formulate a clear claim or thesis for your argument"
            )
          );
        }
        if (inputAny.currentArgument || inputAny.arguments && inputAny.arguments.length > 0) {
          const args = inputAny.arguments || [inputAny.currentArgument];
          for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            const argValidation = this.validateToulminArgument(arg, i);
            warnings.push(...argValidation.warnings);
            errors.push(...argValidation.errors);
          }
        }
        const groundsCount = inputAny.grounds?.length || 0;
        const claimsCount = inputAny.claims?.length || (inputAny.currentClaim ? 1 : 0);
        if (claimsCount > 0 && groundsCount === 0) {
          warnings.push(
            createValidationWarning(
              "grounds",
              "Claims lack supporting grounds/evidence",
              "Provide evidence or data to support your claims"
            )
          );
        }
        if (groundsCount > 0 && (!inputAny.warrants || inputAny.warrants.length === 0)) {
          warnings.push(
            createValidationWarning(
              "warrants",
              "No warrants connecting grounds to claims",
              "Explain how your evidence supports your claim"
            )
          );
        }
        if (inputAny.warrants) {
          const weakWarrants = inputAny.warrants.filter((w) => w.strength < 0.5);
          if (weakWarrants.length > inputAny.warrants.length / 2) {
            warnings.push(
              createValidationWarning(
                "warrants",
                "Many warrants have low strength",
                "Consider strengthening warrants with additional backing"
              )
            );
          }
        }
        if (inputAny.arguments?.length > 0 && (!inputAny.rebuttals || inputAny.rebuttals.length === 0)) {
          warnings.push(
            createValidationWarning(
              "rebuttals",
              "No counter-arguments addressed",
              "Anticipate and address potential rebuttals for stronger argumentation"
            )
          );
        }
        if (inputAny.dialectic) {
          const dialecticValidation = this.validateDialectic(inputAny.dialectic);
          warnings.push(...dialecticValidation.warnings);
        }
        if (inputAny.fallacies && inputAny.fallacies.length > 0) {
          const criticalFallacies = inputAny.fallacies.filter((f) => f.severity === "critical");
          if (criticalFallacies.length > 0) {
            warnings.push(
              createValidationWarning(
                "fallacies",
                `${criticalFallacies.length} critical fallacies detected`,
                "Address critical logical fallacies before finalizing argument"
              )
            );
          }
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get mode-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["formallogic" /* FORMALLOGIC */, "deductive" /* DEDUCTIVE */, "critique" /* CRITIQUE */],
          metrics: {},
          guidingQuestions: [],
          mentalModels: [
            "Toulmin Model",
            "Dialectic Method",
            "Rhetorical Triangle (Ethos, Pathos, Logos)",
            "Logical Validity",
            "Counter-argument Analysis"
          ]
        };
        const claims = thought.claims || [];
        const grounds = thought.grounds || [];
        const warrants = thought.warrants || [];
        const rebuttals = thought.rebuttals || [];
        const arguments_ = thought.arguments || [];
        const fallacies = thought.fallacies || [];
        const groundsToClaimRatio = claims.length > 0 ? grounds.length / claims.length : 0;
        const warrantsPerClaim = claims.length > 0 ? warrants.length / claims.length : 0;
        const rebuttalCoverage = arguments_.length > 0 ? rebuttals.length / arguments_.length : 0;
        const avgGroundsReliability = grounds.length > 0 ? grounds.reduce((sum, g) => sum + (g.reliability || 0), 0) / grounds.length : 0;
        enhancements.metrics = {
          claimCount: claims.length,
          groundsCount: grounds.length,
          warrantsCount: warrants.length,
          rebuttalCount: rebuttals.length,
          argumentCount: arguments_.length,
          fallacyCount: fallacies.length,
          argumentStrength: thought.argumentStrength,
          groundsToClaimRatio,
          warrantsPerClaim,
          rebuttalCoverage,
          avgGroundsReliability
        };
        const thoughtType = thought.thoughtType;
        if (thoughtType === "claim_formulation") {
          enhancements.suggestions.push("Ensure claim is specific, debatable, and significant");
          enhancements.guidingQuestions.push("Is this claim falsifiable and not self-evident?");
        }
        if (thoughtType === "grounds_identification") {
          enhancements.suggestions.push("Gather diverse types of evidence: empirical, statistical, testimonial");
          if (avgGroundsReliability < 0.6) {
            enhancements.suggestions.push("Consider strengthening evidence reliability");
          }
        }
        if (thoughtType === "warrant_construction") {
          const implicitWarrants = warrants.filter((w) => w.implicit);
          if (implicitWarrants.length > warrants.length * 0.5) {
            enhancements.suggestions.push("Many warrants are implicit - consider making them explicit");
          }
        }
        if (thoughtType === "rebuttal_anticipation") {
          enhancements.suggestions.push("Consider rebuttals targeting each Toulmin element");
          enhancements.guidingQuestions.push("What would a skeptic say about this argument?");
        }
        if (thoughtType === "dialectic_analysis" && thought.dialectic) {
          if (!thought.dialectic.synthesis) {
            enhancements.suggestions.push("Develop a synthesis that transcends thesis and antithesis");
          }
        }
        if (fallacies.length > 0) {
          enhancements.warnings = enhancements.warnings || [];
          for (const fallacy of fallacies) {
            enhancements.warnings.push(`${fallacy.severity} fallacy: ${fallacy.name} - ${fallacy.description}`);
          }
        }
        if (thought.argumentStrength < 0.5) {
          enhancements.suggestions.push("Argument strength is low - consider adding more grounds or strengthening warrants");
        } else if (thought.argumentStrength > 0.8) {
          enhancements.suggestions.push("Strong argument - consider addressing potential rebuttals");
        }
        enhancements.guidingQuestions.push(
          "Is the evidence sufficient and relevant to the claim?",
          "Are there unstated assumptions in the warrants?",
          "What are the strongest counter-arguments?",
          "Does the qualifier appropriately limit the claim's scope?"
        );
        return enhancements;
      }
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Resolve thought type to valid ArgumentationThoughtType
       */
      resolveThoughtType(inputType) {
        if (inputType && this.supportedThoughtTypes.includes(inputType)) {
          return inputType;
        }
        return "claim_formulation";
      }
      /**
       * Process arguments with defaults
       */
      processArguments(arguments_) {
        return arguments_.map((arg) => ({
          id: arg.id || randomUUID(),
          name: arg.name,
          claim: arg.claim,
          grounds: arg.grounds || [],
          warrants: arg.warrants || [],
          backings: arg.backings || [],
          qualifiers: arg.qualifiers || [],
          rebuttals: arg.rebuttals || [],
          overallStrength: arg.overallStrength ?? this.calculateArgumentStrength(arg),
          validity: arg.validity || "questionable",
          soundness: arg.soundness || "questionable"
        }));
      }
      /**
       * Calculate strength of a single Toulmin argument
       */
      calculateArgumentStrength(arg) {
        let strength = 0.5;
        if (arg.grounds && arg.grounds.length > 0) {
          const avgReliability = arg.grounds.reduce((sum, g) => sum + (g.reliability || 0.5), 0) / arg.grounds.length;
          const avgRelevance = arg.grounds.reduce((sum, g) => sum + (g.relevance || 0.5), 0) / arg.grounds.length;
          strength += (avgReliability + avgRelevance) * 0.15;
        }
        if (arg.warrants && arg.warrants.length > 0) {
          const avgWarrantStrength = arg.warrants.reduce((sum, w) => sum + (w.strength || 0.5), 0) / arg.warrants.length;
          strength += avgWarrantStrength * 0.15;
        }
        if (arg.backings && arg.backings.length > 0) {
          strength += 0.1;
        }
        if (arg.rebuttals && arg.rebuttals.length > 0) {
          const addressedRebuttals = arg.rebuttals.filter((r) => r.response).length;
          strength += addressedRebuttals / arg.rebuttals.length * 0.1;
        }
        return Math.min(Math.max(strength, 0), 1);
      }
      /**
       * Calculate overall argument strength for the thought
       */
      calculateOverallStrength(arguments_, input) {
        if (arguments_.length > 0) {
          return arguments_.reduce((sum, arg) => sum + arg.overallStrength, 0) / arguments_.length;
        }
        let strength = 0.3;
        if (input.grounds?.length > 0) strength += 0.15;
        if (input.warrants?.length > 0) strength += 0.15;
        if (input.backings?.length > 0) strength += 0.1;
        if (input.qualifiers?.length > 0) strength += 0.1;
        if (input.rebuttals?.length > 0) strength += 0.1;
        return Math.min(strength, 1);
      }
      /**
       * Detect potential logical fallacies
       */
      detectFallacies(input) {
        const fallacies = [];
        const content = input.thought?.toLowerCase() || "";
        for (const fallacy of COMMON_FALLACIES) {
          for (const pattern of fallacy.patterns) {
            if (content.includes(pattern.toLowerCase())) {
              fallacies.push({
                id: randomUUID(),
                name: fallacy.name,
                category: fallacy.category,
                description: `Potential ${fallacy.name} detected based on language patterns`,
                location: "thought content",
                severity: "minor"
              });
              break;
            }
          }
        }
        if (input.warrants && input.claims) {
          for (const warrant of input.warrants) {
            for (const claim of input.claims) {
              if (warrant.statement?.toLowerCase().includes(claim.statement?.toLowerCase().slice(0, 20))) {
                fallacies.push({
                  id: randomUUID(),
                  name: "Circular Reasoning",
                  category: "formal",
                  description: "Warrant appears to restate the claim",
                  location: `warrant ${warrant.id}`,
                  severity: "significant"
                });
              }
            }
          }
        }
        return fallacies;
      }
      /**
       * Validate Toulmin argument structure
       */
      validateToulminArgument(arg, index) {
        const errors = [];
        const warnings = [];
        if (!arg.claim) {
          errors.push(
            createValidationError(
              `arguments[${index}].claim`,
              "Argument has no claim",
              "MISSING_CLAIM"
            )
          );
        }
        if (!arg.grounds || arg.grounds.length === 0) {
          warnings.push(
            createValidationWarning(
              `arguments[${index}].grounds`,
              "Argument has no grounds/evidence",
              "Add supporting evidence for the claim"
            )
          );
        }
        if (!arg.warrants || arg.warrants.length === 0) {
          warnings.push(
            createValidationWarning(
              `arguments[${index}].warrants`,
              "Argument has no warrants",
              "Explain the reasoning connecting evidence to claim"
            )
          );
        }
        if (arg.warrants) {
          const weakWithoutBacking = arg.warrants.filter(
            (w) => w.strength < 0.6 && !arg.backings?.some((b) => b.warrantId === w.id)
          );
          if (weakWithoutBacking.length > 0) {
            warnings.push(
              createValidationWarning(
                `arguments[${index}].warrants`,
                "Some weak warrants lack backing",
                "Strengthen weak warrants with additional support"
              )
            );
          }
        }
        return errors.length > 0 ? validationFailure(errors, warnings) : validationSuccess(warnings);
      }
      /**
       * Validate dialectic analysis
       */
      validateDialectic(dialectic) {
        const warnings = [];
        if (!dialectic.thesis) {
          warnings.push(
            createValidationWarning(
              "dialectic.thesis",
              "No thesis position defined",
              "Define the initial thesis position"
            )
          );
        }
        if (!dialectic.antithesis) {
          warnings.push(
            createValidationWarning(
              "dialectic.antithesis",
              "No antithesis position defined",
              "Define the opposing antithesis position"
            )
          );
        }
        if (dialectic.resolution === "synthesis_achieved" && !dialectic.synthesis) {
          warnings.push(
            createValidationWarning(
              "dialectic.synthesis",
              "Resolution claims synthesis but no synthesis defined",
              "Provide the synthesis that transcends both positions"
            )
          );
        }
        return validationSuccess(warnings);
      }
    };
  }
});
var SOCRATIC_CATEGORIES, CritiqueHandler;
var init_CritiqueHandler = __esm({
  "src/modes/handlers/CritiqueHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    SOCRATIC_CATEGORIES = [
      {
        name: "Clarification",
        description: "Questions that probe for clarity and understanding",
        purpose: "Ensure clear understanding before critique",
        exampleQuestions: [
          "What do you mean by...?",
          "Could you put that another way?",
          "What is your main point?",
          "Could you give me an example?",
          "Can you explain that term?"
        ]
      },
      {
        name: "Assumptions",
        description: "Questions that probe underlying assumptions",
        purpose: "Uncover hidden assumptions that may be flawed",
        exampleQuestions: [
          "What are you assuming here?",
          "Is that always the case?",
          "Why would you assume that?",
          "What could we assume instead?",
          "What if the opposite were true?"
        ]
      },
      {
        name: "Evidence",
        description: "Questions that probe reasons and evidence",
        purpose: "Evaluate the quality and relevance of evidence",
        exampleQuestions: [
          "What evidence supports this?",
          "How do you know this is true?",
          "What would change your mind?",
          "Is there counter-evidence?",
          "How reliable is this source?"
        ]
      },
      {
        name: "Perspectives",
        description: "Questions that probe viewpoints and perspectives",
        purpose: "Consider alternative viewpoints",
        exampleQuestions: [
          "What would X say about this?",
          "How might others view this?",
          "What is an alternative interpretation?",
          "Who benefits from this view?",
          "What perspective is missing?"
        ]
      },
      {
        name: "Implications",
        description: "Questions that probe implications and consequences",
        purpose: "Explore logical consequences of claims",
        exampleQuestions: [
          "What follows from this?",
          "What are the consequences?",
          "How does this affect...?",
          "If this is true, what else must be true?",
          "What are the risks?"
        ]
      },
      {
        name: "Meta",
        description: "Questions about the question itself",
        purpose: "Examine the reasoning process",
        exampleQuestions: [
          "Why is this question important?",
          "What makes this hard to answer?",
          "What do we need to know to answer this?",
          "How can we find out?",
          "What assumptions underlie this question?"
        ]
      }
    ];
    CritiqueHandler = class {
      mode = "critique" /* CRITIQUE */;
      modeName = "Critical Analysis";
      description = "Scholarly critique with Socratic questioning, balanced evaluation, and methodology assessment";
      /**
       * Supported thought types for critique mode
       */
      supportedThoughtTypes = [
        "work_characterization",
        "methodology_evaluation",
        "argument_analysis",
        "evidence_assessment",
        "contribution_evaluation",
        "limitation_identification",
        "strength_recognition",
        "improvement_suggestion"
      ];
      /**
       * Create a critique thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const thoughtType = this.resolveThoughtType(inputAny.thoughtType);
        const work = inputAny.work || {
          id: randomUUID().slice(0, 8),
          title: "Untitled Work",
          authors: [],
          year: (/* @__PURE__ */ new Date()).getFullYear(),
          type: "empirical_study",
          field: "Unknown",
          claimedContribution: ""
        };
        const critiquePoints = inputAny.critiquePoints || [];
        const strengthsIdentified = critiquePoints.filter(
          (p) => p.type === "strength"
        ).length;
        const weaknessesIdentified = critiquePoints.filter(
          (p) => p.type === "weakness" || p.type === "concern"
        ).length;
        const balanceRatio = this.calculateBalanceRatio(strengthsIdentified, weaknessesIdentified);
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          isRevision: input.isRevision,
          revisesThought: input.revisesThought,
          mode: "critique" /* CRITIQUE */,
          thoughtType,
          work,
          methodologyEvaluation: inputAny.methodologyEvaluation,
          argumentCritique: inputAny.argumentCritique,
          evidenceCritique: inputAny.evidenceCritique,
          contributionEvaluation: inputAny.contributionEvaluation,
          critiquePoints,
          improvements: inputAny.improvements || [],
          verdict: inputAny.verdict,
          strengthsIdentified,
          weaknessesIdentified,
          balanceRatio,
          dependencies: inputAny.dependencies || [],
          assumptions: inputAny.assumptions || [],
          uncertainty: inputAny.uncertainty ?? 0.5,
          keyInsight: inputAny.keyInsight
        };
      }
      /**
       * Validate critique-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        if (inputAny.work) {
          const workValidation = this.validateWork(inputAny.work);
          warnings.push(...workValidation.warnings);
        }
        if (inputAny.methodologyEvaluation) {
          const methValidation = this.validateMethodologyEvaluation(inputAny.methodologyEvaluation);
          errors.push(...methValidation.errors);
          warnings.push(...methValidation.warnings);
        }
        if (inputAny.argumentCritique) {
          const argValidation = this.validateArgumentCritique(inputAny.argumentCritique);
          warnings.push(...argValidation.warnings);
        }
        if (inputAny.critiquePoints && Array.isArray(inputAny.critiquePoints)) {
          for (let i = 0; i < inputAny.critiquePoints.length; i++) {
            const point = inputAny.critiquePoints[i];
            const pointValidation = this.validateCritiquePoint(point, i);
            warnings.push(...pointValidation.warnings);
          }
          const strengths = inputAny.critiquePoints.filter(
            (p) => p.type === "strength"
          ).length;
          const weaknesses = inputAny.critiquePoints.filter(
            (p) => p.type === "weakness" || p.type === "concern"
          ).length;
          if (inputAny.critiquePoints.length >= 3) {
            if (strengths === 0) {
              warnings.push(
                createValidationWarning(
                  "critiquePoints",
                  "No strengths identified in critique",
                  "A balanced critique should acknowledge strengths as well as weaknesses"
                )
              );
            } else if (weaknesses === 0) {
              warnings.push(
                createValidationWarning(
                  "critiquePoints",
                  "No weaknesses or concerns identified",
                  "A thorough critique should identify areas for improvement"
                )
              );
            }
          }
        }
        if (inputAny.verdict) {
          const verdictValidation = this.validateVerdict(inputAny.verdict);
          warnings.push(...verdictValidation.warnings);
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get critique-specific enhancements with Socratic questions
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["argumentation" /* ARGUMENTATION */, "synthesis" /* SYNTHESIS */, "analysis" /* ANALYSIS */],
          guidingQuestions: [],
          warnings: [],
          mentalModels: [
            "Socratic Questioning",
            "Peer Review Framework",
            "Toulmin Model",
            "Critical Thinking"
          ]
        };
        const critiquePointCount = thought.critiquePoints?.length || 0;
        const improvementCount = thought.improvements?.length || 0;
        enhancements.metrics = {
          strengthsIdentified: thought.strengthsIdentified,
          weaknessesIdentified: thought.weaknessesIdentified,
          balanceRatio: thought.balanceRatio,
          critiquePointCount,
          improvementCount,
          hasVerdict: thought.verdict ? 1 : 0
        };
        const socraticCategories = this.getSocraticQuestions(thought.thoughtType);
        const socraticQuestionsRecord = {};
        for (const category of socraticCategories) {
          socraticQuestionsRecord[category.name] = category.exampleQuestions;
        }
        enhancements.socraticQuestions = socraticQuestionsRecord;
        for (const category of socraticCategories.slice(0, 2)) {
          enhancements.guidingQuestions.push(category.exampleQuestions[0]);
        }
        if (thought.balanceRatio < 0.2) {
          enhancements.warnings.push(
            "Critique appears heavily weighted toward weaknesses. Consider identifying strengths."
          );
        } else if (thought.balanceRatio > 0.8) {
          enhancements.warnings.push(
            "Critique appears heavily weighted toward strengths. Consider identifying limitations."
          );
        }
        if (!thought.methodologyEvaluation && thought.work?.type === "empirical_study") {
          enhancements.suggestions.push(
            "Consider adding methodology evaluation for empirical work"
          );
        }
        if (!thought.argumentCritique && thought.work?.type === "theoretical_paper") {
          enhancements.suggestions.push(
            "Consider adding argument structure analysis for theoretical work"
          );
        }
        if (critiquePointCount >= 5 && !thought.verdict) {
          enhancements.suggestions.push(
            "Consider providing an overall verdict summarizing the critique"
          );
        }
        if (thought.weaknessesIdentified > 0 && improvementCount === 0) {
          enhancements.suggestions.push(
            "Consider adding constructive improvement suggestions for identified weaknesses"
          );
        }
        if (thought.work) {
          if (!thought.work.researchQuestion && thought.work.type === "empirical_study") {
            enhancements.guidingQuestions.push(
              "What is the research question being addressed?"
            );
          }
        }
        if (thought.critiquePoints && thought.critiquePoints.length > 0) {
          const criticalCount = thought.critiquePoints.filter(
            (p) => p.severity === "critical"
          ).length;
          const majorCount = thought.critiquePoints.filter(
            (p) => p.severity === "major"
          ).length;
          if (criticalCount > 0 && thought.verdict?.recommendation === "accept") {
            enhancements.warnings.push(
              "Accept recommendation despite critical issues. Verify this is intentional."
            );
          }
          if (criticalCount === 0 && majorCount === 0 && thought.verdict?.recommendation === "reject") {
            enhancements.warnings.push(
              "Reject recommendation with no critical/major issues. Consider revising verdict."
            );
          }
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Resolve thought type to valid CritiqueThoughtType
       */
      resolveThoughtType(inputType) {
        if (inputType && this.supportedThoughtTypes.includes(inputType)) {
          return inputType;
        }
        return "work_characterization";
      }
      /**
       * Calculate balance ratio (0 = all weaknesses, 1 = all strengths, 0.5 = balanced)
       */
      calculateBalanceRatio(strengths, weaknesses) {
        const total = strengths + weaknesses;
        if (total === 0) return 0.5;
        return strengths / total;
      }
      /**
       * Validate work being critiqued
       */
      validateWork(work) {
        const warnings = [];
        if (!work.title || work.title.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              "work.title",
              "Work has no title",
              "Add a title to identify the work being critiqued"
            )
          );
        }
        if (!work.authors || work.authors.length === 0) {
          warnings.push(
            createValidationWarning(
              "work.authors",
              "No authors specified",
              "Add author information for proper attribution"
            )
          );
        }
        if (!work.claimedContribution || work.claimedContribution.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              "work.claimedContribution",
              "No claimed contribution specified",
              "Identify what contribution the work claims to make"
            )
          );
        }
        return validationSuccess(warnings);
      }
      /**
       * Validate methodology evaluation
       */
      validateMethodologyEvaluation(meth) {
        const errors = [];
        const warnings = [];
        if (meth.overallRating !== void 0 && (meth.overallRating < 0 || meth.overallRating > 1)) {
          warnings.push(
            createValidationWarning(
              "methodologyEvaluation.overallRating",
              `overallRating (${meth.overallRating}) is outside [0, 1] range`,
              "Ratings should be normalized to [0, 1]"
            )
          );
        }
        const subRatings = ["design.rating", "sample.rating", "analysis.rating"];
        for (const path4 of subRatings) {
          const [parent, child] = path4.split(".");
          const parentObj = meth[parent];
          if (parentObj && parentObj[child] !== void 0) {
            const value = parentObj[child];
            if (value < 0 || value > 1) {
              warnings.push(
                createValidationWarning(
                  `methodologyEvaluation.${path4}`,
                  `${path4} (${value}) is outside [0, 1] range`,
                  "Ratings should be normalized to [0, 1]"
                )
              );
            }
          }
        }
        return errors.length > 0 ? validationFailure(errors, warnings) : validationSuccess(warnings);
      }
      /**
       * Validate argument critique
       */
      validateArgumentCritique(arg) {
        const warnings = [];
        if (arg.rating !== void 0 && (arg.rating < 0 || arg.rating > 1)) {
          warnings.push(
            createValidationWarning(
              "argumentCritique.rating",
              `Argument rating (${arg.rating}) is outside [0, 1] range`,
              "Rating should be normalized to [0, 1]"
            )
          );
        }
        if (arg.logicalStructure) {
          if (arg.logicalStructure.overallCoherence !== void 0) {
            if (arg.logicalStructure.overallCoherence < 0 || arg.logicalStructure.overallCoherence > 1) {
              warnings.push(
                createValidationWarning(
                  "argumentCritique.logicalStructure.overallCoherence",
                  `Coherence (${arg.logicalStructure.overallCoherence}) is outside [0, 1] range`,
                  "Coherence should be normalized to [0, 1]"
                )
              );
            }
          }
          if (arg.logicalStructure.circularReasoning) {
            warnings.push(
              createValidationWarning(
                "argumentCritique.logicalStructure",
                "Circular reasoning detected in the argument",
                "This is a significant logical flaw that should be addressed"
              )
            );
          }
        }
        return validationSuccess(warnings);
      }
      /**
       * Validate a critique point
       */
      validateCritiquePoint(point, index) {
        const warnings = [];
        if (!point.description || point.description.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              `critiquePoints[${index}].description`,
              "Critique point has no description",
              "Add a detailed description of the critique"
            )
          );
        }
        if (point.type === "weakness" || point.type === "concern") {
          if (!point.recommendation) {
            warnings.push(
              createValidationWarning(
                `critiquePoints[${index}].recommendation`,
                "Weakness has no recommendation for improvement",
                "Consider adding a constructive suggestion"
              )
            );
          }
        }
        return validationSuccess(warnings);
      }
      /**
       * Validate verdict
       */
      validateVerdict(verdict) {
        const warnings = [];
        if (verdict.confidence !== void 0 && (verdict.confidence < 0 || verdict.confidence > 1)) {
          warnings.push(
            createValidationWarning(
              "verdict.confidence",
              `Verdict confidence (${verdict.confidence}) is outside [0, 1] range`,
              "Confidence should be between 0 and 1"
            )
          );
        }
        if (!verdict.summary || verdict.summary.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              "verdict.summary",
              "Verdict has no summary",
              "Add a summary explaining the recommendation"
            )
          );
        }
        return validationSuccess(warnings);
      }
      /**
       * Get Socratic questions based on thought type
       */
      getSocraticQuestions(thoughtType) {
        const typeToCategories = {
          work_characterization: ["Clarification", "Meta"],
          methodology_evaluation: ["Evidence", "Assumptions"],
          argument_analysis: ["Assumptions", "Implications"],
          evidence_assessment: ["Evidence", "Perspectives"],
          contribution_evaluation: ["Implications", "Perspectives"],
          limitation_identification: ["Assumptions", "Evidence"],
          strength_recognition: ["Clarification", "Implications"],
          improvement_suggestion: ["Perspectives", "Meta"]
        };
        const categoryNames = typeToCategories[thoughtType] || ["Clarification", "Evidence"];
        return SOCRATIC_CATEGORIES.filter((c) => categoryNames.includes(c.name));
      }
    };
  }
});
var METHODOLOGY_GUIDANCE, AnalysisHandler;
var init_AnalysisHandler = __esm({
  "src/modes/handlers/AnalysisHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    METHODOLOGY_GUIDANCE = {
      thematic_analysis: {
        description: "Braun & Clarke's reflexive thematic analysis",
        keySteps: ["Data familiarization", "Initial coding", "Theme development", "Theme refinement", "Final analysis"]
      },
      grounded_theory: {
        description: "Glaser & Strauss, Charmaz grounded theory approach",
        keySteps: ["Open coding", "Axial coding", "Selective coding", "Theoretical sampling", "Saturation"]
      },
      discourse_analysis: {
        description: "Foucauldian or Critical discourse analysis",
        keySteps: ["Text selection", "Identify patterns", "Analyze power relations", "Interpret social functions"]
      },
      content_analysis: {
        description: "Qualitative content analysis",
        keySteps: ["Define categories", "Create coding scheme", "Code systematically", "Analyze patterns"]
      },
      phenomenological: {
        description: "IPA or Descriptive phenomenological analysis",
        keySteps: ["Bracket assumptions", "Describe experience", "Identify essences", "Synthesize meanings"]
      },
      narrative_analysis: {
        description: "Narrative inquiry approach",
        keySteps: ["Collect stories", "Analyze structure", "Identify themes", "Interpret meanings"]
      },
      framework_analysis: {
        description: "Ritchie & Spencer framework analysis",
        keySteps: ["Familiarization", "Framework identification", "Indexing", "Charting", "Interpretation"]
      },
      template_analysis: {
        description: "King's template analysis",
        keySteps: ["Initial template", "Apply to data", "Modify template", "Final template"]
      },
      mixed_qualitative: {
        description: "Combined qualitative approaches",
        keySteps: ["Justify combination", "Apply methods", "Integrate findings", "Ensure coherence"]
      }
    };
    AnalysisHandler = class {
      mode = "analysis" /* ANALYSIS */;
      modeName = "Qualitative Analysis";
      description = "Rigorous qualitative analysis with codebook validation and saturation assessment";
      supportedThoughtTypes = [
        "data_familiarization",
        "initial_coding",
        "focused_coding",
        "theme_development",
        "theme_refinement",
        "theoretical_integration",
        "memo_writing",
        "saturation_assessment"
      ];
      /**
       * Create an analysis thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const thoughtType = this.resolveThoughtType(inputAny.thoughtType);
        const codebook = this.processCodebook(inputAny.codebook);
        const codingProgress = this.calculateCodingProgress(inputAny.dataSegments, codebook);
        const rigorAssessment = inputAny.rigorAssessment || this.assessRigor(inputAny);
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          isRevision: input.isRevision,
          revisesThought: input.revisesThought,
          mode: "analysis" /* ANALYSIS */,
          thoughtType,
          methodology: inputAny.methodology || "thematic_analysis",
          dataSources: inputAny.dataSources || [],
          dataSegments: inputAny.dataSegments,
          totalSegments: inputAny.dataSegments?.length || inputAny.totalSegments || 0,
          codebook,
          currentCodes: inputAny.currentCodes || codebook?.codes,
          codingProgress,
          themes: inputAny.themes,
          thematicMap: inputAny.thematicMap,
          memos: inputAny.memos || [],
          gtCategories: inputAny.gtCategories,
          theoreticalSampling: inputAny.theoreticalSampling,
          discoursePatterns: inputAny.discoursePatterns,
          rigorAssessment,
          dependencies: inputAny.dependencies || [],
          assumptions: input.assumptions || [],
          uncertainty: inputAny.uncertainty ?? 0.5,
          keyInsight: inputAny.keyInsight
        };
      }
      /**
       * Validate analysis-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!inputAny.dataSources || inputAny.dataSources.length === 0) {
          warnings.push(
            createValidationWarning(
              "dataSources",
              "No data sources specified",
              "Define the data sources for your qualitative analysis"
            )
          );
        }
        if (inputAny.methodology && !Object.keys(METHODOLOGY_GUIDANCE).includes(inputAny.methodology)) {
          warnings.push(
            createValidationWarning(
              "methodology",
              `Unknown methodology: ${inputAny.methodology}`,
              "Use a recognized qualitative methodology"
            )
          );
        }
        if (inputAny.codebook) {
          const codebookValidation = this.validateCodebook(inputAny.codebook);
          errors.push(...codebookValidation.errors);
          warnings.push(...codebookValidation.warnings);
        }
        if (inputAny.codebook && inputAny.codebook.codes?.length > 5) {
          if (inputAny.codebook.intercoderReliability === void 0) {
            warnings.push(
              createValidationWarning(
                "codebook.intercoderReliability",
                "No inter-coder reliability reported",
                "For rigor, consider having multiple coders and reporting agreement"
              )
            );
          } else if (inputAny.codebook.intercoderReliability < 0.7) {
            warnings.push(
              createValidationWarning(
                "codebook.intercoderReliability",
                `Inter-coder reliability is low (${(inputAny.codebook.intercoderReliability * 100).toFixed(1)}%)`,
                "Consider reconciling coding differences or refining code definitions"
              )
            );
          }
        }
        if (inputAny.themes && inputAny.themes.length > 0) {
          const saturatedThemes = inputAny.themes.filter((t) => t.prevalence > 0.7);
          const sparseThemes = inputAny.themes.filter((t) => t.prevalence < 0.2);
          if (sparseThemes.length > saturatedThemes.length) {
            warnings.push(
              createValidationWarning(
                "themes",
                "Many themes have low prevalence",
                "Consider whether sparse themes represent meaningful patterns or should be merged"
              )
            );
          }
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get mode-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["synthesis" /* SYNTHESIS */, "critique" /* CRITIQUE */, "inductive" /* INDUCTIVE */],
          metrics: {},
          guidingQuestions: [],
          mentalModels: [
            "Qualitative Rigor (Guba & Lincoln)",
            "Theoretical Saturation",
            "Constant Comparative Method",
            "Thick Description",
            "Reflexivity"
          ]
        };
        const codebook = thought.codebook;
        const themes = thought.themes || [];
        const methodology = thought.methodology;
        const codeCount = codebook?.codes?.length || 0;
        const themeCount = themes.length;
        const dataSourceCount = thought.dataSources?.length || 0;
        const segmentsCoded = thought.codingProgress?.segmentsCoded || 0;
        const totalSegments = thought.codingProgress?.totalSegments || 0;
        enhancements.metrics = {
          codeCount,
          themeCount,
          dataSourceCount,
          segmentsCoded,
          codingProgress: totalSegments > 0 ? segmentsCoded / totalSegments : 0,
          intercoderReliability: codebook?.intercoderReliability || 0,
          avgThemePrevalence: themes.length > 0 ? themes.reduce((sum, t) => sum + t.prevalence, 0) / themes.length : 0
        };
        if (methodology && METHODOLOGY_GUIDANCE[methodology]) {
          const guide = METHODOLOGY_GUIDANCE[methodology];
          enhancements.suggestions.push(`Using ${guide.description}`);
          enhancements.guidingQuestions.push(`Have you completed: ${guide.keySteps.join(" \u2192 ")}?`);
        }
        const thoughtType = thought.thoughtType;
        if (thoughtType === "initial_coding" && codeCount < 10) {
          enhancements.suggestions.push("Continue generating initial codes - aim for breadth");
        }
        if (thoughtType === "focused_coding" && codeCount > 50) {
          enhancements.suggestions.push("Consider consolidating codes into higher-level categories");
        }
        if (thoughtType === "theme_development" && themeCount === 0) {
          enhancements.suggestions.push("Group related codes into candidate themes");
        }
        if (thoughtType === "saturation_assessment") {
          const rigor = thought.rigorAssessment;
          if (rigor?.saturation?.newCodesLastN !== void 0 && rigor.saturation.newCodesLastN > 3) {
            enhancements.suggestions.push("New codes still emerging - saturation not yet achieved");
          } else if (rigor?.saturation?.achieved) {
            enhancements.suggestions.push("Theoretical saturation achieved - ready for final analysis");
          }
        }
        if (thought.rigorAssessment) {
          const rigor = thought.rigorAssessment;
          if (rigor.credibility.rating < 0.5) {
            enhancements.warnings = enhancements.warnings || [];
            enhancements.warnings.push("Low credibility rating - consider member checking or triangulation");
          }
          if (!rigor.confirmability.reflexivity) {
            enhancements.suggestions.push("Document researcher reflexivity for confirmability");
          }
        }
        enhancements.guidingQuestions.push(
          "Are the codes consistently applied across all data?",
          "Do the themes capture the full meaning of the data?",
          "What alternative interpretations have been considered?",
          "How does researcher positionality affect the analysis?"
        );
        return enhancements;
      }
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Resolve thought type to valid AnalysisThoughtType
       */
      resolveThoughtType(inputType) {
        if (inputType && this.supportedThoughtTypes.includes(inputType)) {
          return inputType;
        }
        return "initial_coding";
      }
      /**
       * Process and validate codebook
       */
      processCodebook(codebook) {
        if (!codebook) return void 0;
        return {
          id: codebook.id || randomUUID(),
          name: codebook.name || "Analysis Codebook",
          version: codebook.version || 1,
          codes: (codebook.codes || []).map((code) => ({
            id: code.id || randomUUID(),
            label: code.label || "",
            definition: code.definition || "",
            type: code.type || "descriptive",
            examples: code.examples || [],
            dataSegmentIds: code.dataSegmentIds || [],
            frequency: code.frequency || 0,
            parentCodeId: code.parentCodeId,
            childCodeIds: code.childCodeIds || [],
            relatedCodeIds: code.relatedCodeIds || [],
            createdAt: code.createdAt || /* @__PURE__ */ new Date(),
            modifiedAt: code.modifiedAt,
            memoIds: code.memoIds || []
          })),
          codeHierarchy: codebook.codeHierarchy || {
            rootCodeIds: [],
            parentChildMap: {}
          },
          cooccurrences: codebook.cooccurrences || [],
          intercoderReliability: codebook.intercoderReliability,
          lastUpdated: codebook.lastUpdated || /* @__PURE__ */ new Date()
        };
      }
      /**
       * Calculate coding progress
       */
      calculateCodingProgress(dataSegments, _codebook) {
        if (!dataSegments) return { segmentsCoded: 0, totalSegments: 0, percentComplete: 0 };
        const totalSegments = dataSegments.length;
        const segmentsCoded = dataSegments.filter((seg) => seg.codes && seg.codes.length > 0).length;
        const percentComplete = totalSegments > 0 ? segmentsCoded / totalSegments * 100 : 0;
        return { segmentsCoded, totalSegments, percentComplete };
      }
      /**
       * Assess qualitative rigor
       */
      assessRigor(input) {
        const hasMultipleCoders = input.codebook?.intercoderReliability !== void 0;
        const hasThickDescription = input.themes?.some((t) => t.keyQuotes?.length > 2);
        const hasMemos = input.memos && input.memos.length > 0;
        const hasReflexiveMemos = input.memos?.some((m) => m.type === "reflective_memo");
        return {
          credibility: {
            rating: hasMultipleCoders ? 0.7 : 0.5,
            strategies: hasMultipleCoders ? ["Multiple coders"] : []
          },
          transferability: {
            rating: hasThickDescription ? 0.7 : 0.4,
            thickDescription: hasThickDescription || false,
            contextProvided: true
          },
          dependability: {
            rating: hasMemos ? 0.6 : 0.4,
            auditTrail: hasMemos || false,
            codebookStability: input.codebook?.version > 1 ? 0.7 : 0.5
          },
          confirmability: {
            rating: hasReflexiveMemos ? 0.7 : 0.4,
            reflexivity: hasReflexiveMemos || false,
            peerDebriefing: false
          },
          saturation: {
            achieved: false,
            evidence: "",
            newCodesLastN: 0
          }
        };
      }
      /**
       * Validate codebook structure
       */
      validateCodebook(codebook) {
        const errors = [];
        const warnings = [];
        const codesWithoutDefinitions = (codebook.codes || []).filter(
          (code) => !code.definition || code.definition.trim().length === 0
        );
        if (codesWithoutDefinitions.length > 0) {
          warnings.push(
            createValidationWarning(
              "codebook.codes",
              `${codesWithoutDefinitions.length} codes lack definitions`,
              "All codes should have clear definitions for consistency"
            )
          );
        }
        const codesWithoutExamples = (codebook.codes || []).filter(
          (code) => !code.examples || code.examples.length === 0
        );
        if (codesWithoutExamples.length > codebook.codes.length * 0.5) {
          warnings.push(
            createValidationWarning(
              "codebook.codes",
              "Many codes lack example quotes",
              "Add exemplar quotes to improve codebook reliability"
            )
          );
        }
        if (codebook.codeHierarchy) {
          const allCodeIds = new Set((codebook.codes || []).map((c) => c.id));
          for (const [parentId, childIds] of Object.entries(codebook.codeHierarchy.parentChildMap || {})) {
            if (!allCodeIds.has(parentId)) {
              warnings.push(
                createValidationWarning(
                  "codebook.codeHierarchy",
                  `Parent code ${parentId} not found in codes`,
                  "Ensure hierarchy references valid codes"
                )
              );
            }
            for (const childId of childIds) {
              if (!allCodeIds.has(childId)) {
                warnings.push(
                  createValidationWarning(
                    "codebook.codeHierarchy",
                    `Child code ${childId} not found in codes`,
                    "Ensure hierarchy references valid codes"
                  )
                );
              }
            }
          }
        }
        return errors.length > 0 ? validationFailure(errors, warnings) : validationSuccess(warnings);
      }
    };
  }
});
var VALID_ANALYSIS_TYPES, EngineeringHandler;
var init_EngineeringHandler = __esm({
  "src/modes/handlers/EngineeringHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    VALID_ANALYSIS_TYPES = [
      "requirements",
      "trade-study",
      "fmea",
      "design-decision",
      "comprehensive"
    ];
    EngineeringHandler = class {
      mode = "engineering" /* ENGINEERING */;
      modeName = "Engineering Analysis";
      description = "Structured engineering analysis with requirements, trade studies, FMEA, and ADRs";
      /**
       * Supported thought types for engineering mode
       */
      supportedThoughtTypes = [
        "requirements_analysis",
        "trade_study",
        "fmea_analysis",
        "design_decision",
        "risk_assessment",
        "traceability",
        "verification"
      ];
      /**
       * Create an engineering thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const analysisType = this.resolveAnalysisType(inputAny.analysisType);
        const requirements = inputAny.requirements ? this.processRequirements(inputAny.requirements) : void 0;
        const tradeStudy = inputAny.tradeStudy ? this.processTradeStudy(inputAny.tradeStudy) : void 0;
        const fmea = inputAny.fmea ? this.processFMEA(inputAny.fmea) : void 0;
        const designDecisions = inputAny.designDecisions ? this.processDesignDecisions(inputAny.designDecisions) : void 0;
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          mode: "engineering" /* ENGINEERING */,
          // Core engineering fields
          analysisType,
          designChallenge: inputAny.designChallenge || "",
          requirements,
          tradeStudy,
          fmea,
          designDecisions,
          assessment: inputAny.assessment,
          // Revision tracking
          isRevision: input.isRevision,
          revisesThought: input.revisesThought
        };
      }
      /**
       * Validate engineering-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        if (inputAny.analysisType && !VALID_ANALYSIS_TYPES.includes(inputAny.analysisType)) {
          warnings.push(
            createValidationWarning(
              "analysisType",
              `Unknown analysis type: ${inputAny.analysisType}`,
              `Valid types: ${VALID_ANALYSIS_TYPES.join(", ")}`
            )
          );
        }
        if (!inputAny.designChallenge || inputAny.designChallenge.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              "designChallenge",
              "No design challenge specified",
              "Describe the problem or design challenge being addressed"
            )
          );
        }
        if (inputAny.tradeStudy) {
          const tsValidation = this.validateTradeStudy(inputAny.tradeStudy);
          warnings.push(...tsValidation);
        }
        if (inputAny.fmea) {
          const fmeaValidation = this.validateFMEA(inputAny.fmea);
          warnings.push(...fmeaValidation);
        }
        if (!inputAny.tradeStudy && !inputAny.fmea && !inputAny.requirements && !inputAny.designDecisions) {
          warnings.push(
            createValidationWarning(
              "analysis",
              "No structured analysis provided",
              "Include requirements, trade study, FMEA, or design decisions for comprehensive engineering analysis"
            )
          );
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get engineering-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["algorithmic" /* ALGORITHMIC */, "systemsthinking" /* SYSTEMSTHINKING */, "optimization" /* OPTIMIZATION */],
          guidingQuestions: [],
          warnings: [],
          metrics: {},
          mentalModels: [
            "Systems Engineering V-Model",
            "Trade Study Matrix",
            "FMEA Risk Priority",
            "Architecture Decision Records",
            "Requirements Traceability"
          ]
        };
        switch (thought.analysisType) {
          case "requirements":
            enhancements.guidingQuestions.push(
              "Are all requirements traceable to source?",
              "What verification method will be used for each requirement?",
              "Are there any conflicting requirements?"
            );
            if (thought.requirements) {
              enhancements.metrics.totalRequirements = thought.requirements.requirements.length;
              const coverage = thought.requirements.coverage;
              if (coverage) {
                enhancements.metrics.coverageTotal = coverage.total;
                enhancements.metrics.coverageVerified = coverage.verified;
              }
            }
            break;
          case "trade-study":
            enhancements.guidingQuestions.push(
              "Do criteria weights sum to 1.0?",
              "Are all alternatives fairly scored?",
              "Is sensitivity analysis needed?"
            );
            if (thought.tradeStudy) {
              enhancements.metrics.alternativeCount = thought.tradeStudy.alternatives.length;
              enhancements.metrics.criteriaCount = thought.tradeStudy.criteria.length;
              enhancements.suggestions.push(
                `Recommendation: ${thought.tradeStudy.recommendation}`
              );
            }
            break;
          case "fmea":
            enhancements.guidingQuestions.push(
              "Are all failure modes identified?",
              "Are RPN values accurately calculated?",
              "Do high-RPN items have mitigation plans?"
            );
            if (thought.fmea) {
              const fmea = thought.fmea;
              enhancements.metrics.totalModes = fmea.summary.totalModes;
              enhancements.metrics.criticalModes = fmea.summary.criticalModes;
              enhancements.metrics.maxRPN = fmea.summary.maxRpn;
              enhancements.metrics.avgRPN = fmea.summary.averageRpn;
              if (fmea.summary.criticalModes > 0) {
                enhancements.warnings.push(
                  `${fmea.summary.criticalModes} failure mode(s) exceed RPN threshold of ${fmea.rpnThreshold}`
                );
              }
            }
            break;
          case "design-decision":
            enhancements.guidingQuestions.push(
              "Have all alternatives been considered?",
              "Are consequences documented?",
              "Who are the stakeholders affected?"
            );
            if (thought.designDecisions) {
              enhancements.metrics.decisionCount = thought.designDecisions.decisions.length;
              const accepted = thought.designDecisions.decisions.filter((d) => d.status === "accepted").length;
              enhancements.metrics.acceptedDecisions = accepted;
            }
            break;
          case "comprehensive":
            enhancements.suggestions.push(
              "Comprehensive analysis covers all engineering artifacts"
            );
            enhancements.guidingQuestions.push(
              "Are all analysis types appropriately addressed?",
              "Is the design challenge fully characterized?"
            );
            break;
        }
        if (thought.assessment) {
          enhancements.metrics.confidence = thought.assessment.confidence;
          enhancements.metrics.riskCount = thought.assessment.keyRisks.length;
          enhancements.metrics.openIssues = thought.assessment.openIssues.length;
          if (thought.assessment.confidence < 0.6) {
            enhancements.warnings.push(
              "Low confidence - consider gathering more data or conducting additional analysis"
            );
          }
          if (thought.assessment.keyRisks.length > 0) {
            enhancements.suggestions.push(
              `Key risks identified: ${thought.assessment.keyRisks.length}`
            );
          }
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Resolve analysis type from input
       */
      resolveAnalysisType(inputType) {
        if (inputType && VALID_ANALYSIS_TYPES.includes(inputType)) {
          return inputType;
        }
        return "comprehensive";
      }
      /**
       * Process requirements traceability
       */
      processRequirements(raw) {
        if (!raw.requirements) {
          return { requirements: [], coverage: { total: 0, verified: 0, tracedToSource: 0, allocatedToDesign: 0 } };
        }
        const requirements = raw.requirements.map((req) => ({
          id: req.id || `REQ-${randomUUID().slice(0, 8)}`,
          title: req.title || "",
          description: req.description || "",
          source: req.source || "derived",
          priority: req.priority || "should",
          status: req.status || "draft",
          rationale: req.rationale,
          verificationMethod: req.verificationMethod,
          verificationCriteria: req.verificationCriteria || [],
          tracesTo: req.tracesTo || [],
          satisfiedBy: req.satisfiedBy || [],
          relatedTo: req.relatedTo || []
        }));
        const coverage = raw.coverage || this.calculateCoverage(requirements);
        return { requirements, coverage };
      }
      /**
       * Calculate requirements coverage
       */
      calculateCoverage(requirements) {
        return {
          total: requirements.length,
          verified: requirements.filter((r) => r.verificationMethod).length,
          tracedToSource: requirements.filter((r) => r.tracesTo && r.tracesTo.length > 0).length,
          allocatedToDesign: requirements.filter((r) => r.satisfiedBy && r.satisfiedBy.length > 0).length
        };
      }
      /**
       * Process trade study
       */
      processTradeStudy(raw) {
        const scores = raw.scores || [];
        const criteriaWeights = {};
        (raw.criteria || []).forEach((c) => {
          criteriaWeights[c.id] = c.weight || 0;
        });
        const enhancedScores = scores.map((s) => ({
          ...s,
          weightedScore: (s.score || 0) * (criteriaWeights[s.criteriaId] || 0)
        }));
        return {
          title: raw.title || "",
          objective: raw.objective || "",
          alternatives: raw.alternatives || [],
          criteria: raw.criteria || [],
          scores: enhancedScores,
          recommendation: raw.recommendation || "",
          justification: raw.justification || "",
          sensitivityNotes: raw.sensitivityNotes
        };
      }
      /**
       * Process FMEA
       */
      processFMEA(raw) {
        const failureModes = (raw.failureModes || []).map((fm) => ({
          ...fm,
          rpn: (fm.severity || 1) * (fm.occurrence || 1) * (fm.detection || 1)
        }));
        const rpnThreshold = raw.rpnThreshold || 100;
        const rpnValues = failureModes.map((fm) => fm.rpn);
        return {
          title: raw.title || "",
          system: raw.system || "",
          failureModes,
          rpnThreshold,
          summary: {
            totalModes: failureModes.length,
            criticalModes: failureModes.filter((fm) => fm.rpn > rpnThreshold).length,
            averageRpn: rpnValues.length > 0 ? rpnValues.reduce((a, b) => a + b, 0) / rpnValues.length : 0,
            maxRpn: rpnValues.length > 0 ? Math.max(...rpnValues) : 0
          }
        };
      }
      /**
       * Process design decisions
       */
      processDesignDecisions(raw) {
        return {
          decisions: (raw.decisions || []).map((d) => ({
            id: d.id || `ADR-${randomUUID().slice(0, 8)}`,
            title: d.title || "",
            date: d.date,
            status: d.status || "proposed",
            context: d.context || "",
            decision: d.decision || "",
            alternatives: d.alternatives || [],
            rationale: d.rationale || "",
            consequences: d.consequences || [],
            supersededBy: d.supersededBy,
            relatedDecisions: d.relatedDecisions || [],
            stakeholders: d.stakeholders || []
          })),
          projectName: raw.projectName
        };
      }
      /**
       * Validate trade study
       */
      validateTradeStudy(tradeStudy) {
        const warnings = [];
        const weights = (tradeStudy.criteria || []).map((c) => c.weight || 0);
        const totalWeight = weights.reduce((a, b) => a + b, 0);
        if (Math.abs(totalWeight - 1) > 0.01) {
          warnings.push(
            createValidationWarning(
              "tradeStudy.criteria",
              `Criteria weights sum to ${totalWeight.toFixed(2)}, should be 1.0`,
              "Adjust weights to sum to 1.0 for proper weighted scoring"
            )
          );
        }
        const altIds = (tradeStudy.alternatives || []).map((a) => a.id);
        const critIds = (tradeStudy.criteria || []).map((c) => c.id);
        const scoreKeys = (tradeStudy.scores || []).map(
          (s) => `${s.alternativeId}-${s.criteriaId}`
        );
        const expectedScores = altIds.flatMap(
          (altId) => critIds.map((critId) => `${altId}-${critId}`)
        );
        const missingScores = expectedScores.filter((key) => !scoreKeys.includes(key));
        if (missingScores.length > 0) {
          warnings.push(
            createValidationWarning(
              "tradeStudy.scores",
              `${missingScores.length} score(s) missing`,
              "Ensure all alternative-criterion pairs are scored"
            )
          );
        }
        return warnings;
      }
      /**
       * Validate FMEA
       */
      validateFMEA(fmea) {
        const warnings = [];
        const failureModes = fmea.failureModes || [];
        const rpnThreshold = fmea.rpnThreshold || 100;
        const highRpnNoMitigation = failureModes.filter(
          (fm) => fm.rpn > rpnThreshold && !fm.mitigation
        );
        if (highRpnNoMitigation.length > 0) {
          warnings.push(
            createValidationWarning(
              "fmea.failureModes",
              `${highRpnNoMitigation.length} high-RPN failure mode(s) lack mitigation plans`,
              "Document mitigation actions for all critical failure modes"
            )
          );
        }
        const invalidRatings = failureModes.filter(
          (fm) => fm.severity < 1 || fm.severity > 10 || fm.occurrence < 1 || fm.occurrence > 10 || fm.detection < 1 || fm.detection > 10
        );
        if (invalidRatings.length > 0) {
          warnings.push(
            createValidationWarning(
              "fmea.failureModes",
              `${invalidRatings.length} failure mode(s) have invalid S/O/D ratings`,
              "Severity, Occurrence, and Detection must be 1-10"
            )
          );
        }
        return warnings;
      }
    };
  }
});
var VALID_THOUGHT_TYPES5, ComputabilityHandler;
var init_ComputabilityHandler = __esm({
  "src/modes/handlers/ComputabilityHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    VALID_THOUGHT_TYPES5 = [
      "machine_definition",
      "computation_trace",
      "decidability_proof",
      "reduction_construction",
      "complexity_analysis",
      "oracle_reasoning",
      "diagonalization"
    ];
    ComputabilityHandler = class {
      mode = "computability" /* COMPUTABILITY */;
      modeName = "Computability Theory";
      description = "Turing machine analysis, decidability proofs, and reductions";
      /**
       * Supported thought types for computability mode
       */
      supportedThoughtTypes = [
        "machine_definition",
        "computation_trace",
        "decidability_proof",
        "reduction_construction",
        "complexity_analysis",
        "oracle_reasoning",
        "diagonalization"
      ];
      /**
       * Create a computability thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const thoughtType = this.resolveThoughtType(inputAny.thoughtType);
        const machines = inputAny.machines ? inputAny.machines.map((m) => this.normalizeMachine(m)) : void 0;
        const decidabilityProof = inputAny.decidabilityProof ? this.normalizeDecidabilityProof(inputAny.decidabilityProof) : void 0;
        const reductions = inputAny.reductions ? inputAny.reductions.map((r) => this.normalizeReduction(r)) : void 0;
        const diagonalization = inputAny.diagonalization ? this.normalizeDiagonalization(inputAny.diagonalization) : void 0;
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          mode: "computability" /* COMPUTABILITY */,
          // Core computability fields
          thoughtType,
          machines,
          currentMachine: machines?.[0],
          computationTrace: inputAny.computationTrace,
          problems: inputAny.problems,
          currentProblem: inputAny.currentProblem,
          reductions,
          reductionChain: inputAny.reductionChain,
          decidabilityProof,
          diagonalization,
          complexityAnalysis: inputAny.complexityAnalysis,
          oracleAnalysis: inputAny.oracleAnalysis,
          classicProblems: inputAny.classicProblems,
          keyInsight: inputAny.keyInsight,
          // Dependencies and assumptions
          dependencies: input.dependencies || [],
          assumptions: input.assumptions || [],
          uncertainty: input.uncertainty ?? 0.5,
          // Revision tracking
          isRevision: input.isRevision,
          revisesThought: input.revisesThought
        };
      }
      /**
       * Validate computability-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        if (inputAny.thoughtType && !VALID_THOUGHT_TYPES5.includes(inputAny.thoughtType)) {
          warnings.push(
            createValidationWarning(
              "thoughtType",
              `Unknown thought type: ${inputAny.thoughtType}`,
              `Valid types: ${VALID_THOUGHT_TYPES5.join(", ")}`
            )
          );
        }
        if (input.uncertainty !== void 0) {
          if (input.uncertainty < 0 || input.uncertainty > 1) {
            errors.push(
              createValidationError(
                "uncertainty",
                `Uncertainty (${input.uncertainty}) must be between 0 and 1`,
                "UNCERTAINTY_OUT_OF_RANGE"
              )
            );
          }
        }
        if (inputAny.machines) {
          for (let i = 0; i < inputAny.machines.length; i++) {
            const machineWarnings = this.validateMachine(inputAny.machines[i], i);
            warnings.push(...machineWarnings);
          }
        }
        if (inputAny.decidabilityProof) {
          const proofWarnings = this.validateDecidabilityProof(inputAny.decidabilityProof);
          warnings.push(...proofWarnings);
        }
        if (inputAny.reductions) {
          for (let i = 0; i < inputAny.reductions.length; i++) {
            const reductionWarnings = this.validateReduction(inputAny.reductions[i], i);
            warnings.push(...reductionWarnings);
          }
        }
        if (inputAny.thoughtType === "machine_definition" && !inputAny.machines) {
          warnings.push(
            createValidationWarning(
              "machines",
              "Machine definition thought without machines specified",
              "Include Turing machine specification"
            )
          );
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get computability-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["mathematics" /* MATHEMATICS */, "algorithmic" /* ALGORITHMIC */, "formallogic" /* FORMALLOGIC */],
          guidingQuestions: [],
          warnings: [],
          metrics: {
            machineCount: thought.machines?.length || 0,
            problemCount: thought.problems?.length || 0,
            reductionCount: thought.reductions?.length || 0,
            uncertainty: thought.uncertainty
          },
          mentalModels: [
            "Turing Machine Model",
            "Church-Turing Thesis",
            "Halting Problem",
            "Diagonalization",
            "Reduction Technique",
            "Rice's Theorem"
          ]
        };
        switch (thought.thoughtType) {
          case "machine_definition":
            enhancements.guidingQuestions.push(
              "Is the transition function fully specified?",
              "Are accept and reject states properly defined?",
              "What language does this machine recognize?"
            );
            if (thought.currentMachine) {
              enhancements.metrics.stateCount = thought.currentMachine.states.length;
              enhancements.metrics.transitionCount = thought.currentMachine.transitions.length;
              enhancements.suggestions.push(
                `Machine type: ${thought.currentMachine.type}`
              );
            }
            break;
          case "computation_trace":
            enhancements.guidingQuestions.push(
              "Does the computation terminate?",
              "How many steps are required?",
              "What is the space usage?"
            );
            if (thought.computationTrace) {
              enhancements.metrics.totalSteps = thought.computationTrace.totalSteps;
              enhancements.metrics.spaceUsed = thought.computationTrace.spaceUsed;
              enhancements.suggestions.push(
                `Result: ${thought.computationTrace.result}`
              );
            }
            break;
          case "decidability_proof":
            enhancements.guidingQuestions.push(
              "What is the proof method?",
              "Is the reduction valid?",
              "Are all cases covered?"
            );
            if (thought.decidabilityProof) {
              enhancements.suggestions.push(
                `Conclusion: ${thought.decidabilityProof.conclusion}`,
                `Method: ${thought.decidabilityProof.method}`
              );
            }
            break;
          case "reduction_construction":
            enhancements.guidingQuestions.push(
              "Is the reduction computable?",
              "Does it preserve membership?",
              "What is the reduction complexity?"
            );
            if (thought.reductions && thought.reductions.length > 0) {
              const r = thought.reductions[0];
              enhancements.suggestions.push(
                `Reduction type: ${r.type}`,
                `${r.fromProblem} \u2264 ${r.toProblem}`
              );
            }
            break;
          case "complexity_analysis":
            enhancements.guidingQuestions.push(
              "What complexity class does this belong to?",
              "Is it complete for its class?",
              "Are there known lower bounds?"
            );
            if (thought.complexityAnalysis) {
              enhancements.metrics.complexityClass = thought.complexityAnalysis.complexityClass;
            }
            break;
          case "oracle_reasoning":
            enhancements.guidingQuestions.push(
              "What oracle is being used?",
              "Does the result relativize?",
              "What are the implications for P vs NP?"
            );
            enhancements.suggestions.push(
              "Consider Baker-Gill-Solovay relativization barriers"
            );
            break;
          case "diagonalization":
            enhancements.guidingQuestions.push(
              "What is being enumerated?",
              "How is the diagonal element constructed?",
              "What contradiction arises?"
            );
            if (thought.diagonalization) {
              enhancements.suggestions.push(
                `Pattern: ${thought.diagonalization.pattern}`
              );
            }
            break;
        }
        if (thought.classicProblems && thought.classicProblems.length > 0) {
          enhancements.suggestions.push(
            `References: ${thought.classicProblems.join(", ")}`
          );
        }
        if (thought.keyInsight) {
          enhancements.suggestions.push(`Key insight: ${thought.keyInsight}`);
        }
        if (thought.uncertainty > 0.7) {
          enhancements.warnings.push(
            "High uncertainty - verify proof steps carefully"
          );
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Resolve thought type from input
       */
      resolveThoughtType(inputType) {
        if (inputType && VALID_THOUGHT_TYPES5.includes(inputType)) {
          return inputType;
        }
        return "machine_definition";
      }
      /**
       * Normalize Turing machine specification
       */
      normalizeMachine(machine) {
        return {
          id: machine.id || randomUUID(),
          name: machine.name || "Unnamed Machine",
          description: machine.description,
          states: machine.states || [],
          inputAlphabet: machine.inputAlphabet || ["0", "1"],
          tapeAlphabet: machine.tapeAlphabet || ["0", "1", "_"],
          blankSymbol: machine.blankSymbol || "_",
          transitions: machine.transitions || [],
          initialState: machine.initialState || machine.states?.[0] || "q0",
          acceptStates: machine.acceptStates || [],
          rejectStates: machine.rejectStates || [],
          type: machine.type || "deterministic",
          oracle: machine.oracle
        };
      }
      /**
       * Normalize decidability proof
       */
      normalizeDecidabilityProof(proof) {
        return {
          id: proof.id || randomUUID(),
          problem: proof.problem || "",
          conclusion: proof.conclusion || "unknown",
          method: proof.method || "direct_machine",
          decidingMachine: proof.decidingMachine,
          reduction: proof.reduction,
          knownUndecidableProblem: proof.knownUndecidableProblem,
          diagonalization: proof.diagonalization,
          riceApplication: proof.riceApplication,
          proofSteps: proof.proofSteps || [],
          keyInsights: proof.keyInsights || []
        };
      }
      /**
       * Normalize reduction
       */
      normalizeReduction(reduction) {
        return {
          id: reduction.id || randomUUID(),
          fromProblem: reduction.fromProblem || "",
          toProblem: reduction.toProblem || "",
          type: reduction.type || "many_one",
          reductionFunction: reduction.reductionFunction || {
            description: "",
            inputTransformation: "",
            outputInterpretation: "",
            preserves: ""
          },
          correctnessProof: reduction.correctnessProof || {
            forwardDirection: "",
            backwardDirection: ""
          },
          reductionComplexity: reduction.reductionComplexity
        };
      }
      /**
       * Normalize diagonalization argument
       */
      normalizeDiagonalization(diag) {
        return {
          id: diag.id || randomUUID(),
          enumeration: diag.enumeration || {
            description: "",
            indexSet: "natural numbers",
            enumeratedObjects: ""
          },
          diagonalConstruction: diag.diagonalConstruction || {
            description: "",
            rule: "",
            resultingObject: ""
          },
          contradiction: diag.contradiction || {
            assumption: "",
            consequence: "",
            impossibility: ""
          },
          pattern: diag.pattern || "custom",
          historicalNote: diag.historicalNote
        };
      }
      /**
       * Validate Turing machine specification
       */
      validateMachine(machine, index) {
        const warnings = [];
        if (!machine.states || machine.states.length === 0) {
          warnings.push(
            createValidationWarning(
              `machines[${index}].states`,
              "No states defined",
              "A Turing machine requires at least one state"
            )
          );
        }
        if (!machine.transitions || machine.transitions.length === 0) {
          warnings.push(
            createValidationWarning(
              `machines[${index}].transitions`,
              "No transitions defined",
              "Define the transition function"
            )
          );
        }
        if (!machine.acceptStates || machine.acceptStates.length === 0) {
          warnings.push(
            createValidationWarning(
              `machines[${index}].acceptStates`,
              "No accept states defined",
              "Define at least one accept state"
            )
          );
        }
        return warnings;
      }
      /**
       * Validate decidability proof
       */
      validateDecidabilityProof(proof) {
        const warnings = [];
        if (!proof.problem) {
          warnings.push(
            createValidationWarning(
              "decidabilityProof.problem",
              "No problem specified",
              "Identify the decision problem being analyzed"
            )
          );
        }
        if (!proof.proofSteps || proof.proofSteps.length === 0) {
          warnings.push(
            createValidationWarning(
              "decidabilityProof.proofSteps",
              "No proof steps provided",
              "Document the proof steps"
            )
          );
        }
        if (proof.method === "reduction" && !proof.reduction && !proof.knownUndecidableProblem) {
          warnings.push(
            createValidationWarning(
              "decidabilityProof",
              "Reduction proof without reduction details",
              "Specify the reduction and known undecidable problem"
            )
          );
        }
        return warnings;
      }
      /**
       * Validate reduction
       */
      validateReduction(reduction, index) {
        const warnings = [];
        if (!reduction.fromProblem || !reduction.toProblem) {
          warnings.push(
            createValidationWarning(
              `reductions[${index}]`,
              "Reduction missing source or target problem",
              "Specify both fromProblem and toProblem"
            )
          );
        }
        if (!reduction.correctnessProof) {
          warnings.push(
            createValidationWarning(
              `reductions[${index}].correctnessProof`,
              "No correctness proof provided",
              "Prove both directions of the reduction"
            )
          );
        }
        return warnings;
      }
    };
  }
});
var VALID_THOUGHT_TYPES6, VALID_CIPHER_TYPES, CONFIRMATION_THRESHOLD, REFUTATION_THRESHOLD, CryptanalyticHandler;
var init_CryptanalyticHandler = __esm({
  "src/modes/handlers/CryptanalyticHandler.ts"() {
    init_esm_shims();
    init_cryptanalytic();
    init_ModeHandler();
    VALID_THOUGHT_TYPES6 = [
      "hypothesis_formation",
      "evidence_accumulation",
      "frequency_analysis",
      "key_elimination",
      "banburismus",
      "crib_analysis",
      "isomorphism_detection"
    ];
    VALID_CIPHER_TYPES = [
      "substitution_simple",
      "substitution_polyalphabetic",
      "substitution_polygraphic",
      "transposition",
      "rotor",
      "stream",
      "block",
      "unknown"
    ];
    CONFIRMATION_THRESHOLD = 20;
    REFUTATION_THRESHOLD = -20;
    CryptanalyticHandler = class {
      mode = "cryptanalytic" /* CRYPTANALYTIC */;
      modeName = "Cryptanalytic Reasoning";
      description = "Bayesian cryptanalysis with Turing's deciban evidence system";
      /**
       * Supported thought types for cryptanalytic mode
       */
      supportedThoughtTypes = [
        "hypothesis_formation",
        "evidence_accumulation",
        "frequency_analysis",
        "key_elimination",
        "banburismus",
        "crib_analysis",
        "isomorphism_detection"
      ];
      /**
       * Create a cryptanalytic thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const thoughtType = this.resolveThoughtType(inputAny.thoughtType);
        const hypotheses = inputAny.hypotheses ? inputAny.hypotheses.map((h) => this.normalizeHypothesis(h)) : void 0;
        const evidenceChains = inputAny.evidenceChains ? inputAny.evidenceChains.map((e) => this.normalizeEvidenceChain(e)) : void 0;
        const currentHypothesis = inputAny.currentHypothesis ? this.normalizeHypothesis(inputAny.currentHypothesis) : hypotheses?.[0];
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          mode: "cryptanalytic" /* CRYPTANALYTIC */,
          // Core cryptanalytic fields
          thoughtType,
          ciphertext: inputAny.ciphertext,
          plaintext: inputAny.plaintext,
          hypotheses,
          currentHypothesis,
          evidenceChains,
          keySpaceAnalysis: inputAny.keySpaceAnalysis,
          frequencyAnalysis: inputAny.frequencyAnalysis,
          banburismusAnalysis: inputAny.banburismusAnalysis,
          cribAnalysis: inputAny.cribAnalysis,
          patterns: inputAny.patterns,
          cipherType: inputAny.cipherType,
          keyInsight: inputAny.keyInsight,
          // Dependencies and assumptions
          dependencies: input.dependencies || [],
          assumptions: input.assumptions || [],
          uncertainty: input.uncertainty ?? 0.5,
          // Revision tracking
          isRevision: input.isRevision,
          revisesThought: input.revisesThought
        };
      }
      /**
       * Validate cryptanalytic-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        if (inputAny.thoughtType && !VALID_THOUGHT_TYPES6.includes(inputAny.thoughtType)) {
          warnings.push(
            createValidationWarning(
              "thoughtType",
              `Unknown thought type: ${inputAny.thoughtType}`,
              `Valid types: ${VALID_THOUGHT_TYPES6.join(", ")}`
            )
          );
        }
        if (inputAny.cipherType && !VALID_CIPHER_TYPES.includes(inputAny.cipherType)) {
          warnings.push(
            createValidationWarning(
              "cipherType",
              `Unknown cipher type: ${inputAny.cipherType}`,
              `Valid types: ${VALID_CIPHER_TYPES.join(", ")}`
            )
          );
        }
        if (input.uncertainty !== void 0) {
          if (input.uncertainty < 0 || input.uncertainty > 1) {
            errors.push(
              createValidationError(
                "uncertainty",
                `Uncertainty (${input.uncertainty}) must be between 0 and 1`,
                "UNCERTAINTY_OUT_OF_RANGE"
              )
            );
          }
        }
        if (inputAny.hypotheses) {
          for (let i = 0; i < inputAny.hypotheses.length; i++) {
            const hypWarnings = this.validateHypothesis(inputAny.hypotheses[i], i);
            warnings.push(...hypWarnings);
          }
        }
        if (inputAny.evidenceChains) {
          for (let i = 0; i < inputAny.evidenceChains.length; i++) {
            const chainWarnings = this.validateEvidenceChain(inputAny.evidenceChains[i], i);
            warnings.push(...chainWarnings);
          }
        }
        if (!inputAny.ciphertext && inputAny.thoughtType !== "hypothesis_formation") {
          warnings.push(
            createValidationWarning(
              "ciphertext",
              "No ciphertext provided",
              "Include ciphertext for cryptanalysis"
            )
          );
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get cryptanalytic-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["bayesian" /* BAYESIAN */, "evidential" /* EVIDENTIAL */, "inductive" /* INDUCTIVE */],
          guidingQuestions: [],
          warnings: [],
          metrics: {
            hypothesisCount: thought.hypotheses?.length || 0,
            evidenceChainCount: thought.evidenceChains?.length || 0,
            uncertainty: thought.uncertainty
          },
          mentalModels: [
            "Turing's Deciban System",
            "Bayesian Hypothesis Testing",
            "Index of Coincidence",
            "Banburismus",
            "Frequency Analysis",
            "Known-Plaintext Attack"
          ]
        };
        switch (thought.thoughtType) {
          case "hypothesis_formation":
            enhancements.guidingQuestions.push(
              "What cipher system is most likely?",
              "What are the prior probabilities for each hypothesis?",
              "What evidence would confirm or refute each hypothesis?"
            );
            break;
          case "evidence_accumulation":
            enhancements.guidingQuestions.push(
              "What is the likelihood ratio for this evidence?",
              "How many decibans does this evidence contribute?",
              "Have we reached the confirmation threshold?"
            );
            if (thought.evidenceChains) {
              for (const chain of thought.evidenceChains) {
                enhancements.metrics[`${chain.hypothesis}_decibans`] = chain.totalDecibans;
                if (chain.conclusion !== "inconclusive") {
                  enhancements.suggestions.push(
                    `Hypothesis "${chain.hypothesis}": ${chain.conclusion} (${chain.totalDecibans.toFixed(1)} db)`
                  );
                }
              }
            }
            break;
          case "frequency_analysis":
            enhancements.guidingQuestions.push(
              "Does the frequency distribution match any known language?",
              "What is the index of coincidence?",
              "Are there significant deviations from expected frequencies?"
            );
            if (thought.frequencyAnalysis) {
              enhancements.metrics.indexOfCoincidence = thought.frequencyAnalysis.indexOfCoincidence;
              enhancements.metrics.chiSquared = thought.frequencyAnalysis.chiSquared;
            }
            break;
          case "key_elimination":
            enhancements.guidingQuestions.push(
              "What portion of the key space has been eliminated?",
              "What methods were used for elimination?",
              "How many candidate keys remain?"
            );
            if (thought.keySpaceAnalysis) {
              const ks = thought.keySpaceAnalysis;
              enhancements.metrics.reductionFactor = ks.reductionFactor;
              enhancements.suggestions.push(
                `Key space reduced by factor of ${ks.reductionFactor.toFixed(2)}`
              );
            }
            break;
          case "banburismus":
            enhancements.guidingQuestions.push(
              "Are there significant coincidences at any offset?",
              "What does this suggest about the wheel order?",
              "Can we chain multiple Banburismus results?"
            );
            if (thought.banburismusAnalysis) {
              const significant = thought.banburismusAnalysis.filter((b) => b.isSignificant);
              enhancements.metrics.significantOffsets = significant.length;
              for (const b of significant) {
                enhancements.suggestions.push(
                  `Significant at offset ${b.offset}: ${b.decibanScore.toFixed(1)} db`
                );
              }
            }
            break;
          case "crib_analysis":
            enhancements.guidingQuestions.push(
              "Is the crib position viable?",
              "Are there any contradictions?",
              "What constraints does this crib impose?"
            );
            if (thought.cribAnalysis) {
              const viable = thought.cribAnalysis.filter((c) => c.isViable);
              enhancements.metrics.viablePositions = viable.length;
            }
            break;
          case "isomorphism_detection":
            enhancements.guidingQuestions.push(
              "What patterns have been detected?",
              "Do patterns suggest repeated words?",
              "What deciban contribution do patterns provide?"
            );
            if (thought.patterns) {
              enhancements.metrics.patternCount = thought.patterns.length;
            }
            break;
        }
        if (thought.currentHypothesis) {
          const h = thought.currentHypothesis;
          enhancements.metrics.currentDecibanScore = h.decibanScore;
          enhancements.metrics.posteriorProbability = h.posteriorProbability;
          if (h.decibanScore >= CONFIRMATION_THRESHOLD) {
            enhancements.suggestions.push(
              `\u2713 Hypothesis "${h.description}" CONFIRMED (${h.decibanScore.toFixed(1)} db)`
            );
          } else if (h.decibanScore <= REFUTATION_THRESHOLD) {
            enhancements.warnings.push(
              `\u2717 Hypothesis "${h.description}" REFUTED (${h.decibanScore.toFixed(1)} db)`
            );
          } else {
            enhancements.suggestions.push(
              `Hypothesis "${h.description}": ${h.decibanScore.toFixed(1)} db (inconclusive, need \xB1${CONFIRMATION_THRESHOLD} db)`
            );
          }
        }
        if (thought.cipherType) {
          enhancements.suggestions.push(`Cipher type: ${thought.cipherType}`);
        }
        if (thought.keyInsight) {
          enhancements.suggestions.push(`Key insight: ${thought.keyInsight}`);
        }
        if (thought.uncertainty > 0.7) {
          enhancements.warnings.push(
            "High uncertainty - gather more evidence"
          );
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Resolve thought type from input
       */
      resolveThoughtType(inputType) {
        if (inputType && VALID_THOUGHT_TYPES6.includes(inputType)) {
          return inputType;
        }
        return "hypothesis_formation";
      }
      /**
       * Normalize hypothesis
       */
      normalizeHypothesis(h) {
        const evidence = (h.evidence || []).map((e) => this.normalizeEvidence(e));
        const totalDecibans = evidence.reduce((sum, e) => sum + e.decibans, 0);
        const posteriorProbability = decibansToProbability(totalDecibans, h.priorProbability || 0.5);
        return {
          id: h.id || randomUUID(),
          description: h.description || "",
          cipherType: h.cipherType,
          parameters: h.parameters,
          priorProbability: h.priorProbability ?? 0.5,
          posteriorProbability,
          decibanScore: totalDecibans,
          evidence,
          status: this.determineHypothesisStatus(totalDecibans)
        };
      }
      /**
       * Normalize evidence
       */
      normalizeEvidence(e) {
        const likelihoodRatio = e.likelihoodRatio ?? (e.decibans ? fromDecibans(e.decibans) : 1);
        const decibans = e.decibans ?? toDecibans(likelihoodRatio);
        return {
          observation: e.observation || "",
          decibans,
          likelihoodRatio,
          source: e.source || "statistical",
          confidence: e.confidence ?? 1,
          explanation: e.explanation
        };
      }
      /**
       * Normalize evidence chain
       */
      normalizeEvidenceChain(chain) {
        const observations = (chain.observations || []).map(
          (o) => this.normalizeEvidence(o)
        );
        const totalDecibans = observations.reduce((sum, o) => sum + o.decibans, 0);
        const confirmationThreshold = chain.confirmationThreshold ?? CONFIRMATION_THRESHOLD;
        const refutationThreshold = chain.refutationThreshold ?? REFUTATION_THRESHOLD;
        let conclusion;
        if (totalDecibans >= confirmationThreshold) {
          conclusion = "confirmed";
        } else if (totalDecibans <= refutationThreshold) {
          conclusion = "refuted";
        } else {
          conclusion = "inconclusive";
        }
        return {
          hypothesis: chain.hypothesis || "",
          observations,
          totalDecibans,
          oddsRatio: fromDecibans(totalDecibans),
          conclusion,
          confirmationThreshold,
          refutationThreshold
        };
      }
      /**
       * Determine hypothesis status based on deciban score
       */
      determineHypothesisStatus(decibans) {
        if (decibans >= CONFIRMATION_THRESHOLD) {
          return "confirmed";
        } else if (decibans <= REFUTATION_THRESHOLD) {
          return "refuted";
        }
        return "active";
      }
      /**
       * Validate hypothesis
       */
      validateHypothesis(h, index) {
        const warnings = [];
        if (!h.description) {
          warnings.push(
            createValidationWarning(
              `hypotheses[${index}].description`,
              "Hypothesis lacks description",
              "Describe what the hypothesis proposes"
            )
          );
        }
        if (h.priorProbability !== void 0 && (h.priorProbability < 0 || h.priorProbability > 1)) {
          warnings.push(
            createValidationWarning(
              `hypotheses[${index}].priorProbability`,
              `Prior probability (${h.priorProbability}) out of range`,
              "Prior probability must be between 0 and 1"
            )
          );
        }
        return warnings;
      }
      /**
       * Validate evidence chain
       */
      validateEvidenceChain(chain, index) {
        const warnings = [];
        if (!chain.hypothesis) {
          warnings.push(
            createValidationWarning(
              `evidenceChains[${index}].hypothesis`,
              "Evidence chain lacks hypothesis reference",
              "Link evidence chain to a hypothesis"
            )
          );
        }
        if (!chain.observations || chain.observations.length === 0) {
          warnings.push(
            createValidationWarning(
              `evidenceChains[${index}].observations`,
              "Evidence chain has no observations",
              "Add deciban evidence observations"
            )
          );
        }
        return warnings;
      }
    };
  }
});
var VALID_THOUGHT_TYPES7, VALID_DESIGN_PATTERNS, AlgorithmicHandler;
var init_AlgorithmicHandler = __esm({
  "src/modes/handlers/AlgorithmicHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    VALID_THOUGHT_TYPES7 = [
      "algorithm_definition",
      "complexity_analysis",
      "recurrence_solving",
      "correctness_proof",
      "invariant_identification",
      "divide_and_conquer",
      "dynamic_programming",
      "greedy_choice",
      "backtracking",
      "branch_and_bound",
      "randomized_analysis",
      "amortized_analysis",
      "data_structure_design",
      "data_structure_analysis",
      "augmentation",
      "graph_traversal",
      "shortest_path",
      "minimum_spanning_tree",
      "network_flow",
      "matching",
      "string_matching",
      "computational_geometry",
      "number_theoretic",
      "approximation",
      "online_algorithm",
      "parallel_algorithm"
    ];
    VALID_DESIGN_PATTERNS = [
      "brute_force",
      "divide_and_conquer",
      "dynamic_programming",
      "greedy",
      "backtracking",
      "branch_and_bound",
      "randomized",
      "approximation",
      "online",
      "parallel",
      "incremental",
      "prune_and_search"
    ];
    AlgorithmicHandler = class {
      mode = "algorithmic" /* ALGORITHMIC */;
      modeName = "Algorithmic Analysis";
      description = "Algorithm design, complexity analysis, and correctness proofs (CLRS coverage)";
      /**
       * Supported thought types for algorithmic mode
       */
      supportedThoughtTypes = VALID_THOUGHT_TYPES7;
      /**
       * Create an algorithmic thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const thoughtType = this.resolveThoughtType(inputAny.thoughtType);
        const timeComplexity = inputAny.timeComplexity ? this.normalizeTimeComplexity(inputAny.timeComplexity) : void 0;
        const spaceComplexity = inputAny.spaceComplexity ? this.normalizeSpaceComplexity(inputAny.spaceComplexity) : void 0;
        const correctnessProof = inputAny.correctnessProof ? this.normalizeCorrectnessProof(inputAny.correctnessProof) : void 0;
        const dpFormulation = inputAny.dpFormulation ? this.normalizeDPFormulation(inputAny.dpFormulation) : void 0;
        const greedyProof = inputAny.greedyProof ? this.normalizeGreedyProof(inputAny.greedyProof) : void 0;
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          mode: "algorithmic" /* ALGORITHMIC */,
          // Core algorithmic fields
          thoughtType,
          algorithm: inputAny.algorithm,
          clrsCategory: inputAny.clrsCategory,
          clrsAlgorithm: inputAny.clrsAlgorithm,
          designPattern: inputAny.designPattern,
          timeComplexity,
          spaceComplexity,
          recurrence: inputAny.recurrence,
          correctnessProof,
          loopInvariants: inputAny.loopInvariants,
          dpFormulation,
          greedyProof,
          graphContext: inputAny.graphContext,
          dataStructure: inputAny.dataStructure,
          amortizedAnalysis: inputAny.amortizedAnalysis,
          comparison: inputAny.comparison,
          pseudocode: inputAny.pseudocode,
          executionTrace: inputAny.executionTrace,
          keyInsight: inputAny.keyInsight,
          // Dependencies and assumptions
          dependencies: input.dependencies || [],
          assumptions: input.assumptions || [],
          uncertainty: input.uncertainty ?? 0.5,
          // Revision tracking
          isRevision: input.isRevision,
          revisesThought: input.revisesThought
        };
      }
      /**
       * Validate algorithmic-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        if (inputAny.thoughtType && !VALID_THOUGHT_TYPES7.includes(inputAny.thoughtType)) {
          warnings.push(
            createValidationWarning(
              "thoughtType",
              `Unknown thought type: ${inputAny.thoughtType}`,
              `Valid types include: ${VALID_THOUGHT_TYPES7.slice(0, 5).join(", ")}...`
            )
          );
        }
        if (inputAny.designPattern && !VALID_DESIGN_PATTERNS.includes(inputAny.designPattern)) {
          warnings.push(
            createValidationWarning(
              "designPattern",
              `Unknown design pattern: ${inputAny.designPattern}`,
              `Valid patterns: ${VALID_DESIGN_PATTERNS.join(", ")}`
            )
          );
        }
        if (input.uncertainty !== void 0) {
          if (input.uncertainty < 0 || input.uncertainty > 1) {
            errors.push(
              createValidationError(
                "uncertainty",
                `Uncertainty (${input.uncertainty}) must be between 0 and 1`,
                "UNCERTAINTY_OUT_OF_RANGE"
              )
            );
          }
        }
        if (inputAny.dpFormulation) {
          const dpWarnings = this.validateDPFormulation(inputAny.dpFormulation);
          warnings.push(...dpWarnings);
        }
        if (inputAny.correctnessProof) {
          const proofWarnings = this.validateCorrectnessProof(inputAny.correctnessProof);
          warnings.push(...proofWarnings);
        }
        if (inputAny.thoughtType === "algorithm_definition" && !inputAny.timeComplexity) {
          warnings.push(
            createValidationWarning(
              "timeComplexity",
              "Algorithm definition without complexity analysis",
              "Include time complexity for complete specification"
            )
          );
        }
        if (inputAny.thoughtType === "dynamic_programming" && !inputAny.dpFormulation) {
          warnings.push(
            createValidationWarning(
              "dpFormulation",
              "DP thought without formulation",
              "Include the four-step DP formulation"
            )
          );
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get algorithmic-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["mathematics" /* MATHEMATICS */, "computability" /* COMPUTABILITY */, "optimization" /* OPTIMIZATION */],
          guidingQuestions: [],
          warnings: [],
          metrics: {
            dependencyCount: thought.dependencies?.length || 0,
            assumptionCount: thought.assumptions?.length || 0,
            uncertainty: thought.uncertainty
          },
          mentalModels: [
            "Divide and Conquer",
            "Dynamic Programming",
            "Greedy Choice Property",
            "Master Theorem",
            "Loop Invariants",
            "Amortized Analysis"
          ]
        };
        switch (thought.thoughtType) {
          case "algorithm_definition":
            enhancements.guidingQuestions.push(
              "What is the input/output specification?",
              "What design pattern does this follow?",
              "Is the algorithm correct for all valid inputs?"
            );
            break;
          case "complexity_analysis":
            enhancements.guidingQuestions.push(
              "What is the dominant operation?",
              "Can we apply the Master Theorem?",
              "Is the analysis tight (\u0398) or just upper bound (O)?"
            );
            if (thought.timeComplexity) {
              enhancements.metrics.worstCase = thought.timeComplexity.worstCase;
              enhancements.suggestions.push(
                `Time: ${thought.timeComplexity.worstCase}`
              );
            }
            if (thought.spaceComplexity) {
              enhancements.metrics.spaceComplexity = thought.spaceComplexity.auxiliary;
            }
            break;
          case "recurrence_solving":
            enhancements.guidingQuestions.push(
              "Which method applies: Master Theorem, substitution, or recursion tree?",
              "What is the recurrence relation?",
              "Is the solution tight?"
            );
            if (thought.recurrence) {
              enhancements.suggestions.push(
                `Recurrence: ${thought.recurrence.formula}`,
                `Solution: ${thought.recurrence.solution}`
              );
            }
            break;
          case "correctness_proof":
            enhancements.guidingQuestions.push(
              "What are the preconditions and postconditions?",
              "What is the loop invariant?",
              "Why does the algorithm terminate?"
            );
            if (thought.correctnessProof) {
              enhancements.suggestions.push(
                `Proof method: ${thought.correctnessProof.method}`
              );
            }
            break;
          case "invariant_identification":
            enhancements.guidingQuestions.push(
              "Does the invariant hold at initialization?",
              "Is it maintained through each iteration?",
              "What does the invariant imply at termination?"
            );
            if (thought.loopInvariants) {
              enhancements.metrics.invariantCount = thought.loopInvariants.length;
            }
            break;
          case "divide_and_conquer":
            enhancements.guidingQuestions.push(
              "How is the problem divided?",
              "What are the subproblems?",
              "How are solutions combined?"
            );
            enhancements.suggestions.push(
              "Apply recurrence analysis using Master Theorem"
            );
            break;
          case "dynamic_programming":
            enhancements.guidingQuestions.push(
              "What is the optimal substructure?",
              "Are there overlapping subproblems?",
              "What is the recurrence relation?"
            );
            if (thought.dpFormulation) {
              enhancements.suggestions.push(
                `State space: ${thought.dpFormulation.recursiveDefinition.stateSpace}`,
                `Complexity: ${thought.dpFormulation.complexity.total}`
              );
            }
            break;
          case "greedy_choice":
            enhancements.guidingQuestions.push(
              "What is the greedy choice?",
              "Why is the greedy choice safe?",
              "Is there optimal substructure?"
            );
            if (thought.greedyProof) {
              enhancements.suggestions.push(
                "Greedy choice property verified"
              );
            }
            break;
          case "amortized_analysis":
            enhancements.guidingQuestions.push(
              "Which method: aggregate, accounting, or potential?",
              "What is the amortized cost per operation?",
              "Is the credit/potential always non-negative?"
            );
            if (thought.amortizedAnalysis) {
              enhancements.suggestions.push(
                `Method: ${thought.amortizedAnalysis.method}`,
                `Amortized cost: ${thought.amortizedAnalysis.result}`
              );
            }
            break;
          case "graph_traversal":
          case "shortest_path":
          case "minimum_spanning_tree":
          case "network_flow":
            if (thought.graphContext) {
              enhancements.metrics.graphType = thought.graphContext.graphType;
              enhancements.metrics.weighted = thought.graphContext.weighted ? 1 : 0;
              enhancements.suggestions.push(
                `Graph: ${thought.graphContext.graphType}, ${thought.graphContext.weighted ? "weighted" : "unweighted"}`
              );
            }
            break;
        }
        if (thought.designPattern) {
          enhancements.metrics.designPattern = thought.designPattern;
          enhancements.suggestions.push(`Design pattern: ${thought.designPattern}`);
        }
        if (thought.clrsAlgorithm) {
          enhancements.suggestions.push(`CLRS Algorithm: ${thought.clrsAlgorithm}`);
        }
        if (thought.clrsCategory) {
          enhancements.metrics.clrsCategory = thought.clrsCategory;
        }
        if (thought.comparison) {
          enhancements.metrics.alternativeCount = thought.comparison.algorithms.length;
        }
        if (thought.keyInsight) {
          enhancements.suggestions.push(`Key insight: ${thought.keyInsight}`);
        }
        if (thought.uncertainty > 0.7) {
          enhancements.warnings.push(
            "High uncertainty - verify analysis carefully"
          );
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Resolve thought type from input
       */
      resolveThoughtType(inputType) {
        if (inputType && VALID_THOUGHT_TYPES7.includes(inputType)) {
          return inputType;
        }
        return "algorithm_definition";
      }
      /**
       * Normalize time complexity
       */
      normalizeTimeComplexity(tc) {
        return {
          bestCase: tc.bestCase || "\u03A9(1)",
          averageCase: tc.averageCase || tc.worstCase || "O(n)",
          worstCase: tc.worstCase || "O(n)",
          amortized: tc.amortized,
          recurrence: tc.recurrence,
          closedForm: tc.closedForm,
          masterTheorem: tc.masterTheorem,
          inputSensitive: tc.inputSensitive
        };
      }
      /**
       * Normalize space complexity
       */
      normalizeSpaceComplexity(sc) {
        return {
          auxiliary: sc.auxiliary || "O(1)",
          total: sc.total || sc.auxiliary || "O(n)",
          inPlace: sc.inPlace ?? false,
          stackDepth: sc.stackDepth,
          cacheEfficiency: sc.cacheEfficiency
        };
      }
      /**
       * Normalize correctness proof
       */
      normalizeCorrectnessProof(proof) {
        return {
          id: proof.id || randomUUID(),
          algorithm: proof.algorithm || "",
          method: proof.method || "loop_invariant",
          preconditions: proof.preconditions || [],
          postconditions: proof.postconditions || [],
          invariants: proof.invariants,
          inductionBase: proof.inductionBase,
          inductionStep: proof.inductionStep,
          terminationArgument: proof.terminationArgument || {
            decreasingQuantity: "",
            lowerBound: "",
            proof: ""
          },
          proofSteps: proof.proofSteps || [],
          keyInsights: proof.keyInsights || []
        };
      }
      /**
       * Normalize DP formulation
       */
      normalizeDPFormulation(dp) {
        return {
          id: dp.id || randomUUID(),
          problem: dp.problem || "",
          characterization: dp.characterization || {
            optimalSubstructure: "",
            subproblemDefinition: ""
          },
          recursiveDefinition: dp.recursiveDefinition || {
            stateSpace: "",
            recurrence: "",
            baseCases: []
          },
          computationOrder: dp.computationOrder || {
            direction: "bottom_up",
            fillOrder: ""
          },
          reconstruction: dp.reconstruction || {
            method: "",
            traceback: ""
          },
          complexity: dp.complexity || {
            states: "",
            transitionCost: "",
            total: ""
          },
          optimizations: dp.optimizations
        };
      }
      /**
       * Normalize greedy proof
       */
      normalizeGreedyProof(proof) {
        return {
          id: proof.id || randomUUID(),
          problem: proof.problem || "",
          greedyChoice: proof.greedyChoice || {
            description: "",
            localOptimum: "",
            globalOptimumProof: ""
          },
          optimalSubstructure: proof.optimalSubstructure || {
            description: "",
            proof: ""
          },
          exchangeArgument: proof.exchangeArgument,
          matroid: proof.matroid
        };
      }
      /**
       * Validate DP formulation
       */
      validateDPFormulation(dp) {
        const warnings = [];
        if (!dp.recursiveDefinition?.recurrence) {
          warnings.push(
            createValidationWarning(
              "dpFormulation.recursiveDefinition.recurrence",
              "DP formulation without recurrence relation",
              "Specify the recurrence that defines optimal value"
            )
          );
        }
        if (!dp.recursiveDefinition?.baseCases || dp.recursiveDefinition.baseCases.length === 0) {
          warnings.push(
            createValidationWarning(
              "dpFormulation.recursiveDefinition.baseCases",
              "No base cases specified",
              "Define base cases for the recurrence"
            )
          );
        }
        if (!dp.characterization?.optimalSubstructure) {
          warnings.push(
            createValidationWarning(
              "dpFormulation.characterization.optimalSubstructure",
              "Optimal substructure not characterized",
              "Prove that optimal solution contains optimal subproblem solutions"
            )
          );
        }
        return warnings;
      }
      /**
       * Validate correctness proof
       */
      validateCorrectnessProof(proof) {
        const warnings = [];
        if (!proof.preconditions || proof.preconditions.length === 0) {
          warnings.push(
            createValidationWarning(
              "correctnessProof.preconditions",
              "No preconditions specified",
              "Define what the algorithm expects as input"
            )
          );
        }
        if (!proof.postconditions || proof.postconditions.length === 0) {
          warnings.push(
            createValidationWarning(
              "correctnessProof.postconditions",
              "No postconditions specified",
              "Define what the algorithm guarantees as output"
            )
          );
        }
        if (!proof.terminationArgument || !proof.terminationArgument.decreasingQuantity) {
          warnings.push(
            createValidationWarning(
              "correctnessProof.terminationArgument",
              "No termination argument",
              "Prove that the algorithm terminates"
            )
          );
        }
        if (proof.method === "loop_invariant" && (!proof.invariants || proof.invariants.length === 0)) {
          warnings.push(
            createValidationWarning(
              "correctnessProof.invariants",
              "Loop invariant method without invariants",
              "Define the loop invariant(s)"
            )
          );
        }
        return warnings;
      }
    };
  }
});
var VALID_META_ACTIONS, MetaReasoningHandler;
var init_MetaReasoningHandler = __esm({
  "src/modes/handlers/MetaReasoningHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    VALID_META_ACTIONS = ["CONTINUE", "SWITCH", "REFINE", "COMBINE"];
    MetaReasoningHandler = class {
      mode = "metareasoning" /* METAREASONING */;
      modeName = "Meta-Reasoning";
      description = "Reasoning about reasoning itself - strategy monitoring and optimization";
      /**
       * Supported thought types for meta-reasoning mode
       */
      supportedThoughtTypes = [
        "strategy_evaluation",
        "mode_switch",
        "resource_allocation",
        "quality_assessment",
        "progress_monitoring",
        "strategy_recommendation"
      ];
      /**
       * Create a meta-reasoning thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const currentStrategy = this.normalizeCurrentStrategy(inputAny.currentStrategy, sessionId);
        const strategyEvaluation = this.normalizeStrategyEvaluation(inputAny.strategyEvaluation);
        const alternativeStrategies = (inputAny.alternativeStrategies || []).map(
          (s) => this.normalizeAlternativeStrategy(s)
        );
        const recommendation = inputAny.recommendation ? this.normalizeRecommendation(inputAny.recommendation) : this.generateRecommendation(strategyEvaluation, alternativeStrategies);
        const resourceAllocation = this.normalizeResourceAllocation(inputAny.resourceAllocation, input);
        const qualityMetrics = this.normalizeQualityMetrics(inputAny.qualityMetrics);
        const sessionContext = this.normalizeSessionContext(inputAny.sessionContext, sessionId);
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          mode: "metareasoning" /* METAREASONING */,
          // Core meta-reasoning fields
          currentStrategy,
          strategyEvaluation,
          alternativeStrategies,
          recommendation,
          resourceAllocation,
          qualityMetrics,
          sessionContext,
          // Revision tracking
          isRevision: input.isRevision,
          revisesThought: input.revisesThought
        };
      }
      /**
       * Validate meta-reasoning-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        if (!inputAny.currentStrategy) {
          warnings.push(
            createValidationWarning(
              "currentStrategy",
              "No current strategy specified",
              "Describe the current reasoning strategy being evaluated"
            )
          );
        }
        if (inputAny.strategyEvaluation) {
          const se = inputAny.strategyEvaluation;
          const scoreFields = ["effectiveness", "efficiency", "confidence", "qualityScore"];
          for (const field of scoreFields) {
            if (se[field] !== void 0 && (se[field] < 0 || se[field] > 1)) {
              warnings.push(
                createValidationWarning(
                  `strategyEvaluation.${field}`,
                  `${field} (${se[field]}) should be between 0 and 1`,
                  "Normalize scores to [0, 1] range"
                )
              );
            }
          }
        }
        if (inputAny.recommendation?.action && !VALID_META_ACTIONS.includes(inputAny.recommendation.action)) {
          warnings.push(
            createValidationWarning(
              "recommendation.action",
              `Unknown action: ${inputAny.recommendation.action}`,
              `Valid actions: ${VALID_META_ACTIONS.join(", ")}`
            )
          );
        }
        if (inputAny.recommendation?.action === "SWITCH" && (!inputAny.alternativeStrategies || inputAny.alternativeStrategies.length === 0)) {
          warnings.push(
            createValidationWarning(
              "alternativeStrategies",
              "SWITCH recommended but no alternatives provided",
              "Include alternative strategies to switch to"
            )
          );
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get meta-reasoning-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["hybrid" /* HYBRID */, "sequential" /* SEQUENTIAL */],
          guidingQuestions: [],
          warnings: [],
          metrics: {
            effectiveness: thought.strategyEvaluation.effectiveness,
            efficiency: thought.strategyEvaluation.efficiency,
            confidence: thought.strategyEvaluation.confidence,
            qualityScore: thought.strategyEvaluation.qualityScore,
            alternativeCount: thought.alternativeStrategies.length
          },
          mentalModels: [
            "Metacognition",
            "Strategy Selection",
            "Resource Allocation",
            "Progress Monitoring",
            "Cognitive Load Management"
          ]
        };
        enhancements.suggestions.push(
          `Current strategy: ${thought.currentStrategy.mode} (${thought.currentStrategy.approach})`
        );
        enhancements.metrics.thoughtsSpent = thought.currentStrategy.thoughtsSpent;
        if (thought.strategyEvaluation.effectiveness < 0.4) {
          enhancements.warnings.push(
            "Low effectiveness - consider switching strategies"
          );
        } else if (thought.strategyEvaluation.effectiveness > 0.8) {
          enhancements.suggestions.push(
            "\u2713 Current strategy is highly effective"
          );
        }
        if (thought.strategyEvaluation.efficiency < 0.4) {
          enhancements.warnings.push(
            "Low efficiency - consider more direct approaches"
          );
        }
        if (thought.strategyEvaluation.issues.length > 0) {
          enhancements.warnings.push(
            `Issues identified: ${thought.strategyEvaluation.issues.slice(0, 2).join(", ")}`
          );
        }
        if (thought.strategyEvaluation.strengths.length > 0) {
          enhancements.suggestions.push(
            `Strengths: ${thought.strategyEvaluation.strengths.slice(0, 2).join(", ")}`
          );
        }
        enhancements.suggestions.push(
          `Recommendation: ${thought.recommendation.action} (confidence: ${(thought.recommendation.confidence * 100).toFixed(0)}%)`
        );
        if (thought.recommendation.action === "SWITCH" && thought.recommendation.targetMode) {
          enhancements.suggestions.push(
            `Switch to: ${thought.recommendation.targetMode}`
          );
        }
        if (thought.alternativeStrategies.length > 0) {
          const bestAlt = thought.alternativeStrategies.reduce(
            (a, b) => a.recommendationScore > b.recommendationScore ? a : b
          );
          enhancements.suggestions.push(
            `Best alternative: ${bestAlt.mode} (score: ${(bestAlt.recommendationScore * 100).toFixed(0)}%)`
          );
        }
        enhancements.metrics.complexityLevel = thought.resourceAllocation.complexityLevel;
        enhancements.metrics.urgency = thought.resourceAllocation.urgency;
        enhancements.metrics.thoughtsRemaining = thought.resourceAllocation.thoughtsRemaining;
        if (thought.resourceAllocation.thoughtsRemaining < 3) {
          enhancements.warnings.push(
            "Few thoughts remaining - focus on conclusions"
          );
        }
        enhancements.metrics.overallQuality = thought.qualityMetrics.overallQuality;
        if (thought.qualityMetrics.logicalConsistency < 0.6) {
          enhancements.warnings.push(
            "Low logical consistency - review reasoning chain"
          );
        }
        if (thought.qualityMetrics.completeness < 0.5) {
          enhancements.warnings.push(
            "Low completeness - ensure all aspects are addressed"
          );
        }
        enhancements.guidingQuestions = [
          "Is the current strategy making progress toward the goal?",
          "Would a different reasoning mode be more effective here?",
          "Are we allocating cognitive effort optimally?",
          "What are the key insights so far?",
          "What remains to be addressed?"
        ];
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Normalize current strategy
       */
      normalizeCurrentStrategy(strategy, _sessionId) {
        return {
          mode: strategy?.mode || "sequential" /* SEQUENTIAL */,
          approach: strategy?.approach || "default",
          startedAt: strategy?.startedAt ? new Date(strategy.startedAt) : /* @__PURE__ */ new Date(),
          thoughtsSpent: strategy?.thoughtsSpent || 0,
          progressIndicators: strategy?.progressIndicators || []
        };
      }
      /**
       * Normalize strategy evaluation
       */
      normalizeStrategyEvaluation(evaluation) {
        return {
          effectiveness: this.clamp(evaluation?.effectiveness ?? 0.5),
          efficiency: this.clamp(evaluation?.efficiency ?? 0.5),
          confidence: this.clamp(evaluation?.confidence ?? 0.5),
          progressRate: evaluation?.progressRate ?? 0,
          qualityScore: this.clamp(evaluation?.qualityScore ?? 0.5),
          issues: evaluation?.issues || [],
          strengths: evaluation?.strengths || []
        };
      }
      /**
       * Normalize alternative strategy
       */
      normalizeAlternativeStrategy(alt) {
        return {
          mode: alt.mode || "sequential" /* SEQUENTIAL */,
          reasoning: alt.reasoning || "",
          expectedBenefit: alt.expectedBenefit || "",
          switchingCost: this.clamp(alt.switchingCost ?? 0.3),
          recommendationScore: this.clamp(alt.recommendationScore ?? 0.5)
        };
      }
      /**
       * Normalize recommendation
       */
      normalizeRecommendation(rec) {
        return {
          action: VALID_META_ACTIONS.includes(rec.action) ? rec.action : "CONTINUE",
          targetMode: rec.targetMode,
          justification: rec.justification || "",
          confidence: this.clamp(rec.confidence ?? 0.5),
          expectedImprovement: rec.expectedImprovement || ""
        };
      }
      /**
       * Generate recommendation from evaluation
       */
      generateRecommendation(evaluation, alternatives) {
        if (evaluation.effectiveness > 0.7 && evaluation.efficiency > 0.5) {
          return {
            action: "CONTINUE",
            justification: "Current strategy is effective and efficient",
            confidence: evaluation.effectiveness,
            expectedImprovement: "Maintain current progress"
          };
        }
        const bestAlt = alternatives.reduce(
          (a, b) => (a?.recommendationScore || 0) > (b?.recommendationScore || 0) ? a : b,
          null
        );
        if (bestAlt && bestAlt.recommendationScore > evaluation.effectiveness + 0.2) {
          return {
            action: "SWITCH",
            targetMode: bestAlt.mode,
            justification: `${bestAlt.mode} offers higher expected benefit`,
            confidence: bestAlt.recommendationScore,
            expectedImprovement: bestAlt.expectedBenefit
          };
        }
        if (evaluation.effectiveness < 0.5) {
          return {
            action: "REFINE",
            justification: "Current strategy needs adjustment",
            confidence: 0.6,
            expectedImprovement: "Address identified issues"
          };
        }
        return {
          action: "CONTINUE",
          justification: "No clear reason to change strategy",
          confidence: 0.5,
          expectedImprovement: "Gradual progress expected"
        };
      }
      /**
       * Normalize resource allocation
       */
      normalizeResourceAllocation(alloc, input) {
        return {
          timeSpent: alloc?.timeSpent ?? 0,
          thoughtsRemaining: alloc?.thoughtsRemaining ?? input.totalThoughts - input.thoughtNumber,
          complexityLevel: alloc?.complexityLevel || "medium",
          urgency: alloc?.urgency || "medium",
          recommendation: alloc?.recommendation || "Maintain balanced effort allocation"
        };
      }
      /**
       * Normalize quality metrics
       */
      normalizeQualityMetrics(metrics) {
        return {
          logicalConsistency: this.clamp(metrics?.logicalConsistency ?? 0.7),
          evidenceQuality: this.clamp(metrics?.evidenceQuality ?? 0.6),
          completeness: this.clamp(metrics?.completeness ?? 0.5),
          originality: this.clamp(metrics?.originality ?? 0.5),
          clarity: this.clamp(metrics?.clarity ?? 0.7),
          overallQuality: this.clamp(metrics?.overallQuality ?? ((metrics?.logicalConsistency || 0.7) + (metrics?.evidenceQuality || 0.6) + (metrics?.completeness || 0.5) + (metrics?.clarity || 0.7)) / 4)
        };
      }
      /**
       * Normalize session context
       */
      normalizeSessionContext(context, sessionId) {
        return {
          sessionId: context?.sessionId || sessionId,
          totalThoughts: context?.totalThoughts || 0,
          modesUsed: context?.modesUsed || [],
          modeSwitches: context?.modeSwitches || 0,
          problemType: context?.problemType || "unknown",
          historicalEffectiveness: context?.historicalEffectiveness
        };
      }
      /**
       * Clamp value to [0, 1] range
       */
      clamp(value) {
        return Math.max(0, Math.min(1, value));
      }
    };
  }
});
var VALID_THOUGHT_TYPES8, VALID_STRATEGIES2, RecursiveHandler;
var init_RecursiveHandler = __esm({
  "src/modes/handlers/RecursiveHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    VALID_THOUGHT_TYPES8 = [
      "problem_decomposition",
      "base_case_identification",
      "recursive_step",
      "subproblem_solution",
      "solution_combination",
      "termination_analysis"
    ];
    VALID_STRATEGIES2 = [
      "divide_and_conquer",
      "decrease_and_conquer",
      "transform_and_conquer",
      "dynamic_programming"
    ];
    RecursiveHandler = class {
      mode = "recursive" /* RECURSIVE */;
      modeName = "Recursive Reasoning";
      description = "Problem decomposition, base case identification, and recursive solution construction";
      /**
       * Supported thought types for recursive mode
       */
      supportedThoughtTypes = [...VALID_THOUGHT_TYPES8];
      /**
       * Create a recursive thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const thoughtType = this.resolveThoughtType(inputAny.thoughtType);
        const subproblems = inputAny.subproblems ? inputAny.subproblems.map((s) => this.normalizeSubproblem(s, 0)) : void 0;
        const baseCases = inputAny.baseCases ? inputAny.baseCases.map((b) => this.normalizeBaseCase(b)) : void 0;
        const baseCaseReached = inputAny.baseCaseReached ?? (baseCases?.some((b) => b.verified) || false);
        const recurrence = inputAny.recurrence ? this.normalizeRecurrence(inputAny.recurrence) : void 0;
        const strategy = this.resolveStrategy(inputAny.strategy);
        const currentDepth = inputAny.currentDepth ?? this.calculateCurrentDepth(subproblems);
        const maxDepth = inputAny.maxDepth ?? Math.max(10, currentDepth + 5);
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          mode: "recursive" /* RECURSIVE */,
          // Core recursive fields
          thoughtType,
          subproblems,
          currentDepth,
          maxDepth,
          baseCases,
          baseCaseReached,
          recurrence,
          strategy,
          divisionFactor: inputAny.divisionFactor,
          // Revision tracking
          isRevision: input.isRevision,
          revisesThought: input.revisesThought
        };
      }
      /**
       * Validate recursive-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        if (inputAny.thoughtType && !VALID_THOUGHT_TYPES8.includes(inputAny.thoughtType)) {
          warnings.push(
            createValidationWarning(
              "thoughtType",
              `Unknown thought type: ${inputAny.thoughtType}`,
              `Valid types: ${VALID_THOUGHT_TYPES8.join(", ")}`
            )
          );
        }
        if (inputAny.strategy && !VALID_STRATEGIES2.includes(inputAny.strategy)) {
          warnings.push(
            createValidationWarning(
              "strategy",
              `Unknown strategy: ${inputAny.strategy}`,
              `Valid strategies: ${VALID_STRATEGIES2.join(", ")}`
            )
          );
        }
        if (inputAny.currentDepth !== void 0 && inputAny.maxDepth !== void 0) {
          if (inputAny.currentDepth > inputAny.maxDepth) {
            warnings.push(
              createValidationWarning(
                "currentDepth",
                `Current depth (${inputAny.currentDepth}) exceeds max depth (${inputAny.maxDepth})`,
                "Recursion may be too deep - check for infinite recursion"
              )
            );
          }
        }
        if (inputAny.thoughtType === "solution_combination") {
          if (!inputAny.baseCases || inputAny.baseCases.length === 0) {
            warnings.push(
              createValidationWarning(
                "baseCases",
                "Solution combination without base cases",
                "Define base cases for proper recursion termination"
              )
            );
          }
        }
        if (inputAny.thoughtType === "problem_decomposition") {
          if (!inputAny.subproblems || inputAny.subproblems.length === 0) {
            warnings.push(
              createValidationWarning(
                "subproblems",
                "Problem decomposition without subproblems",
                "Identify subproblems for divide-and-conquer approach"
              )
            );
          }
        }
        if (inputAny.divisionFactor !== void 0 && inputAny.divisionFactor < 2) {
          warnings.push(
            createValidationWarning(
              "divisionFactor",
              `Division factor (${inputAny.divisionFactor}) should be >= 2`,
              "Typical values are 2 (binary) or 3 (ternary)"
            )
          );
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get recursive-specific enhancements
       */
      getEnhancements(thought) {
        const recThought = thought;
        const enhancements = {
          suggestions: [],
          relatedModes: ["algorithmic" /* ALGORITHMIC */, "mathematics" /* MATHEMATICS */, "optimization" /* OPTIMIZATION */],
          guidingQuestions: [],
          warnings: [],
          metrics: {
            currentDepth: recThought.currentDepth,
            maxDepth: recThought.maxDepth,
            subproblemCount: recThought.subproblems?.length || 0,
            baseCaseCount: recThought.baseCases?.length || 0,
            baseCaseReached: recThought.baseCaseReached ? 1 : 0
          },
          mentalModels: [
            "Divide and Conquer",
            "Mathematical Induction",
            "Tree Traversal",
            "Master Theorem",
            "Recursive Problem Structure"
          ]
        };
        enhancements.suggestions.push(`Strategy: ${recThought.strategy.replace(/_/g, " ")}`);
        switch (recThought.thoughtType) {
          case "problem_decomposition":
            enhancements.guidingQuestions.push(
              "Can this problem be divided into smaller similar problems?",
              "What is the relationship between subproblems?",
              "Is there overlap between subproblems (memoization opportunity)?"
            );
            if (recThought.subproblems) {
              const pendingCount = recThought.subproblems.filter((s) => s.status === "pending").length;
              const solvedCount = recThought.subproblems.filter((s) => s.status === "solved").length;
              enhancements.suggestions.push(
                `Subproblems: ${solvedCount} solved, ${pendingCount} pending`
              );
            }
            break;
          case "base_case_identification":
            enhancements.guidingQuestions.push(
              "What are the smallest/simplest instances of the problem?",
              "Can all base cases be solved directly?",
              "Do base cases cover all termination conditions?"
            );
            if (recThought.baseCases) {
              const verifiedCount = recThought.baseCases.filter((b) => b.verified).length;
              enhancements.suggestions.push(
                `Base cases: ${verifiedCount}/${recThought.baseCases.length} verified`
              );
            }
            break;
          case "recursive_step":
            enhancements.guidingQuestions.push(
              "How do we reduce the problem to smaller instances?",
              "Is progress guaranteed toward base case?",
              "What is the recurrence relation?"
            );
            if (recThought.recurrence) {
              enhancements.suggestions.push(`Recurrence: ${recThought.recurrence.formula}`);
              if (recThought.recurrence.closedForm) {
                enhancements.suggestions.push(`Closed form: ${recThought.recurrence.closedForm}`);
              }
            }
            break;
          case "subproblem_solution":
            enhancements.guidingQuestions.push(
              "Does the subproblem solution satisfy requirements?",
              "Can this solution be reused (memoization)?",
              "What is the time/space cost of this solution?"
            );
            break;
          case "solution_combination":
            enhancements.guidingQuestions.push(
              "How are subproblem solutions combined?",
              "Is the combination step efficient?",
              "Does the combined solution maintain correctness?"
            );
            if (recThought.divisionFactor) {
              enhancements.suggestions.push(`Division factor: ${recThought.divisionFactor}`);
            }
            break;
          case "termination_analysis":
            enhancements.guidingQuestions.push(
              "Is termination guaranteed for all inputs?",
              "What is the maximum recursion depth?",
              "Are there potential stack overflow risks?"
            );
            if (recThought.recurrence?.complexity) {
              enhancements.suggestions.push(`Time complexity: ${recThought.recurrence.complexity}`);
            }
            break;
        }
        if (recThought.currentDepth > recThought.maxDepth * 0.8) {
          enhancements.warnings.push(
            `High recursion depth (${recThought.currentDepth}/${recThought.maxDepth}) - nearing limit`
          );
        }
        if (!recThought.baseCaseReached && recThought.currentDepth > 0) {
          if (!recThought.baseCases || recThought.baseCases.length === 0) {
            enhancements.warnings.push("No base cases defined - ensure termination condition exists");
          }
        }
        if (recThought.strategy === "dynamic_programming") {
          enhancements.suggestions.push("Consider memoization to avoid redundant computation");
          enhancements.relatedModes.push("optimization" /* OPTIMIZATION */);
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Resolve thought type from input
       */
      resolveThoughtType(inputType) {
        if (inputType && VALID_THOUGHT_TYPES8.includes(inputType)) {
          return inputType;
        }
        return "problem_decomposition";
      }
      /**
       * Resolve strategy from input
       */
      resolveStrategy(inputStrategy) {
        if (inputStrategy && VALID_STRATEGIES2.includes(inputStrategy)) {
          return inputStrategy;
        }
        return "divide_and_conquer";
      }
      /**
       * Normalize subproblem
       */
      normalizeSubproblem(sub, defaultDepth) {
        return {
          id: sub.id || randomUUID(),
          name: sub.name || "",
          description: sub.description || "",
          size: sub.size ?? "unknown",
          depth: sub.depth ?? defaultDepth,
          parentId: sub.parentId,
          status: sub.status || "pending",
          result: sub.result
        };
      }
      /**
       * Normalize base case
       */
      normalizeBaseCase(baseCase) {
        return {
          id: baseCase.id || randomUUID(),
          condition: baseCase.condition || "",
          result: baseCase.result || "",
          verified: baseCase.verified ?? false
        };
      }
      /**
       * Normalize recurrence relation
       */
      normalizeRecurrence(rec) {
        return {
          formula: rec.formula || "",
          baseCase: rec.baseCase || "",
          closedForm: rec.closedForm,
          complexity: rec.complexity
        };
      }
      /**
       * Calculate current depth from subproblems
       */
      calculateCurrentDepth(subproblems) {
        if (!subproblems || subproblems.length === 0) {
          return 0;
        }
        return Math.max(...subproblems.map((s) => s.depth ?? 0)) + 1;
      }
    };
  }
});
var VALID_THOUGHT_TYPES9, VALID_LOGIC_SYSTEMS, VALID_MODAL_DOMAINS, ModalHandler;
var init_ModalHandler = __esm({
  "src/modes/handlers/ModalHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    VALID_THOUGHT_TYPES9 = [
      "world_definition",
      "proposition_analysis",
      "accessibility_analysis",
      "necessity_proof",
      "possibility_proof",
      "modal_inference",
      "countermodel"
    ];
    VALID_LOGIC_SYSTEMS = ["K", "T", "S4", "S5", "D", "B", "custom"];
    VALID_MODAL_DOMAINS = ["alethic", "epistemic", "deontic", "temporal"];
    ModalHandler = class {
      mode = "modal" /* MODAL */;
      modeName = "Modal Reasoning";
      description = "Reasoning about necessity, possibility, and possible worlds semantics";
      /**
       * Supported thought types for modal mode
       */
      supportedThoughtTypes = [...VALID_THOUGHT_TYPES9];
      /**
       * Create a modal thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const thoughtType = this.resolveThoughtType(inputAny.thoughtType);
        const worlds = (inputAny.worlds || []).map((w) => this.normalizeWorld(w));
        if (worlds.length === 0) {
          worlds.push(this.createDefaultWorld());
        }
        const actualWorld = inputAny.actualWorld || worlds.find((w) => w.isActual)?.id || worlds[0].id;
        const propositions = (inputAny.propositions || []).map(
          (p) => this.normalizeProposition(p, worlds)
        );
        const accessibilityRelations = (inputAny.accessibilityRelations || []).map(
          (r) => this.normalizeAccessibilityRelation(r, inputAny.modalDomain || "alethic")
        );
        const inferences = inputAny.inferences ? inputAny.inferences.map((i) => this.normalizeInference(i)) : void 0;
        const modalLogicType = this.resolveLogicSystem(inputAny.modalLogicType);
        const modalDomain = this.resolveModalDomain(inputAny.modalDomain);
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          mode: "modal" /* MODAL */,
          // Core modal fields
          thoughtType,
          worlds,
          actualWorld,
          propositions,
          accessibilityRelations,
          modalLogicType,
          modalDomain,
          inferences,
          // Revision tracking
          isRevision: input.isRevision,
          revisesThought: input.revisesThought
        };
      }
      /**
       * Validate modal-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        if (inputAny.thoughtType && !VALID_THOUGHT_TYPES9.includes(inputAny.thoughtType)) {
          warnings.push(
            createValidationWarning(
              "thoughtType",
              `Unknown thought type: ${inputAny.thoughtType}`,
              `Valid types: ${VALID_THOUGHT_TYPES9.join(", ")}`
            )
          );
        }
        if (inputAny.modalLogicType && !VALID_LOGIC_SYSTEMS.includes(inputAny.modalLogicType)) {
          warnings.push(
            createValidationWarning(
              "modalLogicType",
              `Unknown logic system: ${inputAny.modalLogicType}`,
              `Valid systems: ${VALID_LOGIC_SYSTEMS.join(", ")}`
            )
          );
        }
        if (inputAny.modalDomain && !VALID_MODAL_DOMAINS.includes(inputAny.modalDomain)) {
          warnings.push(
            createValidationWarning(
              "modalDomain",
              `Unknown modal domain: ${inputAny.modalDomain}`,
              `Valid domains: ${VALID_MODAL_DOMAINS.join(", ")}`
            )
          );
        }
        if ((inputAny.thoughtType === "necessity_proof" || inputAny.thoughtType === "possibility_proof") && (!inputAny.worlds || inputAny.worlds.length === 0)) {
          warnings.push(
            createValidationWarning(
              "worlds",
              "Modal proof without defined worlds",
              "Define possible worlds for modal evaluation"
            )
          );
        }
        if (inputAny.accessibilityRelations) {
          const worldIds = new Set((inputAny.worlds || []).map((w) => w.id));
          for (const rel of inputAny.accessibilityRelations) {
            if (rel.fromWorld && !worldIds.has(rel.fromWorld)) {
              warnings.push(
                createValidationWarning(
                  "accessibilityRelations",
                  `Relation references unknown world: ${rel.fromWorld}`,
                  "Ensure all relation endpoints reference defined worlds"
                )
              );
            }
            if (rel.toWorld && !worldIds.has(rel.toWorld)) {
              warnings.push(
                createValidationWarning(
                  "accessibilityRelations",
                  `Relation references unknown world: ${rel.toWorld}`,
                  "Ensure all relation endpoints reference defined worlds"
                )
              );
            }
          }
        }
        if (inputAny.modalLogicType === "S5" && inputAny.worlds && inputAny.worlds.length > 1) {
          if (!inputAny.accessibilityRelations || inputAny.accessibilityRelations.length === 0) {
            warnings.push(
              createValidationWarning(
                "accessibilityRelations",
                "S5 logic requires universal accessibility",
                "All worlds should be mutually accessible in S5"
              )
            );
          }
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get modal-specific enhancements
       */
      getEnhancements(thought) {
        const modalThought = thought;
        const worlds = modalThought.worlds || [];
        const propositions = modalThought.propositions || [];
        const accessibilityRelations = modalThought.accessibilityRelations || [];
        const enhancements = {
          suggestions: [],
          relatedModes: ["formallogic" /* FORMALLOGIC */, "counterfactual" /* COUNTERFACTUAL */, "deductive" /* DEDUCTIVE */],
          guidingQuestions: [],
          warnings: [],
          metrics: {
            worldCount: worlds.length,
            propositionCount: propositions.length,
            relationCount: accessibilityRelations.length,
            inferenceCount: modalThought.inferences?.length || 0
          },
          mentalModels: [
            "Possible Worlds Semantics",
            "Kripke Frames",
            "Necessity vs Possibility",
            "Accessibility Relations",
            "Modal Validity"
          ]
        };
        const logicType = modalThought.modalLogicType || modalThought.logicSystem || "K";
        enhancements.suggestions.push(
          `Logic system: ${logicType} (${modalThought.modalDomain})`
        );
        const systemProperties = this.getLogicSystemProperties(logicType);
        if (systemProperties.length > 0) {
          enhancements.suggestions.push(`Properties: ${systemProperties.join(", ")}`);
        }
        switch (modalThought.thoughtType) {
          case "world_definition":
            enhancements.guidingQuestions.push(
              "What propositions are true in each world?",
              "Which world represents the actual state of affairs?",
              "How are the worlds related (accessibility)?"
            );
            enhancements.suggestions.push(`Defined ${worlds.length} possible world(s)`);
            break;
          case "proposition_analysis":
            enhancements.guidingQuestions.push(
              "Is the proposition necessarily true (true in all accessible worlds)?",
              "Is the proposition possibly true (true in some accessible world)?",
              "Is the proposition contingent (could be true or false)?"
            );
            const necessaryCount = propositions.filter(
              (p) => p.operator === "necessary"
            ).length;
            const possibleCount = propositions.filter(
              (p) => p.operator === "possible"
            ).length;
            enhancements.suggestions.push(
              `Propositions: ${necessaryCount} necessary, ${possibleCount} possible`
            );
            break;
          case "accessibility_analysis":
            enhancements.guidingQuestions.push(
              "Is the accessibility relation reflexive (every world accesses itself)?",
              "Is the relation symmetric (if w1 accesses w2, does w2 access w1)?",
              "Is the relation transitive (if w1\u2192w2\u2192w3, does w1\u2192w3)?"
            );
            break;
          case "necessity_proof":
            enhancements.guidingQuestions.push(
              "Is the proposition true in ALL accessible worlds?",
              "Are there any counterexample worlds?",
              "Does necessity hold under the current logic system?"
            );
            break;
          case "possibility_proof":
            enhancements.guidingQuestions.push(
              "Is the proposition true in AT LEAST ONE accessible world?",
              "Can we construct a world where it holds?",
              "What makes this possibility genuine vs. merely apparent?"
            );
            break;
          case "modal_inference":
            enhancements.guidingQuestions.push(
              "Is the inference valid in the current modal logic?",
              "Does the rule preserve truth across all frames?",
              "Are there countermodels to this inference?"
            );
            if (modalThought.inferences) {
              const validCount = modalThought.inferences.filter((i) => i.valid).length;
              enhancements.suggestions.push(
                `Inferences: ${validCount}/${modalThought.inferences.length} valid`
              );
            }
            break;
          case "countermodel":
            enhancements.guidingQuestions.push(
              "What world/truth-value assignment falsifies the claim?",
              "Are the accessibility relations satisfied?",
              "Is this a minimal countermodel?"
            );
            break;
        }
        switch (modalThought.modalDomain) {
          case "epistemic":
            enhancements.suggestions.push("Epistemic: \u25A1p = agent knows p, \u25C7p = p is compatible with knowledge");
            enhancements.mentalModels.push("Knowledge States", "Belief Revision");
            break;
          case "deontic":
            enhancements.suggestions.push("Deontic: \u25A1p = p is obligatory, \u25C7p = p is permissible");
            enhancements.mentalModels.push("Moral Obligations", "Permission Logic");
            break;
          case "temporal":
            enhancements.suggestions.push("Temporal: \u25A1p = always p, \u25C7p = eventually p");
            enhancements.mentalModels.push("Temporal Ordering", "Future Possibilities");
            break;
          case "alethic":
            enhancements.suggestions.push("Alethic: \u25A1p = necessarily p, \u25C7p = possibly p");
            break;
        }
        if (worlds.length === 1) {
          enhancements.warnings.push(
            "Only one world defined - modal distinctions may collapse"
          );
        }
        if (logicType === "S5" && accessibilityRelations.length > 0) {
          const hasUniversalAccess = this.checkUniversalAccessibility(modalThought);
          if (!hasUniversalAccess) {
            enhancements.warnings.push(
              "S5 requires universal accessibility - not all worlds are connected"
            );
          }
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Resolve thought type from input
       */
      resolveThoughtType(inputType) {
        if (inputType && VALID_THOUGHT_TYPES9.includes(inputType)) {
          return inputType;
        }
        return "proposition_analysis";
      }
      /**
       * Resolve logic system
       */
      resolveLogicSystem(system) {
        if (system && VALID_LOGIC_SYSTEMS.includes(system)) {
          return system;
        }
        return "K";
      }
      /**
       * Resolve modal domain
       */
      resolveModalDomain(domain) {
        if (domain && VALID_MODAL_DOMAINS.includes(domain)) {
          return domain;
        }
        return "alethic";
      }
      /**
       * Get properties of a logic system
       */
      getLogicSystemProperties(system) {
        const properties = {
          K: ["basic modal logic"],
          T: ["reflexive"],
          S4: ["reflexive", "transitive"],
          S5: ["reflexive", "symmetric", "transitive"],
          D: ["serial"],
          B: ["reflexive", "symmetric"],
          custom: ["user-defined"]
        };
        return properties[system] || [];
      }
      /**
       * Create a default world
       */
      createDefaultWorld() {
        return {
          id: randomUUID(),
          name: "w0",
          description: "Actual world",
          propositions: {},
          isActual: true,
          accessibility: []
        };
      }
      /**
       * Normalize world
       */
      normalizeWorld(world) {
        return {
          id: world.id || randomUUID(),
          name: world.name || "",
          description: world.description || "",
          propositions: world.propositions || {},
          isActual: world.isActual ?? false,
          accessibility: world.accessibility || []
        };
      }
      /**
       * Normalize proposition
       */
      normalizeProposition(prop, worlds) {
        const worldsTrue = [];
        const worldsFalse = [];
        for (const world of worlds) {
          if (world.propositions?.[prop.content] === true) {
            worldsTrue.push(world.id);
          } else if (world.propositions?.[prop.content] === false) {
            worldsFalse.push(world.id);
          }
        }
        return {
          id: prop.id || randomUUID(),
          content: prop.content || "",
          operator: prop.operator || "contingent",
          truthValue: prop.truthValue,
          worldsTrue: prop.worldsTrue || worldsTrue,
          worldsFalse: prop.worldsFalse || worldsFalse
        };
      }
      /**
       * Normalize accessibility relation
       */
      normalizeAccessibilityRelation(rel, defaultModalType) {
        return {
          id: rel.id || randomUUID(),
          fromWorld: rel.fromWorld || "",
          toWorld: rel.toWorld || "",
          type: rel.type || "reflexive",
          modalType: rel.modalType || defaultModalType
        };
      }
      /**
       * Normalize inference
       */
      normalizeInference(inf) {
        return {
          id: inf.id || randomUUID(),
          premises: inf.premises || [],
          conclusion: inf.conclusion || "",
          rule: inf.rule || "",
          valid: inf.valid ?? false,
          justification: inf.justification || ""
        };
      }
      /**
       * Check if all worlds are mutually accessible (for S5)
       */
      checkUniversalAccessibility(thought) {
        const worlds = thought.worlds || [];
        const relations = thought.accessibilityRelations || [];
        const worldIds = new Set(worlds.map((w) => w.id));
        const accessMap = /* @__PURE__ */ new Map();
        for (const id of worldIds) {
          accessMap.set(id, /* @__PURE__ */ new Set([id]));
        }
        for (const rel of relations) {
          const fromWorld = rel.fromWorld || "";
          const toWorld = rel.toWorld || "";
          if (fromWorld && accessMap.has(fromWorld)) {
            accessMap.get(fromWorld).add(toWorld);
          }
          if (toWorld && accessMap.has(toWorld)) {
            accessMap.get(toWorld).add(fromWorld);
          }
        }
        for (const w1 of worldIds) {
          for (const w2 of worldIds) {
            if (!accessMap.get(w1)?.has(w2)) {
              return false;
            }
          }
        }
        return true;
      }
    };
  }
});
var VALID_THOUGHT_TYPES10, VALID_PROCESS_TYPES, StochasticHandler;
var init_StochasticHandler = __esm({
  "src/modes/handlers/StochasticHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    VALID_THOUGHT_TYPES10 = [
      "process_definition",
      "transition_analysis",
      "steady_state_analysis",
      "random_variable_definition",
      "monte_carlo_simulation",
      "convergence_analysis",
      "hitting_time_analysis"
    ];
    VALID_PROCESS_TYPES = [
      "discrete_time",
      "continuous_time",
      "random_walk",
      "birth_death",
      "queueing"
    ];
    StochasticHandler = class {
      mode = "stochastic" /* STOCHASTIC */;
      modeName = "Stochastic Reasoning";
      description = "Markov chains, random processes, probabilistic state transitions, and Monte Carlo methods";
      /**
       * Supported thought types for stochastic mode
       */
      supportedThoughtTypes = [...VALID_THOUGHT_TYPES10];
      /**
       * Create a stochastic thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const thoughtType = this.resolveThoughtType(inputAny.thoughtType);
        const markovChain = inputAny.markovChain ? this.normalizeMarkovChain(inputAny.markovChain) : void 0;
        const randomVariables = inputAny.randomVariables ? inputAny.randomVariables.map((rv) => this.normalizeRandomVariable(rv)) : void 0;
        const simulations = inputAny.simulations || inputAny.simulationResults ? (inputAny.simulations || inputAny.simulationResults).map((sr) => this.normalizeSimulationResult(sr)) : void 0;
        const processType = this.resolveProcessType(inputAny.processType);
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          mode: "stochastic" /* STOCHASTIC */,
          // Core stochastic fields
          thoughtType,
          markovChain,
          // Handler's MarkovChain has different shape than types file
          processType,
          randomVariables,
          currentState: inputAny.currentState,
          stateHistory: inputAny.stateHistory,
          stepCount: inputAny.stepCount ?? 0,
          simulations,
          // Revision tracking
          isRevision: input.isRevision,
          revisesThought: input.revisesThought
        };
      }
      /**
       * Validate stochastic-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        if (inputAny.thoughtType && !VALID_THOUGHT_TYPES10.includes(inputAny.thoughtType)) {
          warnings.push(
            createValidationWarning(
              "thoughtType",
              `Unknown thought type: ${inputAny.thoughtType}`,
              `Valid types: ${VALID_THOUGHT_TYPES10.join(", ")}`
            )
          );
        }
        if (inputAny.processType && !VALID_PROCESS_TYPES.includes(inputAny.processType)) {
          warnings.push(
            createValidationWarning(
              "processType",
              `Unknown process type: ${inputAny.processType}`,
              `Valid types: ${VALID_PROCESS_TYPES.join(", ")}`
            )
          );
        }
        if (inputAny.markovChain) {
          const mc = inputAny.markovChain;
          if (mc.states && mc.transitions) {
            const transitionSums = /* @__PURE__ */ new Map();
            for (const t of mc.transitions) {
              const current = transitionSums.get(t.fromState) || 0;
              transitionSums.set(t.fromState, current + (t.probability || 0));
            }
            for (const [state, sum] of transitionSums) {
              if (Math.abs(sum - 1) > 0.01) {
                warnings.push(
                  createValidationWarning(
                    `markovChain.transitions[${state}]`,
                    `Transition probabilities from state "${state}" sum to ${sum.toFixed(3)}, should be 1.0`,
                    "Ensure outgoing transition probabilities sum to 1"
                  )
                );
              }
            }
          }
          if (mc.initialDistribution) {
            const sum = Object.values(mc.initialDistribution).reduce(
              (a, b) => a + b,
              0
            );
            if (Math.abs(sum - 1) > 0.01) {
              warnings.push(
                createValidationWarning(
                  "markovChain.initialDistribution",
                  `Initial distribution sums to ${sum.toFixed(3)}, should be 1.0`,
                  "Normalize initial state probabilities"
                )
              );
            }
          }
        }
        if (inputAny.randomVariables) {
          for (let i = 0; i < inputAny.randomVariables.length; i++) {
            const rv = inputAny.randomVariables[i];
            const issues = this.validateDistributionParameters(rv.distribution, rv.parameters);
            for (const issue of issues) {
              warnings.push(
                createValidationWarning(`randomVariables[${i}]`, issue, "Check distribution parameters")
              );
            }
          }
        }
        if (inputAny.simulationResults) {
          for (let i = 0; i < inputAny.simulationResults.length; i++) {
            const sr = inputAny.simulationResults[i];
            if (sr.iterations !== void 0 && sr.iterations < 100) {
              warnings.push(
                createValidationWarning(
                  `simulationResults[${i}].iterations`,
                  `Low iteration count (${sr.iterations})`,
                  "Use at least 1000 iterations for reliable Monte Carlo estimates"
                )
              );
            }
          }
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get stochastic-specific enhancements
       */
      getEnhancements(thought) {
        const stochThought = thought;
        const thoughtAny = thought;
        const markovChain = thoughtAny.markovChain;
        const enhancements = {
          suggestions: [],
          relatedModes: ["bayesian" /* BAYESIAN */, "optimization" /* OPTIMIZATION */, "temporal" /* TEMPORAL */],
          guidingQuestions: [],
          warnings: [],
          metrics: {
            stateCount: markovChain?.states.length || 0,
            transitionCount: markovChain?.transitions.length || 0,
            randomVariableCount: thoughtAny.randomVariables?.length || 0,
            stepCount: stochThought.stepCount
          },
          mentalModels: [
            "Markov Property",
            "Law of Large Numbers",
            "Central Limit Theorem",
            "Ergodic Theory",
            "Queuing Theory"
          ]
        };
        enhancements.suggestions.push(`Process type: ${stochThought.processType.replace(/_/g, " ")}`);
        switch (stochThought.thoughtType) {
          case "process_definition":
            enhancements.guidingQuestions.push(
              "What are the states of the process?",
              "Are transitions time-homogeneous?",
              "Does the process satisfy the Markov property?"
            );
            if (markovChain) {
              enhancements.suggestions.push(
                `States: ${markovChain.states.length}, Transitions: ${markovChain.transitions.length}`
              );
            }
            break;
          case "transition_analysis":
            enhancements.guidingQuestions.push(
              "What is the probability of transitioning from state A to state B?",
              "Are there absorbing states?",
              "What is the expected number of steps to reach a target state?"
            );
            if (markovChain) {
              const absorbingCount = markovChain.states.filter((s) => s.isAbsorbing).length;
              if (absorbingCount > 0) {
                enhancements.suggestions.push(`Absorbing states: ${absorbingCount}`);
              }
            }
            break;
          case "steady_state_analysis":
            enhancements.guidingQuestions.push(
              "Does a stationary distribution exist?",
              "Is the chain irreducible and aperiodic?",
              "What are the long-run probabilities?"
            );
            if (markovChain) {
              if (markovChain.isErgodic) {
                enhancements.suggestions.push("Chain is ergodic - unique stationary distribution exists");
              } else if (markovChain.isIrreducible === false) {
                enhancements.warnings.push("Chain is reducible - multiple stationary distributions possible");
              }
              if (markovChain.period && markovChain.period > 1) {
                enhancements.warnings.push(
                  `Chain is periodic (period=${markovChain.period}) - no stationary distribution`
                );
              }
            }
            break;
          case "random_variable_definition":
            enhancements.guidingQuestions.push(
              "What is the expected value of the random variable?",
              "What is the variance?",
              "Are there any constraints on the variable?"
            );
            if (thoughtAny.randomVariables) {
              for (const rv of thoughtAny.randomVariables) {
                if (rv.expectedValue !== void 0) {
                  enhancements.suggestions.push(
                    `${rv.name}: E[X] = ${rv.expectedValue.toFixed(4)}, Var[X] = ${rv.variance?.toFixed(4) || "unknown"}`
                  );
                }
              }
            }
            break;
          case "monte_carlo_simulation":
            enhancements.guidingQuestions.push(
              "How many iterations are sufficient?",
              "What is the confidence interval?",
              "Has the simulation converged?"
            );
            if (thoughtAny.simulationResults) {
              for (const sr of thoughtAny.simulationResults) {
                enhancements.suggestions.push(
                  `Simulation (n=${sr.iterations}): mean=${sr.mean.toFixed(4)}, var=${sr.variance.toFixed(4)}`
                );
                if (sr.confidenceInterval) {
                  enhancements.suggestions.push(
                    `95% CI: [${sr.confidenceInterval[0].toFixed(4)}, ${sr.confidenceInterval[1].toFixed(4)}]`
                  );
                }
              }
            }
            break;
          case "convergence_analysis":
            enhancements.guidingQuestions.push(
              "At what rate does the process converge?",
              "Is convergence guaranteed?",
              "What is the mixing time?"
            );
            if (thoughtAny.convergenceRate !== void 0) {
              enhancements.suggestions.push(`Convergence rate: ${thoughtAny.convergenceRate.toFixed(4)}`);
            }
            break;
          case "hitting_time_analysis":
            enhancements.guidingQuestions.push(
              "What is the expected time to reach a target state?",
              "What is the probability of reaching the target before returning to start?",
              "Are there multiple paths to consider?"
            );
            break;
        }
        switch (stochThought.processType) {
          case "queueing":
            enhancements.mentalModels.push("Little's Law", "M/M/1 Queue", "Birth-Death Process");
            enhancements.suggestions.push("Consider arrival rate \u03BB and service rate \u03BC");
            break;
          case "random_walk":
            enhancements.mentalModels.push("Gambler's Ruin", "Recurrence", "Transience");
            break;
          case "birth_death":
            enhancements.mentalModels.push("Population Dynamics", "Balance Equations");
            break;
        }
        if (stochThought.stepCount < 10 && stochThought.thoughtType === "convergence_analysis") {
          enhancements.warnings.push("Low step count - convergence analysis may be unreliable");
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Resolve thought type from input
       */
      resolveThoughtType(inputType) {
        if (inputType && VALID_THOUGHT_TYPES10.includes(inputType)) {
          return inputType;
        }
        return "process_definition";
      }
      /**
       * Resolve process type from input
       */
      resolveProcessType(inputType) {
        if (inputType && VALID_PROCESS_TYPES.includes(inputType)) {
          return inputType;
        }
        return "discrete_time";
      }
      /**
       * Normalize Markov chain
       */
      normalizeMarkovChain(mc) {
        const states = (mc.states || []).map((s) => this.normalizeState(s));
        const transitions = (mc.transitions || []).map((t) => this.normalizeTransition(t));
        const isIrreducible = mc.isIrreducible ?? this.checkIrreducibility(states, transitions);
        const period = mc.period ?? 1;
        const isErgodic = mc.isErgodic ?? (isIrreducible && period === 1);
        return {
          id: mc.id || randomUUID(),
          name: mc.name || "",
          states,
          transitions,
          initialDistribution: mc.initialDistribution || {},
          isErgodic,
          isIrreducible,
          period
        };
      }
      /**
       * Normalize state
       */
      normalizeState(state) {
        return {
          id: state.id || randomUUID(),
          name: state.name || "",
          description: state.description,
          probability: state.probability,
          isAbsorbing: state.isAbsorbing ?? false,
          isTransient: state.isTransient
        };
      }
      /**
       * Normalize transition
       */
      normalizeTransition(transition) {
        return {
          id: transition.id || randomUUID(),
          fromState: transition.fromState || "",
          toState: transition.toState || "",
          probability: Math.max(0, Math.min(1, transition.probability ?? 0)),
          condition: transition.condition
        };
      }
      /**
       * Normalize random variable
       */
      normalizeRandomVariable(rv) {
        const normalized = {
          id: rv.id || randomUUID(),
          name: rv.name || "",
          distribution: rv.distribution || "uniform",
          parameters: rv.parameters || {},
          expectedValue: rv.expectedValue,
          variance: rv.variance
        };
        if (normalized.expectedValue === void 0 || normalized.variance === void 0) {
          const stats = this.calculateDistributionStats(normalized.distribution, normalized.parameters);
          if (normalized.expectedValue === void 0) normalized.expectedValue = stats.mean;
          if (normalized.variance === void 0) normalized.variance = stats.variance;
        }
        return normalized;
      }
      /**
       * Normalize simulation result
       */
      normalizeSimulationResult(sr) {
        return {
          id: sr.id || randomUUID(),
          iterations: sr.iterations || 0,
          mean: sr.mean || 0,
          variance: sr.variance || 0,
          confidenceInterval: sr.confidenceInterval,
          samples: sr.samples
        };
      }
      /**
       * Check if chain is irreducible (simplified check)
       */
      checkIrreducibility(states, transitions) {
        if (states.length === 0) return true;
        if (states.length === 1) return true;
        const adj = /* @__PURE__ */ new Map();
        for (const s of states) {
          adj.set(s.id, /* @__PURE__ */ new Set());
        }
        for (const t of transitions) {
          if (t.probability > 0 && adj.has(t.fromState)) {
            adj.get(t.fromState).add(t.toState);
          }
        }
        const visited = /* @__PURE__ */ new Set();
        const queue = [states[0].id];
        visited.add(states[0].id);
        while (queue.length > 0) {
          const current = queue.shift();
          for (const next of adj.get(current) || []) {
            if (!visited.has(next)) {
              visited.add(next);
              queue.push(next);
            }
          }
        }
        return visited.size === states.length;
      }
      /**
       * Validate distribution parameters
       */
      validateDistributionParameters(distribution, params) {
        const issues = [];
        switch (distribution) {
          case "normal":
          case "gaussian":
            if (params.variance !== void 0 && params.variance < 0) {
              issues.push("Normal distribution variance must be non-negative");
            }
            break;
          case "exponential":
            if (params.lambda !== void 0 && params.lambda <= 0) {
              issues.push("Exponential distribution lambda must be positive");
            }
            break;
          case "poisson":
            if (params.lambda !== void 0 && params.lambda < 0) {
              issues.push("Poisson distribution lambda must be non-negative");
            }
            break;
          case "uniform":
            if (params.a !== void 0 && params.b !== void 0 && params.a >= params.b) {
              issues.push("Uniform distribution requires a < b");
            }
            break;
          case "binomial":
            if (params.n !== void 0 && params.n < 0) {
              issues.push("Binomial n must be non-negative");
            }
            if (params.p !== void 0 && (params.p < 0 || params.p > 1)) {
              issues.push("Binomial p must be in [0, 1]");
            }
            break;
        }
        return issues;
      }
      /**
       * Calculate distribution statistics
       */
      calculateDistributionStats(distribution, params) {
        switch (distribution) {
          case "normal":
          case "gaussian":
            return { mean: params.mu || params.mean || 0, variance: params.variance || params.sigma2 || 1 };
          case "exponential":
            const lambda = params.lambda || params.rate || 1;
            return { mean: 1 / lambda, variance: 1 / (lambda * lambda) };
          case "poisson":
            const poissonLambda = params.lambda || 1;
            return { mean: poissonLambda, variance: poissonLambda };
          case "uniform":
            const a = params.a ?? params.min ?? 0;
            const b = params.b ?? params.max ?? 1;
            return { mean: (a + b) / 2, variance: (b - a) ** 2 / 12 };
          case "binomial":
            const n = params.n || 1;
            const p = params.p || 0.5;
            return { mean: n * p, variance: n * p * (1 - p) };
          default:
            return {};
        }
      }
    };
  }
});
var VALID_THOUGHT_TYPES11, VALID_CONSTRAINT_TYPES, VALID_PRIORITIES, ConstraintHandler;
var init_ConstraintHandler = __esm({
  "src/modes/handlers/ConstraintHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    VALID_THOUGHT_TYPES11 = [
      "problem_formulation",
      "variable_definition",
      "constraint_definition",
      "domain_reduction",
      "arc_consistency",
      "propagation",
      "solution_search",
      "backtracking",
      "feasibility_check"
    ];
    VALID_CONSTRAINT_TYPES = ["unary", "binary", "n_ary", "global"];
    VALID_PRIORITIES = ["required", "soft", "preference"];
    ConstraintHandler = class {
      mode = "constraint" /* CONSTRAINT */;
      modeName = "Constraint Reasoning";
      description = "Constraint satisfaction, domain reduction, propagation, and feasibility analysis";
      /**
       * Supported thought types for constraint mode
       */
      supportedThoughtTypes = [...VALID_THOUGHT_TYPES11];
      /**
       * Create a constraint thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const thoughtType = this.resolveThoughtType(inputAny.thoughtType);
        const variables = (inputAny.variables || []).map((v) => this.normalizeVariable(v));
        const constraints = (inputAny.constraints || inputAny.cspConstraints || []).map(
          (c) => this.normalizeConstraint(c)
        );
        const arcs = inputAny.arcs ? inputAny.arcs.map((a) => this.normalizeArc(a)) : this.generateArcs(variables, constraints);
        const currentAssignments = inputAny.currentAssignments || {};
        const assignmentHistory = (inputAny.assignmentHistory || []).map(
          (a) => this.normalizeAssignment(a)
        );
        const isArcConsistent = inputAny.isArcConsistent ?? this.checkArcConsistency(variables, constraints);
        const solutionStatus = this.determineSolutionStatus(
          inputAny.solutionStatus,
          variables,
          constraints,
          currentAssignments
        );
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          mode: "constraint" /* CONSTRAINT */,
          // Core constraint fields
          thoughtType,
          variables,
          constraints,
          currentAssignments,
          assignmentHistory,
          searchStep: inputAny.searchStep ?? assignmentHistory.length,
          backtracks: inputAny.backtracks ?? assignmentHistory.filter((a) => a.backtracked).length,
          arcs,
          isArcConsistent,
          solutionStatus,
          solutionCount: inputAny.solutionCount ?? 0,
          // Revision tracking
          isRevision: input.isRevision,
          revisesThought: input.revisesThought
        };
      }
      /**
       * Validate constraint-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        if (inputAny.thoughtType && !VALID_THOUGHT_TYPES11.includes(inputAny.thoughtType)) {
          warnings.push(
            createValidationWarning(
              "thoughtType",
              `Unknown thought type: ${inputAny.thoughtType}`,
              `Valid types: ${VALID_THOUGHT_TYPES11.join(", ")}`
            )
          );
        }
        if (inputAny.variables) {
          for (let i = 0; i < inputAny.variables.length; i++) {
            const v = inputAny.variables[i];
            if (!v.domain || v.domain.length === 0) {
              warnings.push(
                createValidationWarning(
                  `variables[${i}].domain`,
                  `Variable "${v.name || v.id}" has empty domain`,
                  "Empty domains indicate infeasibility"
                )
              );
            }
          }
        }
        const varIds = new Set((inputAny.variables || []).map((v) => v.id || v.name));
        const cspConstraints = inputAny.constraints || inputAny.cspConstraints || [];
        for (let i = 0; i < cspConstraints.length; i++) {
          const c = cspConstraints[i];
          if (c.variables) {
            for (const varRef of c.variables) {
              if (!varIds.has(varRef)) {
                warnings.push(
                  createValidationWarning(
                    `constraints[${i}].variables`,
                    `Constraint references unknown variable: ${varRef}`,
                    "Ensure all constraint variables are defined"
                  )
                );
              }
            }
          }
          if (c.type && !VALID_CONSTRAINT_TYPES.includes(c.type)) {
            warnings.push(
              createValidationWarning(
                `constraints[${i}].type`,
                `Unknown constraint type: ${c.type}`,
                `Valid types: ${VALID_CONSTRAINT_TYPES.join(", ")}`
              )
            );
          }
          if (c.priority && !VALID_PRIORITIES.includes(c.priority)) {
            warnings.push(
              createValidationWarning(
                `constraints[${i}].priority`,
                `Unknown priority: ${c.priority}`,
                `Valid priorities: ${VALID_PRIORITIES.join(", ")}`
              )
            );
          }
          if (!c.expression) {
            warnings.push(
              createValidationWarning(
                `constraints[${i}].expression`,
                "Constraint lacks expression",
                "Define the constraint condition"
              )
            );
          }
        }
        if (inputAny.currentAssignments && inputAny.variables) {
          for (const [varId, value] of Object.entries(inputAny.currentAssignments)) {
            const variable = inputAny.variables.find((v) => (v.id || v.name) === varId);
            if (variable && variable.domain && !variable.domain.includes(value)) {
              warnings.push(
                createValidationWarning(
                  `currentAssignments[${varId}]`,
                  `Assigned value ${value} not in domain`,
                  "Assignment violates domain constraint"
                )
              );
            }
          }
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get constraint-specific enhancements
       */
      getEnhancements(thought) {
        const cspThought = thought;
        const enhancements = {
          suggestions: [],
          relatedModes: ["optimization" /* OPTIMIZATION */, "algorithmic" /* ALGORITHMIC */, "formallogic" /* FORMALLOGIC */],
          guidingQuestions: [],
          warnings: [],
          metrics: {
            variableCount: cspThought.variables.length,
            constraintCount: cspThought.constraints.length,
            assignedCount: Object.keys(cspThought.currentAssignments).length,
            backtrackCount: cspThought.backtracks,
            searchStep: cspThought.searchStep || 0,
            solutionCount: cspThought.solutionCount || 0
          },
          mentalModels: [
            "Constraint Propagation",
            "Arc Consistency",
            "Backtracking Search",
            "Domain Reduction",
            "Conflict-Directed Backjumping"
          ]
        };
        enhancements.suggestions.push(`Status: ${cspThought.solutionStatus || "unknown"}`);
        if (cspThought.isArcConsistent) {
          enhancements.suggestions.push("Problem is arc-consistent");
        } else {
          enhancements.warnings.push("Problem is not arc-consistent - consider propagation");
        }
        switch (cspThought.thoughtType) {
          case "problem_formulation":
            enhancements.guidingQuestions.push(
              "What are the decision variables?",
              "What constraints must be satisfied?",
              "Are there any global constraints?"
            );
            break;
          case "variable_definition":
            enhancements.guidingQuestions.push(
              "What is the domain of each variable?",
              "Are domains finite and discrete?",
              "Can domains be reduced initially?"
            );
            const avgDomainSize = cspThought.variables.length > 0 ? cspThought.variables.reduce((sum, v) => sum + v.domain.length, 0) / cspThought.variables.length : 0;
            enhancements.suggestions.push(`Average domain size: ${avgDomainSize.toFixed(1)}`);
            break;
          case "constraint_definition":
            enhancements.guidingQuestions.push(
              "Are all constraints necessary?",
              "Are there redundant constraints?",
              "Can constraints be tightened?"
            );
            const requiredCount = cspThought.constraints.filter((c) => c.priority === "required").length;
            const softCount = cspThought.constraints.length - requiredCount;
            enhancements.suggestions.push(`Constraints: ${requiredCount} required, ${softCount} soft`);
            break;
          case "domain_reduction":
            enhancements.guidingQuestions.push(
              "Which values can be pruned?",
              "Are there singleton domains?",
              "Has propagation been exhausted?"
            );
            const reducedCount = cspThought.variables.filter((v) => v.domainReduced).length;
            enhancements.suggestions.push(`Variables with reduced domains: ${reducedCount}`);
            break;
          case "arc_consistency":
            enhancements.guidingQuestions.push(
              "Are all arcs consistent?",
              "Which arcs need revision?",
              "Has a fixpoint been reached?"
            );
            if (cspThought.arcs) {
              enhancements.suggestions.push(`Arcs: ${cspThought.arcs.length}`);
            }
            break;
          case "propagation":
            enhancements.guidingQuestions.push(
              "What can be inferred from current assignments?",
              "Are there forced assignments?",
              "Can we detect early failure?"
            );
            break;
          case "solution_search":
            enhancements.guidingQuestions.push(
              "Which variable should be assigned next?",
              "What value should be tried first?",
              "Is the current partial solution extensible?"
            );
            const progress = cspThought.variables.length > 0 ? Object.keys(cspThought.currentAssignments).length / cspThought.variables.length * 100 : 0;
            enhancements.suggestions.push(`Search progress: ${progress.toFixed(1)}%`);
            break;
          case "backtracking":
            enhancements.guidingQuestions.push(
              "Why did the current assignment fail?",
              "What is the most recent decision point?",
              "Can we learn from this failure (nogood)?"
            );
            enhancements.suggestions.push(`Backtracks so far: ${cspThought.backtracks}`);
            break;
          case "feasibility_check":
            enhancements.guidingQuestions.push(
              "Is the problem satisfiable?",
              "Are there inconsistent constraints?",
              "What is the minimal unsatisfiable subset?"
            );
            break;
        }
        const emptyDomainVars = cspThought.variables.filter((v) => v.domain.length === 0);
        if (emptyDomainVars.length > 0) {
          enhancements.warnings.push(
            `${emptyDomainVars.length} variable(s) have empty domains - problem is infeasible`
          );
        }
        const searchStep = cspThought.searchStep || 0;
        if (searchStep > 0 && cspThought.backtracks / searchStep > 0.5) {
          enhancements.warnings.push(
            "High backtrack rate - consider better variable/value ordering"
          );
        }
        if (cspThought.thoughtType === "solution_search") {
          enhancements.mentalModels.push(
            "MRV (Minimum Remaining Values)",
            "Degree Heuristic",
            "LCV (Least Constraining Value)"
          );
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Resolve thought type from input
       */
      resolveThoughtType(inputType) {
        if (inputType && VALID_THOUGHT_TYPES11.includes(inputType)) {
          return inputType;
        }
        return "problem_formulation";
      }
      /**
       * Normalize variable
       */
      normalizeVariable(variable) {
        return {
          id: variable.id || randomUUID(),
          name: variable.name || "",
          domain: variable.domain || [],
          currentValue: variable.currentValue,
          domainReduced: variable.domainReduced ?? false,
          assignedAt: variable.assignedAt
        };
      }
      /**
       * Normalize constraint
       */
      normalizeConstraint(constraint) {
        let type = constraint.type;
        if (!type && constraint.variables) {
          const arity = constraint.variables.length;
          if (arity === 1) type = "unary";
          else if (arity === 2) type = "binary";
          else type = "n_ary";
        }
        return {
          id: constraint.id || randomUUID(),
          name: constraint.name || "",
          type: VALID_CONSTRAINT_TYPES.includes(type) ? type : "binary",
          variables: constraint.variables || [],
          expression: constraint.expression || "",
          satisfied: constraint.satisfied,
          priority: VALID_PRIORITIES.includes(constraint.priority) ? constraint.priority : "required",
          weight: constraint.weight
        };
      }
      /**
       * Normalize arc
       */
      normalizeArc(arc) {
        return {
          from: arc.from || "",
          to: arc.to || "",
          constraintId: arc.constraintId || ""
        };
      }
      /**
       * Normalize assignment
       */
      normalizeAssignment(assignment) {
        return {
          variableId: assignment.variableId || "",
          value: assignment.value,
          step: assignment.step || 0,
          backtracked: assignment.backtracked ?? false
        };
      }
      /**
       * Generate arcs from binary constraints
       */
      generateArcs(_variables, constraints) {
        const arcs = [];
        for (const constraint of constraints) {
          if (constraint.type === "binary" && constraint.variables.length === 2) {
            const [v1, v2] = constraint.variables;
            arcs.push({ from: v1, to: v2, constraintId: constraint.id });
            arcs.push({ from: v2, to: v1, constraintId: constraint.id });
          }
        }
        return arcs;
      }
      /**
       * Check basic arc consistency (simplified)
       */
      checkArcConsistency(variables, constraints) {
        for (const v of variables) {
          if (v.domain.length === 0) {
            return false;
          }
        }
        for (const c of constraints) {
          if (c.satisfied === false && c.priority === "required") {
            return false;
          }
        }
        return true;
      }
      /**
       * Determine solution status
       */
      determineSolutionStatus(explicit, variables, constraints, assignments) {
        const validStatuses = ["searching", "found", "infeasible", "timeout"];
        if (explicit && validStatuses.includes(explicit)) {
          return explicit;
        }
        if (variables.some((v) => v.domain.length === 0)) {
          return "infeasible";
        }
        const allAssigned = variables.every((v) => assignments[v.id] !== void 0 || assignments[v.name] !== void 0);
        if (allAssigned && variables.length > 0) {
          const allSatisfied = constraints.filter((c) => c.priority === "required").every((c) => c.satisfied !== false);
          if (allSatisfied) {
            return "found";
          }
        }
        return "searching";
      }
    };
  }
});
var VALID_THOUGHT_TYPES12, VALID_PROBLEM_TYPES, VALID_SOLUTION_TYPES, OptimizationHandler;
var init_OptimizationHandler = __esm({
  "src/modes/handlers/OptimizationHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    VALID_THOUGHT_TYPES12 = [
      "problem_formulation",
      "variable_definition",
      "constraint_identification",
      "objective_setting",
      "solution_search",
      "sensitivity_analysis"
    ];
    VALID_PROBLEM_TYPES = [
      "linear",
      "nonlinear",
      "integer",
      "mixed_integer",
      "constraint_satisfaction",
      "multi_objective"
    ];
    VALID_SOLUTION_TYPES = ["optimal", "feasible", "infeasible", "unbounded", "approximate"];
    OptimizationHandler = class {
      mode = "optimization" /* OPTIMIZATION */;
      modeName = "Optimization Analysis";
      description = "Constraint optimization, objective functions, and solution search";
      /**
       * Supported thought types for optimization mode
       */
      supportedThoughtTypes = [...VALID_THOUGHT_TYPES12];
      /**
       * Create an optimization thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const thoughtType = this.resolveThoughtType(inputAny.thoughtType);
        const problem = inputAny.problem ? this.normalizeProblem(inputAny.problem) : void 0;
        const variables = inputAny.variables ? inputAny.variables.map((v) => this.normalizeVariable(v)) : void 0;
        const optimizationConstraints = inputAny.optimizationConstraints || inputAny.constraints ? (inputAny.optimizationConstraints || inputAny.constraints).map((c) => this.normalizeConstraint(c)) : void 0;
        const objectives = inputAny.objectives ? inputAny.objectives.map((o) => this.normalizeObjective(o)) : void 0;
        const solution = inputAny.solution ? this.normalizeSolution(inputAny.solution, optimizationConstraints) : void 0;
        const analysis = inputAny.analysis ? this.normalizeAnalysis(inputAny.analysis) : void 0;
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          mode: "optimization" /* OPTIMIZATION */,
          // Core optimization fields
          thoughtType,
          problem,
          variables,
          optimizationConstraints,
          objectives,
          solution,
          analysis,
          // Revision tracking
          isRevision: input.isRevision,
          revisesThought: input.revisesThought
        };
      }
      /**
       * Validate optimization-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        if (inputAny.thoughtType && !VALID_THOUGHT_TYPES12.includes(inputAny.thoughtType)) {
          warnings.push(
            createValidationWarning(
              "thoughtType",
              `Unknown thought type: ${inputAny.thoughtType}`,
              `Valid types: ${VALID_THOUGHT_TYPES12.join(", ")}`
            )
          );
        }
        if (inputAny.problem?.type && !VALID_PROBLEM_TYPES.includes(inputAny.problem.type)) {
          warnings.push(
            createValidationWarning(
              "problem.type",
              `Unknown problem type: ${inputAny.problem.type}`,
              `Valid types: ${VALID_PROBLEM_TYPES.join(", ")}`
            )
          );
        }
        if (inputAny.solution?.type && !VALID_SOLUTION_TYPES.includes(inputAny.solution.type)) {
          warnings.push(
            createValidationWarning(
              "solution.type",
              `Unknown solution type: ${inputAny.solution.type}`,
              `Valid types: ${VALID_SOLUTION_TYPES.join(", ")}`
            )
          );
        }
        const constraints = inputAny.optimizationConstraints || inputAny.constraints;
        if (constraints) {
          for (let i = 0; i < constraints.length; i++) {
            const c = constraints[i];
            if (!c.formula) {
              warnings.push(
                createValidationWarning(
                  `constraints[${i}].formula`,
                  "Constraint lacks formula",
                  "Specify the mathematical constraint expression"
                )
              );
            }
          }
        }
        if (inputAny.objectives) {
          let totalWeight = 0;
          for (let i = 0; i < inputAny.objectives.length; i++) {
            const o = inputAny.objectives[i];
            if (!o.formula) {
              warnings.push(
                createValidationWarning(
                  `objectives[${i}].formula`,
                  "Objective lacks formula",
                  "Specify the objective function"
                )
              );
            }
            if (o.weight !== void 0) {
              totalWeight += o.weight;
            }
          }
          if (inputAny.objectives.length > 1 && Math.abs(totalWeight - 1) > 0.01 && totalWeight > 0) {
            warnings.push(
              createValidationWarning(
                "objectives",
                `Objective weights sum to ${totalWeight.toFixed(2)}, should be 1.0`,
                "Normalize weights for multi-objective optimization"
              )
            );
          }
        }
        if (!inputAny.variables && inputAny.thoughtType !== "problem_formulation") {
          warnings.push(
            createValidationWarning(
              "variables",
              "No decision variables defined",
              "Define the variables to be optimized"
            )
          );
        }
        if (!inputAny.objectives && inputAny.thoughtType === "solution_search") {
          warnings.push(
            createValidationWarning(
              "objectives",
              "Solution search without objectives",
              "Define objective functions to optimize"
            )
          );
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get optimization-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["mathematics" /* MATHEMATICS */, "algorithmic" /* ALGORITHMIC */, "engineering" /* ENGINEERING */],
          guidingQuestions: [],
          warnings: [],
          metrics: {
            variableCount: thought.variables?.length || 0,
            constraintCount: thought.optimizationConstraints?.length || 0,
            objectiveCount: thought.objectives?.length || 0
          },
          mentalModels: [
            "Linear Programming",
            "Constraint Satisfaction",
            "Pareto Optimality",
            "Sensitivity Analysis",
            "Lagrangian Relaxation"
          ]
        };
        switch (thought.thoughtType) {
          case "problem_formulation":
            enhancements.guidingQuestions.push(
              "What are we trying to optimize?",
              "What constraints must be satisfied?",
              "Is this a single or multi-objective problem?"
            );
            if (thought.problem) {
              enhancements.suggestions.push(
                `Problem type: ${thought.problem.type}`,
                `Approach: ${thought.problem.approach || "not specified"}`
              );
              if (thought.problem.complexity) {
                enhancements.metrics.complexity = thought.problem.complexity;
              }
            }
            break;
          case "variable_definition":
            enhancements.guidingQuestions.push(
              "Are all decision variables identified?",
              "What are the variable domains?",
              "Are there any implicit variables?"
            );
            if (thought.variables) {
              const types = thought.variables.map((v) => v.type);
              const uniqueTypes = [...new Set(types)];
              enhancements.suggestions.push(
                `Variable types: ${uniqueTypes.join(", ")}`
              );
            }
            break;
          case "constraint_identification":
            enhancements.guidingQuestions.push(
              "Are all constraints identified?",
              "Which constraints are hard vs soft?",
              "Are the constraints consistent?"
            );
            if (thought.optimizationConstraints) {
              const hard = thought.optimizationConstraints.filter((c) => c.type === "hard").length;
              const soft = thought.optimizationConstraints.length - hard;
              enhancements.suggestions.push(
                `Constraints: ${hard} hard, ${soft} soft`
              );
            }
            break;
          case "objective_setting":
            enhancements.guidingQuestions.push(
              "Is the objective function well-defined?",
              "Are there conflicting objectives?",
              "How will trade-offs be handled?"
            );
            if (thought.objectives) {
              const maxCount = thought.objectives.filter((o) => o.type === "maximize").length;
              const minCount = thought.objectives.length - maxCount;
              enhancements.suggestions.push(
                `Objectives: ${maxCount} maximize, ${minCount} minimize`
              );
            }
            break;
          case "solution_search":
            enhancements.guidingQuestions.push(
              "Is the solution feasible?",
              "Is the solution optimal or approximate?",
              "What method was used to find it?"
            );
            if (thought.solution) {
              enhancements.suggestions.push(
                `Solution type: ${thought.solution.type}`
              );
              enhancements.metrics.solutionQuality = thought.solution.quality;
              if (thought.solution.type === "infeasible") {
                enhancements.warnings.push(
                  "Solution is infeasible - check constraint compatibility"
                );
              } else if (thought.solution.type === "unbounded") {
                enhancements.warnings.push(
                  "Problem is unbounded - add missing constraints"
                );
              }
              if (thought.solution.guarantees) {
                enhancements.suggestions.push(
                  `Guarantees: ${thought.solution.guarantees.join(", ")}`
                );
              }
            }
            break;
          case "sensitivity_analysis":
            enhancements.guidingQuestions.push(
              "How robust is the solution?",
              "Which constraints are binding?",
              "What are the shadow prices?"
            );
            if (thought.analysis) {
              enhancements.metrics.robustness = thought.analysis.robustness;
              enhancements.metrics.criticalConstraintCount = thought.analysis.criticalConstraints.length;
              if (thought.analysis.robustness < 0.5) {
                enhancements.warnings.push(
                  "Low solution robustness - small changes may significantly affect results"
                );
              }
              if (thought.analysis.criticalConstraints.length > 0) {
                enhancements.suggestions.push(
                  `Critical constraints: ${thought.analysis.criticalConstraints.length}`
                );
              }
            }
            break;
        }
        if (thought.problem?.type === "multi_objective" && !thought.objectives?.some((o) => o.weight !== void 0)) {
          enhancements.warnings.push(
            "Multi-objective problem without weights - consider Pareto analysis"
          );
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Resolve thought type from input
       */
      resolveThoughtType(inputType) {
        if (inputType && VALID_THOUGHT_TYPES12.includes(inputType)) {
          return inputType;
        }
        return "problem_formulation";
      }
      /**
       * Normalize problem
       */
      normalizeProblem(problem) {
        return {
          id: problem.id || randomUUID(),
          name: problem.name || "",
          description: problem.description || "",
          type: VALID_PROBLEM_TYPES.includes(problem.type) ? problem.type : "linear",
          approach: problem.approach,
          complexity: problem.complexity
        };
      }
      /**
       * Normalize variable
       */
      normalizeVariable(variable) {
        return {
          id: variable.id || randomUUID(),
          name: variable.name || "",
          description: variable.description || "",
          type: variable.type || "continuous",
          domain: variable.domain || { type: "continuous", lowerBound: 0, upperBound: Infinity },
          unit: variable.unit,
          semantics: variable.semantics || ""
        };
      }
      /**
       * Normalize constraint
       */
      normalizeConstraint(constraint) {
        return {
          id: constraint.id || randomUUID(),
          name: constraint.name || "",
          description: constraint.description || "",
          type: constraint.type || "hard",
          formula: constraint.formula || "",
          latex: constraint.latex,
          variables: constraint.variables || [],
          penalty: constraint.penalty,
          rationale: constraint.rationale || "",
          priority: constraint.priority
        };
      }
      /**
       * Normalize objective
       */
      normalizeObjective(objective) {
        return {
          id: objective.id || randomUUID(),
          name: objective.name || "",
          description: objective.description || "",
          type: objective.type || "minimize",
          formula: objective.formula || "",
          latex: objective.latex,
          variables: objective.variables || [],
          weight: objective.weight,
          units: objective.units,
          idealValue: objective.idealValue,
          acceptableRange: objective.acceptableRange
        };
      }
      /**
       * Normalize solution
       */
      normalizeSolution(solution, constraints) {
        let constraintSatisfaction = solution.constraintSatisfaction;
        if (!constraintSatisfaction && constraints) {
          constraintSatisfaction = constraints.map((c) => ({
            constraintId: c.id,
            satisfied: true,
            // Default assumption
            violation: void 0
          }));
        }
        return {
          id: solution.id || randomUUID(),
          type: VALID_SOLUTION_TYPES.includes(solution.type) ? solution.type : "feasible",
          variableValues: solution.variableValues || {},
          objectiveValues: solution.objectiveValues || {},
          constraintSatisfaction: constraintSatisfaction || [],
          quality: Math.max(0, Math.min(1, solution.quality ?? 0.5)),
          computationTime: solution.computationTime,
          iterations: solution.iterations,
          method: solution.method,
          guarantees: solution.guarantees
        };
      }
      /**
       * Normalize analysis
       */
      normalizeAnalysis(analysis) {
        return {
          id: analysis.id || randomUUID(),
          parameters: analysis.parameters || [],
          robustness: Math.max(0, Math.min(1, analysis.robustness ?? 0.5)),
          criticalConstraints: analysis.criticalConstraints || [],
          shadowPrices: analysis.shadowPrices,
          recommendations: analysis.recommendations || []
        };
      }
    };
  }
});
var CustomHandler;
var init_CustomHandler = __esm({
  "src/modes/handlers/CustomHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    CustomHandler = class {
      mode = "custom" /* CUSTOM */;
      modeName = "Custom Reasoning";
      description = "User-defined reasoning patterns with flexible structure and custom validation";
      /**
       * Create a custom thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const customFields = inputAny.customFields ? inputAny.customFields.map((f) => this.normalizeField(f)) : [];
        const stages2 = inputAny.stages ? inputAny.stages.map((s, idx) => this.normalizeStage(s, idx)) : void 0;
        const validationRules = inputAny.validationRules ? inputAny.validationRules.map((r) => this.normalizeValidationRule(r)) : void 0;
        const basedOnModes = inputAny.basedOnModes ? inputAny.basedOnModes.map((m) => this.resolveMode(m)) : void 0;
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          mode: "custom" /* CUSTOM */,
          // Custom configuration
          thoughtType: inputAny.thoughtType || "custom_analysis",
          customModeName: inputAny.customModeName || "Custom Mode",
          customModeDescription: inputAny.customModeDescription,
          // User-defined fields
          customFields,
          // Custom stages
          stages: stages2,
          currentStage: inputAny.currentStage,
          // Custom validation
          validationRules,
          // Extension data
          metadata: inputAny.metadata || {},
          // Related modes
          basedOnModes,
          // Revision tracking
          isRevision: input.isRevision,
          revisesThought: input.revisesThought
        };
      }
      /**
       * Validate custom-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        if (!inputAny.customModeName) {
          warnings.push(
            createValidationWarning(
              "customModeName",
              "No custom mode name provided",
              "Define a name for your custom reasoning mode"
            )
          );
        }
        if (inputAny.customFields) {
          for (let i = 0; i < inputAny.customFields.length; i++) {
            const field = inputAny.customFields[i];
            if (field.required && (field.value === void 0 || field.value === null)) {
              warnings.push(
                createValidationWarning(
                  `customFields[${i}]`,
                  `Required field "${field.name}" has no value`,
                  "Provide a value for required fields"
                )
              );
            }
            if (field.type && field.value !== void 0) {
              const actualType = Array.isArray(field.value) ? "array" : typeof field.value;
              if (actualType !== field.type && field.type !== "object") {
                warnings.push(
                  createValidationWarning(
                    `customFields[${i}].value`,
                    `Field "${field.name}" type mismatch: expected ${field.type}, got ${actualType}`,
                    "Ensure field value matches declared type"
                  )
                );
              }
            }
          }
        }
        if (inputAny.stages) {
          const stageIds = /* @__PURE__ */ new Set();
          for (let i = 0; i < inputAny.stages.length; i++) {
            const stage = inputAny.stages[i];
            if (stageIds.has(stage.id)) {
              warnings.push(
                createValidationWarning(
                  `stages[${i}].id`,
                  `Duplicate stage ID: ${stage.id}`,
                  "Each stage should have a unique ID"
                )
              );
            }
            stageIds.add(stage.id);
          }
          if (inputAny.currentStage && !stageIds.has(inputAny.currentStage)) {
            warnings.push(
              createValidationWarning(
                "currentStage",
                `Current stage "${inputAny.currentStage}" not found in stages`,
                "Set currentStage to a valid stage ID"
              )
            );
          }
        }
        if (inputAny.validationRules && inputAny.customFields) {
          const fieldMap = new Map(
            inputAny.customFields.map((f) => [f.name, f.value])
          );
          for (const rule of inputAny.validationRules) {
            const value = fieldMap.get(rule.field);
            if (!this.evaluateRule(rule.rule, value, fieldMap)) {
              warnings.push(
                createValidationWarning(
                  rule.field,
                  rule.message || `Validation failed: ${rule.rule}`,
                  "Check field value against rule"
                )
              );
            }
          }
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get custom-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: thought.basedOnModes || ["sequential" /* SEQUENTIAL */],
          guidingQuestions: [],
          warnings: [],
          metrics: {
            fieldCount: thought.customFields.length,
            stageCount: thought.stages?.length || 0,
            completedStages: thought.stages?.filter((s) => s.completed).length || 0,
            metadataKeys: Object.keys(thought.metadata).length
          },
          mentalModels: [
            "Domain-Specific Reasoning",
            "Custom Frameworks",
            "Flexible Analysis",
            "User-Defined Logic"
          ]
        };
        enhancements.suggestions.push(`Custom mode: ${thought.customModeName}`);
        if (thought.customModeDescription) {
          enhancements.suggestions.push(`Description: ${thought.customModeDescription}`);
        }
        if (thought.stages && thought.stages.length > 0) {
          const completed = thought.stages.filter((s) => s.completed).length;
          const total = thought.stages.length;
          const progress = (completed / total * 100).toFixed(0);
          enhancements.suggestions.push(`Stage progress: ${completed}/${total} (${progress}%)`);
          if (thought.currentStage) {
            const current = thought.stages.find((s) => s.id === thought.currentStage);
            if (current) {
              enhancements.suggestions.push(`Current stage: ${current.name}`);
              enhancements.guidingQuestions.push(`What is needed to complete "${current.name}"?`);
            }
          }
          const nextStage = thought.stages.find((s) => !s.completed);
          if (nextStage && nextStage.id !== thought.currentStage) {
            enhancements.suggestions.push(`Next stage: ${nextStage.name}`);
          }
        }
        if (thought.customFields.length > 0) {
          const filledFields = thought.customFields.filter(
            (f) => f.value !== void 0 && f.value !== null
          ).length;
          enhancements.suggestions.push(`Fields: ${filledFields}/${thought.customFields.length} populated`);
          const missingRequired = thought.customFields.filter(
            (f) => f.required && (f.value === void 0 || f.value === null)
          );
          if (missingRequired.length > 0) {
            enhancements.warnings.push(
              `Missing required fields: ${missingRequired.map((f) => f.name).join(", ")}`
            );
          }
        }
        enhancements.guidingQuestions.push(
          "Are all necessary fields defined?",
          "Does the custom structure fit the problem?",
          "Would predefined modes work better?"
        );
        if (thought.basedOnModes && thought.basedOnModes.length > 0) {
          enhancements.suggestions.push(
            `Based on: ${thought.basedOnModes.join(", ")}`
          );
          enhancements.mentalModels.push("Mode Composition");
        }
        if (Object.keys(thought.metadata).length > 0) {
          enhancements.metrics.metadataKeys = Object.keys(thought.metadata).length;
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       * Custom handler supports any thought type
       */
      supportsThoughtType(_thoughtType) {
        return true;
      }
      /**
       * Normalize custom field
       */
      normalizeField(field) {
        return {
          name: field.name || "unnamed",
          type: this.resolveFieldType(field.type),
          value: field.value,
          description: field.description,
          required: field.required ?? false
        };
      }
      /**
       * Resolve field type
       */
      resolveFieldType(type) {
        const validTypes = ["string", "number", "boolean", "array", "object"];
        if (type && validTypes.includes(type)) {
          return type;
        }
        return "string";
      }
      /**
       * Normalize custom stage
       */
      normalizeStage(stage, defaultOrder) {
        return {
          id: stage.id || randomUUID(),
          name: stage.name || `Stage ${defaultOrder + 1}`,
          description: stage.description || "",
          order: stage.order ?? defaultOrder,
          completed: stage.completed ?? false
        };
      }
      /**
       * Normalize validation rule
       */
      normalizeValidationRule(rule) {
        return {
          field: rule.field || "",
          rule: rule.rule || "",
          message: rule.message || "Validation failed"
        };
      }
      /**
       * Resolve mode from string
       */
      resolveMode(mode) {
        const modeMap = {
          sequential: "sequential" /* SEQUENTIAL */,
          shannon: "shannon" /* SHANNON */,
          mathematics: "mathematics" /* MATHEMATICS */,
          physics: "physics" /* PHYSICS */,
          hybrid: "hybrid" /* HYBRID */,
          inductive: "inductive" /* INDUCTIVE */,
          deductive: "deductive" /* DEDUCTIVE */,
          abductive: "abductive" /* ABDUCTIVE */,
          causal: "causal" /* CAUSAL */,
          bayesian: "bayesian" /* BAYESIAN */,
          counterfactual: "counterfactual" /* COUNTERFACTUAL */,
          temporal: "temporal" /* TEMPORAL */,
          gametheory: "gametheory" /* GAMETHEORY */,
          evidential: "evidential" /* EVIDENTIAL */,
          analogical: "analogical" /* ANALOGICAL */,
          firstprinciples: "firstprinciples" /* FIRSTPRINCIPLES */,
          systemsthinking: "systemsthinking" /* SYSTEMSTHINKING */,
          scientificmethod: "scientificmethod" /* SCIENTIFICMETHOD */,
          formallogic: "formallogic" /* FORMALLOGIC */,
          metareasoning: "metareasoning" /* METAREASONING */,
          optimization: "optimization" /* OPTIMIZATION */,
          engineering: "engineering" /* ENGINEERING */,
          algorithmic: "algorithmic" /* ALGORITHMIC */,
          computability: "computability" /* COMPUTABILITY */,
          cryptanalytic: "cryptanalytic" /* CRYPTANALYTIC */,
          synthesis: "synthesis" /* SYNTHESIS */,
          argumentation: "argumentation" /* ARGUMENTATION */,
          critique: "critique" /* CRITIQUE */,
          analysis: "analysis" /* ANALYSIS */,
          custom: "custom" /* CUSTOM */
        };
        return modeMap[mode.toLowerCase()] || "sequential" /* SEQUENTIAL */;
      }
      /**
       * Evaluate a simple validation rule
       */
      evaluateRule(rule, value, _allFields) {
        try {
          if (rule === "required") {
            return value !== void 0 && value !== null && value !== "";
          }
          if (rule.startsWith("min:")) {
            const min = parseFloat(rule.substring(4));
            return typeof value === "number" && value >= min;
          }
          if (rule.startsWith("max:")) {
            const max = parseFloat(rule.substring(4));
            return typeof value === "number" && value <= max;
          }
          if (rule.startsWith("minLength:")) {
            const min = parseInt(rule.substring(10));
            return typeof value === "string" && value.length >= min;
          }
          if (rule.startsWith("maxLength:")) {
            const max = parseInt(rule.substring(10));
            return typeof value === "string" && value.length <= max;
          }
          if (rule.startsWith("pattern:")) {
            const pattern = rule.substring(8);
            return typeof value === "string" && new RegExp(pattern).test(value);
          }
          if (rule.startsWith("in:")) {
            const options = rule.substring(3).split(",");
            return options.includes(String(value));
          }
          if (rule === "positive") {
            return typeof value === "number" && value > 0;
          }
          if (rule === "negative") {
            return typeof value === "number" && value < 0;
          }
          if (rule === "integer") {
            return typeof value === "number" && Number.isInteger(value);
          }
          return true;
        } catch {
          return true;
        }
      }
    };
  }
});

// src/modes/registry.ts
function getRegistry() {
  return ModeHandlerRegistry.getInstance();
}
var ModeHandlerRegistry;
var init_registry = __esm({
  "src/modes/registry.ts"() {
    init_esm_shims();
    init_core();
    init_ModeHandler();
    init_GenericModeHandler();
    ModeHandlerRegistry = class _ModeHandlerRegistry {
      static instance = null;
      handlers = /* @__PURE__ */ new Map();
      constructor() {
      }
      /**
       * Get the singleton instance
       */
      static getInstance() {
        if (!_ModeHandlerRegistry.instance) {
          _ModeHandlerRegistry.instance = new _ModeHandlerRegistry();
        }
        return _ModeHandlerRegistry.instance;
      }
      /**
       * Reset the singleton (for testing)
       */
      static resetInstance() {
        _ModeHandlerRegistry.instance = null;
      }
      /**
       * Register a mode handler
       *
       * @param handler - The handler to register
       * @throws Error if handler for mode is already registered
       */
      register(handler) {
        if (this.handlers.has(handler.mode)) {
          throw new Error(
            `Handler for mode '${handler.mode}' is already registered. Use replace() to override an existing handler.`
          );
        }
        this.handlers.set(handler.mode, handler);
      }
      /**
       * Replace an existing handler or register a new one
       *
       * @param handler - The handler to register/replace
       */
      replace(handler) {
        this.handlers.set(handler.mode, handler);
      }
      /**
       * Unregister a handler
       *
       * @param mode - The mode to unregister
       * @returns true if handler was removed, false if not found
       */
      unregister(mode) {
        return this.handlers.delete(mode);
      }
      /**
       * Get handler for a mode
       *
       * Returns the specialized handler if registered,
       * otherwise returns the generic handler.
       *
       * @param mode - The thinking mode
       * @returns The handler for the mode
       */
      getHandler(mode) {
        return this.handlers.get(mode) || this.createGenericHandlerForMode(mode);
      }
      /**
       * Check if a specialized handler is registered for a mode
       *
       * @param mode - The thinking mode
       * @returns true if a specialized handler exists
       */
      hasSpecializedHandler(mode) {
        return this.handlers.has(mode);
      }
      /**
       * Get all registered modes
       *
       * @returns Array of modes with specialized handlers
       */
      getRegisteredModes() {
        return Array.from(this.handlers.keys());
      }
      /**
       * Create a thought using the appropriate handler
       *
       * This is the main entry point for thought creation.
       * Delegates to specialized handler if registered,
       * otherwise uses generic handler.
       *
       * @param input - The tool input
       * @param sessionId - The session ID
       * @returns Created thought
       */
      createThought(input, sessionId) {
        const mode = input.mode || "hybrid" /* HYBRID */;
        const handler = this.getHandler(mode);
        return handler.createThought(input, sessionId);
      }
      /**
       * Validate input using the appropriate handler
       *
       * @param input - The tool input
       * @returns Validation result
       */
      validate(input) {
        const mode = input.mode || "hybrid" /* HYBRID */;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        const handler = this.getHandler(mode);
        return handler.validate(input);
      }
      /**
       * Get mode status information
       *
       * @param mode - The thinking mode
       * @returns Mode status for API response
       */
      getModeStatus(mode) {
        const hasSpecialized = this.hasSpecializedHandler(mode);
        const handler = this.getHandler(mode);
        return {
          mode,
          isFullyImplemented: isFullyImplemented(mode),
          hasSpecializedHandler: hasSpecialized,
          note: this.getModeNote(mode, hasSpecialized),
          supportedThoughtTypes: this.getSupportedThoughtTypes(handler, mode)
        };
      }
      /**
       * Get registry statistics
       *
       * @returns Statistics about registered handlers
       */
      getStats() {
        const allModes = Object.values(ThinkingMode).filter(
          (v) => typeof v === "string"
        );
        const modesWithHandlers = this.getRegisteredModes();
        const modesWithGenericHandler = allModes.filter(
          (mode) => !this.handlers.has(mode)
        );
        return {
          totalHandlers: this.handlers.size,
          specializedHandlers: this.handlers.size,
          modesWithHandlers,
          modesWithGenericHandler
        };
      }
      /**
       * Create a generic handler configured for a specific mode
       */
      createGenericHandlerForMode(mode) {
        return new GenericModeHandler(mode);
      }
      /**
       * Get appropriate note for mode status
       */
      getModeNote(mode, hasSpecialized) {
        if (!isFullyImplemented(mode)) {
          return "This mode is experimental with limited runtime implementation";
        }
        if (!hasSpecialized) {
          return "Using generic handler - specialized validation not available";
        }
        return void 0;
      }
      /**
       * Get supported thought types for a mode
       */
      getSupportedThoughtTypes(_handler, mode) {
        const thoughtTypes = {
          mathematics: [
            "problem_definition",
            "constraints",
            "model",
            "proof",
            "implementation",
            "proof_decomposition",
            "dependency_analysis",
            "consistency_check",
            "gap_identification",
            "assumption_trace"
          ],
          physics: [
            "problem_definition",
            "model",
            "tensor_formulation",
            "conservation_law",
            "dimensional_analysis"
          ],
          causal: ["problem_definition", "graph_construction", "intervention_analysis", "mechanism_identification"],
          bayesian: ["prior_definition", "likelihood_assessment", "posterior_calculation", "sensitivity_analysis"],
          temporal: ["event_definition", "interval_analysis", "constraint_checking", "timeline_construction"],
          gametheory: ["game_definition", "strategy_analysis", "equilibrium_finding", "payoff_calculation"],
          synthesis: ["source_identification", "theme_extraction", "gap_analysis", "framework_construction"],
          argumentation: ["claim_formulation", "grounds_development", "warrant_construction", "rebuttal_analysis"],
          critique: ["work_characterization", "methodology_evaluation", "argument_critique", "contribution_assessment"],
          analysis: ["data_familiarization", "coding", "theme_development", "pattern_analysis"]
        };
        const modeKey = mode.toLowerCase();
        return thoughtTypes[modeKey] || ["general"];
      }
      /**
       * Clear all registered handlers (for testing)
       */
      clear() {
        this.handlers.clear();
      }
    };
  }
});

// src/modes/index.ts
function registerAllHandlers() {
  const registry = getRegistry();
  registry.replace(new SequentialHandler());
  registry.replace(new ShannonHandler());
  registry.replace(new MathematicsHandler());
  registry.replace(new PhysicsHandler());
  registry.replace(new HybridHandler());
  registry.replace(new InductiveHandler());
  registry.replace(new DeductiveHandler());
  registry.replace(new AbductiveHandler());
  registry.replace(new CausalHandler());
  registry.replace(new BayesianHandler());
  registry.replace(new CounterfactualHandler());
  registry.replace(new TemporalHandler());
  registry.replace(new GameTheoryHandler());
  registry.replace(new EvidentialHandler());
  registry.replace(new AnalogicalHandler());
  registry.replace(new FirstPrinciplesHandler());
  registry.replace(new SystemsThinkingHandler());
  registry.replace(new ScientificMethodHandler());
  registry.replace(new FormalLogicHandler());
  registry.replace(new SynthesisHandler());
  registry.replace(new ArgumentationHandler());
  registry.replace(new CritiqueHandler());
  registry.replace(new AnalysisHandler());
  registry.replace(new EngineeringHandler());
  registry.replace(new ComputabilityHandler());
  registry.replace(new CryptanalyticHandler());
  registry.replace(new AlgorithmicHandler());
  registry.replace(new MetaReasoningHandler());
  registry.replace(new RecursiveHandler());
  registry.replace(new ModalHandler());
  registry.replace(new StochasticHandler());
  registry.replace(new ConstraintHandler());
  registry.replace(new OptimizationHandler());
  registry.replace(new CustomHandler());
}
var init_modes = __esm({
  "src/modes/index.ts"() {
    init_esm_shims();
    init_registry();
    init_SequentialHandler();
    init_ShannonHandler();
    init_MathematicsHandler();
    init_PhysicsHandler();
    init_HybridHandler();
    init_InductiveHandler();
    init_DeductiveHandler();
    init_AbductiveHandler();
    init_CausalHandler();
    init_BayesianHandler();
    init_CounterfactualHandler();
    init_TemporalHandler();
    init_GameTheoryHandler();
    init_EvidentialHandler();
    init_AnalogicalHandler();
    init_FirstPrinciplesHandler();
    init_SystemsThinkingHandler();
    init_ScientificMethodHandler();
    init_FormalLogicHandler();
    init_SynthesisHandler();
    init_ArgumentationHandler();
    init_CritiqueHandler();
    init_AnalysisHandler();
    init_EngineeringHandler();
    init_ComputabilityHandler();
    init_CryptanalyticHandler();
    init_AlgorithmicHandler();
    init_MetaReasoningHandler();
    init_RecursiveHandler();
    init_ModalHandler();
    init_StochasticHandler();
    init_ConstraintHandler();
    init_OptimizationHandler();
    init_CustomHandler();
    init_registry();
  }
});

// src/utils/errors.ts
var DeepThinkingError, SessionNotFoundError;
var init_errors = __esm({
  "src/utils/errors.ts"() {
    init_esm_shims();
    DeepThinkingError = class extends Error {
      code;
      context;
      timestamp;
      constructor(message, code, context) {
        super(message);
        this.name = this.constructor.name;
        this.code = code;
        this.context = context;
        this.timestamp = /* @__PURE__ */ new Date();
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
      }
      /**
       * Convert error to JSON for logging/serialization
       */
      toJSON() {
        return {
          name: this.name,
          message: this.message,
          code: this.code,
          context: this.context,
          timestamp: this.timestamp.toISOString(),
          stack: this.stack
        };
      }
    };
    SessionNotFoundError = class extends DeepThinkingError {
      constructor(sessionId) {
        super(`Session not found: ${sessionId}`, "SESSION_NOT_FOUND", { sessionId });
      }
    };
  }
});

// src/utils/sanitization.ts
function sanitizeString(input, maxLength = MAX_LENGTHS.STRING_FIELD, fieldName = "input") {
  if (typeof input !== "string") {
    throw new Error(`${fieldName} must be a string`);
  }
  const trimmed = input.trim();
  if (trimmed.length === 0) {
    throw new Error(`${fieldName} cannot be empty`);
  }
  if (trimmed.length > maxLength) {
    throw new Error(`${fieldName} exceeds maximum length of ${maxLength} characters`);
  }
  if (trimmed.includes("\0")) {
    throw new Error(`${fieldName} contains invalid null bytes`);
  }
  return trimmed;
}
function validateSessionId(sessionId) {
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  if (!uuidRegex.test(sessionId)) {
    throw new Error(`Invalid session ID format: ${sessionId}`);
  }
  return sessionId;
}
function sanitizeThoughtContent(content) {
  return sanitizeString(content, MAX_LENGTHS.THOUGHT_CONTENT, "thought content");
}
function escapeHtml(text) {
  const htmlEscapeMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;",
    "/": "&#x2F;"
  };
  return text.replace(/[&<>"'\/]/g, (char) => htmlEscapeMap[char] || char);
}
function escapeLatex(text) {
  const latexEscapeMap = {
    "\\": "\\textbackslash{}",
    "{": "\\{",
    "}": "\\}",
    "$": "\\$",
    "&": "\\&",
    "%": "\\%",
    "#": "\\#",
    "_": "\\_",
    "~": "\\textasciitilde{}",
    "^": "\\textasciicircum{}"
  };
  return text.replace(/[\\{}$&%#_~^]/g, (char) => latexEscapeMap[char] || char);
}
var MAX_LENGTHS;
var init_sanitization = __esm({
  "src/utils/sanitization.ts"() {
    init_esm_shims();
    MAX_LENGTHS = {
      THOUGHT_CONTENT: 1e5,
      // 100KB for thought content
      TITLE: 500,
      DOMAIN: 200,
      AUTHOR: 300,
      SESSION_ID: 100,
      HYPOTHESIS: 5e3,
      DESCRIPTION: 1e4,
      STRING_FIELD: 1e3
    };
  }
});

// src/utils/logger-types.ts
var LogLevel;
var init_logger_types = __esm({
  "src/utils/logger-types.ts"() {
    init_esm_shims();
    LogLevel = /* @__PURE__ */ ((LogLevel2) => {
      LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
      LogLevel2[LogLevel2["INFO"] = 1] = "INFO";
      LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
      LogLevel2[LogLevel2["ERROR"] = 3] = "ERROR";
      LogLevel2[LogLevel2["SILENT"] = 4] = "SILENT";
      return LogLevel2;
    })(LogLevel || {});
  }
});

// src/utils/logger.ts
function createLogger(config) {
  return new Logger(config);
}
var DEFAULT_CONFIG, Logger, logger;
var init_logger = __esm({
  "src/utils/logger.ts"() {
    init_esm_shims();
    init_logger_types();
    DEFAULT_CONFIG = {
      minLevel: 1 /* INFO */,
      enableConsole: true,
      enableTimestamps: true,
      prettyPrint: true
    };
    Logger = class {
      config;
      logs = [];
      constructor(config) {
        this.config = { ...DEFAULT_CONFIG, ...config };
      }
      /**
       * Log a debug message
       */
      debug(message, context) {
        this.log(0 /* DEBUG */, message, context);
      }
      /**
       * Log an info message
       */
      info(message, context) {
        this.log(1 /* INFO */, message, context);
      }
      /**
       * Log a warning message
       */
      warn(message, context) {
        this.log(2 /* WARN */, message, context);
      }
      /**
       * Log an error message
       */
      error(message, error, context) {
        this.log(3 /* ERROR */, message, context, error);
      }
      /**
       * Internal log method
       */
      log(level, message, context, error) {
        if (level < this.config.minLevel) {
          return;
        }
        const entry = {
          level,
          message,
          timestamp: /* @__PURE__ */ new Date(),
          context,
          error
        };
        this.logs.push(entry);
        if (this.config.enableConsole) {
          this.writeToConsole(entry);
        }
      }
      /**
       * Write log entry to console
       */
      writeToConsole(entry) {
        const levelName = LogLevel[entry.level];
        const timestamp = this.config.enableTimestamps ? `[${entry.timestamp.toISOString()}] ` : "";
        let message = `${timestamp}${levelName}: ${entry.message}`;
        if (entry.context && this.config.prettyPrint) {
          message += `
  Context: ${JSON.stringify(entry.context, null, 2)}`;
        }
        if (entry.error) {
          message += `
  Error: ${entry.error.message}`;
          if (entry.error.stack && this.config.prettyPrint) {
            message += `
  Stack: ${entry.error.stack}`;
          }
        }
        switch (entry.level) {
          case 0 /* DEBUG */:
          case 1 /* INFO */:
            console.log(message);
            break;
          case 2 /* WARN */:
            console.warn(message);
            break;
          case 3 /* ERROR */:
            console.error(message);
            break;
        }
      }
      /**
       * Get all log entries
       */
      getLogs(minLevel) {
        if (minLevel !== void 0) {
          return this.logs.filter((log) => log.level >= minLevel);
        }
        return [...this.logs];
      }
      /**
       * Clear all logs
       */
      clearLogs() {
        this.logs = [];
      }
      /**
       * Set minimum log level
       */
      setLevel(level) {
        this.config.minLevel = level;
      }
      /**
       * Export logs as JSON
       */
      exportLogs() {
        return JSON.stringify(this.logs.map((log) => ({
          ...log,
          level: LogLevel[log.level],
          timestamp: log.timestamp.toISOString()
        })), null, 2);
      }
    };
    logger = new Logger();
  }
});

// src/cache/lru.ts
var LRUCache;
var init_lru = __esm({
  "src/cache/lru.ts"() {
    init_esm_shims();
    LRUCache = class {
      cache;
      config;
      stats;
      constructor(config = {}) {
        this.cache = /* @__PURE__ */ new Map();
        this.config = {
          /**
           * Default max cache size: 100 entries
           * Reasoning:
           * - Validation cache typically stores session/thought validation results
           * - Average entry size: ~1-2KB (validation result + metadata)
           * - 100 entries = ~100-200KB memory usage
           * - Sufficient for most use cases (covers recent validations)
           * - Prevents unbounded memory growth in long-running processes
           * - Can be overridden via config parameter for high-traffic scenarios
           */
          maxSize: config.maxSize || 100,
          strategy: "lru",
          ttl: config.ttl || 0,
          enableStats: config.enableStats !== false,
          onEvict: config.onEvict || (() => {
          })
        };
        this.stats = {
          size: 0,
          maxSize: this.config.maxSize,
          hits: 0,
          misses: 0,
          hitRate: 0,
          evictions: 0,
          sets: 0,
          deletes: 0,
          memoryUsage: 0,
          avgAccessTime: 0
        };
      }
      /**
       * Get value by key
       */
      get(key) {
        const entry = this.cache.get(key);
        if (!entry) {
          if (this.config.enableStats) {
            this.stats.misses++;
            this.updateHitRate();
          }
          return void 0;
        }
        if (entry.expiresAt && entry.expiresAt < /* @__PURE__ */ new Date()) {
          this.delete(key);
          if (this.config.enableStats) {
            this.stats.misses++;
            this.updateHitRate();
          }
          return void 0;
        }
        entry.lastAccessedAt = /* @__PURE__ */ new Date();
        entry.accessCount++;
        this.cache.delete(key);
        this.cache.set(key, entry);
        if (this.config.enableStats) {
          this.stats.hits++;
          this.updateHitRate();
        }
        return entry.value;
      }
      /**
       * Set value for key
       */
      set(key, value, ttl) {
        const existing = this.cache.get(key);
        if (existing) {
          this.cache.delete(key);
        } else if (this.cache.size >= this.config.maxSize) {
          this.evictLRU();
        }
        const now = /* @__PURE__ */ new Date();
        const effectiveTtl = ttl ?? this.config.ttl;
        const entry = {
          key,
          value,
          createdAt: now,
          lastAccessedAt: now,
          accessCount: 0,
          expiresAt: effectiveTtl ? new Date(now.getTime() + effectiveTtl) : void 0,
          size: this.estimateSize(value)
        };
        this.cache.set(key, entry);
        if (this.config.enableStats) {
          this.stats.sets++;
          this.stats.size = this.cache.size;
          this.stats.memoryUsage += entry.size || 0;
        }
      }
      /**
       * Check if key exists
       */
      has(key) {
        const entry = this.cache.get(key);
        if (!entry) return false;
        if (entry.expiresAt && entry.expiresAt < /* @__PURE__ */ new Date()) {
          this.delete(key);
          return false;
        }
        return true;
      }
      /**
       * Delete entry by key
       */
      delete(key) {
        const entry = this.cache.get(key);
        if (!entry) return false;
        this.cache.delete(key);
        if (this.config.enableStats) {
          this.stats.deletes++;
          this.stats.size = this.cache.size;
          this.stats.memoryUsage -= entry.size || 0;
        }
        return true;
      }
      /**
       * Clear all entries
       */
      clear() {
        this.cache.clear();
        if (this.config.enableStats) {
          this.stats.size = 0;
          this.stats.memoryUsage = 0;
        }
      }
      /**
       * Get cache size
       */
      size() {
        return this.cache.size;
      }
      /**
       * Get cache statistics
       */
      getStats() {
        return { ...this.stats };
      }
      /**
       * Get all keys
       */
      keys() {
        return Array.from(this.cache.keys());
      }
      /**
       * Get all values
       */
      values() {
        return Array.from(this.cache.values()).map((e) => e.value);
      }
      /**
       * Get all entries
       */
      entries() {
        return Array.from(this.cache.entries()).map(([k, v]) => [k, v.value]);
      }
      /**
       * Evict least recently used entry
       */
      evictLRU() {
        const firstKey = this.cache.keys().next().value;
        if (firstKey) {
          const entry = this.cache.get(firstKey);
          this.cache.delete(firstKey);
          if (this.config.onEvict && entry) {
            this.config.onEvict(firstKey, entry.value);
          }
          if (this.config.enableStats) {
            this.stats.evictions++;
            this.stats.size = this.cache.size;
            if (entry) {
              this.stats.memoryUsage -= entry.size || 0;
            }
          }
        }
      }
      /**
       * Update hit rate
       */
      updateHitRate() {
        const total = this.stats.hits + this.stats.misses;
        this.stats.hitRate = total > 0 ? this.stats.hits / total : 0;
      }
      /**
       * Estimate entry size
       */
      estimateSize(value) {
        try {
          return JSON.stringify(value).length * 2;
        } catch {
          return 0;
        }
      }
      /**
       * Clean expired entries
       */
      cleanExpired() {
        let cleaned = 0;
        const now = /* @__PURE__ */ new Date();
        for (const [key, entry] of this.cache) {
          if (entry.expiresAt && entry.expiresAt < now) {
            this.delete(key);
            cleaned++;
          }
        }
        return cleaned;
      }
    };
  }
});

// src/config/index.ts
function getConfig() {
  return Object.freeze({ ...activeConfig });
}
function validateConfig(config) {
  if (config.maxThoughtsInMemory < 1) {
    throw new Error("maxThoughtsInMemory must be at least 1");
  }
  if (config.compressionThreshold < 0) {
    throw new Error("compressionThreshold must be non-negative");
  }
  if (config.maxContentLength < 1) {
    throw new Error("maxContentLength must be at least 1");
  }
  if (config.validationTolerance < 0 || config.validationTolerance > 1) {
    throw new Error("validationTolerance must be between 0 and 1");
  }
  if (config.maxActiveSessions < 1) {
    throw new Error("maxActiveSessions must be at least 1");
  }
  if (config.sessionTimeoutMs < 0) {
    throw new Error("sessionTimeoutMs must be non-negative");
  }
  if (config.validationCacheMaxSize < 0) {
    throw new Error("validationCacheMaxSize must be non-negative");
  }
  if (!["debug", "info", "warn", "error"].includes(config.logLevel)) {
    throw new Error("logLevel must be one of: debug, info, warn, error");
  }
}
var defaultConfig, activeConfig;
var init_config = __esm({
  "src/config/index.ts"() {
    init_esm_shims();
    defaultConfig = {
      maxThoughtsInMemory: parseInt(process.env.MCP_MAX_THOUGHTS || "1000", 10),
      compressionThreshold: parseInt(process.env.MCP_COMPRESSION_THRESHOLD || "500", 10),
      maxContentLength: parseInt(process.env.MCP_MAX_CONTENT_LENGTH || "10000", 10),
      validationTolerance: parseFloat(process.env.MCP_VALIDATION_TOLERANCE || "0.01"),
      maxActiveSessions: parseInt(process.env.MCP_MAX_SESSIONS || "100", 10),
      sessionTimeoutMs: parseInt(process.env.MCP_SESSION_TIMEOUT_MS || "0", 10),
      enableValidationCache: process.env.MCP_ENABLE_VALIDATION_CACHE !== "false",
      validationCacheMaxSize: parseInt(process.env.MCP_VALIDATION_CACHE_SIZE || "1000", 10),
      enablePersistence: process.env.MCP_ENABLE_PERSISTENCE === "true",
      persistenceDir: process.env.MCP_PERSISTENCE_DIR || "./.deepthinking-sessions",
      logLevel: process.env.MCP_LOG_LEVEL || "info",
      enablePerformanceMetrics: process.env.MCP_ENABLE_PERF_METRICS === "true"
    };
    activeConfig = { ...defaultConfig };
    validateConfig(activeConfig);
    getConfig();
  }
});
var ValidationCache, validationCache;
var init_cache = __esm({
  "src/validation/cache.ts"() {
    init_esm_shims();
    init_config();
    ValidationCache = class {
      cache;
      maxSize;
      hits = 0;
      misses = 0;
      constructor(maxSize) {
        const config = getConfig();
        this.maxSize = maxSize || config.validationCacheMaxSize;
        this.cache = /* @__PURE__ */ new Map();
      }
      /**
       * Generate a cache key from thought content
       *
       * Uses SHA-256 hash of JSON-serialized content for reliable cache keys
       *
       * @param content - Content to hash
       * @returns Cache key
       */
      generateKey(content) {
        const json = JSON.stringify(content);
        return createHash("sha256").update(json).digest("hex");
      }
      /**
       * Get validation result from cache
       *
       * @param content - Content to look up
       * @returns Cached result or undefined if not found
       */
      get(content) {
        const key = this.generateKey(content);
        const entry = this.cache.get(key);
        if (entry) {
          this.hits++;
          entry.hitCount++;
          this.cache.delete(key);
          this.cache.set(key, entry);
          return entry;
        }
        this.misses++;
        return void 0;
      }
      /**
       * Store validation result in cache
       *
       * @param content - Content that was validated
       * @param result - Validation result to cache
       */
      set(content, result) {
        const key = this.generateKey(content);
        if (this.cache.size >= this.maxSize) {
          const firstKey = this.cache.keys().next().value;
          if (firstKey !== void 0) {
            this.cache.delete(firstKey);
          }
        }
        const entry = {
          result,
          timestamp: Date.now(),
          hitCount: 0
        };
        this.cache.set(key, entry);
      }
      /**
       * Check if content is in cache
       *
       * @param content - Content to check
       * @returns true if cached
       */
      has(content) {
        const key = this.generateKey(content);
        return this.cache.has(key);
      }
      /**
       * Clear all cached validation results
       */
      clear() {
        this.cache.clear();
        this.hits = 0;
        this.misses = 0;
      }
      /**
       * Get cache statistics
       */
      getStats() {
        const total = this.hits + this.misses;
        return {
          size: this.cache.size,
          maxSize: this.maxSize,
          hits: this.hits,
          misses: this.misses,
          hitRate: total > 0 ? this.hits / total : 0
        };
      }
      /**
       * Resize the cache
       *
       * @param newSize - New maximum cache size
       */
      resize(newSize) {
        this.maxSize = newSize;
        if (this.cache.size > newSize) {
          const keysToDelete = this.cache.size - newSize;
          const keys = Array.from(this.cache.keys());
          for (let i = 0; i < keysToDelete; i++) {
            this.cache.delete(keys[i]);
          }
        }
      }
      /**
       * Get entries sorted by hit count (most used first)
       */
      getTopEntries(limit = 10) {
        const entries = Array.from(this.cache.entries()).map(([key, entry]) => ({ key, entry })).sort((a, b) => b.entry.hitCount - a.entry.hitCount);
        return entries.slice(0, limit);
      }
      /**
       * Remove entries older than a certain age
       *
       * @param maxAgeMs - Maximum age in milliseconds
       * @returns Number of entries removed
       */
      evictOld(maxAgeMs) {
        const now = Date.now();
        let removed = 0;
        for (const [key, entry] of this.cache.entries()) {
          if (now - entry.timestamp > maxAgeMs) {
            this.cache.delete(key);
            removed++;
          }
        }
        return removed;
      }
    };
    validationCache = new ValidationCache();
  }
});

// src/session/SessionMetricsCalculator.ts
var SessionMetricsCalculator;
var init_SessionMetricsCalculator = __esm({
  "src/session/SessionMetricsCalculator.ts"() {
    init_esm_shims();
    init_core();
    init_cache();
    SessionMetricsCalculator = class {
      /**
       * Initialize metrics for a new session
       *
       * Creates a fresh metrics object with all counters set to zero
       * and cache statistics initialized.
       *
       * @returns Initialized session metrics
       *
       * @example
       * ```typescript
       * const metrics = calculator.initializeMetrics();
       * session.metrics = metrics;
       * ```
       */
      initializeMetrics() {
        return {
          totalThoughts: 0,
          thoughtsByType: {},
          averageUncertainty: 0,
          revisionCount: 0,
          timeSpent: 0,
          dependencyDepth: 0,
          customMetrics: /* @__PURE__ */ new Map(),
          cacheStats: {
            hits: 0,
            misses: 0,
            hitRate: 0,
            size: 0,
            maxSize: 0
          }
        };
      }
      /**
       * Update session metrics after adding a thought
       *
       * Performs incremental updates using O(1) algorithms for performance.
       * Handles mode-specific metrics for temporal, game theory, and evidential modes.
       *
       * **Performance Optimizations**:
       * - Incremental thoughtsByType counter (O(1) vs O(n) recalculation)
       * - Running average for uncertainty (O(1) vs O(n) recalculation)
       * - Max dependency depth tracking (O(1) comparison)
       *
       * @param session - Session to update (modified in-place)
       * @param thought - Newly added thought
       *
       * @example
       * ```typescript
       * calculator.updateMetrics(session, newThought);
       * console.log(session.metrics.totalThoughts); // Incremented
       * ```
       */
      updateMetrics(session, thought) {
        const metrics = session.metrics;
        metrics.totalThoughts = session.thoughts.length;
        const thoughtType = thought.mode || "unknown";
        metrics.thoughtsByType[thoughtType] = (metrics.thoughtsByType[thoughtType] || 0) + 1;
        if (thought.isRevision) {
          metrics.revisionCount++;
        }
        metrics.timeSpent = session.updatedAt.getTime() - session.createdAt.getTime();
        if ("uncertainty" in thought && typeof thought.uncertainty === "number") {
          const uncertaintyValue = thought.uncertainty;
          const currentSum = metrics._uncertaintySum || 0;
          const currentCount = metrics._uncertaintyCount || 0;
          const newSum = currentSum + uncertaintyValue;
          const newCount = currentCount + 1;
          metrics._uncertaintySum = newSum;
          metrics._uncertaintyCount = newCount;
          metrics.averageUncertainty = newSum / newCount;
        }
        if ("dependencies" in thought && thought.dependencies) {
          const deps = thought.dependencies;
          if (deps && deps.length > metrics.dependencyDepth) {
            metrics.dependencyDepth = deps.length;
          }
        }
        this.updateModeSpecificMetrics(metrics, thought);
        this.updateCacheStats(session);
      }
      /**
       * Update mode-specific custom metrics
       *
       * Calculates and stores metrics unique to specific thinking modes:
       * - Temporal: events, timeline, relations, constraints, intervals
       * - Game Theory: players, strategies, equilibria, game type
       * - Evidential: hypotheses, evidence, belief functions, decisions
       *
       * @param metrics - Session metrics to update
       * @param thought - Thought to analyze
       */
      updateModeSpecificMetrics(metrics, thought) {
        if (isTemporalThought(thought)) {
          if (thought.events) {
            metrics.customMetrics.set("totalEvents", thought.events.length);
          }
          if (thought.timeline) {
            metrics.customMetrics.set("timelineUnit", thought.timeline.timeUnit);
          }
          if (thought.relations) {
            const causalRelations = thought.relations.filter((r) => r.relationType === "causes");
            metrics.customMetrics.set("causalRelations", causalRelations.length);
          }
          if (thought.constraints) {
            metrics.customMetrics.set("temporalConstraints", thought.constraints.length);
          }
          if (thought.intervals) {
            metrics.customMetrics.set("timeIntervals", thought.intervals.length);
          }
        }
        if (isGameTheoryThought(thought)) {
          if (thought.players) {
            metrics.customMetrics.set("numPlayers", thought.players.length);
          }
          if (thought.strategies) {
            metrics.customMetrics.set("totalStrategies", thought.strategies.length);
            const mixedStrategies = thought.strategies.filter((s) => !s.isPure);
            metrics.customMetrics.set("mixedStrategies", mixedStrategies.length);
          }
          if (thought.nashEquilibria) {
            metrics.customMetrics.set("nashEquilibria", thought.nashEquilibria.length);
            const pureEquilibria = thought.nashEquilibria.filter((e) => e.type === "pure");
            metrics.customMetrics.set("pureNashEquilibria", pureEquilibria.length);
          }
          if (thought.dominantStrategies) {
            metrics.customMetrics.set("dominantStrategies", thought.dominantStrategies.length);
          }
          if (thought.game) {
            metrics.customMetrics.set("gameType", thought.game.type);
            metrics.customMetrics.set("isZeroSum", thought.game.isZeroSum);
          }
        }
        if (isEvidentialThought(thought)) {
          if (thought.hypotheses) {
            metrics.customMetrics.set("totalHypotheses", thought.hypotheses.length);
          }
          if (thought.evidence) {
            metrics.customMetrics.set("totalEvidence", thought.evidence.length);
            const avgReliability = thought.evidence.reduce((sum, e) => sum + e.reliability, 0) / thought.evidence.length;
            metrics.customMetrics.set("avgEvidenceReliability", avgReliability);
          }
          if (thought.beliefFunctions) {
            metrics.customMetrics.set("beliefFunctions", thought.beliefFunctions.length);
          }
          if (thought.combinedBelief) {
            metrics.customMetrics.set("hasCombinedBelief", true);
            if (thought.combinedBelief.conflictMass !== void 0) {
              metrics.customMetrics.set("conflictMass", thought.combinedBelief.conflictMass);
            }
          }
          if (thought.decisions) {
            metrics.customMetrics.set("decisions", thought.decisions.length);
          }
        }
      }
      /**
       * Update validation cache statistics in session metrics
       *
       * Retrieves current validation cache statistics and updates the
       * session metrics with the latest values.
       *
       * @param session - Session to update
       *
       * @example
       * ```typescript
       * calculator.updateCacheStats(session);
       * console.log(session.metrics.cacheStats.hitRate); // Updated
       * ```
       */
      updateCacheStats(session) {
        const cacheStats = validationCache.getStats();
        session.metrics.cacheStats = {
          hits: cacheStats.hits,
          misses: cacheStats.misses,
          hitRate: cacheStats.hitRate,
          size: cacheStats.size,
          maxSize: cacheStats.maxSize
        };
      }
    };
  }
});

// src/services/MetaMonitor.ts
var MetaMonitor, metaMonitor;
var init_MetaMonitor = __esm({
  "src/services/MetaMonitor.ts"() {
    init_esm_shims();
    MetaMonitor = class {
      sessionHistory = /* @__PURE__ */ new Map();
      currentStrategies = /* @__PURE__ */ new Map();
      modeTransitions = /* @__PURE__ */ new Map();
      /**
       * Record a thought in session history
       */
      recordThought(sessionId, thought) {
        if (!this.sessionHistory.has(sessionId)) {
          this.sessionHistory.set(sessionId, []);
        }
        const history = this.sessionHistory.get(sessionId);
        history.push({
          thoughtId: thought.id,
          mode: thought.mode,
          timestamp: thought.timestamp,
          content: thought.content,
          uncertainty: "uncertainty" in thought ? thought.uncertainty : void 0
        });
        if (!this.modeTransitions.has(sessionId)) {
          this.modeTransitions.set(sessionId, []);
        }
        const transitions = this.modeTransitions.get(sessionId);
        if (transitions.length === 0 || transitions[transitions.length - 1] !== thought.mode) {
          transitions.push(thought.mode);
        }
      }
      /**
       * Start tracking a new strategy
       */
      startStrategy(sessionId, mode) {
        this.currentStrategies.set(sessionId, {
          mode,
          thoughtsSpent: 0,
          startTime: /* @__PURE__ */ new Date(),
          progressIndicators: [],
          issuesEncountered: []
        });
      }
      /**
       * Update current strategy progress
       */
      updateStrategyProgress(sessionId, indicator) {
        const strategy = this.currentStrategies.get(sessionId);
        if (strategy) {
          strategy.progressIndicators.push(indicator);
          strategy.thoughtsSpent++;
        }
      }
      /**
       * Record an issue with current strategy
       */
      recordStrategyIssue(sessionId, issue) {
        const strategy = this.currentStrategies.get(sessionId);
        if (strategy) {
          strategy.issuesEncountered.push(issue);
        }
      }
      /**
       * Evaluate current strategy effectiveness
       */
      evaluateStrategy(sessionId) {
        const strategy = this.currentStrategies.get(sessionId);
        if (!strategy) {
          return {
            effectiveness: 0.5,
            efficiency: 0.5,
            confidence: 0.5,
            progressRate: 0,
            qualityScore: 0.5,
            issues: ["No active strategy being tracked"],
            strengths: []
          };
        }
        const thoughtsSpent = strategy.thoughtsSpent;
        const progressMade = strategy.progressIndicators.length;
        const issuesCount = strategy.issuesEncountered.length;
        const timeElapsed = (/* @__PURE__ */ new Date()).getTime() - strategy.startTime.getTime();
        const effectiveness = Math.min(1, progressMade / Math.max(1, thoughtsSpent));
        const efficiency = timeElapsed > 0 ? Math.min(1, progressMade / (timeElapsed / 6e4)) : 0.5;
        const confidence = Math.max(0.1, 1 - issuesCount * 0.15);
        const progressRate = thoughtsSpent > 0 ? progressMade / thoughtsSpent : 0;
        const qualityScore = effectiveness * 0.4 + efficiency * 0.2 + confidence * 0.4;
        return {
          effectiveness,
          efficiency,
          confidence,
          progressRate,
          qualityScore,
          issues: [...strategy.issuesEncountered],
          strengths: strategy.progressIndicators.slice(-3)
          // Recent progress
        };
      }
      /**
       * Suggest alternative strategies based on current performance
       */
      suggestAlternatives(sessionId, currentMode) {
        const evaluation = this.evaluateStrategy(sessionId);
        const alternatives = [];
        if (evaluation.effectiveness < 0.4) {
          if (currentMode !== "hybrid" /* HYBRID */) {
            alternatives.push({
              mode: "hybrid" /* HYBRID */,
              reasoning: "Low effectiveness detected - hybrid multi-modal approach may provide better results",
              expectedBenefit: "Combines multiple reasoning types for comprehensive analysis",
              switchingCost: 0.3,
              recommendationScore: 0.85
            });
          }
          if (currentMode !== "inductive" /* INDUCTIVE */) {
            alternatives.push({
              mode: "inductive" /* INDUCTIVE */,
              reasoning: "Consider gathering more empirical observations",
              expectedBenefit: "Build stronger generalizations from specific cases",
              switchingCost: 0.2,
              recommendationScore: 0.7
            });
          }
        }
        if (evaluation.effectiveness >= 0.4 && evaluation.efficiency < 0.5) {
          alternatives.push({
            mode: currentMode,
            // Same mode, but recommend refinement
            reasoning: "Progress detected but efficiency is low - consider refining current approach",
            expectedBenefit: "Improved efficiency while maintaining progress",
            switchingCost: 0.1,
            recommendationScore: 0.65
          });
        }
        return alternatives;
      }
      /**
       * Calculate quality metrics for current session
       */
      calculateQualityMetrics(sessionId) {
        const history = this.sessionHistory.get(sessionId) || [];
        const strategy = this.currentStrategies.get(sessionId);
        if (history.length === 0) {
          return {
            logicalConsistency: 0.5,
            evidenceQuality: 0.5,
            completeness: 0.5,
            originality: 0.5,
            clarity: 0.5,
            overallQuality: 0.5
          };
        }
        const issuesCount = strategy?.issuesEncountered.length || 0;
        const logicalConsistency = Math.max(0.1, 1 - issuesCount * 0.1);
        const avgUncertainty = history.reduce((sum, entry) => sum + (entry.uncertainty || 0.5), 0) / history.length;
        const evidenceQuality = 1 - avgUncertainty;
        const completeness = Math.min(1, history.length / 5);
        const uniqueModes = new Set(history.map((h) => h.mode)).size;
        const originality = Math.min(1, uniqueModes / 3);
        const progressCount = strategy?.progressIndicators.length || 0;
        const clarity = Math.min(1, progressCount / Math.max(1, history.length));
        const overallQuality = logicalConsistency * 0.25 + evidenceQuality * 0.2 + completeness * 0.15 + originality * 0.15 + clarity * 0.25;
        return {
          logicalConsistency,
          evidenceQuality,
          completeness,
          originality,
          clarity,
          overallQuality
        };
      }
      /**
       * Get session context for meta-reasoning
       */
      getSessionContext(sessionId, problemType) {
        const history = this.sessionHistory.get(sessionId) || [];
        const transitions = this.modeTransitions.get(sessionId) || [];
        return {
          sessionId,
          totalThoughts: history.length,
          modesUsed: transitions,
          modeSwitches: Math.max(0, transitions.length - 1),
          problemType,
          historicalEffectiveness: this.getHistoricalEffectiveness(problemType)
        };
      }
      /**
       * Get historical effectiveness for similar problems (simplified)
       */
      getHistoricalEffectiveness(_problemType) {
        return void 0;
      }
      /**
       * Clear session data (for cleanup)
       */
      clearSession(sessionId) {
        this.sessionHistory.delete(sessionId);
        this.currentStrategies.delete(sessionId);
        this.modeTransitions.delete(sessionId);
      }
      /**
       * Get all tracked sessions
       */
      getActiveSessions() {
        return Array.from(this.sessionHistory.keys());
      }
    };
    metaMonitor = new MetaMonitor();
  }
});
var DEFAULT_CONFIG2, SessionManager;
var init_manager = __esm({
  "src/session/manager.ts"() {
    init_esm_shims();
    init_errors();
    init_sanitization();
    init_logger();
    init_lru();
    init_SessionMetricsCalculator();
    init_MetaMonitor();
    DEFAULT_CONFIG2 = {
      modeConfig: {
        mode: "hybrid" /* HYBRID */,
        strictValidation: false,
        allowModeSwitch: true
      },
      enableAutoSave: true,
      enableValidation: true,
      enableVisualization: true,
      integrations: {},
      exportFormats: ["markdown", "latex", "json"],
      autoExportOnComplete: false,
      maxThoughtsInMemory: 1e3,
      compressionThreshold: 500
    };
    SessionManager = class {
      activeSessions;
      config;
      logger;
      storage;
      metricsCalculator;
      monitor;
      /**
       * Creates a new SessionManager instance
       *
       * @param config - Optional default configuration applied to all new sessions
       * @param logger - Optional logger instance or log level (default: INFO level logger)
       * @param storage - Optional persistent storage backend for sessions
       * @param monitor - Optional MetaMonitor instance for dependency injection
       *
       * @example
       * ```typescript
       * // Memory-only mode with default logger
       * const manager = new SessionManager({
       *   enableAutoSave: true,
       *   maxThoughtsInMemory: 500
       * });
       *
       * // With custom logger (DI)
       * import { createLogger, LogLevel } from './utils/logger.js';
       * const logger = createLogger({ minLevel: LogLevel.DEBUG });
       * const manager = new SessionManager({}, logger);
       *
       * // With file-based persistence (backward compatible)
       * import { FileSessionStore } from './storage/file-store.js';
       * const storage = new FileSessionStore('./sessions');
       * await storage.initialize();
       * const manager = new SessionManager({}, LogLevel.INFO, storage);
       * ```
       */
      constructor(config, logger2, storage, monitor) {
        this.activeSessions = new LRUCache({
          maxSize: 1e3,
          enableStats: true,
          onEvict: async (key, session) => {
            if (this.storage && session.config.enableAutoSave) {
              try {
                await this.storage.saveSession(session);
                this.logger.debug("Evicted session saved to storage", { sessionId: key });
              } catch (error) {
                this.logger.error("Failed to save evicted session", error, { sessionId: key });
              }
            }
            if (this.monitor) {
              this.monitor.clearSession(key);
            }
          }
        });
        this.config = config || {};
        this.storage = storage;
        this.monitor = monitor || metaMonitor;
        if (logger2 && typeof logger2 === "object" && "info" in logger2) {
          this.logger = logger2;
        } else {
          this.logger = createLogger({
            minLevel: logger2 || 1 /* INFO */,
            enableConsole: true
          });
        }
        this.metricsCalculator = new SessionMetricsCalculator();
      }
      /**
       * Create a new thinking session
       *
       * Creates and initializes a new thinking session with the specified configuration.
       * Sessions are stored in memory and tracked until explicitly deleted.
       *
       * @param options - Session creation options
       * @param options.title - Session title (default: 'Untitled Session')
       * @param options.mode - Thinking mode to use (default: HYBRID)
       * @param options.domain - Problem domain (e.g., 'mathematics', 'physics')
       * @param options.author - Session creator/author
       * @param options.config - Session-specific configuration overrides
       * @returns Promise resolving to the created session
       *
       * @example
       * ```typescript
       * const session = await manager.createSession({
       *   title: 'Mathematical Proof',
       *   mode: ThinkingMode.MATHEMATICS,
       *   domain: 'number-theory',
       *   author: 'user@example.com'
       * });
       * ```
       */
      async createSession(options = {}) {
        const title = options.title ? sanitizeString(options.title, MAX_LENGTHS.TITLE, "title") : "Untitled Session";
        const domain = options.domain ? sanitizeString(options.domain, MAX_LENGTHS.DOMAIN, "domain") : void 0;
        const author = options.author ? sanitizeString(options.author, MAX_LENGTHS.AUTHOR, "author") : void 0;
        const sessionId = randomUUID();
        const now = /* @__PURE__ */ new Date();
        const session = {
          id: sessionId,
          title,
          mode: options.mode || "hybrid" /* HYBRID */,
          domain,
          config: this.mergeConfig(options.config),
          thoughts: [],
          createdAt: now,
          updatedAt: now,
          author,
          currentThoughtNumber: 0,
          isComplete: false,
          metrics: this.metricsCalculator.initializeMetrics(),
          tags: [],
          collaborators: author ? [author] : []
        };
        this.activeSessions.set(sessionId, session);
        if (this.storage && session.config.enableAutoSave) {
          try {
            await this.storage.saveSession(session);
            this.logger.debug("Session persisted to storage", { sessionId });
          } catch (error) {
            this.logger.error("Failed to persist session", error, { sessionId });
          }
        }
        this.monitor.startStrategy(sessionId, session.mode);
        this.logger.info("Session created", {
          sessionId,
          title,
          mode: session.mode,
          domain,
          author
        });
        return session;
      }
      /**
       * Get a session by ID
       *
       * Retrieves a session by its unique identifier. If the session is not in memory
       * but storage is available, it will attempt to load from storage.
       *
       * @param sessionId - Unique UUID v4 identifier of the session
       * @returns Promise resolving to the session, or null if not found
       *
       * @example
       * ```typescript
       * const session = await manager.getSession('550e8400-e29b-41d4-a716-446655440000');
       * if (session) {
       *   console.log(`Session: ${session.title}`);
       *   console.log(`Thoughts: ${session.thoughts.length}`);
       * }
       * ```
       */
      async getSession(sessionId) {
        let session = this.activeSessions.get(sessionId);
        if (!session && this.storage) {
          try {
            session = await this.storage.loadSession(sessionId) ?? void 0;
            if (session) {
              this.activeSessions.set(sessionId, session);
              this.logger.debug("Session loaded from storage", { sessionId });
            }
          } catch (error) {
            this.logger.error("Failed to load session from storage", error, { sessionId });
          }
        }
        return session || null;
      }
      /**
       * Add a thought to a session
       *
       * Adds a new thought to an existing session and automatically updates:
       * - Session metrics (uses O(1) incremental calculation)
       * - Thought timestamps
       * - Session completion status
       * - Mode-specific analytics
       *
       * @param sessionId - ID of the session to add thought to
       * @param thought - The thought object to add
       * @returns Promise resolving to the updated session
       * @throws Error if session is not found
       *
       * @example
       * ```typescript
       * await manager.addThought(session.id, {
       *   thought: 'Initial hypothesis: the problem can be solved using...',
       *   thoughtNumber: 1,
       *   totalThoughts: 5,
       *   nextThoughtNeeded: true,
       *   uncertainty: 0.3
       * });
       * ```
       */
      async addThought(sessionId, thought) {
        validateSessionId(sessionId);
        const session = this.activeSessions.get(sessionId);
        if (!session) {
          this.logger.error("Session not found", void 0, { sessionId });
          throw new SessionNotFoundError(sessionId);
        }
        if (thought.content) {
          thought.content = sanitizeThoughtContent(thought.content);
        }
        thought.sessionId = sessionId;
        thought.timestamp = /* @__PURE__ */ new Date();
        session.thoughts.push(thought);
        session.currentThoughtNumber = thought.thoughtNumber;
        session.updatedAt = /* @__PURE__ */ new Date();
        this.metricsCalculator.updateMetrics(session, thought);
        this.monitor.recordThought(sessionId, thought);
        if (!thought.nextThoughtNeeded) {
          session.isComplete = true;
          this.logger.info("Session completed", {
            sessionId,
            title: session.title,
            totalThoughts: session.thoughts.length
          });
        }
        if (this.storage && session.config.enableAutoSave) {
          try {
            await this.storage.saveSession(session);
            this.logger.debug("Session persisted after thought added", { sessionId });
          } catch (error) {
            this.logger.error("Failed to persist session", error, { sessionId });
          }
        }
        this.logger.debug("Thought added", {
          sessionId,
          thoughtNumber: thought.thoughtNumber,
          totalThoughts: session.thoughts.length
        });
        return session;
      }
      /**
       * Update session mode (switch reasoning approach mid-session)
       *
       * Changes the thinking mode of an active session. This is useful when
       * the problem requires a different reasoning approach.
       *
       * @param sessionId - ID of the session to update
       * @param newMode - New thinking mode to switch to
       * @param reason - Optional reason for the mode switch
       * @returns Promise resolving to the updated session
       * @throws Error if session is not found
       *
       * @example
       * ```typescript
       * await manager.switchMode(
       *   session.id,
       *   ThinkingMode.CAUSAL,
       *   'Need to analyze cause-effect relationships'
       * );
       * ```
       */
      async switchMode(sessionId, newMode, reason) {
        validateSessionId(sessionId);
        const session = this.activeSessions.get(sessionId);
        if (!session) {
          this.logger.error("Session not found", void 0, { sessionId });
          throw new SessionNotFoundError(sessionId);
        }
        const oldMode = session.mode;
        session.mode = newMode;
        session.config.modeConfig.mode = newMode;
        session.updatedAt = /* @__PURE__ */ new Date();
        if (this.storage && session.config.enableAutoSave) {
          try {
            await this.storage.saveSession(session);
            this.logger.debug("Session persisted after mode switch", { sessionId });
          } catch (error) {
            this.logger.error("Failed to persist session", error, { sessionId });
          }
        }
        this.logger.info("Session mode switched", {
          sessionId,
          oldMode,
          newMode,
          reason
        });
        return session;
      }
      /**
       * List all active sessions with metadata
       *
       * Returns summary information for all sessions. If storage is available,
       * includes both in-memory sessions and persisted sessions.
       *
       * @param includeStoredSessions - Whether to include sessions from storage (default: true)
       * @returns Promise resolving to array of session metadata
       *
       * @example
       * ```typescript
       * const sessions = await manager.listSessions();
       * sessions.forEach(s => {
       *   console.log(`${s.title}: ${s.thoughtCount} thoughts (${s.mode})`);
       * });
       * ```
       */
      async listSessions(includeStoredSessions = true) {
        const memoryMetadata = Array.from(this.activeSessions.values()).map((session) => ({
          id: session.id,
          title: session.title,
          createdAt: session.createdAt,
          updatedAt: session.updatedAt,
          thoughtCount: session.thoughts.length,
          mode: session.mode,
          isComplete: session.isComplete
        }));
        if (!this.storage || !includeStoredSessions) {
          return memoryMetadata;
        }
        try {
          const storedMetadata = await this.storage.listSessions();
          const memoryIds = new Set(memoryMetadata.map((s) => s.id));
          const combined = [
            ...memoryMetadata,
            ...storedMetadata.filter((s) => !memoryIds.has(s.id))
          ];
          return combined;
        } catch (error) {
          this.logger.error("Failed to list stored sessions", error);
          return memoryMetadata;
        }
      }
      /**
       * Delete a session
       *
       * Removes a session from memory and storage (if available).
       * This operation cannot be undone.
       *
       * @param sessionId - ID of the session to delete
       * @returns Promise that resolves when deletion is complete
       *
       * @example
       * ```typescript
       * await manager.deleteSession('old-session-id');
       * ```
       */
      async deleteSession(sessionId) {
        const session = this.activeSessions.get(sessionId);
        const deletedFromMemory = this.activeSessions.delete(sessionId);
        if (this.storage) {
          try {
            await this.storage.deleteSession(sessionId);
            this.logger.debug("Session deleted from storage", { sessionId });
          } catch (error) {
            this.logger.error("Failed to delete session from storage", error, { sessionId });
          }
        }
        if (deletedFromMemory && session) {
          this.logger.info("Session deleted", {
            sessionId,
            title: session.title,
            thoughtCount: session.thoughts.length
          });
        } else {
          this.logger.warn("Attempted to delete non-existent session from memory", { sessionId });
        }
      }
      /**
       * Generate a text summary of a session
       *
       * Creates a markdown-formatted summary including:
       * - Session metadata (title, mode, status)
       * - Total thought count
       * - Key thoughts (first 100 characters of each)
       *
       * @param sessionId - ID of the session to summarize
       * @returns Promise resolving to markdown-formatted summary
       * @throws Error if session is not found
       *
       * @example
       * ```typescript
       * const summary = await manager.generateSummary(session.id);
       * console.log(summary);
       * // Output:
       * // # Mathematical Proof
       * // Mode: mathematics
       * // Total Thoughts: 15
       * // Status: Complete
       * // ...
       * ```
       */
      async generateSummary(sessionId) {
        validateSessionId(sessionId);
        const session = this.activeSessions.get(sessionId);
        if (!session) {
          throw new SessionNotFoundError(sessionId);
        }
        let summary = `# ${session.title}

`;
        summary += `Mode: ${session.mode}
`;
        summary += `Total Thoughts: ${session.thoughts.length}
`;
        summary += `Status: ${session.isComplete ? "Complete" : "In Progress"}

`;
        summary += `## Key Thoughts:

`;
        for (const thought of session.thoughts) {
          summary += `${thought.thoughtNumber}. ${thought.content.substring(0, 100)}...
`;
        }
        return summary;
      }
      /**
       * Merge configurations (private helper)
       *
       * Combines default config, instance config, and user config
       * with proper precedence: user > instance > default
       */
      mergeConfig(userConfig) {
        return {
          ...DEFAULT_CONFIG2,
          ...this.config,
          ...userConfig
        };
      }
    };
  }
});

// src/session/index.ts
var session_exports = {};
__export(session_exports, {
  SessionManager: () => SessionManager
});
var init_session2 = __esm({
  "src/session/index.ts"() {
    init_esm_shims();
    init_manager();
  }
});

// src/session/storage/interface.ts
var DEFAULT_STORAGE_CONFIG;
var init_interface = __esm({
  "src/session/storage/interface.ts"() {
    init_esm_shims();
    DEFAULT_STORAGE_CONFIG = {
      autoSave: true,
      autoSaveDelay: 1e3,
      // 1 second
      enableCompression: false,
      maxSessions: 1e3,
      maxSessionAge: 30 * 24 * 60 * 60 * 1e3,
      // 30 days
      enableEncryption: false,
      serialization: {
        prettyPrint: false,
        includeMetadata: true
      }
    };
  }
});
function getLockPath(filePath) {
  return `${filePath}.lock`;
}
function getSharedLockDir(filePath) {
  return `${filePath}.locks`;
}
function createLockInfo(type) {
  return {
    pid: process.pid,
    hostname: __require("os").hostname(),
    timestamp: Date.now(),
    type,
    instanceId: INSTANCE_ID
  };
}
function isLockStale(lockInfo, staleThreshold) {
  const age = Date.now() - lockInfo.timestamp;
  return age > staleThreshold;
}
async function readLockInfo(lockPath) {
  try {
    const content = await promises.readFile(lockPath, "utf-8");
    return JSON.parse(content);
  } catch {
    return null;
  }
}
async function writeLockInfo(lockPath, lockInfo) {
  const tempPath = `${lockPath}.${INSTANCE_ID}.tmp`;
  try {
    await promises.writeFile(tempPath, JSON.stringify(lockInfo), { flag: "wx" });
    await promises.rename(tempPath, lockPath);
    return true;
  } catch (error) {
    try {
      await promises.unlink(tempPath);
    } catch {
    }
    if (error.code === "EEXIST" || error.code === "EPERM" || error.code === "ENOENT") {
      return false;
    }
    throw error;
  }
}
async function acquireExclusiveLock(filePath, options) {
  const lockPath = getLockPath(filePath);
  const sharedLockDir = getSharedLockDir(filePath);
  const startTime = Date.now();
  while (Date.now() - startTime < options.timeout) {
    const existingLock = await readLockInfo(lockPath);
    if (existingLock) {
      if (existingLock.instanceId === INSTANCE_ID) {
        return async () => {
          await promises.unlink(lockPath).catch(() => {
          });
        };
      }
      if (isLockStale(existingLock, options.staleThreshold)) {
        await promises.unlink(lockPath).catch(() => {
        });
      } else {
        await sleep(options.retryInterval);
        continue;
      }
    }
    try {
      const sharedLocks = await promises.readdir(sharedLockDir);
      const validSharedLocks = [];
      for (const lockFile of sharedLocks) {
        const sharedLockPath = path3.join(sharedLockDir, lockFile);
        const sharedLockInfo = await readLockInfo(sharedLockPath);
        if (sharedLockInfo && !isLockStale(sharedLockInfo, options.staleThreshold)) {
          validSharedLocks.push(sharedLockInfo);
        } else {
          await promises.unlink(sharedLockPath).catch(() => {
          });
        }
      }
      if (validSharedLocks.length > 0) {
        await sleep(options.retryInterval);
        continue;
      }
    } catch (error) {
      if (error.code !== "ENOENT") {
        throw error;
      }
    }
    const lockInfo = createLockInfo("exclusive");
    if (await writeLockInfo(lockPath, lockInfo)) {
      return async () => {
        await promises.unlink(lockPath).catch(() => {
        });
      };
    }
    await sleep(options.retryInterval);
  }
  throw new Error(`Timeout acquiring exclusive lock on ${filePath} after ${options.timeout}ms`);
}
async function acquireSharedLock(filePath, options) {
  const exclusiveLockPath = getLockPath(filePath);
  const sharedLockDir = getSharedLockDir(filePath);
  const sharedLockPath = path3.join(sharedLockDir, `${INSTANCE_ID}.lock`);
  const startTime = Date.now();
  while (Date.now() - startTime < options.timeout) {
    const exclusiveLock = await readLockInfo(exclusiveLockPath);
    if (exclusiveLock) {
      if (isLockStale(exclusiveLock, options.staleThreshold)) {
        await promises.unlink(exclusiveLockPath).catch(() => {
        });
      } else {
        await sleep(options.retryInterval);
        continue;
      }
    }
    await promises.mkdir(sharedLockDir, { recursive: true });
    const lockInfo = createLockInfo("shared");
    try {
      await promises.writeFile(sharedLockPath, JSON.stringify(lockInfo), { flag: "wx" });
      const recheck = await readLockInfo(exclusiveLockPath);
      if (recheck && !isLockStale(recheck, options.staleThreshold)) {
        await promises.unlink(sharedLockPath).catch(() => {
        });
        await sleep(options.retryInterval);
        continue;
      }
      return async () => {
        await promises.unlink(sharedLockPath).catch(() => {
        });
        try {
          const remaining = await promises.readdir(sharedLockDir);
          if (remaining.length === 0) {
            await promises.rmdir(sharedLockDir);
          }
        } catch {
        }
      };
    } catch (error) {
      if (error.code === "EEXIST") {
        return async () => {
          await promises.unlink(sharedLockPath).catch(() => {
          });
        };
      }
      throw error;
    }
  }
  throw new Error(`Timeout acquiring shared lock on ${filePath} after ${options.timeout}ms`);
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
async function acquireLock(filePath, options) {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  if (opts.type === "shared") {
    return acquireSharedLock(filePath, opts);
  }
  return acquireExclusiveLock(filePath, opts);
}
async function withLock(filePath, fn, options) {
  const release = await acquireLock(filePath, { ...options, type: "exclusive" });
  try {
    return await fn();
  } finally {
    await release();
  }
}
async function withSharedLock(filePath, fn, options) {
  const release = await acquireLock(filePath, { ...options, type: "shared" });
  try {
    return await fn();
  } finally {
    await release();
  }
}
var DEFAULT_OPTIONS, INSTANCE_ID;
var init_file_lock = __esm({
  "src/utils/file-lock.ts"() {
    init_esm_shims();
    DEFAULT_OPTIONS = {
      timeout: 1e4,
      retryInterval: 50,
      staleThreshold: 3e4,
      type: "exclusive"
    };
    INSTANCE_ID = `${process.pid}-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
  }
});

// src/session/storage/file-store.ts
var file_store_exports = {};
__export(file_store_exports, {
  FileSessionStore: () => FileSessionStore
});
var DEFAULT_LOCK_OPTIONS, FileSessionStore;
var init_file_store = __esm({
  "src/session/storage/file-store.ts"() {
    init_esm_shims();
    init_interface();
    init_logger();
    init_file_lock();
    DEFAULT_LOCK_OPTIONS = {
      timeout: 1e4,
      // 10 seconds
      retryInterval: 50,
      // 50ms between retries
      staleThreshold: 3e4
      // 30 seconds before lock is considered stale
    };
    FileSessionStore = class {
      baseDir;
      sessionsDir;
      metadataFile;
      config;
      metadataCache;
      initialized = false;
      lockOptions;
      /**
       * Create a new FileSessionStore
       *
       * @param baseDir - Base directory for session storage
       * @param config - Storage configuration options
       */
      constructor(baseDir, config) {
        this.baseDir = baseDir;
        this.sessionsDir = path3.join(baseDir, "sessions");
        this.metadataFile = path3.join(baseDir, "metadata", "index.json");
        this.config = { ...DEFAULT_STORAGE_CONFIG, ...config };
        this.metadataCache = /* @__PURE__ */ new Map();
        this.lockOptions = { ...DEFAULT_LOCK_OPTIONS };
      }
      /**
       * Initialize storage directories
       */
      async initialize() {
        if (this.initialized) {
          return;
        }
        try {
          await promises.mkdir(this.sessionsDir, { recursive: true });
          await promises.mkdir(path3.dirname(this.metadataFile), { recursive: true });
          await this.loadMetadataIndex();
          this.initialized = true;
          logger.info("FileSessionStore initialized", {
            baseDir: this.baseDir,
            config: this.config
          });
        } catch (error) {
          logger.error("Failed to initialize FileSessionStore", error instanceof Error ? error : new Error(String(error)), {
            baseDir: this.baseDir
          });
          throw error;
        }
      }
      /**
       * Save a session to disk (with exclusive lock)
       */
      async saveSession(session) {
        await this.ensureInitialized();
        const sessionPath = this.getSessionPath(session.id);
        try {
          await withLock(sessionPath, async () => {
            const serializable = this.prepareForSerialization(session);
            const json = this.config.serialization?.prettyPrint ? JSON.stringify(serializable, null, 2) : JSON.stringify(serializable);
            await promises.writeFile(sessionPath, json, "utf-8");
          }, this.lockOptions);
          await this.updateMetadata(session);
          logger.debug("Session saved", { sessionId: session.id, path: sessionPath });
        } catch (error) {
          logger.error("Failed to save session", error instanceof Error ? error : new Error(String(error)), {
            sessionId: session.id
          });
          throw error;
        }
      }
      /**
       * Load a session from disk (with shared lock)
       */
      async loadSession(sessionId) {
        await this.ensureInitialized();
        const sessionPath = this.getSessionPath(sessionId);
        try {
          try {
            await promises.access(sessionPath);
          } catch {
            return null;
          }
          const session = await withSharedLock(sessionPath, async () => {
            const json = await promises.readFile(sessionPath, "utf-8");
            const parsed = JSON.parse(json);
            return this.restoreFromSerialization(parsed);
          }, this.lockOptions);
          logger.debug("Session loaded", { sessionId });
          return session;
        } catch (error) {
          logger.error("Failed to load session", error instanceof Error ? error : new Error(String(error)), { sessionId });
          return null;
        }
      }
      /**
       * Delete a session from disk (with exclusive lock)
       */
      async deleteSession(sessionId) {
        await this.ensureInitialized();
        const sessionPath = this.getSessionPath(sessionId);
        try {
          try {
            await promises.access(sessionPath);
          } catch {
            return false;
          }
          await withLock(sessionPath, async () => {
            await promises.unlink(sessionPath);
          }, this.lockOptions);
          this.metadataCache.delete(sessionId);
          await this.saveMetadataIndex();
          logger.info("Session deleted", { sessionId });
          return true;
        } catch (error) {
          logger.error("Failed to delete session", error instanceof Error ? error : new Error(String(error)), { sessionId });
          return false;
        }
      }
      /**
       * List all sessions (metadata only)
       * Refreshes from disk to get updates from other instances
       */
      async listSessions() {
        await this.ensureInitialized();
        await this.loadMetadataIndex();
        return Array.from(this.metadataCache.values());
      }
      /**
       * Check if a session exists
       */
      async exists(sessionId) {
        await this.ensureInitialized();
        await this.loadMetadataIndex();
        return this.metadataCache.has(sessionId);
      }
      /**
       * Get storage statistics
       */
      async getStats() {
        await this.ensureInitialized();
        await this.loadMetadataIndex();
        const sessions = Array.from(this.metadataCache.values());
        const totalSessions = sessions.length;
        const totalThoughts = sessions.reduce((sum, s) => sum + s.thoughtCount, 0);
        let storageSize = 0;
        try {
          const files = await promises.readdir(this.sessionsDir);
          for (const file of files) {
            if (file.endsWith(".json")) {
              const filePath = path3.join(this.sessionsDir, file);
              const stats = await promises.stat(filePath);
              storageSize += stats.size;
            }
          }
        } catch (error) {
          logger.warn("Failed to calculate storage size", { error });
        }
        const dates = sessions.map((s) => new Date(s.createdAt)).sort((a, b) => a.getTime() - b.getTime());
        const averageSessionSize = totalSessions > 0 ? storageSize / totalSessions : 0;
        let storageHealth = "healthy";
        if (totalSessions > this.config.maxSessions * 0.9) {
          storageHealth = "critical";
        } else if (totalSessions > this.config.maxSessions * 0.7) {
          storageHealth = "warning";
        }
        return {
          totalSessions,
          totalThoughts,
          storageSize,
          oldestSession: dates[0],
          newestSession: dates[dates.length - 1],
          averageSessionSize,
          storageHealth
        };
      }
      /**
       * Clean up old sessions
       */
      async cleanup(maxAgeMs) {
        await this.ensureInitialized();
        await this.loadMetadataIndex();
        const now = Date.now();
        const sessions = Array.from(this.metadataCache.values());
        let cleanedCount = 0;
        for (const session of sessions) {
          const age = now - new Date(session.createdAt).getTime();
          if (age > maxAgeMs) {
            await this.deleteSession(session.id);
            cleanedCount++;
          }
        }
        if (cleanedCount > 0) {
          logger.info("Cleanup completed", {
            cleanedCount,
            maxAgeMs,
            remaining: sessions.length - cleanedCount
          });
        }
        return cleanedCount;
      }
      /**
       * Close storage (no-op for file storage)
       */
      async close() {
        logger.info("FileSessionStore closed");
        this.initialized = false;
      }
      /**
       * Get file path for a session
       */
      getSessionPath(sessionId) {
        return path3.join(this.sessionsDir, `${sessionId}.json`);
      }
      /**
       * Update metadata cache and index (with exclusive lock)
       */
      async updateMetadata(session) {
        const metadata = {
          id: session.id,
          title: session.title,
          createdAt: session.createdAt,
          updatedAt: session.updatedAt,
          thoughtCount: session.thoughts.length,
          mode: session.mode,
          isComplete: session.isComplete
        };
        this.metadataCache.set(session.id, metadata);
        await this.saveMetadataIndex();
      }
      /**
       * Load metadata index from disk (with shared lock)
       */
      async loadMetadataIndex() {
        try {
          await promises.access(this.metadataFile);
          const metadata = await withSharedLock(this.metadataFile, async () => {
            const json = await promises.readFile(this.metadataFile, "utf-8");
            const parsed = JSON.parse(json);
            return parsed.map(
              (item) => this.restoreFromSerialization(item)
            );
          }, this.lockOptions);
          this.metadataCache.clear();
          for (const meta of metadata) {
            this.metadataCache.set(meta.id, meta);
          }
          logger.debug("Metadata index loaded", {
            sessionCount: metadata.length
          });
        } catch {
          this.metadataCache.clear();
        }
      }
      /**
       * Save metadata index to disk (with exclusive lock)
       */
      async saveMetadataIndex() {
        try {
          await promises.access(this.metadataFile);
          const existingJson = await promises.readFile(this.metadataFile, "utf-8");
          const existingParsed = JSON.parse(existingJson);
          const existingMetadata = existingParsed.map(
            (item) => this.restoreFromSerialization(item)
          );
          for (const meta of existingMetadata) {
            if (!this.metadataCache.has(meta.id)) {
              const sessionPath = this.getSessionPath(meta.id);
              try {
                await promises.access(sessionPath);
                this.metadataCache.set(meta.id, meta);
              } catch {
              }
            }
          }
        } catch {
        }
        await withLock(this.metadataFile, async () => {
          const metadata = Array.from(this.metadataCache.values());
          const serializable = metadata.map((item) => this.prepareForSerialization(item));
          const json = JSON.stringify(serializable, null, 2);
          await promises.writeFile(this.metadataFile, json, "utf-8");
        }, this.lockOptions);
      }
      /**
       * Ensure storage is initialized
       */
      async ensureInitialized() {
        if (!this.initialized) {
          await this.initialize();
        }
      }
      /**
       * Prepare an object for serialization by converting special types
       * Recursively processes the object tree to handle Date and Map objects
       */
      prepareForSerialization(obj) {
        if (obj === null || obj === void 0) {
          return obj;
        }
        if (obj instanceof Date) {
          return {
            _type: "Date",
            value: obj.toISOString()
          };
        }
        if (obj instanceof Map) {
          return {
            _type: "Map",
            value: Array.from(obj.entries())
          };
        }
        if (Array.isArray(obj)) {
          return obj.map((item) => this.prepareForSerialization(item));
        }
        if (typeof obj === "object") {
          const result = {};
          for (const [key, value] of Object.entries(obj)) {
            result[key] = this.prepareForSerialization(value);
          }
          return result;
        }
        return obj;
      }
      /**
       * Restore an object from serialization by reconstructing special types
       * Recursively processes the object tree to restore Date and Map objects
       */
      restoreFromSerialization(obj) {
        if (obj === null || obj === void 0) {
          return obj;
        }
        if (typeof obj === "object" && obj._type) {
          if (obj._type === "Date") {
            return new Date(obj.value);
          }
          if (obj._type === "Map") {
            return new Map(obj.value);
          }
        }
        if (Array.isArray(obj)) {
          return obj.map((item) => this.restoreFromSerialization(item));
        }
        if (typeof obj === "object") {
          const result = {};
          for (const [key, value] of Object.entries(obj)) {
            result[key] = this.restoreFromSerialization(value);
          }
          return result;
        }
        return obj;
      }
    };
  }
});
var ThoughtFactory;
var init_ThoughtFactory = __esm({
  "src/services/ThoughtFactory.ts"() {
    init_esm_shims();
    init_type_guards();
    init_logger();
    init_modes();
    ThoughtFactory = class {
      logger;
      registry;
      useRegistryForAll;
      constructor(config = {}) {
        this.logger = config.logger || createLogger({ minLevel: 1 /* INFO */, enableConsole: true });
        this.registry = ModeHandlerRegistry.getInstance();
        this.useRegistryForAll = config.useRegistryForAll ?? true;
        if (config.autoRegisterHandlers !== false) {
          this.registerAllModeHandlers();
        }
      }
      /**
       * Register all 33 mode handlers (Phase 10 Sprint 3 v8.4.0)
       *
       * Uses the centralized registerAllHandlers() function from modes/index.ts
       * which registers handlers for all ThinkingModes:
       * - Core (5): Sequential, Shannon, Mathematics, Physics, Hybrid
       * - Fundamental Triad (3): Inductive, Deductive, Abductive
       * - Causal/Probabilistic (6): Causal, Bayesian, Counterfactual, Temporal, GameTheory, Evidential
       * - Analogical/First Principles (2): Analogical, FirstPrinciples
       * - Systems/Scientific (3): SystemsThinking, ScientificMethod, FormalLogic
       * - Academic (4): Synthesis, Argumentation, Critique, Analysis
       * - Engineering (4): Engineering, Computability, Cryptanalytic, Algorithmic
       * - Advanced Runtime (6): MetaReasoning, Recursive, Modal, Stochastic, Constraint, Optimization
       * - User-Defined (1): Custom
       */
      registerAllModeHandlers() {
        registerAllHandlers();
        const stats = this.registry.getStats();
        this.logger.debug("All mode handlers registered", {
          count: stats.specializedHandlers,
          categories: [
            "Core (5)",
            "Fundamental Triad (3)",
            "Causal/Probabilistic (6)",
            "Analogical/First Principles (2)",
            "Systems/Scientific (3)",
            "Academic (4)",
            "Engineering (4)",
            "Advanced Runtime (6)",
            "User-Defined (1)"
          ]
        });
      }
      // @deprecated registerSpecializedHandlers() - use registerAllModeHandlers() instead
      /**
       * Check if a mode has a specialized handler
       */
      hasSpecializedHandler(mode) {
        return this.registry.hasSpecializedHandler(mode);
      }
      /**
       * Get stats about registered handlers
       */
      getStats() {
        const stats = this.registry.getStats();
        return {
          specializedHandlers: stats.specializedHandlers,
          modesWithHandlers: stats.modesWithHandlers
        };
      }
      /**
       * Validate input using appropriate handler
       *
       * @param input - Tool input to validate
       * @returns Validation result
       */
      validate(input) {
        return this.registry.validate(input);
      }
      /**
       * Get mode status for API response
       *
       * @param mode - The thinking mode
       * @returns Mode status information
       */
      getModeStatus(mode) {
        return this.registry.getModeStatus(mode);
      }
      /**
       * Get the underlying registry for direct access
       *
       * Use this to register new handlers or access registry stats.
       *
       * @returns The ModeHandlerRegistry instance
       */
      getRegistry() {
        return this.registry;
      }
      /**
       * Determine if registry should be used for a mode
       */
      shouldUseRegistry(mode) {
        if (this.registry.hasSpecializedHandler(mode)) {
          return true;
        }
        if (this.useRegistryForAll) {
          return true;
        }
        return false;
      }
      /**
       * Create a thought object based on input and mode
       *
       * Generates a properly typed thought object with mode-specific fields
       * and default values. Each mode has unique required and optional fields.
       *
       * @param input - Thought input from MCP tool
       * @param sessionId - Session ID this thought belongs to
       * @returns Typed thought object ready for session storage
       *
       * @example
       * ```typescript
       * const thought = factory.createThought({
       *   mode: 'mathematics',
       *   thought: 'Analyzing the problem...',
       *   thoughtNumber: 1,
       *   totalThoughts: 5,
       *   nextThoughtNeeded: true,
       *   mathematicalModel: { equations: ['E = mc^2'] }
       * }, 'session-123');
       * ```
       */
      createThought(input, sessionId) {
        const mode = input.mode || "hybrid" /* HYBRID */;
        this.logger.debug("Creating thought", {
          sessionId,
          mode,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          isRevision: input.isRevision,
          hasSpecializedHandler: this.registry.hasSpecializedHandler(mode),
          useRegistryForAll: this.useRegistryForAll
        });
        if (this.shouldUseRegistry(mode)) {
          this.logger.debug("Using registry handler", { mode });
          return this.registry.createThought(input, sessionId);
        }
        this.logger.warn("Using legacy switch statement - mode handler not found", { mode });
        const baseThought = {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          isRevision: input.isRevision,
          revisesThought: input.revisesThought
        };
        switch (input.mode) {
          case "sequential":
            return {
              ...baseThought,
              mode: "sequential" /* SEQUENTIAL */,
              revisionReason: input.revisionReason,
              branchFrom: input.branchFrom,
              branchId: input.branchId
            };
          case "shannon":
            return {
              ...baseThought,
              mode: "shannon" /* SHANNON */,
              stage: input.stage || "problem_definition" /* PROBLEM_DEFINITION */,
              uncertainty: input.uncertainty || 0.5,
              dependencies: input.dependencies || [],
              assumptions: input.assumptions || []
            };
          case "mathematics":
            return {
              ...baseThought,
              mode: "mathematics" /* MATHEMATICS */,
              thoughtType: toExtendedThoughtType(input.thoughtType, "model"),
              mathematicalModel: input.mathematicalModel,
              proofStrategy: input.proofStrategy,
              dependencies: input.dependencies || [],
              assumptions: input.assumptions || [],
              uncertainty: input.uncertainty || 0.5
            };
          case "physics":
            return {
              ...baseThought,
              mode: "physics" /* PHYSICS */,
              thoughtType: toExtendedThoughtType(input.thoughtType, "model"),
              tensorProperties: input.tensorProperties,
              physicalInterpretation: input.physicalInterpretation,
              dependencies: input.dependencies || [],
              assumptions: input.assumptions || [],
              uncertainty: input.uncertainty || 0.5
            };
          case "inductive":
            return {
              ...baseThought,
              mode: "inductive" /* INDUCTIVE */,
              observations: input.observations || [],
              pattern: input.pattern,
              generalization: input.generalization || "",
              confidence: input.confidence ?? 0.5,
              counterexamples: input.counterexamples || [],
              sampleSize: input.sampleSize
            };
          case "deductive":
            return {
              ...baseThought,
              mode: "deductive" /* DEDUCTIVE */,
              premises: input.premises || [],
              conclusion: input.conclusion || "",
              logicForm: input.logicForm,
              validityCheck: input.validityCheck ?? false,
              soundnessCheck: input.soundnessCheck
            };
          case "abductive":
            return {
              ...baseThought,
              mode: "abductive" /* ABDUCTIVE */,
              thoughtType: toExtendedThoughtType(input.thoughtType, "problem_definition"),
              observations: input.observations || [],
              hypotheses: input.hypotheses || [],
              evaluationCriteria: input.evaluationCriteria,
              evidence: input.evidence || [],
              bestExplanation: input.bestExplanation
            };
          case "causal":
            const inputAny = input;
            const causalGraph = input.causalGraph || {
              nodes: inputAny.nodes || [],
              edges: inputAny.edges || []
            };
            return {
              ...baseThought,
              mode: "causal" /* CAUSAL */,
              thoughtType: toExtendedThoughtType(input.thoughtType, "problem_definition"),
              causalGraph,
              interventions: input.interventions || [],
              mechanisms: input.mechanisms || [],
              confounders: input.confounders || []
            };
          case "bayesian":
            return {
              ...baseThought,
              mode: "bayesian" /* BAYESIAN */,
              thoughtType: toExtendedThoughtType(input.thoughtType, "problem_definition"),
              hypothesis: input.hypothesis,
              prior: input.prior,
              likelihood: input.likelihood,
              evidence: input.evidence || [],
              posterior: input.posterior,
              bayesFactor: input.bayesFactor
            };
          case "counterfactual":
            return {
              ...baseThought,
              mode: "counterfactual" /* COUNTERFACTUAL */,
              thoughtType: toExtendedThoughtType(input.thoughtType, "problem_definition"),
              actual: input.actual,
              counterfactuals: input.counterfactuals || [],
              comparison: input.comparison,
              interventionPoint: input.interventionPoint,
              causalChains: input.causalChains || []
            };
          case "analogical":
            return {
              ...baseThought,
              mode: "analogical" /* ANALOGICAL */,
              thoughtType: toExtendedThoughtType(input.thoughtType, "analogy"),
              sourceDomain: input.sourceDomain,
              targetDomain: input.targetDomain,
              mapping: input.mapping || [],
              insights: input.insights || [],
              inferences: input.inferences || [],
              limitations: input.limitations || [],
              analogyStrength: input.analogyStrength
            };
          case "temporal":
            return {
              ...baseThought,
              mode: "temporal" /* TEMPORAL */,
              thoughtType: input.thoughtType || "event_definition",
              timeline: input.timeline,
              events: input.events || [],
              intervals: input.intervals || [],
              constraints: input.constraints || [],
              relations: input.relations || []
            };
          case "gametheory":
            return {
              ...baseThought,
              mode: "gametheory" /* GAMETHEORY */,
              thoughtType: input.thoughtType || "game_definition",
              game: input.game,
              players: input.players || [],
              strategies: input.strategies || [],
              payoffMatrix: input.payoffMatrix,
              nashEquilibria: input.nashEquilibria || [],
              dominantStrategies: input.dominantStrategies || [],
              gameTree: input.gameTree
            };
          case "evidential":
            return {
              ...baseThought,
              mode: "evidential" /* EVIDENTIAL */,
              thoughtType: input.thoughtType || "hypothesis_definition",
              frameOfDiscernment: input.frameOfDiscernment,
              hypotheses: input.hypotheses || [],
              evidence: input.evidence || [],
              beliefFunctions: input.beliefFunctions || [],
              combinedBelief: input.combinedBelief,
              plausibility: input.plausibility,
              decisions: input.decisions || []
            };
          case "firstprinciples" /* FIRSTPRINCIPLES */:
            return {
              ...baseThought,
              mode: "firstprinciples" /* FIRSTPRINCIPLES */,
              question: input.question || "",
              principles: input.principles || [],
              derivationSteps: input.derivationSteps || [],
              conclusion: input.conclusion || { statement: "", derivationChain: [], certainty: 0 },
              alternativeInterpretations: input.alternativeInterpretations || []
            };
          case "metareasoning": {
            const metaInput = input;
            return {
              ...baseThought,
              mode: "metareasoning" /* METAREASONING */,
              currentStrategy: metaInput.currentStrategy || {
                mode: "sequential" /* SEQUENTIAL */,
                approach: "Default sequential approach",
                startedAt: /* @__PURE__ */ new Date(),
                thoughtsSpent: 0,
                progressIndicators: []
              },
              strategyEvaluation: metaInput.strategyEvaluation || {
                effectiveness: 0.5,
                efficiency: 0.5,
                confidence: 0.5,
                progressRate: 0,
                qualityScore: 0.5,
                issues: [],
                strengths: []
              },
              alternativeStrategies: metaInput.alternativeStrategies || [],
              recommendation: metaInput.recommendation || {
                action: "CONTINUE",
                justification: "No specific recommendation yet",
                confidence: 0.5,
                expectedImprovement: "Monitor progress"
              },
              resourceAllocation: metaInput.resourceAllocation || {
                timeSpent: 0,
                thoughtsRemaining: input.totalThoughts - input.thoughtNumber,
                complexityLevel: "medium",
                urgency: "medium",
                recommendation: "Continue with current approach"
              },
              qualityMetrics: metaInput.qualityMetrics || {
                logicalConsistency: 0.5,
                evidenceQuality: 0.5,
                completeness: 0.5,
                originality: 0.5,
                clarity: 0.5,
                overallQuality: 0.5
              },
              sessionContext: metaInput.sessionContext || {
                sessionId,
                totalThoughts: input.thoughtNumber,
                modesUsed: [input.mode],
                modeSwitches: 0,
                problemType: "general"
              }
            };
          }
          case "engineering": {
            const engInput = input;
            return {
              ...baseThought,
              mode: "engineering" /* ENGINEERING */,
              analysisType: engInput.analysisType || "comprehensive",
              designChallenge: engInput.designChallenge || input.thought,
              requirements: engInput.requirements,
              tradeStudy: engInput.tradeStudy,
              fmea: engInput.fmea,
              designDecisions: engInput.designDecisions,
              assessment: engInput.assessment
            };
          }
          // ===== Phase 11 v7.2.0 - Turing's legacy =====
          case "computability": {
            const compInput = input;
            return {
              ...baseThought,
              mode: "computability" /* COMPUTABILITY */,
              thoughtType: compInput.thoughtType || "machine_definition",
              machines: compInput.machines || [],
              currentMachine: compInput.currentMachine,
              computationTrace: compInput.computationTrace,
              problems: compInput.problems || [],
              currentProblem: compInput.currentProblem,
              reductions: compInput.reductions || [],
              reductionChain: compInput.reductionChain || [],
              decidabilityProof: compInput.decidabilityProof,
              diagonalization: compInput.diagonalization,
              complexityAnalysis: compInput.complexityAnalysis,
              oracleAnalysis: compInput.oracleAnalysis,
              dependencies: compInput.dependencies || [],
              assumptions: compInput.assumptions || [],
              uncertainty: compInput.uncertainty ?? 0.5,
              classicProblems: compInput.classicProblems || [],
              keyInsight: compInput.keyInsight
            };
          }
          case "cryptanalytic": {
            const cryptInput = input;
            return {
              ...baseThought,
              mode: "cryptanalytic" /* CRYPTANALYTIC */,
              thoughtType: cryptInput.thoughtType || "hypothesis_formation",
              ciphertext: cryptInput.ciphertext,
              plaintext: cryptInput.plaintext,
              hypotheses: cryptInput.hypotheses || [],
              currentHypothesis: cryptInput.currentHypothesis,
              evidenceChains: cryptInput.evidenceChains || [],
              keySpaceAnalysis: cryptInput.keySpaceAnalysis,
              frequencyAnalysis: cryptInput.frequencyAnalysis,
              banburismusAnalysis: cryptInput.banburismusAnalysis || [],
              cribAnalysis: cryptInput.cribAnalysis || [],
              patterns: cryptInput.patterns || [],
              cipherType: cryptInput.cipherType,
              dependencies: cryptInput.dependencies || [],
              assumptions: cryptInput.assumptions || [],
              uncertainty: cryptInput.uncertainty ?? 0.5,
              keyInsight: cryptInput.keyInsight
            };
          }
          // ===== Phase 12 v7.3.0 - CLRS algorithms =====
          case "algorithmic": {
            const algoInput = input;
            return {
              ...baseThought,
              mode: "algorithmic" /* ALGORITHMIC */,
              thoughtType: algoInput.thoughtType || "algorithm_definition",
              algorithm: algoInput.algorithm,
              clrsCategory: algoInput.clrsCategory,
              clrsAlgorithm: algoInput.clrsAlgorithm,
              designPattern: algoInput.designPattern,
              timeComplexity: algoInput.timeComplexity,
              spaceComplexity: algoInput.spaceComplexity,
              recurrence: algoInput.recurrence,
              correctnessProof: algoInput.correctnessProof,
              loopInvariants: algoInput.loopInvariants || [],
              dpFormulation: algoInput.dpFormulation,
              greedyProof: algoInput.greedyProof,
              graphContext: algoInput.graphContext,
              dataStructure: algoInput.dataStructure,
              amortizedAnalysis: algoInput.amortizedAnalysis,
              comparison: algoInput.comparison,
              dependencies: algoInput.dependencies || [],
              assumptions: algoInput.assumptions || [],
              uncertainty: algoInput.uncertainty ?? 0.5,
              keyInsight: algoInput.keyInsight,
              pseudocode: algoInput.pseudocode,
              executionTrace: algoInput.executionTrace
            };
          }
          // ===== Phase 4 v3.2.0 - Scientific modes =====
          case "systemsthinking": {
            const sysInput = input;
            return {
              ...baseThought,
              mode: "systemsthinking" /* SYSTEMSTHINKING */,
              thoughtType: sysInput.thoughtType || "system_definition",
              system: sysInput.system,
              components: sysInput.components || [],
              feedbackLoops: sysInput.feedbackLoops || [],
              leveragePoints: sysInput.leveragePoints || [],
              behaviors: sysInput.behaviors || []
            };
          }
          case "scientificmethod": {
            const sciInput = input;
            return {
              ...baseThought,
              mode: "scientificmethod" /* SCIENTIFICMETHOD */,
              thoughtType: sciInput.thoughtType || "question_formulation",
              researchQuestion: sciInput.researchQuestion,
              scientificHypotheses: sciInput.scientificHypotheses || [],
              experiment: sciInput.experiment,
              data: sciInput.data,
              analysis: sciInput.analysis,
              conclusion: sciInput.conclusion
            };
          }
          case "formallogic": {
            const logicInput = input;
            return {
              ...baseThought,
              mode: "formallogic" /* FORMALLOGIC */,
              thoughtType: logicInput.thoughtType || "proposition_definition",
              propositions: logicInput.propositions || [],
              logicalInferences: logicInput.logicalInferences || [],
              proof: logicInput.proof,
              truthTable: logicInput.truthTable,
              satisfiability: logicInput.satisfiability
            };
          }
          case "optimization": {
            const optInput = input;
            return {
              ...baseThought,
              mode: "optimization" /* OPTIMIZATION */,
              thoughtType: optInput.thoughtType || "problem_formulation",
              objectiveFunction: optInput.objectiveFunction,
              constraints: optInput.constraints || [],
              variables: optInput.variables || [],
              solution: optInput.solution,
              method: optInput.method,
              convergence: optInput.convergence,
              sensitivity: optInput.sensitivity
            };
          }
          // ===== Phase 13 v7.4.0 - Academic Research modes =====
          case "synthesis": {
            const synthInput = input;
            return {
              ...baseThought,
              mode: "synthesis" /* SYNTHESIS */,
              thoughtType: synthInput.thoughtType || "source_identification",
              sources: synthInput.sources || [],
              reviewMetadata: synthInput.reviewMetadata,
              concepts: synthInput.concepts || [],
              themes: synthInput.themes || [],
              findings: synthInput.findings || [],
              patterns: synthInput.patterns || [],
              relations: synthInput.relations || [],
              gaps: synthInput.gaps || [],
              contradictions: synthInput.contradictions || [],
              framework: synthInput.framework,
              conclusions: synthInput.conclusions || [],
              dependencies: synthInput.dependencies || [],
              assumptions: synthInput.assumptions || [],
              uncertainty: synthInput.uncertainty ?? 0.5,
              keyInsight: synthInput.keyInsight
            };
          }
          case "argumentation": {
            const argInput = input;
            return {
              ...baseThought,
              mode: "argumentation" /* ARGUMENTATION */,
              thoughtType: argInput.thoughtType || "claim_formulation",
              claims: argInput.claims || [],
              currentClaim: argInput.currentClaim,
              grounds: argInput.grounds || [],
              warrants: argInput.warrants || [],
              backings: argInput.backings || [],
              qualifiers: argInput.qualifiers || [],
              rebuttals: argInput.rebuttals || [],
              arguments: argInput.arguments || [],
              currentArgument: argInput.currentArgument,
              argumentChain: argInput.argumentChain,
              dialectic: argInput.dialectic,
              rhetoricalStrategies: argInput.rhetoricalStrategies || [],
              audienceConsideration: argInput.audienceConsideration,
              fallacies: argInput.fallacies || [],
              argumentStrength: argInput.argumentStrength ?? 0.5,
              dependencies: argInput.dependencies || [],
              assumptions: argInput.assumptions || [],
              uncertainty: argInput.uncertainty ?? 0.5,
              keyInsight: argInput.keyInsight
            };
          }
          case "critique": {
            const critInput = input;
            return {
              ...baseThought,
              mode: "critique" /* CRITIQUE */,
              thoughtType: critInput.thoughtType || "work_characterization",
              work: critInput.work || {
                id: randomUUID(),
                title: "Untitled Work",
                authors: [],
                year: (/* @__PURE__ */ new Date()).getFullYear(),
                type: "empirical_study",
                field: "Unknown",
                claimedContribution: ""
              },
              methodologyEvaluation: critInput.methodologyEvaluation,
              argumentCritique: critInput.argumentCritique,
              evidenceCritique: critInput.evidenceCritique,
              contributionEvaluation: critInput.contributionEvaluation,
              critiquePoints: critInput.critiquePoints || [],
              improvements: critInput.improvements || [],
              verdict: critInput.verdict,
              strengthsIdentified: critInput.strengthsIdentified ?? 0,
              weaknessesIdentified: critInput.weaknessesIdentified ?? 0,
              balanceRatio: critInput.balanceRatio ?? 1,
              dependencies: critInput.dependencies || [],
              assumptions: critInput.assumptions || [],
              uncertainty: critInput.uncertainty ?? 0.5,
              keyInsight: critInput.keyInsight
            };
          }
          case "analysis": {
            const analInput = input;
            return {
              ...baseThought,
              mode: "analysis" /* ANALYSIS */,
              thoughtType: analInput.thoughtType || "data_familiarization",
              methodology: analInput.methodology || "thematic_analysis",
              dataSources: analInput.dataSources || [],
              dataSegments: analInput.dataSegments || [],
              totalSegments: analInput.totalSegments,
              codebook: analInput.codebook,
              currentCodes: analInput.currentCodes || [],
              codingProgress: analInput.codingProgress,
              themes: analInput.themes || [],
              thematicMap: analInput.thematicMap,
              memos: analInput.memos || [],
              gtCategories: analInput.gtCategories || [],
              theoreticalSampling: analInput.theoreticalSampling || [],
              discoursePatterns: analInput.discoursePatterns || [],
              rigorAssessment: analInput.rigorAssessment,
              dependencies: analInput.dependencies || [],
              assumptions: analInput.assumptions || [],
              uncertainty: analInput.uncertainty ?? 0.5,
              keyInsight: analInput.keyInsight
            };
          }
          case "hybrid":
          default:
            return {
              ...baseThought,
              mode: "hybrid" /* HYBRID */,
              thoughtType: toExtendedThoughtType(input.thoughtType, "synthesis"),
              stage: input.stage,
              uncertainty: input.uncertainty,
              dependencies: input.dependencies,
              assumptions: input.assumptions,
              mathematicalModel: input.mathematicalModel,
              tensorProperties: input.tensorProperties,
              physicalInterpretation: input.physicalInterpretation,
              primaryMode: input.mode || "hybrid" /* HYBRID */,
              secondaryFeatures: []
            };
        }
      }
    };
  }
});

// src/export/visual/utils.ts
function sanitizeId(id) {
  return id.replace(/[^a-zA-Z0-9_]/g, "_");
}
var init_utils = __esm({
  "src/export/visual/utils.ts"() {
    init_esm_shims();
  }
});

// src/export/visual/utils/mermaid.ts
function sanitizeMermaidId(id) {
  return id.replace(/[^a-zA-Z0-9_]/g, "_").replace(/^(\d)/, "_$1").replace(/__+/g, "_").replace(/^_+|_+$/g, "") || "node";
}
function escapeMermaidLabel(label) {
  return label.replace(/"/g, "#quot;").replace(/</g, "#lt;").replace(/>/g, "#gt;").replace(/\[/g, "#91;").replace(/\]/g, "#93;").replace(/\{/g, "#123;").replace(/\}/g, "#125;").replace(/\(/g, "#40;").replace(/\)/g, "#41;").replace(/\|/g, "#124;").replace(/\n/g, "<br/>");
}
function truncateLabel(label, maxLength = 40) {
  if (label.length <= maxLength) return label;
  return label.substring(0, maxLength - 3) + "...";
}
function getNodeShapeBrackets(shape) {
  switch (shape) {
    case "rectangle":
      return ["[", "]"];
    case "rounded":
      return ["(", ")"];
    case "stadium":
      return ["([", "])"];
    case "subroutine":
      return ["[[", "]]"];
    case "cylinder":
      return ["[(", ")]"];
    case "circle":
      return ["((", "))"];
    case "asymmetric":
      return [">", "]"];
    case "rhombus":
      return ["{", "}"];
    case "hexagon":
      return ["{{", "}}"];
    case "parallelogram":
      return ["[/", "/]"];
    case "parallelogram-alt":
      return ["[\\", "\\]"];
    case "trapezoid":
      return ["[/", "\\]"];
    case "trapezoid-alt":
      return ["[\\", "/]"];
    case "double-circle":
      return ["(((", ")))"];
    default:
      return ["[", "]"];
  }
}
function renderMermaidNode(node) {
  const id = sanitizeMermaidId(node.id);
  const label = escapeMermaidLabel(node.label);
  const [open, close] = getNodeShapeBrackets(node.shape || "rectangle");
  let nodeStr = `  ${id}${open}"${label}"${close}`;
  if (node.className) {
    nodeStr += `:::${node.className}`;
  }
  return nodeStr;
}
function renderMermaidNodeStyle(nodeId, style) {
  if (!style) return "";
  const id = sanitizeMermaidId(nodeId);
  const styles = [];
  if (style.fill) styles.push(`fill:${style.fill}`);
  if (style.stroke) styles.push(`stroke:${style.stroke}`);
  if (style.strokeWidth) styles.push(`stroke-width:${style.strokeWidth}`);
  if (style.color) styles.push(`color:${style.color}`);
  if (styles.length === 0) return "";
  return `  style ${id} ${styles.join(",")}`;
}
function getEdgeArrow(style) {
  switch (style) {
    case "arrow":
      return "-->";
    case "open":
      return "---";
    case "dotted":
      return "-.->";
    case "thick":
      return "==>";
    case "invisible":
      return "~~~";
    default:
      return "-->";
  }
}
function renderMermaidEdge(edge) {
  const source = sanitizeMermaidId(edge.source);
  const target = sanitizeMermaidId(edge.target);
  const arrow = getEdgeArrow(edge.style || "arrow");
  if (edge.label) {
    const label = escapeMermaidLabel(edge.label);
    return `  ${source} ${arrow}|${label}| ${target}`;
  }
  return `  ${source} ${arrow} ${target}`;
}
function getMermaidColor(type, scheme = "default") {
  return MERMAID_COLORS[scheme][type];
}
function generateMermaidFlowchart(nodes, edges, options = {}) {
  const { direction = "TD", colorScheme = "default" } = options;
  const lines = [];
  lines.push(`graph ${direction}`);
  if (nodes.length > 0) {
    lines.push("");
    for (const node of nodes) {
      lines.push(renderMermaidNode(node));
    }
  }
  if (edges.length > 0) {
    lines.push("");
    for (const edge of edges) {
      lines.push(renderMermaidEdge(edge));
    }
  }
  if (colorScheme !== "monochrome") {
    const styledNodes = nodes.filter((n) => n.style);
    if (styledNodes.length > 0) {
      lines.push("");
      for (const node of styledNodes) {
        const styleStr = renderMermaidNodeStyle(node.id, node.style);
        if (styleStr) lines.push(styleStr);
      }
    }
  }
  return lines.join("\n");
}
var MERMAID_COLORS;
var init_mermaid = __esm({
  "src/export/visual/utils/mermaid.ts"() {
    init_esm_shims();
    MERMAID_COLORS = {
      default: {
        primary: "#a8d5ff",
        secondary: "#ffd699",
        success: "#81c784",
        warning: "#ffb74d",
        danger: "#e57373",
        info: "#4fc3f7",
        neutral: "#e0e0e0"
      },
      pastel: {
        primary: "#e1f5ff",
        secondary: "#fff3e0",
        success: "#c8e6c9",
        warning: "#ffecb3",
        danger: "#ffcdd2",
        info: "#b3e5fc",
        neutral: "#f5f5f5"
      },
      monochrome: {
        primary: "#e0e0e0",
        secondary: "#bdbdbd",
        success: "#9e9e9e",
        warning: "#757575",
        danger: "#616161",
        info: "#424242",
        neutral: "#f5f5f5"
      }
    };
  }
});

// src/export/visual/utils/dot.ts
function sanitizeDotId(id) {
  if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(id)) {
    return id;
  }
  return `"${escapeDotString(id)}"`;
}
function escapeDotString(str) {
  return str.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
}
function truncateDotLabel(label, maxLength = 50) {
  if (label.length <= maxLength) return label;
  return label.substring(0, maxLength - 3) + "...";
}
function renderDotNodeAttrs(node) {
  const attrs = [];
  if (node.label !== void 0) {
    attrs.push(`label="${escapeDotString(node.label)}"`);
  }
  if (node.shape) {
    attrs.push(`shape=${node.shape}`);
  }
  if (node.style) {
    const styleStr = Array.isArray(node.style) ? node.style.join(",") : node.style;
    attrs.push(`style="${styleStr}"`);
  }
  if (node.fillColor) {
    attrs.push(`fillcolor="${node.fillColor}"`);
  }
  if (node.color) {
    attrs.push(`color="${node.color}"`);
  }
  if (node.fontColor) {
    attrs.push(`fontcolor="${node.fontColor}"`);
  }
  if (node.fontName) {
    attrs.push(`fontname="${node.fontName}"`);
  }
  if (node.fontSize) {
    attrs.push(`fontsize=${node.fontSize}`);
  }
  if (node.width) {
    attrs.push(`width=${node.width}`);
  }
  if (node.height) {
    attrs.push(`height=${node.height}`);
  }
  if (node.tooltip) {
    attrs.push(`tooltip="${escapeDotString(node.tooltip)}"`);
  }
  if (node.url) {
    attrs.push(`URL="${escapeDotString(node.url)}"`);
  }
  return attrs.length > 0 ? ` [${attrs.join(", ")}]` : "";
}
function renderDotEdgeAttrs(edge) {
  const attrs = [];
  if (edge.label) {
    attrs.push(`label="${escapeDotString(edge.label)}"`);
  }
  if (edge.style) {
    attrs.push(`style=${edge.style}`);
  }
  if (edge.color) {
    attrs.push(`color="${edge.color}"`);
  }
  if (edge.fontColor) {
    attrs.push(`fontcolor="${edge.fontColor}"`);
  }
  if (edge.arrowHead) {
    attrs.push(`arrowhead=${edge.arrowHead}`);
  }
  if (edge.arrowTail) {
    attrs.push(`arrowtail=${edge.arrowTail}`);
  }
  if (edge.constraint === false) {
    attrs.push("constraint=false");
  }
  if (edge.weight !== void 0) {
    attrs.push(`weight=${edge.weight}`);
  }
  if (edge.penWidth !== void 0) {
    attrs.push(`penwidth=${edge.penWidth}`);
  }
  if (edge.tooltip) {
    attrs.push(`tooltip="${escapeDotString(edge.tooltip)}"`);
  }
  return attrs.length > 0 ? ` [${attrs.join(", ")}]` : "";
}
function renderDotNode(node) {
  const id = sanitizeDotId(node.id);
  const attrs = renderDotNodeAttrs(node);
  return `  ${id}${attrs};`;
}
function renderDotEdge(edge, directed = true) {
  const source = sanitizeDotId(edge.source);
  const target = sanitizeDotId(edge.target);
  const arrow = directed ? "->" : "--";
  const attrs = renderDotEdgeAttrs(edge);
  return `  ${source} ${arrow} ${target}${attrs};`;
}
function generateDotGraph(nodes, edges, options = {}) {
  const {
    graphType = "digraph",
    graphName = "G",
    rankDir = "TB",
    splines,
    overlap,
    concentrate,
    compound,
    bgcolor,
    fontName,
    fontSize,
    nodeDefaults,
    edgeDefaults
  } = options;
  const lines = [];
  const directed = graphType === "digraph";
  lines.push(`${graphType} ${sanitizeDotId(graphName)} {`);
  lines.push(`  rankdir=${rankDir};`);
  if (splines) lines.push(`  splines=${splines};`);
  if (overlap !== void 0) lines.push(`  overlap=${overlap};`);
  if (concentrate) lines.push("  concentrate=true;");
  if (compound) lines.push("  compound=true;");
  if (bgcolor) lines.push(`  bgcolor="${bgcolor}";`);
  if (fontName) lines.push(`  fontname="${fontName}";`);
  if (fontSize) lines.push(`  fontsize=${fontSize};`);
  if (nodeDefaults) {
    const defaultAttrs = [];
    if (nodeDefaults.shape) defaultAttrs.push(`shape=${nodeDefaults.shape}`);
    if (nodeDefaults.style) {
      const styleStr = Array.isArray(nodeDefaults.style) ? nodeDefaults.style.join(",") : nodeDefaults.style;
      defaultAttrs.push(`style="${styleStr}"`);
    }
    if (nodeDefaults.fillColor) defaultAttrs.push(`fillcolor="${nodeDefaults.fillColor}"`);
    if (nodeDefaults.fontName) defaultAttrs.push(`fontname="${nodeDefaults.fontName}"`);
    if (nodeDefaults.fontSize) defaultAttrs.push(`fontsize=${nodeDefaults.fontSize}`);
    if (defaultAttrs.length > 0) {
      lines.push(`  node [${defaultAttrs.join(", ")}];`);
    }
  }
  if (edgeDefaults) {
    const defaultAttrs = [];
    if (edgeDefaults.style) defaultAttrs.push(`style=${edgeDefaults.style}`);
    if (edgeDefaults.color) defaultAttrs.push(`color="${edgeDefaults.color}"`);
    if (edgeDefaults.arrowHead) defaultAttrs.push(`arrowhead=${edgeDefaults.arrowHead}`);
    if (defaultAttrs.length > 0) {
      lines.push(`  edge [${defaultAttrs.join(", ")}];`);
    }
  }
  lines.push("");
  for (const node of nodes) {
    lines.push(renderDotNode(node));
  }
  if (edges.length > 0) {
    lines.push("");
    for (const edge of edges) {
      lines.push(renderDotEdge(edge, directed));
    }
  }
  lines.push("}");
  return lines.join("\n");
}
var init_dot = __esm({
  "src/export/visual/utils/dot.ts"() {
    init_esm_shims();
  }
});

// src/export/visual/utils/ascii.ts
function generateAsciiHeader(title, style = "equals") {
  const underlineChar = style === "double" ? "\u2550" : style === "equals" ? "=" : style === "single" ? "\u2500" : "-";
  const underline = underlineChar.repeat(title.length);
  return `${title}
${underline}`;
}
function generateAsciiSectionHeader(title, icon) {
  const prefix = "";
  return `${prefix}${title}:
${"-".repeat((prefix + title + ":").length)}`;
}
function generateAsciiBulletList(items, bullet = "bullet", indent = 2) {
  const bulletChar = BULLETS[bullet];
  const indentStr = " ".repeat(indent);
  return items.map((item) => `${indentStr}${bulletChar} ${item}`).join("\n");
}
var BULLETS;
var init_ascii = __esm({
  "src/export/visual/utils/ascii.ts"() {
    init_esm_shims();
    BULLETS = {
      circle: "\u25CB",
      filledCircle: "\u25CF",
      square: "\u25A1",
      filledSquare: "\u25A0",
      diamond: "\u25C7",
      filledDiamond: "\u25C6",
      triangle: "\u25B3",
      filledTriangle: "\u25B2",
      star: "\u2606",
      filledStar: "\u2605",
      check: "\u2713",
      cross: "\u2717",
      dash: "\u2500",
      bullet: "\u2022",
      asciiBullet: "*",
      asciiDash: "-"
    };
  }
});

// src/export/visual/utils/svg.ts
function getNodeColor(type, colorScheme = "default") {
  const palette = COLOR_PALETTES[colorScheme] || COLOR_PALETTES.default;
  return palette[type] || palette.neutral;
}
function escapeSVGText(text) {
  return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
}
function truncateText(text, maxChars = 30) {
  if (text.length <= maxChars) return text;
  return text.substring(0, maxChars - 3) + "...";
}
function generateSVGHeader(width, height, title) {
  return `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${width} ${height}" width="${width}" height="${height}">
  <defs>
    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" fill="#333"/>
    </marker>
    <marker id="arrowhead-red" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" fill="#e53935"/>
    </marker>
    <marker id="arrowhead-green" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" fill="#388e3c"/>
    </marker>
    <marker id="arrowhead-blue" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" fill="#1976d2"/>
    </marker>
  </defs>

  <style>
    .title { font-family: Arial, sans-serif; font-size: 16px; font-weight: bold; }
    .subtitle { font-family: Arial, sans-serif; font-size: 12px; fill: #666; font-style: italic; }
    .node-label { font-family: Arial, sans-serif; font-size: 12px; }
    .edge-label { font-family: Arial, sans-serif; font-size: 10px; fill: #666; }
    .metrics { font-family: Arial, sans-serif; font-size: 11px; fill: #444; }
    .legend-text { font-family: Arial, sans-serif; font-size: 10px; }
  </style>

  <!-- Background -->
  <rect width="100%" height="100%" fill="#fafafa"/>
${title ? `
  <!-- Title -->
  <text x="${width / 2}" y="25" text-anchor="middle" class="title">${escapeSVGText(truncateText(title, 60))}</text>
` : ""}`;
}
function generateSVGFooter() {
  return "</svg>";
}
function renderRectNode(pos, colors, rx = 8) {
  const escapedLabel = escapeSVGText(truncateText(pos.label, 25));
  return `
    <g class="node" data-id="${pos.id}">
      <rect x="${pos.x}" y="${pos.y}" width="${pos.width}" height="${pos.height}"
            rx="${rx}" ry="${rx}" fill="${colors.fill}" stroke="${colors.stroke}" stroke-width="2"/>
      <text x="${pos.x + pos.width / 2}" y="${pos.y + pos.height / 2 + 5}"
            text-anchor="middle" class="node-label">${escapedLabel}</text>
    </g>`;
}
function renderStadiumNode(pos, colors) {
  const escapedLabel = escapeSVGText(truncateText(pos.label, 25));
  return `
    <g class="node" data-id="${pos.id}">
      <rect x="${pos.x}" y="${pos.y}" width="${pos.width}" height="${pos.height}"
            rx="20" ry="20" fill="${colors.fill}" stroke="${colors.stroke}" stroke-width="2"/>
      <text x="${pos.x + pos.width / 2}" y="${pos.y + pos.height / 2 + 5}"
            text-anchor="middle" class="node-label">${escapedLabel}</text>
    </g>`;
}
function renderDiamondNode(pos, colors) {
  const cx = pos.x + pos.width / 2;
  const cy = pos.y + pos.height / 2;
  const escapedLabel = escapeSVGText(truncateText(pos.label, 20));
  return `
    <g class="node" data-id="${pos.id}">
      <polygon points="${cx},${pos.y} ${pos.x + pos.width},${cy} ${cx},${pos.y + pos.height} ${pos.x},${cy}"
               fill="${colors.fill}" stroke="${colors.stroke}" stroke-width="2"/>
      <text x="${cx}" y="${cy + 5}"
            text-anchor="middle" class="node-label">${escapedLabel}</text>
    </g>`;
}
function renderEllipseNode(pos, colors) {
  const cx = pos.x + pos.width / 2;
  const cy = pos.y + pos.height / 2;
  const escapedLabel = escapeSVGText(truncateText(pos.label, 20));
  return `
    <g class="node" data-id="${pos.id}">
      <ellipse cx="${cx}" cy="${cy}" rx="${pos.width / 2}" ry="${pos.height / 2}"
               fill="${colors.fill}" stroke="${colors.stroke}" stroke-width="2"/>
      <text x="${cx}" y="${cy + 5}"
            text-anchor="middle" class="node-label">${escapedLabel}</text>
    </g>`;
}
function renderEdge(fromPos, toPos, options = {}) {
  const { label, style = "solid", color = "#333333", markerEnd = "arrowhead" } = options;
  const fromX = fromPos.x + fromPos.width / 2;
  const fromY = fromPos.y + fromPos.height;
  const toX = toPos.x + toPos.width / 2;
  const toY = toPos.y;
  const midY = (fromY + toY) / 2;
  const path4 = `M ${fromX} ${fromY} C ${fromX} ${midY}, ${toX} ${midY}, ${toX} ${toY - 8}`;
  const dashStyle = style === "dashed" ? 'stroke-dasharray="8,4"' : style === "dotted" ? 'stroke-dasharray="2,2"' : "";
  const labelElement = label ? `<text x="${(fromX + toX) / 2}" y="${midY - 5}" text-anchor="middle" class="edge-label">${escapeSVGText(label)}</text>` : "";
  return `
    <g class="edge">
      <path d="${path4}" fill="none" stroke="${color}" stroke-width="2" ${dashStyle} marker-end="url(#${markerEnd})"/>
      ${labelElement}
    </g>`;
}
function renderHorizontalEdge(fromPos, toPos, options = {}) {
  const { label, style = "solid", color = "#333333" } = options;
  const fromX = fromPos.x + fromPos.width;
  const fromY = fromPos.y + fromPos.height / 2;
  const toX = toPos.x;
  const toY = toPos.y + toPos.height / 2;
  const dashStyle = style === "dashed" ? 'stroke-dasharray="8,4"' : style === "dotted" ? 'stroke-dasharray="2,2"' : "";
  const labelElement = label ? `<text x="${(fromX + toX) / 2}" y="${(fromY + toY) / 2 - 8}" text-anchor="middle" class="edge-label">${escapeSVGText(label)}</text>` : "";
  return `
    <g class="edge">
      <line x1="${fromX}" y1="${fromY}" x2="${toX - 8}" y2="${toY}"
            stroke="${color}" stroke-width="2" ${dashStyle} marker-end="url(#arrowhead)"/>
      ${labelElement}
    </g>`;
}
function renderMetricsPanel(x, y, metrics) {
  const panelHeight = 30 + metrics.length * 16;
  let svg = `
  <g class="metrics-panel">
    <rect x="${x}" y="${y}" width="160" height="${panelHeight}" rx="8" fill="#f5f5f5" stroke="#ddd" stroke-width="1"/>
    <text x="${x + 10}" y="${y + 20}" class="metrics" font-weight="bold">Metrics</text>`;
  metrics.forEach((metric, i) => {
    svg += `
    <text x="${x + 10}" y="${y + 38 + i * 16}" class="metrics">${escapeSVGText(metric.label)}: ${escapeSVGText(String(metric.value))}</text>`;
  });
  svg += "\n  </g>";
  return svg;
}
function renderLegend(x, y, items) {
  let svg = `
  <g class="legend" transform="translate(${x}, ${y})">
    <text x="0" y="0" font-weight="bold" class="legend-text">Legend</text>`;
  items.forEach((item, i) => {
    const itemY = 12 + i * 18;
    let shapeEl;
    switch (item.shape) {
      case "diamond":
        shapeEl = `<polygon points="10,${itemY} 20,${itemY + 6} 10,${itemY + 12} 0,${itemY + 6}" fill="${item.color.fill}" stroke="${item.color.stroke}"/>`;
        break;
      case "ellipse":
        shapeEl = `<ellipse cx="10" cy="${itemY + 6}" rx="10" ry="6" fill="${item.color.fill}" stroke="${item.color.stroke}"/>`;
        break;
      case "stadium":
        shapeEl = `<rect x="0" y="${itemY}" width="20" height="12" rx="6" ry="6" fill="${item.color.fill}" stroke="${item.color.stroke}"/>`;
        break;
      default:
        shapeEl = `<rect x="0" y="${itemY}" width="20" height="12" rx="4" fill="${item.color.fill}" stroke="${item.color.stroke}"/>`;
    }
    svg += `
    ${shapeEl}
    <text x="25" y="${itemY + 10}" class="legend-text">${escapeSVGText(item.label)}</text>`;
  });
  svg += "\n  </g>";
  return svg;
}
function layoutNodesInLayers(layers, options = {}) {
  const opts = { ...DEFAULT_SVG_OPTIONS, ...options };
  const positions = /* @__PURE__ */ new Map();
  let currentY = opts.padding + (opts.title ? 40 : 0);
  for (const layer of layers) {
    if (layer.length === 0) continue;
    const layerWidth = layer.length * (opts.nodeWidth + opts.nodeSpacing) - opts.nodeSpacing;
    let startX = (opts.width - layerWidth) / 2;
    for (const node of layer) {
      positions.set(node.id, {
        id: node.id,
        x: startX,
        y: currentY,
        width: opts.nodeWidth,
        height: opts.nodeHeight,
        label: node.label,
        type: node.type
      });
      startX += opts.nodeWidth + opts.nodeSpacing;
    }
    currentY += opts.nodeHeight + opts.layerSpacing;
  }
  return positions;
}
function layoutNodesHorizontally(nodes, options = {}) {
  const opts = { ...DEFAULT_SVG_OPTIONS, ...options };
  const positions = /* @__PURE__ */ new Map();
  const totalWidth = nodes.length * (opts.nodeWidth + opts.nodeSpacing) - opts.nodeSpacing;
  let startX = Math.max(opts.padding, (opts.width - totalWidth) / 2);
  const y = opts.height / 2 - opts.nodeHeight / 2;
  for (const node of nodes) {
    positions.set(node.id, {
      id: node.id,
      x: startX,
      y,
      width: opts.nodeWidth,
      height: opts.nodeHeight,
      label: node.label,
      type: node.type
    });
    startX += opts.nodeWidth + opts.nodeSpacing;
  }
  return positions;
}
function calculateSVGHeight(positions, padding = 40, extraSpace = 120) {
  let maxY = 0;
  for (const pos of positions.values()) {
    maxY = Math.max(maxY, pos.y + pos.height);
  }
  return maxY + padding + extraSpace;
}
var DEFAULT_SVG_OPTIONS, COLOR_PALETTES;
var init_svg = __esm({
  "src/export/visual/utils/svg.ts"() {
    init_esm_shims();
    DEFAULT_SVG_OPTIONS = {
      width: 800,
      height: 600,
      nodeWidth: 150,
      nodeHeight: 40,
      nodeSpacing: 20,
      layerSpacing: 100,
      padding: 40,
      colorScheme: "default",
      includeLabels: true,
      includeMetrics: true,
      title: ""
    };
    COLOR_PALETTES = {
      default: {
        primary: { fill: "#64b5f6", stroke: "#1976d2" },
        secondary: { fill: "#81c784", stroke: "#388e3c" },
        tertiary: { fill: "#ffb74d", stroke: "#f57c00" },
        quaternary: { fill: "#ba68c8", stroke: "#7b1fa2" },
        neutral: { fill: "#bdbdbd", stroke: "#616161" },
        success: { fill: "#81c784", stroke: "#388e3c" },
        warning: { fill: "#ffb74d", stroke: "#f57c00" },
        error: { fill: "#e57373", stroke: "#d32f2f" },
        info: { fill: "#64b5f6", stroke: "#1976d2" },
        highlight: { fill: "#fff176", stroke: "#fbc02d" }
      },
      pastel: {
        primary: { fill: "#bbdefb", stroke: "#2196f3" },
        secondary: { fill: "#c8e6c9", stroke: "#4caf50" },
        tertiary: { fill: "#ffe0b2", stroke: "#ff9800" },
        quaternary: { fill: "#e1bee7", stroke: "#9c27b0" },
        neutral: { fill: "#e0e0e0", stroke: "#757575" },
        success: { fill: "#c8e6c9", stroke: "#4caf50" },
        warning: { fill: "#fff9c4", stroke: "#ffc107" },
        error: { fill: "#ffcdd2", stroke: "#e53935" },
        info: { fill: "#bbdefb", stroke: "#2196f3" },
        highlight: { fill: "#fff9c4", stroke: "#fbc02d" }
      },
      monochrome: {
        primary: { fill: "#ffffff", stroke: "#333333" },
        secondary: { fill: "#f5f5f5", stroke: "#333333" },
        tertiary: { fill: "#eeeeee", stroke: "#333333" },
        quaternary: { fill: "#e0e0e0", stroke: "#333333" },
        neutral: { fill: "#fafafa", stroke: "#333333" },
        success: { fill: "#ffffff", stroke: "#333333" },
        warning: { fill: "#f5f5f5", stroke: "#333333" },
        error: { fill: "#eeeeee", stroke: "#333333" },
        info: { fill: "#ffffff", stroke: "#333333" },
        highlight: { fill: "#e0e0e0", stroke: "#333333" }
      }
    };
  }
});

// src/export/visual/utils/graphml.ts
function escapeXML(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
function generateGraphMLHeader(options = {}) {
  const { graphId = "G", directed = true, graphName } = options;
  let header = `<?xml version="1.0" encoding="UTF-8"?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns
         http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">

  <!-- Node attributes -->
  <key id="label" for="node" attr.name="label" attr.type="string"/>
  <key id="type" for="node" attr.name="type" attr.type="string"/>
  <key id="description" for="node" attr.name="description" attr.type="string"/>

  <!-- Edge attributes -->
  <key id="edgeLabel" for="edge" attr.name="label" attr.type="string"/>
  <key id="weight" for="edge" attr.name="weight" attr.type="double"/>
  <key id="edgeType" for="edge" attr.name="type" attr.type="string"/>

  <!-- Graph attributes -->
  <key id="graphName" for="graph" attr.name="name" attr.type="string"/>

  <graph id="${escapeXML(graphId)}" edgedefault="${directed ? "directed" : "undirected"}">`;
  if (graphName) {
    header += `
    <data key="graphName">${escapeXML(graphName)}</data>`;
  }
  return header;
}
function generateGraphMLFooter() {
  return `
  </graph>
</graphml>`;
}
function renderGraphMLNode(node, options = {}) {
  const { includeLabels = true, includeMetadata = true } = options;
  let nodeXML = `
    <node id="${escapeXML(node.id)}">`;
  if (includeLabels && node.label) {
    nodeXML += `
      <data key="label">${escapeXML(node.label)}</data>`;
  }
  if (node.type) {
    nodeXML += `
      <data key="type">${escapeXML(node.type)}</data>`;
  }
  if (includeMetadata && node.metadata) {
    if (node.metadata.description) {
      nodeXML += `
      <data key="description">${escapeXML(String(node.metadata.description))}</data>`;
    }
  }
  nodeXML += `
    </node>`;
  return nodeXML;
}
function renderGraphMLEdge(edge, options = {}) {
  const { includeLabels = true, includeMetadata = true } = options;
  let edgeXML = `
    <edge id="${escapeXML(edge.id)}" source="${escapeXML(edge.source)}" target="${escapeXML(edge.target)}">`;
  if (includeLabels && edge.label) {
    edgeXML += `
      <data key="edgeLabel">${escapeXML(edge.label)}</data>`;
  }
  if (includeMetadata && edge.metadata) {
    if (edge.metadata.weight !== void 0) {
      edgeXML += `
      <data key="weight">${edge.metadata.weight}</data>`;
    }
    if (edge.metadata.type) {
      edgeXML += `
      <data key="edgeType">${escapeXML(String(edge.metadata.type))}</data>`;
    }
  }
  edgeXML += `
    </edge>`;
  return edgeXML;
}
function generateGraphML(nodes, edges, options = {}) {
  const mergedOptions = { ...DEFAULT_GRAPHML_OPTIONS, ...options };
  let graphml = generateGraphMLHeader(mergedOptions);
  graphml += "\n\n    <!-- Nodes -->";
  for (const node of nodes) {
    graphml += renderGraphMLNode(node, mergedOptions);
  }
  graphml += "\n\n    <!-- Edges -->";
  for (const edge of edges) {
    graphml += renderGraphMLEdge(edge, mergedOptions);
  }
  graphml += generateGraphMLFooter();
  return graphml;
}
function createLinearGraphML(nodeLabels, options = {}) {
  const nodes = nodeLabels.map((label, i) => ({
    id: `n${i}`,
    label,
    type: "step"
  }));
  const edges = [];
  for (let i = 0; i < nodeLabels.length - 1; i++) {
    edges.push({
      id: `e${i}`,
      source: `n${i}`,
      target: `n${i + 1}`
    });
  }
  return generateGraphML(nodes, edges, options);
}
function createTreeGraphML(root, options = {}) {
  const nodes = [];
  const edges = [];
  let edgeCount = 0;
  function traverse(node, depth = 0) {
    nodes.push({
      id: node.id,
      label: node.label,
      type: depth === 0 ? "root" : "node",
      metadata: { depth }
    });
    if (node.children && Array.isArray(node.children)) {
      for (const child of node.children) {
        edges.push({
          id: `e${edgeCount++}`,
          source: node.id,
          target: child.id
        });
        traverse(child, depth + 1);
      }
    }
  }
  traverse(root);
  return generateGraphML(nodes, edges, options);
}
var DEFAULT_GRAPHML_OPTIONS;
var init_graphml = __esm({
  "src/export/visual/utils/graphml.ts"() {
    init_esm_shims();
    DEFAULT_GRAPHML_OPTIONS = {
      directed: true,
      includeMetadata: true,
      includeLabels: true,
      graphId: "G",
      graphName: "Graph"
    };
  }
});

// src/export/visual/utils/tikz.ts
function getTikZColor(nodeType, colorScheme = "default") {
  const palette = COLOR_PALETTES2[colorScheme] || COLOR_PALETTES2.default;
  const colorMap = {
    primary: "primary",
    secondary: "secondary",
    tertiary: "tertiary",
    neutral: "neutral",
    success: "success",
    warning: "warning",
    danger: "danger",
    info: "info",
    cause: "primary",
    effect: "tertiary",
    mediator: "secondary",
    confounder: "warning",
    root: "primary",
    current: "primary",
    terminal: "success",
    hypothesis: "info",
    evidence: "secondary",
    conclusion: "success"
  };
  const key = colorMap[nodeType] || "neutral";
  return palette[key];
}
function escapeLatex2(str) {
  return str.replace(/\\/g, "\\textbackslash{}").replace(/%/g, "\\%").replace(/\$/g, "\\$").replace(/&/g, "\\&").replace(/#/g, "\\#").replace(/_/g, "\\_").replace(/{/g, "\\{").replace(/}/g, "\\}").replace(/\^/g, "\\textasciicircum{}").replace(/~/g, "\\textasciitilde{}");
}
function generateTikZHeader(options = {}) {
  const { standalone = false, title, scale = 1 } = options;
  let header = "";
  if (standalone) {
    header += `\\documentclass[tikz,border=10pt]{standalone}
\\usepackage{tikz}
\\usetikzlibrary{shapes,arrows,positioning,calc,backgrounds,fit}
\\begin{document}
`;
  }
  header += `\\begin{tikzpicture}[
  scale=${scale},
  every node/.style={font=\\small},
  box/.style={rectangle, draw, rounded corners=3pt, minimum width=2cm, minimum height=0.8cm, text centered},
  circle node/.style={circle, draw, minimum size=0.8cm, text centered},
  ellipse node/.style={ellipse, draw, minimum width=2cm, minimum height=0.8cm, text centered},
  diamond node/.style={diamond, draw, aspect=2, minimum width=1.5cm, text centered},
  stadium node/.style={rectangle, draw, rounded corners=0.4cm, minimum width=2cm, minimum height=0.8cm, text centered},
  arrow/.style={->, >=stealth, thick},
  dashed arrow/.style={->, >=stealth, thick, dashed},
  dotted arrow/.style={->, >=stealth, thick, dotted},
  edge label/.style={font=\\footnotesize, fill=white, inner sep=1pt}
]`;
  if (title) {
    header += `

% Title
\\node[font=\\large\\bfseries] at (4, 0.5) {${escapeLatex2(title)}};`;
  }
  return header;
}
function generateTikZFooter(options = {}) {
  const { standalone = false } = options;
  let footer = "\n\\end{tikzpicture}";
  if (standalone) {
    footer += "\n\\end{document}";
  }
  return footer;
}
function getShapeStyle(shape) {
  switch (shape) {
    case "circle":
      return "circle node";
    case "ellipse":
      return "ellipse node";
    case "diamond":
      return "diamond node";
    case "stadium":
    case "rounded":
      return "stadium node";
    case "rectangle":
    default:
      return "box";
  }
}
function renderTikZNode(node, options = {}) {
  const { colorScheme = "default", includeLabels = true } = options;
  const colors = getTikZColor(node.type || "neutral", colorScheme);
  const shapeStyle = getShapeStyle(node.shape);
  const label = includeLabels ? escapeLatex2(node.label) : escapeLatex2(node.id);
  const position = node.x !== void 0 && node.y !== void 0 ? `at (${node.x}, ${node.y})` : "";
  return `
  \\node[${shapeStyle}, fill=${colors.fill}, draw=${colors.stroke}] (${node.id}) ${position} {${label}};`;
}
function renderTikZEdge(edge, options = {}) {
  const { includeLabels = true } = options;
  let style = "arrow";
  if (edge.style === "dashed") style = "dashed arrow";
  if (edge.style === "dotted") style = "dotted arrow";
  if (edge.directed === false) style = style.replace("->", "-");
  let bendOption = "";
  if (edge.bend) {
    if (typeof edge.bend === "number") {
      bendOption = `, bend ${edge.bend > 0 ? "left" : "right"}=${Math.abs(edge.bend)}`;
    } else {
      bendOption = `, bend ${edge.bend}`;
    }
  }
  let labelOption = "";
  if (includeLabels && edge.label) {
    labelOption = ` node[edge label, midway] {${escapeLatex2(edge.label)}}`;
  }
  return `
  \\draw[${style}${bendOption}] (${edge.source}) --${labelOption} (${edge.target});`;
}
function renderTikZMetrics(x, y, metrics) {
  let tikz = `

  % Metrics Panel
  \\node[draw, fill=white, rounded corners, align=left, font=\\footnotesize] at (${x}, ${y}) {`;
  const lines = metrics.map((m) => `${escapeLatex2(m.label)}: ${escapeLatex2(String(m.value))}`);
  tikz += lines.join(" \\\\ ");
  tikz += "};";
  return tikz;
}
function renderTikZLegend(x, y, items) {
  let tikz = "\n\n  % Legend";
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    const itemY = y - i * 0.5;
    const shapeStyle = getShapeStyle(item.shape);
    tikz += `
  \\node[${shapeStyle}, fill=${item.color.fill}, draw=${item.color.stroke}, minimum width=0.5cm, minimum height=0.3cm] at (${x}, ${itemY}) {};`;
    tikz += `
  \\node[right, font=\\footnotesize] at (${x + 0.4}, ${itemY}) {${escapeLatex2(item.label)}};`;
  }
  return tikz;
}
function generateTikZ(nodes, edges, options = {}) {
  const mergedOptions = { ...DEFAULT_TIKZ_OPTIONS, ...options };
  let tikz = generateTikZHeader(mergedOptions);
  tikz += "\n\n  % Nodes";
  for (const node of nodes) {
    tikz += renderTikZNode(node, mergedOptions);
  }
  tikz += "\n\n  % Edges";
  for (const edge of edges) {
    tikz += renderTikZEdge(edge, mergedOptions);
  }
  tikz += generateTikZFooter(mergedOptions);
  return tikz;
}
function createLinearTikZ(nodeLabels, options = {}) {
  const nodes = nodeLabels.map((label, i) => ({
    id: `n${i}`,
    label,
    x: i * 3,
    y: 0,
    type: i === 0 ? "primary" : i === nodeLabels.length - 1 ? "success" : "neutral",
    shape: "rectangle"
  }));
  const edges = [];
  for (let i = 0; i < nodeLabels.length - 1; i++) {
    edges.push({
      source: `n${i}`,
      target: `n${i + 1}`,
      directed: true
    });
  }
  return generateTikZ(nodes, edges, options);
}
function createTreeTikZ(root, options = {}) {
  const nodes = [];
  const edges = [];
  function traverse(node, x, y, width) {
    nodes.push({
      id: node.id,
      label: node.label,
      x,
      y,
      type: y === 0 ? "primary" : "neutral",
      shape: "rectangle"
    });
    if (node.children && Array.isArray(node.children)) {
      const children = node.children;
      const childWidth = width / children.length;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        const childX = x - width / 2 + childWidth / 2 + i * childWidth;
        edges.push({
          source: node.id,
          target: child.id,
          directed: true
        });
        traverse(child, childX, y - 2, childWidth);
      }
    }
  }
  traverse(root, 4, 0, 8);
  return generateTikZ(nodes, edges, options);
}
var DEFAULT_TIKZ_OPTIONS, COLOR_PALETTES2;
var init_tikz = __esm({
  "src/export/visual/utils/tikz.ts"() {
    init_esm_shims();
    DEFAULT_TIKZ_OPTIONS = {
      standalone: false,
      includeLabels: true,
      includeMetrics: true,
      colorScheme: "default",
      scale: 1,
      nodeDistance: "2cm",
      levelDistance: "1.5cm"
    };
    COLOR_PALETTES2 = {
      default: {
        primary: { fill: "blue!20", stroke: "blue!60" },
        secondary: { fill: "green!20", stroke: "green!60" },
        tertiary: { fill: "orange!20", stroke: "orange!60" },
        neutral: { fill: "gray!20", stroke: "gray!60" },
        success: { fill: "green!30", stroke: "green!70" },
        warning: { fill: "yellow!30", stroke: "yellow!70" },
        danger: { fill: "red!20", stroke: "red!60" },
        info: { fill: "cyan!20", stroke: "cyan!60" }
      },
      pastel: {
        primary: { fill: "blue!10", stroke: "blue!40" },
        secondary: { fill: "green!10", stroke: "green!40" },
        tertiary: { fill: "orange!10", stroke: "orange!40" },
        neutral: { fill: "gray!10", stroke: "gray!40" },
        success: { fill: "green!15", stroke: "green!50" },
        warning: { fill: "yellow!15", stroke: "yellow!50" },
        danger: { fill: "red!10", stroke: "red!40" },
        info: { fill: "cyan!10", stroke: "cyan!40" }
      },
      monochrome: {
        primary: { fill: "black!10", stroke: "black!60" },
        secondary: { fill: "black!15", stroke: "black!70" },
        tertiary: { fill: "black!20", stroke: "black!80" },
        neutral: { fill: "black!5", stroke: "black!50" },
        success: { fill: "black!10", stroke: "black!60" },
        warning: { fill: "black!15", stroke: "black!70" },
        danger: { fill: "black!20", stroke: "black!80" },
        info: { fill: "black!10", stroke: "black!60" }
      }
    };
  }
});

// src/export/visual/utils/html.ts
function getHTMLThemeColors(theme = "light") {
  if (theme === "dark") {
    return {
      background: "#1a1a2e",
      text: "#eaeaea",
      primary: "#4a90d9",
      secondary: "#6c757d",
      success: "#28a745",
      warning: "#ffc107",
      danger: "#dc3545",
      info: "#17a2b8",
      border: "#444",
      tableHeader: "#2d2d44",
      tableRow: "#1a1a2e",
      tableRowAlt: "#252538"
    };
  }
  return {
    background: "#ffffff",
    text: "#333333",
    primary: "#2563eb",
    secondary: "#6b7280",
    success: "#16a34a",
    warning: "#ca8a04",
    danger: "#dc2626",
    info: "#0891b2",
    border: "#e5e7eb",
    tableHeader: "#f3f4f6",
    tableRow: "#ffffff",
    tableRowAlt: "#f9fafb"
  };
}
function generateHTMLHeader(title, options = {}) {
  const { standalone = true, theme = "light", customStyles = "" } = options;
  const colors = getHTMLThemeColors(theme);
  if (!standalone) {
    return `<div class="visual-export" data-theme="${theme}">
`;
  }
  return `<!DOCTYPE html>
<html lang="en" data-theme="${theme}">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${escapeHTML(title)}</title>
  <style>
    :root {
      --bg-color: ${colors.background};
      --text-color: ${colors.text};
      --primary-color: ${colors.primary};
      --secondary-color: ${colors.secondary};
      --success-color: ${colors.success};
      --warning-color: ${colors.warning};
      --danger-color: ${colors.danger};
      --info-color: ${colors.info};
      --border-color: ${colors.border};
      --table-header-bg: ${colors.tableHeader};
      --table-row-bg: ${colors.tableRow};
      --table-row-alt-bg: ${colors.tableRowAlt};
    }

    * { box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.6;
      color: var(--text-color);
      background-color: var(--bg-color);
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
    }

    h1, h2, h3, h4 { margin-top: 1.5rem; margin-bottom: 0.5rem; }
    h1 { font-size: 2rem; border-bottom: 2px solid var(--primary-color); padding-bottom: 0.5rem; }
    h2 { font-size: 1.5rem; color: var(--primary-color); }
    h3 { font-size: 1.25rem; }

    .section {
      margin: 1.5rem 0;
      padding: 1rem;
      border: 1px solid var(--border-color);
      border-radius: 8px;
    }

    .section-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .badge {
      display: inline-block;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .badge-primary { background: var(--primary-color); color: white; }
    .badge-success { background: var(--success-color); color: white; }
    .badge-warning { background: var(--warning-color); color: black; }
    .badge-danger { background: var(--danger-color); color: white; }
    .badge-info { background: var(--info-color); color: white; }
    .badge-secondary { background: var(--secondary-color); color: white; }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
      font-size: 0.9rem;
    }

    th, td {
      padding: 0.75rem;
      text-align: left;
      border: 1px solid var(--border-color);
    }

    th {
      background: var(--table-header-bg);
      font-weight: 600;
    }

    tr:nth-child(even) { background: var(--table-row-alt-bg); }
    tr:nth-child(odd) { background: var(--table-row-bg); }

    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
      margin: 1rem 0;
    }

    .metric-card {
      padding: 1rem;
      background: var(--table-header-bg);
      border-radius: 8px;
      text-align: center;
    }

    .metric-value {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--primary-color);
    }

    .metric-label {
      font-size: 0.85rem;
      color: var(--secondary-color);
    }

    .progress-bar {
      height: 8px;
      background: var(--border-color);
      border-radius: 4px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: var(--primary-color);
      transition: width 0.3s ease;
    }

    .list-styled {
      list-style: none;
      padding: 0;
    }

    .list-styled li {
      padding: 0.5rem 0;
      border-bottom: 1px solid var(--border-color);
    }

    .list-styled li:last-child { border-bottom: none; }

    .icon { margin-right: 0.5rem; }

    .text-success { color: var(--success-color); }
    .text-warning { color: var(--warning-color); }
    .text-danger { color: var(--danger-color); }
    .text-info { color: var(--info-color); }
    .text-secondary { color: var(--secondary-color); }

    .card {
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 1rem;
      margin: 0.5rem 0;
    }

    .card-header {
      font-weight: 600;
      margin-bottom: 0.5rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--border-color);
    }

    .flex { display: flex; }
    .flex-wrap { flex-wrap: wrap; }
    .gap-1 { gap: 0.5rem; }
    .gap-2 { gap: 1rem; }

    .footer {
      margin-top: 2rem;
      padding-top: 1rem;
      border-top: 1px solid var(--border-color);
      font-size: 0.85rem;
      color: var(--secondary-color);
      text-align: center;
    }

    ${customStyles}
  </style>
</head>
<body>
`;
}
function generateHTMLFooter(standalone = true) {
  if (!standalone) {
    return "</div>\n";
  }
  return `
  <div class="footer">
    Generated by DeepThinking MCP v7.1.0
  </div>
</body>
</html>`;
}
function escapeHTML(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
function renderMetricCard(label, value, color) {
  const colorClass = color ? ` style="color: var(--${color}-color)"` : "";
  return `
    <div class="metric-card">
      <div class="metric-value"${colorClass}>${escapeHTML(String(value))}</div>
      <div class="metric-label">${escapeHTML(label)}</div>
    </div>`;
}
function renderProgressBar(percent, color = "primary") {
  const clampedPercent = Math.max(0, Math.min(100, percent));
  return `
    <div class="progress-bar">
      <div class="progress-fill" style="width: ${clampedPercent}%; background: var(--${color}-color)"></div>
    </div>`;
}
function renderBadge(text, type = "primary") {
  return `<span class="badge badge-${type}">${escapeHTML(text)}</span>`;
}
function renderTable(headers, rows, options = {}) {
  const headerCells = headers.map((h) => `<th>${escapeHTML(h)}</th>`).join("");
  const bodyRows = rows.map((row) => {
    const cells = row.map((cell) => `<td>${escapeHTML(String(cell))}</td>`).join("");
    return `<tr>${cells}</tr>`;
  }).join("\n");
  let html = "<table>";
  if (options.caption) {
    html += `<caption>${escapeHTML(options.caption)}</caption>`;
  }
  html += `<thead><tr>${headerCells}</tr></thead>`;
  html += `<tbody>${bodyRows}</tbody>`;
  html += "</table>";
  return html;
}
function renderSection(title, content, icon) {
  const iconHtml = icon ? `<span class="icon">${icon}</span>` : "";
  return `
    <div class="section">
      <div class="section-header">
        ${iconHtml}<h3>${escapeHTML(title)}</h3>
      </div>
      ${content}
    </div>`;
}
function renderList(items, ordered = false) {
  const tag = ordered ? "ol" : "ul";
  const listItems = items.map((item) => `<li>${escapeHTML(item)}</li>`).join("\n");
  return `<${tag} class="list-styled">${listItems}</${tag}>`;
}
var init_html = __esm({
  "src/export/visual/utils/html.ts"() {
    init_esm_shims();
  }
});

// src/export/visual/utils/modelica.ts
function sanitizeModelicaId(id) {
  let sanitized = id.replace(/[-\s]/g, "_");
  sanitized = sanitized.replace(/[^a-zA-Z0-9_]/g, "");
  if (!/^[a-zA-Z]/.test(sanitized)) {
    sanitized = "id_" + sanitized;
  }
  return sanitized || "unnamed";
}
function escapeModelicaString(str) {
  return str.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
}
function generateModelicaPackageHeader(name, description, options = {}) {
  const packageName = options.packageName || sanitizeModelicaId(name);
  const lines = [];
  lines.push(`package ${packageName}`);
  lines.push(`  "${escapeModelicaString(description)}"`);
  lines.push("");
  return lines.join("\n");
}
function generateModelicaPackageFooter(name, options = {}) {
  const packageName = options.packageName || sanitizeModelicaId(name);
  const lines = [];
  if (options.includeAnnotations !== false) {
    lines.push("  annotation(");
    lines.push('    Documentation(info="<html>');
    lines.push(`      <p>Generated by DeepThinking MCP v${options.version || "7.1.0"}</p>`);
    lines.push('    </html>"),');
    lines.push('    version="1.0.0"');
    lines.push("  );");
  }
  lines.push(`end ${packageName};`);
  return lines.join("\n");
}
function generateModelicaRecord(recordName, description, fields, _options = {}) {
  const lines = [];
  const safeRecordName = sanitizeModelicaId(recordName);
  lines.push(`  record ${safeRecordName}`);
  lines.push(`    "${escapeModelicaString(description)}"`);
  lines.push("");
  for (const field of fields) {
    const safeName = sanitizeModelicaId(field.name);
    const desc = field.description ? ` "${escapeModelicaString(field.description)}"` : "";
    lines.push(`    ${field.type} ${safeName} = ${field.value}${desc};`);
  }
  lines.push(`  end ${safeRecordName};`);
  lines.push("");
  return lines.join("\n");
}
function generateLinearFlowModelica(stages2, currentStage, options = {}) {
  const packageName = options.packageName || "LinearFlow";
  const lines = [];
  lines.push(`package ${sanitizeModelicaId(packageName)}`);
  lines.push('  "Linear stage flow representation"');
  lines.push("");
  lines.push("  type Stage = enumeration(");
  for (let i = 0; i < stages2.length; i++) {
    const stage = stages2[i];
    const comma = i < stages2.length - 1 ? "," : "";
    lines.push(`    ${sanitizeModelicaId(stage)} "${escapeModelicaString(stage)}"${comma}`);
  }
  lines.push("  );");
  lines.push("");
  lines.push(`  parameter Stage currentStage = Stage.${sanitizeModelicaId(currentStage)};`);
  lines.push(`  final parameter Integer stageIndex = ${stages2.indexOf(currentStage) + 1};`);
  lines.push(`  final parameter Integer totalStages = ${stages2.length};`);
  lines.push(`  final parameter Real progress = stageIndex / totalStages;`);
  lines.push("");
  lines.push(generateModelicaPackageFooter(packageName, options));
  return lines.join("\n");
}
function generateHierarchyModelica(rootName, rootDescription, children, options = {}) {
  const packageName = options.packageName || sanitizeModelicaId(rootName);
  const lines = [];
  lines.push(`package ${packageName}`);
  lines.push(`  "${escapeModelicaString(rootDescription)}"`);
  lines.push("");
  for (const child of children) {
    const childId = sanitizeModelicaId(child.name);
    lines.push(`  record ${childId}`);
    lines.push(`    "${escapeModelicaString(child.description)}"`);
    if (child.score !== void 0 && options.includeMetrics !== false) {
      lines.push(`    constant Real score = ${child.score.toFixed(3)};`);
    }
    lines.push(`  end ${childId};`);
    lines.push("");
  }
  lines.push(generateModelicaPackageFooter(packageName, options));
  return lines.join("\n");
}
var init_modelica = __esm({
  "src/export/visual/utils/modelica.ts"() {
    init_esm_shims();
  }
});

// src/export/visual/utils/uml.ts
function sanitizeUmlId(id) {
  let sanitized = id.replace(/[^a-zA-Z0-9_]/g, "_");
  if (!/^[a-zA-Z]/.test(sanitized)) {
    sanitized = "id_" + sanitized;
  }
  return sanitized || "unnamed";
}
function escapeUml(str) {
  return str.replace(/\\/g, "\\\\").replace(/"/g, '"').replace(/\n/g, "\\n").replace(/<(?![\/#])/g, "&lt;").replace(/(?<![\/#])>/g, "&gt;");
}
function getArrowSyntax(type) {
  switch (type) {
    case "dependency":
      return "..>";
    case "inheritance":
      return "--|>";
    case "implementation":
      return "..|>";
    case "composition":
      return "*--";
    case "aggregation":
      return "o--";
    case "dashed":
      return "..";
    case "arrow":
      return "-->";
    case "association":
    default:
      return "--";
  }
}
function generateUmlHeader(options = {}) {
  const lines = ["@startuml"];
  if (options.title) {
    lines.push(`title ${escapeUml(options.title)}`);
  }
  if (options.theme && options.theme !== "default") {
    lines.push(`!theme ${options.theme}`);
  }
  if (options.direction) {
    lines.push(options.direction === "left to right" ? "left to right direction" : "top to bottom direction");
  }
  if (options.scale) {
    lines.push(`scale ${options.scale}`);
  }
  lines.push("");
  return lines.join("\n");
}
function generateUmlFooter() {
  return "@enduml\n";
}
function renderUmlNode(node) {
  const lines = [];
  const id = sanitizeUmlId(node.id);
  const label = node.label || node.id;
  const shape = node.shape || "rectangle";
  switch (shape) {
    case "class":
    case "interface":
    case "abstract":
      lines.push(`${shape} "${escapeUml(label)}" as ${id} {`);
      if (node.attributes && node.attributes.length > 0) {
        for (const attr of node.attributes) {
          lines.push(`  ${escapeUml(attr)}`);
        }
      }
      if (node.methods && node.methods.length > 0) {
        lines.push("  --");
        for (const method of node.methods) {
          lines.push(`  ${escapeUml(method)}`);
        }
      }
      lines.push("}");
      break;
    case "usecase":
      lines.push(`usecase "${escapeUml(label)}" as ${id}`);
      break;
    case "actor":
      lines.push(`actor "${escapeUml(label)}" as ${id}`);
      break;
    case "component":
      lines.push(`component "${escapeUml(label)}" as ${id}`);
      break;
    case "node":
      lines.push(`node "${escapeUml(label)}" as ${id}`);
      break;
    case "database":
      lines.push(`database "${escapeUml(label)}" as ${id}`);
      break;
    case "package":
      lines.push(`package "${escapeUml(label)}" as ${id} {`);
      lines.push("}");
      break;
    case "folder":
      lines.push(`folder "${escapeUml(label)}" as ${id}`);
      break;
    case "cloud":
      lines.push(`cloud "${escapeUml(label)}" as ${id}`);
      break;
    case "state":
      lines.push(`state "${escapeUml(label)}" as ${id}`);
      break;
    case "activity":
      lines.push(`:${escapeUml(label)};`);
      break;
    case "entity":
      lines.push(`entity "${escapeUml(label)}" as ${id}`);
      break;
    case "rectangle":
    default:
      if (node.stereotype) {
        lines.push(`rectangle "${escapeUml(label)}" <<${escapeUml(node.stereotype)}>> as ${id}`);
      } else {
        lines.push(`rectangle "${escapeUml(label)}" as ${id}`);
      }
  }
  if (node.color) {
    const lastLine = lines.pop();
    if (lastLine) {
      lines.push(lastLine.replace(/}$/, "") + ` #${node.color}`);
      if (lastLine.endsWith("}")) {
        lines.push("}");
      }
    }
  }
  return lines.join("\n");
}
function renderUmlEdge(edge) {
  const sourceId = sanitizeUmlId(edge.source);
  const targetId = sanitizeUmlId(edge.target);
  const arrow = getArrowSyntax(edge.type);
  let line = `${sourceId} ${arrow} ${targetId}`;
  if (edge.label) {
    line += ` : ${escapeUml(edge.label)}`;
  }
  return line;
}
function generateUmlDiagram(nodes, edges, options = {}) {
  const lines = [];
  lines.push(generateUmlHeader(options));
  if (nodes.length > 0) {
    lines.push("' Nodes");
    for (const node of nodes) {
      lines.push(renderUmlNode(node));
    }
    lines.push("");
  }
  if (edges.length > 0) {
    lines.push("' Relationships");
    for (const edge of edges) {
      lines.push(renderUmlEdge(edge));
    }
    lines.push("");
  }
  lines.push(generateUmlFooter());
  return lines.join("\n");
}
function generateActivityDiagram(activities, currentActivity, options = {}) {
  const lines = [];
  lines.push(generateUmlHeader({ ...options}));
  lines.push("start");
  for (const activity of activities) {
    const isCurrent = activity === currentActivity;
    if (isCurrent) {
      lines.push(`#lightblue:${escapeUml(activity)};`);
    } else {
      lines.push(`:${escapeUml(activity)};`);
    }
  }
  lines.push("stop");
  lines.push("");
  lines.push(generateUmlFooter());
  return lines.join("\n");
}
function generateStateDiagram(states, transitions, currentState, options = {}) {
  const lines = [];
  lines.push(generateUmlHeader({ ...options}));
  for (const state of states) {
    const id = sanitizeUmlId(state);
    const isCurrent = state === currentState;
    if (isCurrent) {
      lines.push(`state "${escapeUml(state)}" as ${id} #lightblue`);
    } else {
      lines.push(`state "${escapeUml(state)}" as ${id}`);
    }
  }
  lines.push("");
  if (states.length > 0) {
    lines.push(`[*] --> ${sanitizeUmlId(states[0])}`);
  }
  for (const t of transitions) {
    const label = t.event ? ` : ${escapeUml(t.event)}` : "";
    lines.push(`${sanitizeUmlId(t.from)} --> ${sanitizeUmlId(t.to)}${label}`);
  }
  lines.push("");
  lines.push(generateUmlFooter());
  return lines.join("\n");
}
var init_uml = __esm({
  "src/export/visual/utils/uml.ts"() {
    init_esm_shims();
  }
});

// src/export/visual/utils/json.ts
function createJsonGraph(title, mode, options = {}) {
  return {
    type: "deepthinking-visual-graph",
    version: "1.0.0",
    metadata: {
      title,
      mode,
      exportedAt: (/* @__PURE__ */ new Date()).toISOString(),
      generator: "DeepThinking MCP v7.1.0"
    },
    nodes: [],
    edges: [],
    layout: options.includeLayout !== false ? { type: "hierarchical", direction: "TB" } : void 0,
    metrics: options.includeMetrics !== false ? {} : void 0,
    legend: options.includeLegend !== false ? [] : void 0
  };
}
function addNode(graph, node) {
  graph.nodes.push(node);
}
function addEdge(graph, edge) {
  graph.edges.push(edge);
}
function addMetric(graph, key, value) {
  if (graph.metrics) {
    graph.metrics[key] = value;
  }
}
function addLegendItem(graph, label, color, shape) {
  if (graph.legend) {
    graph.legend.push({ label, color, shape });
  }
}
function serializeGraph(graph, options = {}) {
  const indent = options.prettyPrint !== false ? options.indent || 2 : 0;
  return JSON.stringify(graph, null, indent);
}
function generateLinearFlowJson(title, mode, stages2, currentStage, options = {}) {
  const graph = createJsonGraph(title, mode, options);
  if (graph.layout) {
    graph.layout.type = "linear";
    graph.layout.direction = "LR";
  }
  for (let i = 0; i < stages2.length; i++) {
    const stage = stages2[i];
    const isCurrent = stage === currentStage;
    addNode(graph, {
      id: `stage_${i}`,
      label: stage,
      type: isCurrent ? "current" : "stage",
      x: i * 150,
      y: 0,
      color: isCurrent ? "#a8d5ff" : "#e0e0e0",
      shape: isCurrent ? "stadium" : "rectangle"
    });
    if (i > 0) {
      addEdge(graph, {
        id: `edge_${i - 1}_${i}`,
        source: `stage_${i - 1}`,
        target: `stage_${i}`,
        directed: true,
        style: "solid"
      });
    }
  }
  if (graph.metrics) {
    graph.metrics.totalStages = stages2.length;
    graph.metrics.currentStageIndex = stages2.indexOf(currentStage);
    graph.metrics.progress = (stages2.indexOf(currentStage) + 1) / stages2.length;
  }
  if (graph.legend) {
    addLegendItem(graph, "Current Stage", "#a8d5ff", "stadium");
    addLegendItem(graph, "Stage", "#e0e0e0", "rectangle");
  }
  return serializeGraph(graph, options);
}
function generateHierarchyJson(title, mode, root, children, options = {}) {
  const graph = createJsonGraph(title, mode, options);
  if (graph.layout) {
    graph.layout.type = "tree";
    graph.layout.direction = "TB";
  }
  addNode(graph, {
    id: "root",
    label: root.label,
    type: "root",
    x: 0,
    y: 0,
    color: "#a8d5ff",
    shape: "ellipse",
    metadata: root.metadata
  });
  const childCount = children.length;
  const spacing = 150;
  const startX = -((childCount - 1) * spacing) / 2;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    addNode(graph, {
      id: child.id,
      label: child.label,
      type: "child",
      x: startX + i * spacing,
      y: 100,
      color: "#e0e0e0",
      shape: "rectangle",
      metadata: {
        ...child.metadata,
        score: child.score
      }
    });
    addEdge(graph, {
      id: `edge_root_${child.id}`,
      source: "root",
      target: child.id,
      directed: true,
      style: "solid"
    });
  }
  if (graph.metrics) {
    graph.metrics.childCount = children.length;
    if (children.some((c) => c.score !== void 0)) {
      graph.metrics.averageScore = children.reduce((sum, c) => sum + (c.score || 0), 0) / children.length;
      graph.metrics.maxScore = Math.max(...children.map((c) => c.score || 0));
    }
  }
  return serializeGraph(graph, options);
}
function generateBayesianJson(title, prior, posterior, bayesFactor, hypothesis, evidence, options = {}) {
  const graph = createJsonGraph(title, "bayesian", options);
  if (graph.layout) {
    graph.layout.type = "hierarchical";
    graph.layout.direction = "TB";
  }
  addNode(graph, {
    id: "prior",
    label: `Prior: ${prior.toFixed(3)}`,
    type: "prior",
    x: 0,
    y: 0,
    color: "#a8d5ff",
    shape: "stadium"
  });
  addNode(graph, {
    id: "evidence",
    label: "Evidence",
    type: "evidence",
    x: 200,
    y: 0,
    color: "#81c784",
    shape: "rectangle",
    metadata: { items: evidence }
  });
  addNode(graph, {
    id: "hypothesis",
    label: hypothesis,
    type: "hypothesis",
    x: 100,
    y: 100,
    color: "#e0e0e0",
    shape: "ellipse"
  });
  addNode(graph, {
    id: "posterior",
    label: `Posterior: ${posterior.toFixed(3)}`,
    type: "posterior",
    x: 100,
    y: 200,
    color: "#4caf50",
    shape: "stadium"
  });
  addEdge(graph, {
    id: "edge_prior_hyp",
    source: "prior",
    target: "hypothesis",
    directed: true
  });
  addEdge(graph, {
    id: "edge_evidence_hyp",
    source: "evidence",
    target: "hypothesis",
    directed: true
  });
  addEdge(graph, {
    id: "edge_hyp_post",
    source: "hypothesis",
    target: "posterior",
    directed: true
  });
  if (graph.metrics) {
    graph.metrics.prior = prior;
    graph.metrics.posterior = posterior;
    graph.metrics.bayesFactor = bayesFactor;
    graph.metrics.evidenceCount = evidence.length;
    graph.metrics.probabilityChange = posterior - prior;
  }
  if (graph.legend) {
    addLegendItem(graph, "Prior", "#a8d5ff", "stadium");
    addLegendItem(graph, "Evidence", "#81c784", "rectangle");
    addLegendItem(graph, "Hypothesis", "#e0e0e0", "ellipse");
    addLegendItem(graph, "Posterior", "#4caf50", "stadium");
  }
  return serializeGraph(graph, options);
}
function generateCausalJson(title, mode, causes, effects, links, options = {}) {
  const graph = createJsonGraph(title, mode, options);
  if (graph.layout) {
    graph.layout.type = "hierarchical";
    graph.layout.direction = "LR";
  }
  for (let i = 0; i < causes.length; i++) {
    const cause = causes[i];
    addNode(graph, {
      id: cause.id,
      label: cause.label,
      type: "cause",
      x: 0,
      y: i * 80,
      color: "#ffb74d",
      shape: "rectangle",
      metadata: { strength: cause.strength }
    });
  }
  for (let i = 0; i < effects.length; i++) {
    const effect = effects[i];
    addNode(graph, {
      id: effect.id,
      label: effect.label,
      type: "effect",
      x: 250,
      y: i * 80,
      color: "#4fc3f7",
      shape: "rectangle"
    });
  }
  let edgeId = 0;
  for (const link of links) {
    addEdge(graph, {
      id: `causal_${edgeId++}`,
      source: link.cause,
      target: link.effect,
      weight: link.strength,
      directed: true,
      style: "solid"
    });
  }
  if (graph.metrics) {
    graph.metrics.causeCount = causes.length;
    graph.metrics.effectCount = effects.length;
    graph.metrics.linkCount = links.length;
  }
  if (graph.legend) {
    addLegendItem(graph, "Cause", "#ffb74d", "rectangle");
    addLegendItem(graph, "Effect", "#4fc3f7", "rectangle");
  }
  return serializeGraph(graph, options);
}
var init_json = __esm({
  "src/export/visual/utils/json.ts"() {
    init_esm_shims();
  }
});

// src/export/visual/utils/markdown.ts
function heading(text, level = 1) {
  const prefix = "#".repeat(level);
  return `${prefix} ${text}
`;
}
function bold(text) {
  return `**${text}**`;
}
function codeBlock(code, language = "") {
  return `\`\`\`${language}
${code}
\`\`\`
`;
}
function listItem(text, style = "bullet", indent = 0) {
  const indentStr = "  ".repeat(indent);
  switch (style) {
    case "numbered":
      return `${indentStr}1. ${text}`;
    case "checkbox":
      return `${indentStr}- [ ] ${text}`;
    case "checkbox-checked":
      return `${indentStr}- [x] ${text}`;
    case "bullet":
    default:
      return `${indentStr}- ${text}`;
  }
}
function list(items, style = "bullet") {
  return items.map((item, index) => {
    if (style === "numbered") {
      return `${index + 1}. ${item}`;
    }
    return listItem(item, style);
  }).join("\n") + "\n";
}
function getAlignmentSeparator(alignment) {
  switch (alignment) {
    case "center":
      return ":---:";
    case "right":
      return "---:";
    case "left":
    default:
      return ":---";
  }
}
function escapeTableCell(text) {
  return text.replace(/\|/g, "\\|");
}
function table(headers, rows, alignments) {
  const aligns = headers.map(() => "left");
  const headerRow = "| " + headers.map(escapeTableCell).join(" | ") + " |";
  const separatorRow = "| " + aligns.map(getAlignmentSeparator).join(" | ") + " |";
  const dataRows = rows.map((row) => {
    const cells = row.map(escapeTableCell);
    while (cells.length < headers.length) {
      cells.push("");
    }
    return "| " + cells.join(" | ") + " |";
  });
  return [headerRow, separatorRow, ...dataRows].join("\n") + "\n";
}
function progressBar(value, max = 100, width = 20) {
  const percentage = Math.min(100, Math.max(0, value / max * 100));
  const filled = Math.round(percentage / 100 * width);
  const empty = width - filled;
  const bar = "\u2588".repeat(filled) + "\u2591".repeat(empty);
  return `${bar} ${percentage.toFixed(0)}%`;
}
function keyValueSection(items) {
  return Object.entries(items).map(([key, value]) => `- ${bold(key)}: ${value}`).join("\n") + "\n";
}
function mermaidBlock(diagram) {
  return codeBlock(diagram, "mermaid");
}
function section(title, content, level = 2) {
  return heading(title, level) + "\n" + content + "\n";
}
function frontmatter(metadata) {
  const lines = ["---"];
  for (const [key, value] of Object.entries(metadata)) {
    if (Array.isArray(value)) {
      lines.push(`${key}:`);
      value.forEach((v) => lines.push(`  - ${v}`));
    } else {
      lines.push(`${key}: ${typeof value === "string" ? `"${value}"` : value}`);
    }
  }
  lines.push("---", "");
  return lines.join("\n");
}
function document(title, content, options = {}) {
  const { includeFrontmatter = false, metadata = {}, includeTableOfContents = false } = options;
  const parts = [];
  if (includeFrontmatter) {
    const fm = {
      title,
      date: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
      ...metadata
    };
    parts.push(frontmatter(fm));
  }
  parts.push(heading(title, 1));
  if (includeTableOfContents) {
    parts.push("\n## Table of Contents\n\n[TOC]\n");
  }
  parts.push(content);
  return parts.join("\n");
}
var init_markdown = __esm({
  "src/export/visual/utils/markdown.ts"() {
    init_esm_shims();
  }
});

// src/export/visual/modes/sequential.ts
function exportSequentialDependencyGraph(thought, options) {
  const { format, colorScheme = "default", includeLabels = true } = options;
  switch (format) {
    case "mermaid":
      return sequentialToMermaid(thought, colorScheme, includeLabels);
    case "dot":
      return sequentialToDOT(thought, includeLabels);
    case "ascii":
      return sequentialToASCII(thought);
    case "svg":
      return sequentialToSVG(thought, options);
    case "graphml":
      return sequentialToGraphML(thought, options);
    case "tikz":
      return sequentialToTikZ(thought, options);
    case "html":
      return sequentialToHTML(thought, options);
    case "modelica":
      return sequentialToModelica(thought, options);
    case "uml":
      return sequentialToUML(thought, options);
    case "json":
      return sequentialToJSON(thought, options);
    case "markdown":
      return sequentialToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function sequentialToMermaid(thought, colorScheme, includeLabels) {
  const scheme = colorScheme;
  const nodes = [];
  const edges = [];
  const nodeId = sanitizeId(thought.id);
  const label = includeLabels ? truncateLabel(thought.content, 50) : nodeId;
  nodes.push({
    id: nodeId,
    label,
    shape: thought.isRevision ? "hexagon" : "stadium",
    style: colorScheme !== "monochrome" ? {
      fill: thought.isRevision ? getMermaidColor("warning", scheme) : getMermaidColor("primary", scheme)
    } : void 0
  });
  if (thought.buildUpon && thought.buildUpon.length > 0) {
    for (const depId of thought.buildUpon) {
      const depNodeId = sanitizeId(depId);
      nodes.push({
        id: depNodeId,
        label: depNodeId,
        shape: "rectangle"
      });
      edges.push({
        source: depNodeId,
        target: nodeId,
        style: "arrow"
      });
    }
  }
  if (thought.branchFrom) {
    const branchId = sanitizeId(thought.branchFrom);
    edges.push({
      source: branchId,
      target: nodeId,
      style: "dotted",
      label: "branch"
    });
  }
  if (thought.revisesThought) {
    const revisedId = sanitizeId(thought.revisesThought);
    edges.push({
      source: revisedId,
      target: nodeId,
      style: "thick",
      label: "revises"
    });
  }
  return generateMermaidFlowchart(nodes, edges, { direction: "TD", colorScheme: scheme });
}
function sequentialToDOT(thought, includeLabels) {
  const nodes = [];
  const edges = [];
  const nodeId = sanitizeId(thought.id);
  const label = includeLabels ? truncateDotLabel(thought.content, 50) : nodeId;
  nodes.push({
    id: nodeId,
    label,
    shape: thought.isRevision ? "hexagon" : "box",
    style: ["rounded", "filled"],
    fillColor: thought.isRevision ? "#ffd699" : "#a8d5ff"
  });
  if (thought.buildUpon && thought.buildUpon.length > 0) {
    for (const depId of thought.buildUpon) {
      const depNodeId = sanitizeId(depId);
      nodes.push({
        id: depNodeId,
        label: depNodeId,
        shape: "box",
        style: "rounded"
      });
      edges.push({
        source: depNodeId,
        target: nodeId
      });
    }
  }
  if (thought.branchFrom) {
    const branchId = sanitizeId(thought.branchFrom);
    edges.push({
      source: branchId,
      target: nodeId,
      style: "dashed",
      label: "branch"
    });
  }
  if (thought.revisesThought) {
    const revisedId = sanitizeId(thought.revisesThought);
    edges.push({
      source: revisedId,
      target: nodeId,
      style: "bold",
      label: "revises"
    });
  }
  return generateDotGraph(nodes, edges, {
    graphName: "SequentialDependency",
    rankDir: "TB",
    nodeDefaults: { shape: "box", style: "rounded" }
  });
}
function sequentialToASCII(thought) {
  const lines = [];
  lines.push(generateAsciiHeader("Sequential Dependency Graph", "equals"));
  lines.push("");
  lines.push(`Current Thought: ${thought.id}`);
  lines.push(`Content: ${thought.content.substring(0, 100)}...`);
  lines.push("");
  if (thought.buildUpon && thought.buildUpon.length > 0) {
    lines.push(generateAsciiSectionHeader("Builds Upon"));
    lines.push(generateAsciiBulletList(
      thought.buildUpon.map((depId) => `\u2193 ${depId}`),
      "asciiBullet",
      0
    ));
    lines.push("");
  }
  if (thought.branchFrom) {
    lines.push(generateAsciiSectionHeader("Branch Information"));
    lines.push(`  Branches From: ${thought.branchFrom}`);
    if (thought.branchId) {
      lines.push(`  Branch ID: ${thought.branchId}`);
    }
    lines.push("");
  }
  if (thought.revisesThought) {
    lines.push(generateAsciiSectionHeader("Revision Information"));
    lines.push(`  Revises: ${thought.revisesThought}`);
    if (thought.revisionReason) {
      lines.push(`  Reason: ${thought.revisionReason}`);
    }
    lines.push("");
  }
  return lines.join("\n");
}
function sequentialToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width
  } = options;
  const nodeWidth = 160;
  const nodeHeight = 50;
  const padding = 40;
  const verticalSpacing = 80;
  const positions = /* @__PURE__ */ new Map();
  let currentY = padding + 40;
  const mainNodeId = sanitizeId(thought.id);
  const mainLabel = includeLabels ? thought.content.substring(0, 40) + "..." : mainNodeId;
  if (thought.buildUpon && thought.buildUpon.length > 0) {
    const depWidth = thought.buildUpon.length * (nodeWidth + 20) - 20;
    let startX = (svgWidth - depWidth) / 2;
    for (const depId of thought.buildUpon) {
      const depNodeId = sanitizeId(depId);
      positions.set(depId, {
        id: depId,
        x: startX,
        y: currentY,
        width: nodeWidth,
        height: nodeHeight,
        label: depNodeId,
        type: "dependency"
      });
      startX += nodeWidth + 20;
    }
    currentY += nodeHeight + verticalSpacing;
  }
  positions.set(thought.id, {
    id: thought.id,
    x: (svgWidth - nodeWidth) / 2,
    y: currentY,
    width: nodeWidth,
    height: nodeHeight,
    label: mainLabel,
    type: thought.isRevision ? "revision" : "main"
  });
  currentY += nodeHeight + padding;
  const actualHeight = currentY + 80;
  let svg = generateSVGHeader(svgWidth, actualHeight, "Sequential Dependency Graph");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  if (thought.buildUpon) {
    for (const depId of thought.buildUpon) {
      const fromPos = positions.get(depId);
      const toPos = positions.get(thought.id);
      if (fromPos && toPos) {
        svg += renderEdge(fromPos, toPos, {});
      }
    }
  }
  if (thought.branchFrom) {
    const branchLabel = "branch";
    svg += `
    <text x="${svgWidth / 2 - 100}" y="${padding + 20}" class="edge-label">${branchLabel} from: ${thought.branchFrom}</text>`;
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  for (const [, pos] of positions) {
    const colors = pos.type === "revision" ? getNodeColor("warning", colorScheme) : pos.type === "main" ? getNodeColor("primary", colorScheme) : getNodeColor("neutral", colorScheme);
    if (pos.type === "main" || pos.type === "revision") {
      svg += renderStadiumNode(pos, colors);
    } else {
      svg += renderRectNode(pos, colors);
    }
  }
  svg += "\n  </g>";
  const legendItems = [
    { label: "Current", color: getNodeColor("primary", colorScheme) },
    { label: "Revision", color: getNodeColor("warning", colorScheme) },
    { label: "Dependency", color: getNodeColor("neutral", colorScheme) }
  ];
  svg += renderLegend(20, actualHeight - 80, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function sequentialToGraphML(thought, options) {
  const { includeLabels = true } = options;
  const nodes = [];
  const edges = [];
  if (thought.buildUpon && thought.buildUpon.length > 0) {
    thought.buildUpon.forEach((depId, index) => {
      nodes.push({
        id: sanitizeId(depId),
        label: includeLabels ? `Step ${index + 1}: ${depId}` : sanitizeId(depId),
        type: "dependency"
      });
    });
    nodes.push({
      id: sanitizeId(thought.id),
      label: includeLabels ? `Step ${nodes.length + 1}: ${thought.content.substring(0, 50)}...` : sanitizeId(thought.id),
      type: "current"
    });
    thought.buildUpon.forEach((depId, index) => {
      const sourceId = sanitizeId(depId);
      const targetId = index < thought.buildUpon.length - 1 ? sanitizeId(thought.buildUpon[index + 1]) : sanitizeId(thought.id);
      edges.push({
        id: `e${index}`,
        source: sourceId,
        target: targetId,
        directed: true
      });
    });
  } else {
    nodes.push({
      id: sanitizeId(thought.id),
      label: includeLabels ? thought.content.substring(0, 100) : sanitizeId(thought.id),
      type: "current"
    });
  }
  return generateGraphML(nodes, edges, {
    graphName: "Sequential Dependency Graph",
    directed: true,
    includeLabels
  });
}
function sequentialToTikZ(thought, options) {
  const { includeLabels = true, colorScheme = "default" } = options;
  const nodes = [];
  const edges = [];
  if (thought.buildUpon && thought.buildUpon.length > 0) {
    thought.buildUpon.forEach((depId, index) => {
      nodes.push({
        id: sanitizeId(depId),
        label: includeLabels ? `Step ${index + 1}` : sanitizeId(depId),
        x: index * 3,
        y: 0,
        type: "success",
        // Completed steps
        shape: "rectangle"
      });
    });
    nodes.push({
      id: sanitizeId(thought.id),
      label: includeLabels ? `Step ${nodes.length + 1}` : sanitizeId(thought.id),
      x: nodes.length * 3,
      y: 0,
      type: "primary",
      // Current step
      shape: "rectangle"
    });
    thought.buildUpon.forEach((depId, index) => {
      const sourceId = sanitizeId(depId);
      const targetId = index < thought.buildUpon.length - 1 ? sanitizeId(thought.buildUpon[index + 1]) : sanitizeId(thought.id);
      edges.push({
        source: sourceId,
        target: targetId,
        directed: true
      });
    });
  } else {
    nodes.push({
      id: sanitizeId(thought.id),
      label: includeLabels ? "Current" : sanitizeId(thought.id),
      x: 0,
      y: 0,
      type: "primary",
      shape: "rectangle"
    });
  }
  return generateTikZ(nodes, edges, {
    title: "Sequential Dependency Graph",
    colorScheme,
    includeLabels
  });
}
function sequentialToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Sequential Thinking Analysis",
    htmlTheme = "light"
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  html += '<div class="metrics-grid">';
  html += renderMetricCard("Thought #", thought.thoughtNumber, "primary");
  html += renderMetricCard("Total", thought.totalThoughts, "info");
  if (thought.buildUpon && thought.buildUpon.length > 0) {
    html += renderMetricCard("Dependencies", thought.buildUpon.length, "secondary");
  }
  html += "</div>\n";
  const badges = [];
  if (thought.isRevision) badges.push(renderBadge("Revision", "warning"));
  if (thought.branchFrom) badges.push(renderBadge("Branched", "info"));
  html += renderSection("Current Thought", `
    <div class="flex gap-1" style="margin-bottom: 0.5rem">${badges.join(" ")}</div>
    <p>${escapeHTML(thought.content)}</p>
    ${thought.nextThoughtNeeded ? '<p class="text-info">More thoughts needed...</p>' : '<p class="text-success">Reasoning complete.</p>'}
  `, "\u{1F4AD}");
  if (thought.buildUpon && thought.buildUpon.length > 0) {
    html += renderSection("Builds Upon", renderList(thought.buildUpon), "\u{1F517}");
  }
  if (thought.branchFrom) {
    html += renderSection("Branch Information", `
      <p><strong>Branched from:</strong> ${escapeHTML(thought.branchFrom)}</p>
      ${thought.branchId ? `<p><strong>Branch ID:</strong> ${escapeHTML(thought.branchId)}</p>` : ""}
    `, "\u{1F33F}");
  }
  if (thought.isRevision && thought.revisesThought) {
    html += renderSection("Revision Information", `
      <p><strong>Revises:</strong> ${escapeHTML(thought.revisesThought)}</p>
      ${thought.revisionReason ? `<p><strong>Reason:</strong> ${escapeHTML(thought.revisionReason)}</p>` : ""}
    `, "\u270F\uFE0F");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function sequentialToModelica(thought, options) {
  const { modelicaPackageName, modelicaIncludeAnnotations = true } = options;
  const packageName = modelicaPackageName || "SequentialDependency";
  const lines = [];
  lines.push(`package ${sanitizeModelicaId(packageName)}`);
  lines.push(`  "Sequential dependency graph for thought ${sanitizeId(thought.id)}"`);
  lines.push("");
  lines.push("  record CurrentThought");
  lines.push(`    constant String id = "${sanitizeModelicaId(thought.id)}";`);
  lines.push(`    constant Integer thoughtNumber = ${thought.thoughtNumber};`);
  lines.push(`    constant Integer totalThoughts = ${thought.totalThoughts};`);
  lines.push(`    constant Boolean isRevision = ${thought.isRevision || false};`);
  lines.push(`    constant Boolean nextThoughtNeeded = ${thought.nextThoughtNeeded};`);
  lines.push("  end CurrentThought;");
  lines.push("");
  if (thought.buildUpon && thought.buildUpon.length > 0) {
    lines.push("  // Dependencies");
    lines.push("  type Dependency = enumeration(");
    for (let i = 0; i < thought.buildUpon.length; i++) {
      const dep = thought.buildUpon[i];
      const comma = i < thought.buildUpon.length - 1 ? "," : "";
      lines.push(`    ${sanitizeModelicaId(dep)} "${escapeModelicaString(dep)}"${comma}`);
    }
    lines.push("  );");
    lines.push("");
  }
  if (thought.branchFrom) {
    lines.push("  record BranchInfo");
    lines.push(`    constant String branchFrom = "${sanitizeModelicaId(thought.branchFrom)}";`);
    if (thought.branchId) {
      lines.push(`    constant String branchId = "${sanitizeModelicaId(thought.branchId)}";`);
    }
    lines.push("  end BranchInfo;");
    lines.push("");
  }
  if (thought.revisesThought) {
    lines.push("  record RevisionInfo");
    lines.push(`    constant String revisesThought = "${sanitizeModelicaId(thought.revisesThought)}";`);
    if (thought.revisionReason) {
      lines.push(`    constant String revisionReason = "${escapeModelicaString(thought.revisionReason)}";`);
    }
    lines.push("  end RevisionInfo;");
    lines.push("");
  }
  if (modelicaIncludeAnnotations) {
    lines.push("  annotation(");
    lines.push('    Documentation(info="<html>');
    lines.push("      <p>Generated by DeepThinking MCP v7.1.0</p>");
    lines.push('    </html>")');
    lines.push("  );");
  }
  lines.push(`end ${sanitizeModelicaId(packageName)};`);
  return lines.join("\n");
}
function sequentialToUML(thought, options) {
  const { umlTheme, umlDirection } = options;
  const activities = [];
  if (thought.buildUpon && thought.buildUpon.length > 0) {
    for (const dep of thought.buildUpon) {
      activities.push(dep);
    }
  }
  activities.push(thought.content.substring(0, 50) + "...");
  return generateActivityDiagram(activities, thought.content.substring(0, 50) + "...", {
    title: "Sequential Dependency Graph",
    theme: umlTheme,
    direction: umlDirection
  });
}
function sequentialToJSON(thought, options) {
  const { jsonPrettyPrint = true, jsonIndent = 2, includeMetrics = true } = options;
  const graph = createJsonGraph("Sequential Dependency Graph", "sequential", {
    includeMetrics
  });
  if (thought.buildUpon && thought.buildUpon.length > 0) {
    for (let i = 0; i < thought.buildUpon.length; i++) {
      const dep = thought.buildUpon[i];
      addNode(graph, {
        id: sanitizeId(dep),
        label: dep,
        type: "dependency",
        x: i * 150,
        y: 0,
        color: "#e0e0e0",
        shape: "rectangle"
      });
    }
  }
  addNode(graph, {
    id: sanitizeId(thought.id),
    label: thought.content.substring(0, 50) + "...",
    type: thought.isRevision ? "revision" : "current",
    x: (thought.buildUpon?.length || 0) * 75,
    y: 100,
    color: thought.isRevision ? "#ffd699" : "#a8d5ff",
    shape: "stadium",
    metadata: {
      thoughtNumber: thought.thoughtNumber,
      totalThoughts: thought.totalThoughts,
      isRevision: thought.isRevision,
      nextThoughtNeeded: thought.nextThoughtNeeded
    }
  });
  if (thought.buildUpon && thought.buildUpon.length > 0) {
    for (let i = 0; i < thought.buildUpon.length; i++) {
      const dep = thought.buildUpon[i];
      addEdge(graph, {
        id: `edge_${i}`,
        source: sanitizeId(dep),
        target: sanitizeId(thought.id),
        directed: true,
        style: "solid"
      });
    }
  }
  if (includeMetrics && graph.metrics) {
    addMetric(graph, "thoughtNumber", thought.thoughtNumber);
    addMetric(graph, "totalThoughts", thought.totalThoughts);
    addMetric(graph, "dependencyCount", thought.buildUpon?.length || 0);
    addMetric(graph, "isRevision", thought.isRevision || false);
    addMetric(graph, "nextThoughtNeeded", thought.nextThoughtNeeded);
  }
  return serializeGraph(graph, { prettyPrint: jsonPrettyPrint, indent: jsonIndent });
}
function sequentialToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true
  } = options;
  const parts = [];
  const overviewContent = keyValueSection({
    "Thought Number": `${thought.thoughtNumber} of ${thought.totalThoughts}`,
    "Status": thought.nextThoughtNeeded ? "In Progress" : "Complete",
    "Revision": thought.isRevision ? "Yes" : "No"
  });
  parts.push(section("Overview", overviewContent));
  parts.push(section("Current Thought", thought.content));
  if (thought.buildUpon && thought.buildUpon.length > 0) {
    parts.push(section("Dependencies (Builds Upon)", list(thought.buildUpon)));
  }
  if (thought.branchFrom) {
    const branchContent = keyValueSection({
      "Branched From": thought.branchFrom,
      ...thought.branchId ? { "Branch ID": thought.branchId } : {}
    });
    parts.push(section("Branch Information", branchContent));
  }
  if (thought.isRevision && thought.revisesThought) {
    const revisionContent = keyValueSection({
      "Revises": thought.revisesThought,
      ...thought.revisionReason ? { "Reason": thought.revisionReason } : {}
    });
    parts.push(section("Revision Information", revisionContent));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = sequentialToMermaid(thought, "default", true);
    parts.push(section("Dependency Graph", mermaidBlock(mermaidDiagram)));
  }
  return document("Sequential Dependency Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "sequential",
      thoughtNumber: thought.thoughtNumber,
      totalThoughts: thought.totalThoughts
    }
  });
}
var init_sequential = __esm({
  "src/export/visual/modes/sequential.ts"() {
    init_esm_shims();
    init_utils();
    init_mermaid();
    init_dot();
    init_ascii();
    init_svg();
    init_graphml();
    init_tikz();
    init_html();
    init_modelica();
    init_uml();
    init_json();
    init_markdown();
  }
});

// src/export/visual/modes/shannon.ts
function exportShannonStageFlow(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return shannonToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return shannonToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return shannonToASCII(thought);
    case "svg":
      return shannonToSVG(thought, options);
    case "graphml":
      return shannonToGraphML(thought, options);
    case "tikz":
      return shannonToTikZ(thought, options);
    case "html":
      return shannonToHTML(thought, options);
    case "modelica":
      return shannonToModelica(thought, options);
    case "uml":
      return shannonToUML(thought, options);
    case "json":
      return shannonToJSON(thought, options);
    case "markdown":
      return shannonToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function shannonToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph LR\n";
  for (let i = 0; i < stages.length; i++) {
    const stage = stages[i];
    const stageId = sanitizeId(stage);
    const label = includeLabels ? stageLabels[stage] : stageId;
    mermaid += `  ${stageId}["${label}"]
`;
    if (i < stages.length - 1) {
      const nextStageId = sanitizeId(stages[i + 1]);
      mermaid += `  ${stageId} --> ${nextStageId}
`;
    }
  }
  if (colorScheme !== "monochrome") {
    mermaid += "\n";
    const currentStageId = sanitizeId(thought.stage);
    const color = colorScheme === "pastel" ? "#e1f5ff" : "#a8d5ff";
    mermaid += `  style ${currentStageId} fill:${color},stroke:#333,stroke-width:3px
`;
  }
  if (includeMetrics && thought.uncertainty !== void 0) {
    mermaid += `
  uncertainty["Uncertainty: ${thought.uncertainty.toFixed(2)}"]
`;
    mermaid += `  uncertainty -.-> ${sanitizeId(thought.stage)}
`;
  }
  return mermaid;
}
function shannonToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph ShannonStageFlow {\n";
  dot += "  rankdir=LR;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  for (let i = 0; i < stages.length; i++) {
    const stage = stages[i];
    const stageId = sanitizeId(stage);
    const label = includeLabels ? stageLabels[stage] : stageId;
    const isCurrent = stage === thought.stage;
    const style = isCurrent ? ", style=filled, fillcolor=lightblue" : "";
    dot += `  ${stageId} [label="${label}"${style}];
`;
    if (i < stages.length - 1) {
      const nextStageId = sanitizeId(stages[i + 1]);
      dot += `  ${stageId} -> ${nextStageId};
`;
    }
  }
  if (includeMetrics && thought.uncertainty !== void 0) {
    dot += `
  uncertainty [label="Uncertainty: ${thought.uncertainty.toFixed(2)}", shape=ellipse];
`;
    dot += `  uncertainty -> ${sanitizeId(thought.stage)} [style=dashed];
`;
  }
  dot += "}\n";
  return dot;
}
function shannonToASCII(thought) {
  let ascii = "Shannon Stage Flow:\n";
  ascii += "===================\n\n";
  ascii += "Flow: ";
  for (let i = 0; i < stages.length; i++) {
    const stage = stages[i];
    const isCurrent = stage === thought.stage;
    if (isCurrent) {
      ascii += `[${stageLabels[stage]}]`;
    } else {
      ascii += stageLabels[stage];
    }
    if (i < stages.length - 1) {
      ascii += " \u2192 ";
    }
  }
  ascii += "\n\n";
  ascii += `Current Stage: ${stageLabels[thought.stage]}
`;
  ascii += `Uncertainty: ${thought.uncertainty.toFixed(2)}
`;
  if (thought.dependencies && thought.dependencies.length > 0) {
    ascii += "\nDependencies:\n";
    for (const dep of thought.dependencies) {
      ascii += `  \u2022 ${dep}
`;
    }
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    ascii += "\nAssumptions:\n";
    for (const assumption of thought.assumptions) {
      ascii += `  \u2022 ${assumption}
`;
    }
  }
  return ascii;
}
function shannonToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width,
    svgHeight = 300
  } = options;
  const nodes = stages.map((stage) => ({
    id: sanitizeId(stage),
    label: includeLabels ? stageLabels[stage] : sanitizeId(stage),
    type: stage === thought.stage ? "current" : "stage"
  }));
  const positions = layoutNodesHorizontally(nodes, {
    width: svgWidth,
    height: svgHeight,
    nodeWidth: 130,
    nodeHeight: 45,
    nodeSpacing: 25
  });
  let svg = generateSVGHeader(svgWidth, svgHeight, "Shannon Stage Flow");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  for (let i = 0; i < stages.length - 1; i++) {
    const fromPos = positions.get(sanitizeId(stages[i]));
    const toPos = positions.get(sanitizeId(stages[i + 1]));
    if (fromPos && toPos) {
      svg += renderHorizontalEdge(fromPos, toPos, {});
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  for (let i = 0; i < stages.length; i++) {
    const stage = stages[i];
    const pos = positions.get(sanitizeId(stage));
    if (pos) {
      const isCurrent = stage === thought.stage;
      const colors = isCurrent ? getNodeColor("primary", colorScheme) : getNodeColor("neutral", colorScheme);
      if (isCurrent) {
        svg += renderStadiumNode(pos, colors);
      } else {
        svg += renderRectNode(pos, colors);
      }
    }
  }
  svg += "\n  </g>";
  if (includeMetrics && thought.uncertainty !== void 0) {
    const metrics = [
      { label: "Stage", value: stageLabels[thought.stage] },
      { label: "Uncertainty", value: thought.uncertainty.toFixed(2) }
    ];
    svg += renderMetricsPanel(svgWidth - 180, svgHeight - 80, metrics);
  }
  const legendItems = [
    { label: "Current", color: getNodeColor("primary", colorScheme) },
    { label: "Stage", color: getNodeColor("neutral", colorScheme) }
  ];
  svg += renderLegend(20, svgHeight - 60, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function shannonToGraphML(_thought, options) {
  const { includeLabels = true } = options;
  const labels = stages.map(
    (stage) => includeLabels ? stageLabels[stage] : sanitizeId(stage)
  );
  return createLinearGraphML(labels, {
    graphName: "Shannon Stage Flow",
    directed: true
  });
}
function shannonToTikZ(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = stages.map((stage, i) => ({
    id: sanitizeId(stage),
    label: includeLabels ? stageLabels[stage] : sanitizeId(stage),
    x: i * 3,
    y: 0,
    shape: stage === thought.stage ? "stadium" : "rectangle",
    type: stage === thought.stage ? "primary" : "neutral"
  }));
  const edges = [];
  for (let i = 0; i < stages.length - 1; i++) {
    edges.push({
      source: sanitizeId(stages[i]),
      target: sanitizeId(stages[i + 1]),
      label: ""
    });
  }
  return generateTikZ(nodes, edges, {
    title: "Shannon Stage Flow",
    includeLabels,
    includeMetrics
  });
}
function shannonToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Shannon Problem-Solving Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  if (includeMetrics) {
    const stageIndex = stages.indexOf(thought.stage);
    const progress = (stageIndex + 1) / stages.length * 100;
    html += '<div class="metrics-grid">';
    html += renderMetricCard("Current Stage", stageLabels[thought.stage], "primary");
    html += renderMetricCard("Uncertainty", thought.uncertainty.toFixed(2), "info");
    html += renderMetricCard("Progress", `${progress.toFixed(0)}%`, "success");
    html += "</div>\n";
  }
  html += renderSection("Stage Flow", `
    <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap; margin: 1rem 0;">
      ${stages.map((stage) => {
    const isCurrent = stage === thought.stage;
    const badge = renderBadge(stageLabels[stage], isCurrent ? "primary" : "secondary");
    return badge;
  }).join(" \u2192 ")}
    </div>
    ${renderProgressBar((stages.indexOf(thought.stage) + 1) / stages.length * 100, "primary")}
  `, "\u{1F504}");
  html += renderSection("Current Stage", `
    <p><strong>${stageLabels[thought.stage]}</strong></p>
    <p class="text-secondary">Uncertainty: ${(thought.uncertainty * 100).toFixed(0)}%</p>
  `, "\u{1F4CD}");
  if (thought.dependencies && thought.dependencies.length > 0) {
    html += renderSection("Dependencies", renderList(thought.dependencies), "\u{1F517}");
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    html += renderSection("Assumptions", renderList(thought.assumptions), "\u{1F4A1}");
  }
  if (thought.knownLimitations && thought.knownLimitations.length > 0) {
    html += renderSection("Known Limitations", renderList(thought.knownLimitations), "\u26A0\uFE0F");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function shannonToModelica(thought, options) {
  const { modelicaPackageName, modelicaIncludeAnnotations = true, includeMetrics = true } = options;
  const stageLabelsArray = stages.map((s) => stageLabels[s]);
  let modelica = generateLinearFlowModelica(stageLabelsArray, stageLabels[thought.stage], {
    packageName: modelicaPackageName || "ShannonStageFlow",
    includeAnnotations: modelicaIncludeAnnotations});
  if (includeMetrics && thought.uncertainty !== void 0) {
    const insertPoint = modelica.lastIndexOf("end ");
    const metricsSection = `
  // Shannon-specific metrics
  parameter Real uncertainty = ${thought.uncertainty.toFixed(3)} "Current uncertainty level";

`;
    modelica = modelica.slice(0, insertPoint) + metricsSection + modelica.slice(insertPoint);
  }
  return modelica;
}
function shannonToUML(thought, options) {
  const { umlTheme, umlDirection } = options;
  const stageLabelsArray = stages.map((s) => stageLabels[s]);
  return generateActivityDiagram(stageLabelsArray, stageLabels[thought.stage], {
    title: "Shannon Stage Flow",
    theme: umlTheme,
    direction: umlDirection
  });
}
function shannonToJSON(thought, options) {
  const { jsonPrettyPrint = true, jsonIndent = 2, includeMetrics = true } = options;
  const stageLabelsArray = stages.map((s) => stageLabels[s]);
  let json = generateLinearFlowJson("Shannon Stage Flow", "shannon", stageLabelsArray, stageLabels[thought.stage], {
    prettyPrint: jsonPrettyPrint,
    indent: jsonIndent,
    includeMetrics
  });
  if (includeMetrics) {
    const graph = JSON.parse(json);
    graph.metadata.mode = "shannon";
    graph.metrics = graph.metrics || {};
    graph.metrics.uncertainty = thought.uncertainty;
    graph.metrics.stage = thought.stage;
    if (thought.dependencies) {
      graph.metrics.dependencyCount = thought.dependencies.length;
    }
    if (thought.assumptions) {
      graph.metrics.assumptionCount = thought.assumptions.length;
    }
    json = JSON.stringify(graph, null, jsonPrettyPrint !== false ? jsonIndent : 0);
  }
  return json;
}
function shannonToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  if (includeMetrics) {
    const stageIndex2 = stages.indexOf(thought.stage);
    const progress = (stageIndex2 + 1) / stages.length * 100;
    const metricsContent = keyValueSection({
      "Current Stage": stageLabels[thought.stage],
      "Uncertainty": thought.uncertainty.toFixed(2),
      "Progress": `${progress.toFixed(0)}%`
    });
    parts.push(section("Metrics", metricsContent));
  }
  const stageFlow = stages.map((stage) => {
    const isCurrent = stage === thought.stage;
    return isCurrent ? `**[${stageLabels[stage]}]**` : stageLabels[stage];
  }).join(" \u2192 ");
  const stageIndex = stages.indexOf(thought.stage);
  const progressPct = (stageIndex + 1) / stages.length * 100;
  parts.push(section("Stage Flow", `${stageFlow}

${progressBar(progressPct)}`));
  parts.push(section("Current Stage", `**${stageLabels[thought.stage]}**

Uncertainty: ${(thought.uncertainty * 100).toFixed(0)}%`));
  if (thought.dependencies && thought.dependencies.length > 0) {
    parts.push(section("Dependencies", list(thought.dependencies)));
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    parts.push(section("Assumptions", list(thought.assumptions)));
  }
  if (thought.knownLimitations && thought.knownLimitations.length > 0) {
    parts.push(section("Known Limitations", list(thought.knownLimitations)));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = shannonToMermaid(thought, "default", true, true);
    parts.push(section("Stage Flow Diagram", mermaidBlock(mermaidDiagram)));
  }
  return document("Shannon Problem-Solving Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "shannon",
      stage: thought.stage,
      uncertainty: thought.uncertainty
    }
  });
}
var stages, stageLabels;
var init_shannon = __esm({
  "src/export/visual/modes/shannon.ts"() {
    init_esm_shims();
    init_utils();
    init_svg();
    init_graphml();
    init_tikz();
    init_html();
    init_modelica();
    init_uml();
    init_json();
    init_markdown();
    stages = [
      "problem_definition",
      "constraints",
      "model",
      "proof",
      "implementation"
    ];
    stageLabels = {
      problem_definition: "Problem Definition",
      constraints: "Constraints",
      model: "Model",
      proof: "Proof",
      implementation: "Implementation"
    };
  }
});

// src/export/visual/modes/mathematics.ts
function exportMathematicsDerivation(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return mathematicsToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return mathematicsToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return mathematicsToASCII(thought);
    case "svg":
      return mathematicsToSVG(thought, options);
    case "graphml":
      return mathematicsToGraphML(thought, options);
    case "tikz":
      return mathematicsToTikZ(thought, options);
    case "html":
      return mathematicsToHTML(thought, options);
    case "modelica":
      return mathematicsToModelica(thought, options);
    case "uml":
      return mathematicsToUML(thought, options);
    case "json":
      return mathematicsToJSON(thought, options);
    case "markdown":
      return mathematicsToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function mathematicsToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TB\n";
  const typeId = sanitizeId(`type_${thought.thoughtType || "proof"}`);
  const typeLabel = includeLabels ? (thought.thoughtType || "Proof").replace(/_/g, " ") : typeId;
  mermaid += `  ${typeId}[["${typeLabel}"]]
`;
  if (thought.proofStrategy) {
    const strategyId = sanitizeId("strategy");
    const strategyLabel = thought.proofStrategy.type;
    mermaid += `  ${strategyId}(["${strategyLabel}"])
`;
    mermaid += `  ${typeId} --> ${strategyId}
`;
    let prevStepId = strategyId;
    thought.proofStrategy.steps.forEach((step, index) => {
      const stepId = sanitizeId(`step_${index}`);
      const stepLabel = includeLabels ? step.slice(0, 40) + (step.length > 40 ? "..." : "") : `Step ${index + 1}`;
      mermaid += `  ${stepId}["${stepLabel}"]
`;
      mermaid += `  ${prevStepId} --> ${stepId}
`;
      prevStepId = stepId;
    });
    if (includeMetrics) {
      const completenessId = sanitizeId("completeness");
      const completenessLabel = `Completeness: ${(thought.proofStrategy.completeness * 100).toFixed(0)}%`;
      mermaid += `  ${completenessId}{{${completenessLabel}}}
`;
      mermaid += `  ${prevStepId} --> ${completenessId}
`;
    }
  }
  if (thought.mathematicalModel) {
    const modelId = sanitizeId("model");
    const modelLabel = thought.mathematicalModel.symbolic || "Mathematical Model";
    mermaid += `  ${modelId}["${modelLabel}"]
`;
    mermaid += `  ${typeId} --> ${modelId}
`;
  }
  if (thought.theorems && thought.theorems.length > 0) {
    thought.theorems.forEach((theorem, index) => {
      const theoremId = sanitizeId(`theorem_${index}`);
      const theoremLabel = theorem.name || `Theorem ${index + 1}`;
      mermaid += `  ${theoremId}[/"${theoremLabel}"/]
`;
      mermaid += `  ${typeId} --> ${theoremId}
`;
    });
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    const assumptionsId = sanitizeId("assumptions");
    mermaid += `  ${assumptionsId}>"Assumptions: ${thought.assumptions.length}"]
`;
  }
  if (colorScheme !== "monochrome") {
    const colors = colorScheme === "pastel" ? { type: "#e8f4e8", strategy: "#fff3e0"} : { type: "#90EE90", strategy: "#FFD700"};
    mermaid += `
  style ${typeId} fill:${colors.type}
`;
    if (thought.proofStrategy) {
      mermaid += `  style ${sanitizeId("strategy")} fill:${colors.strategy}
`;
    }
  }
  return mermaid;
}
function mathematicsToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph MathematicsDerivation {\n";
  dot += "  rankdir=TB;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  const typeId = sanitizeId(`type_${thought.thoughtType || "proof"}`);
  const typeLabel = includeLabels ? (thought.thoughtType || "Proof").replace(/_/g, " ") : typeId;
  dot += `  ${typeId} [label="${typeLabel}", shape=doubleoctagon];
`;
  if (thought.proofStrategy) {
    const strategyId = sanitizeId("strategy");
    dot += `  ${strategyId} [label="${thought.proofStrategy.type}", shape=ellipse];
`;
    dot += `  ${typeId} -> ${strategyId};
`;
    let prevStepId = strategyId;
    thought.proofStrategy.steps.forEach((step, index) => {
      const stepId = sanitizeId(`step_${index}`);
      const stepLabel = includeLabels ? step.slice(0, 30).replace(/"/g, '\\"') : `Step ${index + 1}`;
      dot += `  ${stepId} [label="${stepLabel}"];
`;
      dot += `  ${prevStepId} -> ${stepId};
`;
      prevStepId = stepId;
    });
    if (includeMetrics) {
      const completenessId = sanitizeId("completeness");
      dot += `  ${completenessId} [label="${(thought.proofStrategy.completeness * 100).toFixed(0)}%", shape=diamond];
`;
      dot += `  ${prevStepId} -> ${completenessId};
`;
    }
  }
  if (thought.theorems) {
    thought.theorems.forEach((theorem, index) => {
      const theoremId = sanitizeId(`theorem_${index}`);
      dot += `  ${theoremId} [label="${theorem.name || `Theorem ${index + 1}`}", shape=parallelogram];
`;
      dot += `  ${typeId} -> ${theoremId};
`;
    });
  }
  dot += "}\n";
  return dot;
}
function mathematicsToASCII(thought) {
  let ascii = "Mathematics Derivation:\n";
  ascii += "=======================\n\n";
  ascii += `Type: ${(thought.thoughtType || "proof").replace(/_/g, " ")}
`;
  ascii += `Uncertainty: ${(thought.uncertainty * 100).toFixed(1)}%

`;
  if (thought.mathematicalModel) {
    ascii += "Mathematical Model:\n";
    ascii += `  LaTeX: ${thought.mathematicalModel.latex}
`;
    ascii += `  Symbolic: ${thought.mathematicalModel.symbolic}
`;
    if (thought.mathematicalModel.ascii) {
      ascii += `  ASCII: ${thought.mathematicalModel.ascii}
`;
    }
    ascii += "\n";
  }
  if (thought.proofStrategy) {
    ascii += `Proof Strategy: ${thought.proofStrategy.type}
`;
    ascii += `Completeness: ${(thought.proofStrategy.completeness * 100).toFixed(0)}%
`;
    ascii += "Steps:\n";
    thought.proofStrategy.steps.forEach((step, index) => {
      ascii += `  ${index + 1}. ${step}
`;
    });
    if (thought.proofStrategy.baseCase) {
      ascii += `Base Case: ${thought.proofStrategy.baseCase}
`;
    }
    if (thought.proofStrategy.inductiveStep) {
      ascii += `Inductive Step: ${thought.proofStrategy.inductiveStep}
`;
    }
    ascii += "\n";
  }
  if (thought.theorems && thought.theorems.length > 0) {
    ascii += "Theorems:\n";
    thought.theorems.forEach((theorem, index) => {
      ascii += `  [${index + 1}] ${theorem.name}: ${theorem.statement}
`;
      if (theorem.hypotheses.length > 0) {
        ascii += `      Hypotheses: ${theorem.hypotheses.join(", ")}
`;
      }
      ascii += `      Conclusion: ${theorem.conclusion}
`;
    });
    ascii += "\n";
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    ascii += "Assumptions:\n";
    thought.assumptions.forEach((assumption, index) => {
      ascii += `  ${index + 1}. ${assumption}
`;
    });
    ascii += "\n";
  }
  if (thought.dependencies && thought.dependencies.length > 0) {
    ascii += "Dependencies:\n";
    thought.dependencies.forEach((dep, index) => {
      ascii += `  ${index + 1}. ${dep}
`;
    });
  }
  return ascii;
}
function mathematicsToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width
  } = options;
  const positions = /* @__PURE__ */ new Map();
  const nodeWidth = 150;
  const nodeHeight = 40;
  let currentY = 80;
  const typeId = "type";
  positions.set(typeId, {
    id: typeId,
    label: includeLabels ? (thought.thoughtType || "Proof").replace(/_/g, " ") : typeId,
    x: svgWidth / 2,
    y: currentY,
    width: nodeWidth,
    height: nodeHeight,
    type: "type"
  });
  currentY += 120;
  if (thought.proofStrategy) {
    positions.set("strategy", {
      id: "strategy",
      label: thought.proofStrategy.type,
      x: svgWidth / 2,
      y: currentY,
      width: nodeWidth,
      height: nodeHeight,
      type: "strategy"
    });
    currentY += 100;
    thought.proofStrategy.steps.forEach((step, index) => {
      const stepId = `step_${index}`;
      positions.set(stepId, {
        id: stepId,
        label: includeLabels ? `${index + 1}. ${step.substring(0, 25)}...` : `Step ${index + 1}`,
        x: 150 + index % 3 * 200,
        y: currentY + Math.floor(index / 3) * 80,
        width: nodeWidth,
        height: nodeHeight,
        type: "step"
      });
    });
    currentY += Math.ceil(thought.proofStrategy.steps.length / 3) * 80 + 40;
  }
  if (thought.theorems && thought.theorems.length > 0) {
    thought.theorems.forEach((theorem, index) => {
      const theoremId = `theorem_${index}`;
      positions.set(theoremId, {
        id: theoremId,
        label: theorem.name || `Theorem ${index + 1}`,
        x: svgWidth / 2,
        y: currentY,
        width: nodeWidth,
        height: nodeHeight,
        type: "theorem"
      });
      currentY += 80;
    });
  }
  const actualHeight = Math.max(DEFAULT_SVG_OPTIONS.height, currentY + 100);
  let svg = generateSVGHeader(svgWidth, actualHeight, "Mathematics Derivation");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  if (thought.proofStrategy) {
    const typePos = positions.get("type");
    const strategyPos = positions.get("strategy");
    if (typePos && strategyPos) {
      svg += renderEdge(typePos, strategyPos);
    }
    const stratPos = positions.get("strategy");
    thought.proofStrategy.steps.forEach((_, index) => {
      const stepPos = positions.get(`step_${index}`);
      if (stratPos && stepPos) {
        svg += renderEdge(stratPos, stepPos);
      }
    });
  }
  if (thought.theorems) {
    const typePos = positions.get("type");
    thought.theorems.forEach((_, index) => {
      const theoremPos = positions.get(`theorem_${index}`);
      if (typePos && theoremPos) {
        svg += renderEdge(typePos, theoremPos);
      }
    });
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  const typeColors = getNodeColor("primary", colorScheme);
  const strategyColors = getNodeColor("secondary", colorScheme);
  const stepColors = getNodeColor("neutral", colorScheme);
  const theoremColors = getNodeColor("tertiary", colorScheme);
  for (const [, pos] of positions) {
    if (pos.type === "type") {
      svg += renderStadiumNode(pos, typeColors);
    } else if (pos.type === "strategy") {
      svg += renderEllipseNode(pos, strategyColors);
    } else if (pos.type === "step") {
      svg += renderRectNode(pos, stepColors);
    } else if (pos.type === "theorem") {
      svg += renderRectNode(pos, theoremColors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Uncertainty", value: `${(thought.uncertainty * 100).toFixed(1)}%` },
      { label: "Theorems", value: thought.theorems?.length || 0 },
      { label: "Assumptions", value: thought.assumptions?.length || 0 }
    ];
    svg += renderMetricsPanel(svgWidth - 180, actualHeight - 110, metrics);
  }
  const legendItems = [
    { label: "Type", color: typeColors, shape: "stadium" },
    { label: "Strategy", color: strategyColors, shape: "ellipse" },
    { label: "Step", color: stepColors },
    { label: "Theorem", color: theoremColors }
  ];
  svg += renderLegend(20, actualHeight - 130, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function mathematicsToGraphML(thought, options) {
  const { includeLabels = true } = options;
  const nodes = [];
  const edges = [];
  let edgeCount = 0;
  const typeId = sanitizeId(`type_${thought.thoughtType || "proof"}`);
  nodes.push({
    id: typeId,
    label: includeLabels ? (thought.thoughtType || "Proof").replace(/_/g, " ") : typeId,
    type: "type"
  });
  if (thought.theorems && thought.theorems.length > 0) {
    thought.theorems.forEach((theorem, index) => {
      const theoremId = sanitizeId(`theorem_${index}`);
      nodes.push({
        id: theoremId,
        label: theorem.name || `Theorem ${index + 1}`,
        type: "axiom",
        metadata: {
          description: theorem.statement
        }
      });
      edges.push({
        id: `e${edgeCount++}`,
        source: typeId,
        target: theoremId,
        directed: true
      });
    });
  }
  if (thought.proofStrategy) {
    const strategyId = sanitizeId("strategy");
    nodes.push({
      id: strategyId,
      label: thought.proofStrategy.type,
      type: "strategy"
    });
    edges.push({
      id: `e${edgeCount++}`,
      source: typeId,
      target: strategyId,
      directed: true
    });
    let prevStepId = strategyId;
    thought.proofStrategy.steps.forEach((step, index) => {
      const stepId = sanitizeId(`step_${index}`);
      nodes.push({
        id: stepId,
        label: includeLabels ? step.slice(0, 40) + (step.length > 40 ? "..." : "") : `Step ${index + 1}`,
        type: "step",
        metadata: {
          description: step
        }
      });
      edges.push({
        id: `e${edgeCount++}`,
        source: prevStepId,
        target: stepId,
        directed: true
      });
      prevStepId = stepId;
    });
  }
  if (thought.mathematicalModel) {
    const modelId = sanitizeId("model");
    nodes.push({
      id: modelId,
      label: thought.mathematicalModel.symbolic || "Mathematical Model",
      type: "model",
      metadata: {
        description: thought.mathematicalModel.latex
      }
    });
    edges.push({
      id: `e${edgeCount++}`,
      source: typeId,
      target: modelId,
      directed: true
    });
  }
  return generateGraphML(nodes, edges, {
    graphName: "Mathematics Derivation",
    directed: true,
    includeLabels
  });
}
function mathematicsToTikZ(thought, options) {
  const { includeLabels = true, colorScheme = "default" } = options;
  const nodes = [];
  const edges = [];
  let yPos = 0;
  const typeId = sanitizeId(`type_${thought.thoughtType || "proof"}`);
  nodes.push({
    id: typeId,
    label: includeLabels ? (thought.thoughtType || "Proof").replace(/_/g, " ") : typeId,
    x: 4,
    y: yPos,
    type: "primary",
    shape: "stadium"
  });
  yPos -= 2;
  if (thought.theorems && thought.theorems.length > 0) {
    thought.theorems.forEach((theorem, index) => {
      const theoremId = sanitizeId(`theorem_${index}`);
      const xPos = 1 + index * 3;
      nodes.push({
        id: theoremId,
        label: theorem.name || `Theorem ${index + 1}`,
        x: xPos,
        y: yPos,
        type: "secondary",
        shape: "stadium"
      });
      edges.push({
        source: typeId,
        target: theoremId,
        directed: true
      });
    });
    yPos -= 2;
  }
  if (thought.proofStrategy) {
    const strategyId = sanitizeId("strategy");
    nodes.push({
      id: strategyId,
      label: thought.proofStrategy.type,
      x: 4,
      y: yPos,
      type: "secondary",
      shape: "ellipse"
    });
    edges.push({
      source: typeId,
      target: strategyId,
      directed: true
    });
    yPos -= 2;
    let prevStepId = strategyId;
    thought.proofStrategy.steps.forEach((step, index) => {
      const stepId = sanitizeId(`step_${index}`);
      const xPos = 1 + index % 3 * 2.5;
      const stepYPos = yPos - Math.floor(index / 3) * 1.5;
      nodes.push({
        id: stepId,
        label: includeLabels ? `${index + 1}. ${step.substring(0, 20)}...` : `Step ${index + 1}`,
        x: xPos,
        y: stepYPos,
        type: "neutral",
        shape: "rectangle"
      });
      edges.push({
        source: prevStepId,
        target: stepId,
        directed: true
      });
      prevStepId = stepId;
    });
  }
  return generateTikZ(nodes, edges, {
    title: "Mathematics Derivation",
    colorScheme,
    includeLabels
  });
}
function mathematicsToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Mathematics Derivation Analysis",
    htmlTheme = "light"
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  html += '<div class="metrics-grid">';
  html += renderMetricCard("Uncertainty", `${(thought.uncertainty * 100).toFixed(1)}%`, "warning");
  if (thought.theorems) {
    html += renderMetricCard("Theorems", thought.theorems.length, "primary");
  }
  if (thought.assumptions) {
    html += renderMetricCard("Assumptions", thought.assumptions.length, "info");
  }
  if (thought.proofStrategy) {
    html += renderMetricCard("Completeness", `${(thought.proofStrategy.completeness * 100).toFixed(0)}%`, "success");
  }
  html += "</div>\n";
  const badges = [];
  if (thought.thoughtType) {
    badges.push(renderBadge(thought.thoughtType.replace(/_/g, " "), "primary"));
  }
  if (badges.length > 0) {
    html += `<div class="flex gap-1" style="margin: 1rem 0">${badges.join(" ")}</div>
`;
  }
  if (thought.mathematicalModel) {
    const modelContent = `
      <p><strong>LaTeX:</strong> <code>${escapeHTML(thought.mathematicalModel.latex)}</code></p>
      <p><strong>Symbolic:</strong> <code>${escapeHTML(thought.mathematicalModel.symbolic)}</code></p>
      ${thought.mathematicalModel.ascii ? `<p><strong>ASCII:</strong> <code>${escapeHTML(thought.mathematicalModel.ascii)}</code></p>` : ""}
    `;
    html += renderSection("Mathematical Model", modelContent, "\u{1F4D0}");
  }
  if (thought.proofStrategy) {
    const proofContent = `
      <p><strong>Type:</strong> ${renderBadge(thought.proofStrategy.type, "info")}</p>
      <p><strong>Completeness:</strong></p>
      ${renderProgressBar(thought.proofStrategy.completeness * 100, "success")}
      <p style="margin-top: 1rem"><strong>Steps:</strong></p>
      <ol class="list-styled">
        ${thought.proofStrategy.steps.map((step) => `<li>${escapeHTML(step)}</li>`).join("")}
      </ol>
      ${thought.proofStrategy.baseCase ? `<p><strong>Base Case:</strong> ${escapeHTML(thought.proofStrategy.baseCase)}</p>` : ""}
      ${thought.proofStrategy.inductiveStep ? `<p><strong>Inductive Step:</strong> ${escapeHTML(thought.proofStrategy.inductiveStep)}</p>` : ""}
    `;
    html += renderSection("Proof Strategy", proofContent, "\u{1F50D}");
  }
  if (thought.theorems && thought.theorems.length > 0) {
    const theoremsContent = thought.theorems.map((theorem, index) => `
      <div class="card">
        <div class="card-header">${escapeHTML(theorem.name || `Theorem ${index + 1}`)}</div>
        <p><strong>Statement:</strong> ${escapeHTML(theorem.statement)}</p>
        ${theorem.hypotheses.length > 0 ? `<p><strong>Hypotheses:</strong> ${escapeHTML(theorem.hypotheses.join(", "))}</p>` : ""}
        <p><strong>Conclusion:</strong> ${escapeHTML(theorem.conclusion)}</p>
      </div>
    `).join("");
    html += renderSection("Theorems", theoremsContent, "\u{1F4DC}");
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    const assumptionsList = thought.assumptions.map((a) => escapeHTML(a));
    html += renderSection("Assumptions", `
      <ul class="list-styled">
        ${assumptionsList.map((a) => `<li>${a}</li>`).join("")}
      </ul>
    `, "\u26A0\uFE0F");
  }
  if (thought.dependencies && thought.dependencies.length > 0) {
    const depsList = thought.dependencies.map((d) => escapeHTML(d));
    html += renderSection("Dependencies", `
      <ul class="list-styled">
        ${depsList.map((d) => `<li>${d}</li>`).join("")}
      </ul>
    `, "\u{1F517}");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function mathematicsToModelica(thought, options) {
  const { includeLabels = true } = options;
  let modelica = "// Mathematics Derivation Model\n";
  modelica += `package MathematicsDerivation "${thought.thoughtType || "Proof"}"
`;
  modelica += '  "Mathematical derivation and proof structure"\n\n';
  modelica += "  // Mathematical Model\n";
  if (thought.mathematicalModel) {
    const modelName = sanitizeModelicaId("MathModel");
    modelica += `  model ${modelName} "Mathematical Expression"
`;
    modelica += `    parameter String latex = "${escapeModelicaString(thought.mathematicalModel.latex)}";
`;
    modelica += `    parameter String symbolic = "${escapeModelicaString(thought.mathematicalModel.symbolic)}";
`;
    if (thought.mathematicalModel.ascii) {
      modelica += `    parameter String ascii = "${escapeModelicaString(thought.mathematicalModel.ascii)}";
`;
    }
    modelica += `  end ${modelName};

`;
  }
  if (thought.theorems && thought.theorems.length > 0) {
    modelica += "  // Theorems\n";
    thought.theorems.forEach((theorem, index) => {
      const theoremName = sanitizeModelicaId(theorem.name || `Theorem${index + 1}`);
      modelica += `  model ${theoremName} "Theorem ${index + 1}"
`;
      modelica += `    parameter String statement = "${escapeModelicaString(theorem.statement)}";
`;
      if (theorem.hypotheses.length > 0) {
        theorem.hypotheses.forEach((hyp, hypIndex) => {
          modelica += `    parameter String hypothesis${hypIndex + 1} = "${escapeModelicaString(hyp)}";
`;
        });
      }
      modelica += `    parameter String conclusion = "${escapeModelicaString(theorem.conclusion)}";
`;
      modelica += `  end ${theoremName};

`;
    });
  }
  if (thought.proofStrategy) {
    const strategyName = sanitizeModelicaId(thought.proofStrategy.type.replace(/\s+/g, "_"));
    modelica += "  // Proof Strategy\n";
    modelica += `  model ${strategyName} "Proof Strategy"
`;
    modelica += `    parameter String proofType = "${escapeModelicaString(thought.proofStrategy.type)}";
`;
    modelica += `    parameter Real completeness = ${thought.proofStrategy.completeness};
`;
    thought.proofStrategy.steps.forEach((step, index) => {
      if (includeLabels) {
        modelica += `    parameter String step${index + 1} = "${escapeModelicaString(step)}";
`;
      }
    });
    if (thought.proofStrategy.baseCase) {
      modelica += `    parameter String baseCase = "${escapeModelicaString(thought.proofStrategy.baseCase)}";
`;
    }
    if (thought.proofStrategy.inductiveStep) {
      modelica += `    parameter String inductiveStep = "${escapeModelicaString(thought.proofStrategy.inductiveStep)}";
`;
    }
    modelica += `  end ${strategyName};

`;
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    modelica += "  // Assumptions\n";
    modelica += '  model Assumptions "Proof Assumptions"\n';
    thought.assumptions.forEach((assumption, index) => {
      modelica += `    parameter String assumption${index + 1} = "${escapeModelicaString(assumption)}";
`;
    });
    modelica += "  end Assumptions;\n\n";
  }
  modelica += "  // Metadata\n";
  modelica += '  model Metadata "Derivation Metadata"\n';
  modelica += `    parameter Real uncertainty = ${thought.uncertainty};
`;
  modelica += `    parameter Integer theoremCount = ${thought.theorems?.length || 0};
`;
  modelica += `    parameter Integer assumptionCount = ${thought.assumptions?.length || 0};
`;
  modelica += "  end Metadata;\n\n";
  modelica += "end MathematicsDerivation;\n";
  return modelica;
}
function mathematicsToUML(thought, options) {
  const { includeLabels = true } = options;
  const nodes = [];
  const edges = [];
  const typeId = sanitizeId(`type_${thought.thoughtType || "proof"}`);
  nodes.push({
    id: typeId,
    label: includeLabels ? (thought.thoughtType || "Proof").replace(/_/g, " ") : typeId,
    shape: "class",
    stereotype: "mathematical",
    attributes: [
      `uncertainty: ${(thought.uncertainty * 100).toFixed(1)}%`
    ]
  });
  if (thought.mathematicalModel) {
    const modelId = sanitizeId("model");
    nodes.push({
      id: modelId,
      label: "Mathematical Model",
      shape: "class",
      stereotype: "model",
      attributes: [
        `latex: ${thought.mathematicalModel.latex.substring(0, 40)}...`,
        `symbolic: ${thought.mathematicalModel.symbolic}`
      ]
    });
    edges.push({
      source: typeId,
      target: modelId,
      type: "composition",
      label: "contains"
    });
  }
  if (thought.theorems && thought.theorems.length > 0) {
    thought.theorems.forEach((theorem, index) => {
      const theoremId = sanitizeId(`theorem_${index}`);
      const attributes = [
        `statement: ${theorem.statement.substring(0, 40)}...`,
        `hypotheses: ${theorem.hypotheses.length}`,
        `conclusion: ${theorem.conclusion.substring(0, 40)}...`
      ];
      nodes.push({
        id: theoremId,
        label: theorem.name || `Theorem ${index + 1}`,
        shape: "class",
        stereotype: "theorem",
        attributes
      });
      edges.push({
        source: typeId,
        target: theoremId,
        type: "association",
        label: "uses"
      });
    });
  }
  if (thought.proofStrategy) {
    const strategyId = sanitizeId("strategy");
    const methods = thought.proofStrategy.steps.map((step, index) => {
      return includeLabels ? `step${index + 1}(): ${step.substring(0, 30)}...` : `step${index + 1}()`;
    });
    nodes.push({
      id: strategyId,
      label: thought.proofStrategy.type,
      shape: "class",
      stereotype: "strategy",
      attributes: [
        `completeness: ${(thought.proofStrategy.completeness * 100).toFixed(0)}%`
      ],
      methods
    });
    edges.push({
      source: typeId,
      target: strategyId,
      type: "dependency",
      label: "applies"
    });
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    const assumptionsId = sanitizeId("assumptions");
    nodes.push({
      id: assumptionsId,
      label: "Assumptions",
      shape: "interface",
      attributes: thought.assumptions.slice(0, 5).map((a, i) => `${i + 1}. ${a.substring(0, 30)}...`)
    });
    edges.push({
      source: typeId,
      target: assumptionsId,
      type: "implementation",
      label: "assumes"
    });
  }
  return generateUmlDiagram(nodes, edges, {
    title: "Mathematics Derivation Structure"});
}
function mathematicsToJSON(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const graph = createJsonGraph("Mathematics Derivation", "mathematics");
  const typeId = sanitizeId(`type_${thought.thoughtType || "proof"}`);
  addNode(graph, {
    id: typeId,
    label: includeLabels ? (thought.thoughtType || "Proof").replace(/_/g, " ") : typeId,
    type: "type",
    metadata: {
      thoughtType: thought.thoughtType || "proof",
      uncertainty: thought.uncertainty
    }
  });
  if (thought.mathematicalModel) {
    const modelId = sanitizeId("model");
    addNode(graph, {
      id: modelId,
      label: thought.mathematicalModel.symbolic || "Mathematical Model",
      type: "model",
      metadata: {
        latex: thought.mathematicalModel.latex,
        symbolic: thought.mathematicalModel.symbolic,
        ascii: thought.mathematicalModel.ascii
      }
    });
    addEdge(graph, {
      id: `edge_${typeId}_${modelId}`,
      source: typeId,
      target: modelId,
      label: "contains",
      type: "composition"
    });
  }
  if (thought.theorems && thought.theorems.length > 0) {
    thought.theorems.forEach((theorem, index) => {
      const theoremId = sanitizeId(`theorem_${index}`);
      addNode(graph, {
        id: theoremId,
        label: theorem.name || `Theorem ${index + 1}`,
        type: "theorem",
        metadata: {
          statement: theorem.statement,
          hypotheses: theorem.hypotheses,
          conclusion: theorem.conclusion
        }
      });
      addEdge(graph, {
        id: `edge_${typeId}_${theoremId}`,
        source: typeId,
        target: theoremId,
        label: "uses",
        type: "association"
      });
    });
  }
  if (thought.proofStrategy) {
    const strategyId = sanitizeId("strategy");
    addNode(graph, {
      id: strategyId,
      label: thought.proofStrategy.type,
      type: "strategy",
      metadata: {
        proofType: thought.proofStrategy.type,
        completeness: thought.proofStrategy.completeness,
        baseCase: thought.proofStrategy.baseCase,
        inductiveStep: thought.proofStrategy.inductiveStep
      }
    });
    addEdge(graph, {
      id: `edge_${typeId}_${strategyId}`,
      source: typeId,
      target: strategyId,
      label: "applies",
      type: "dependency"
    });
    let prevStepId = strategyId;
    thought.proofStrategy.steps.forEach((step, index) => {
      const stepId = sanitizeId(`step_${index}`);
      addNode(graph, {
        id: stepId,
        label: includeLabels ? `Step ${index + 1}` : stepId,
        type: "step",
        metadata: {
          stepNumber: index + 1,
          description: step
        }
      });
      addEdge(graph, {
        id: `edge_${prevStepId}_${stepId}`,
        source: prevStepId,
        target: stepId,
        label: "leads_to",
        type: "sequence"
      });
      prevStepId = stepId;
    });
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    thought.assumptions.forEach((assumption, index) => {
      const assumptionId = sanitizeId(`assumption_${index}`);
      addNode(graph, {
        id: assumptionId,
        label: includeLabels ? `Assumption ${index + 1}` : assumptionId,
        type: "assumption",
        metadata: {
          description: assumption
        }
      });
      addEdge(graph, {
        id: `edge_${typeId}_${assumptionId}`,
        source: typeId,
        target: assumptionId,
        label: "assumes",
        type: "dependency"
      });
    });
  }
  if (includeMetrics) {
    addMetric(graph, "uncertainty", thought.uncertainty);
    addMetric(graph, "theorem_count", thought.theorems?.length || 0);
    addMetric(graph, "assumption_count", thought.assumptions?.length || 0);
    addMetric(graph, "dependency_count", thought.dependencies?.length || 0);
    if (thought.proofStrategy) {
      addMetric(graph, "proof_completeness", thought.proofStrategy.completeness);
      addMetric(graph, "proof_step_count", thought.proofStrategy.steps.length);
    }
  }
  return serializeGraph(graph);
}
function mathematicsToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  const typeContent = keyValueSection({
    "Type": (thought.thoughtType || "proof").replace(/_/g, " "),
    "Uncertainty": `${(thought.uncertainty * 100).toFixed(1)}%`
  });
  parts.push(section("Overview", typeContent));
  if (thought.mathematicalModel) {
    const modelContent = keyValueSection({
      "LaTeX": `\`${thought.mathematicalModel.latex}\``,
      "Symbolic": `\`${thought.mathematicalModel.symbolic}\``,
      "ASCII": thought.mathematicalModel.ascii ? `\`${thought.mathematicalModel.ascii}\`` : "N/A"
    });
    parts.push(section("Mathematical Model", modelContent));
  }
  if (includeMetrics) {
    const metricsContent = keyValueSection({
      "Uncertainty": `${(thought.uncertainty * 100).toFixed(1)}%`,
      "Theorems": thought.theorems?.length || 0,
      "Assumptions": thought.assumptions?.length || 0,
      "Proof Completeness": thought.proofStrategy ? `${(thought.proofStrategy.completeness * 100).toFixed(0)}%` : "N/A"
    });
    parts.push(section("Metrics", metricsContent));
  }
  if (thought.proofStrategy) {
    let proofContent = `**Type:** ${thought.proofStrategy.type}

`;
    proofContent += `**Completeness:** ${(thought.proofStrategy.completeness * 100).toFixed(0)}%

`;
    proofContent += "**Steps:**\n\n";
    const stepItems = thought.proofStrategy.steps.map(
      (step, index) => `${index + 1}. ${step}`
    );
    proofContent += list(stepItems, "numbered");
    if (thought.proofStrategy.baseCase) {
      proofContent += `
**Base Case:** ${thought.proofStrategy.baseCase}
`;
    }
    if (thought.proofStrategy.inductiveStep) {
      proofContent += `
**Inductive Step:** ${thought.proofStrategy.inductiveStep}
`;
    }
    parts.push(section("Proof Strategy", proofContent));
  }
  if (thought.theorems && thought.theorems.length > 0) {
    const theoremItems = thought.theorems.map(
      (theorem) => `**${theorem.name}**: ${theorem.statement}
  - Hypotheses: ${theorem.hypotheses.join(", ")}
  - Conclusion: ${theorem.conclusion}`
    );
    parts.push(section("Theorems", list(theoremItems)));
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    parts.push(section("Assumptions", list(thought.assumptions)));
  }
  if (thought.dependencies && thought.dependencies.length > 0) {
    parts.push(section("Dependencies", list(thought.dependencies)));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = mathematicsToMermaid(thought, "default", true, true);
    parts.push(section("Derivation Diagram", mermaidBlock(mermaidDiagram)));
  }
  return document("Mathematics Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: { mode: "mathematics" }
  });
}
var init_mathematics = __esm({
  "src/export/visual/modes/mathematics.ts"() {
    init_esm_shims();
    init_utils();
    init_svg();
    init_graphml();
    init_tikz();
    init_html();
    init_modelica();
    init_uml();
    init_json();
    init_markdown();
  }
});

// src/export/visual/modes/physics.ts
function exportPhysicsVisualization(thought, options) {
  const { format, colorScheme = "default" } = options;
  switch (format) {
    case "mermaid":
      return physicsToMermaid(thought, colorScheme, options.includeLabels ?? true, options.includeMetrics ?? true);
    case "dot":
      return physicsToDOT(thought, options.includeLabels ?? true, options.includeMetrics ?? true);
    case "ascii":
      return physicsToASCII(thought);
    case "svg":
      return physicsToSVG(thought, options);
    case "graphml":
      return physicsToGraphML(thought, options);
    case "tikz":
      return physicsToTikZ(thought, options);
    case "html":
      return physicsToHTML(thought, options);
    case "modelica":
      return physicsToModelica(thought, options);
    case "uml":
      return physicsToUML(thought, options);
    case "json":
      return physicsToJSON(thought, options);
    case "markdown":
      return physicsToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function physicsToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TB\n";
  const typeId = sanitizeId(`type_${thought.thoughtType || "physics"}`);
  const typeLabel = includeLabels ? (thought.thoughtType || "Physics").replace(/_/g, " ") : typeId;
  mermaid += `  ${typeId}[["${typeLabel}"]]
`;
  if (thought.tensorProperties) {
    const tensorId = sanitizeId("tensor");
    const rankLabel = `Rank (${thought.tensorProperties.rank[0]},${thought.tensorProperties.rank[1]})`;
    mermaid += `  ${tensorId}(["${rankLabel}"])
`;
    mermaid += `  ${typeId} --> ${tensorId}
`;
    const compId = sanitizeId("components");
    const compLabel = includeLabels ? thought.tensorProperties.components.slice(0, 30) + (thought.tensorProperties.components.length > 30 ? "..." : "") : "Components";
    mermaid += `  ${compId}["${compLabel}"]
`;
    mermaid += `  ${tensorId} --> ${compId}
`;
    if (thought.tensorProperties.symmetries.length > 0) {
      const symId = sanitizeId("symmetries");
      mermaid += `  ${symId}{{"Symmetries: ${thought.tensorProperties.symmetries.length}"}}
`;
      mermaid += `  ${tensorId} --> ${symId}
`;
    }
    if (thought.tensorProperties.invariants.length > 0) {
      const invId = sanitizeId("invariants");
      mermaid += `  ${invId}{{"Invariants: ${thought.tensorProperties.invariants.length}"}}
`;
      mermaid += `  ${tensorId} --> ${invId}
`;
    }
  }
  if (thought.physicalInterpretation) {
    const interpId = sanitizeId("interpretation");
    const interpLabel = thought.physicalInterpretation.quantity;
    mermaid += `  ${interpId}[/"${interpLabel}"/]
`;
    mermaid += `  ${typeId} --> ${interpId}
`;
    const unitsId = sanitizeId("units");
    mermaid += `  ${unitsId}(["${thought.physicalInterpretation.units}"])
`;
    mermaid += `  ${interpId} --> ${unitsId}
`;
    if (thought.physicalInterpretation.conservationLaws.length > 0) {
      thought.physicalInterpretation.conservationLaws.forEach((law, index) => {
        const lawId = sanitizeId(`conservation_${index}`);
        const lawLabel = includeLabels ? law.slice(0, 25) + (law.length > 25 ? "..." : "") : `Law ${index + 1}`;
        mermaid += `  ${lawId}>"${lawLabel}"]
`;
        mermaid += `  ${interpId} --> ${lawId}
`;
      });
    }
  }
  if (thought.fieldTheoryContext) {
    const fieldId = sanitizeId("field_theory");
    mermaid += `  ${fieldId}[("Field Theory")]
`;
    mermaid += `  ${typeId} --> ${fieldId}
`;
    thought.fieldTheoryContext.fields.forEach((field, index) => {
      const fId = sanitizeId(`field_${index}`);
      mermaid += `  ${fId}["${field}"]
`;
      mermaid += `  ${fieldId} --> ${fId}
`;
    });
    const symGroupId = sanitizeId("symmetry_group");
    mermaid += `  ${symGroupId}{{"${thought.fieldTheoryContext.symmetryGroup}"}}
`;
    mermaid += `  ${fieldId} --> ${symGroupId}
`;
  }
  if (includeMetrics) {
    const uncertId = sanitizeId("uncertainty");
    const uncertLabel = `Uncertainty: ${(thought.uncertainty * 100).toFixed(1)}%`;
    mermaid += `  ${uncertId}{{${uncertLabel}}}
`;
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    const assumptionsId = sanitizeId("assumptions");
    mermaid += `  ${assumptionsId}>"Assumptions: ${thought.assumptions.length}"]
`;
  }
  if (colorScheme !== "monochrome") {
    const colors = colorScheme === "pastel" ? { type: "#e3f2fd", tensor: "#fff3e0", interp: "#e8f5e9" } : { type: "#87CEEB", tensor: "#FFD700", interp: "#90EE90" };
    mermaid += `
  style ${typeId} fill:${colors.type}
`;
    if (thought.tensorProperties) {
      mermaid += `  style ${sanitizeId("tensor")} fill:${colors.tensor}
`;
    }
    if (thought.physicalInterpretation) {
      mermaid += `  style ${sanitizeId("interpretation")} fill:${colors.interp}
`;
    }
  }
  return mermaid;
}
function physicsToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph PhysicsVisualization {\n";
  dot += "  rankdir=TB;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  const typeId = sanitizeId(`type_${thought.thoughtType || "physics"}`);
  const typeLabel = includeLabels ? (thought.thoughtType || "Physics").replace(/_/g, " ") : typeId;
  dot += `  ${typeId} [label="${typeLabel}", shape=doubleoctagon];
`;
  if (thought.tensorProperties) {
    const tensorId = sanitizeId("tensor");
    const rankLabel = `Rank (${thought.tensorProperties.rank[0]},${thought.tensorProperties.rank[1]})`;
    dot += `  ${tensorId} [label="${rankLabel}", shape=ellipse];
`;
    dot += `  ${typeId} -> ${tensorId};
`;
    const compId = sanitizeId("components");
    const compLabel = includeLabels ? thought.tensorProperties.components.slice(0, 25).replace(/"/g, '"') : "Components";
    dot += `  ${compId} [label="${compLabel}"];
`;
    dot += `  ${tensorId} -> ${compId};
`;
    const transId = sanitizeId("transformation");
    dot += `  ${transId} [label="${thought.tensorProperties.transformation}", shape=diamond];
`;
    dot += `  ${tensorId} -> ${transId};
`;
  }
  if (thought.physicalInterpretation) {
    const interpId = sanitizeId("interpretation");
    dot += `  ${interpId} [label="${thought.physicalInterpretation.quantity}", shape=parallelogram];
`;
    dot += `  ${typeId} -> ${interpId};
`;
    const unitsId = sanitizeId("units");
    dot += `  ${unitsId} [label="${thought.physicalInterpretation.units}", shape=ellipse];
`;
    dot += `  ${interpId} -> ${unitsId};
`;
    thought.physicalInterpretation.conservationLaws.forEach((law, index) => {
      const lawId = sanitizeId(`conservation_${index}`);
      const lawLabel = includeLabels ? law.slice(0, 20).replace(/"/g, '"') : `Law ${index + 1}`;
      dot += `  ${lawId} [label="${lawLabel}", shape=hexagon];
`;
      dot += `  ${interpId} -> ${lawId};
`;
    });
  }
  if (thought.fieldTheoryContext) {
    const fieldId = sanitizeId("field_theory");
    dot += `  ${fieldId} [label="Field Theory", shape=cylinder];
`;
    dot += `  ${typeId} -> ${fieldId};
`;
    thought.fieldTheoryContext.fields.forEach((field, index) => {
      const fId = sanitizeId(`field_${index}`);
      dot += `  ${fId} [label="${field}"];
`;
      dot += `  ${fieldId} -> ${fId};
`;
    });
    const symGroupId = sanitizeId("symmetry_group");
    dot += `  ${symGroupId} [label="${thought.fieldTheoryContext.symmetryGroup}", shape=diamond];
`;
    dot += `  ${fieldId} -> ${symGroupId};
`;
  }
  if (includeMetrics) {
    const uncertId = sanitizeId("uncertainty");
    dot += `  ${uncertId} [label="${(thought.uncertainty * 100).toFixed(1)}%", shape=diamond];
`;
  }
  dot += "}\n";
  return dot;
}
function physicsToASCII(thought) {
  let ascii = "Physics Analysis:\n";
  ascii += "=================\n\n";
  ascii += `Type: ${(thought.thoughtType || "physics").replace(/_/g, " ")}
`;
  ascii += `Uncertainty: ${(thought.uncertainty * 100).toFixed(1)}%

`;
  if (thought.tensorProperties) {
    ascii += "Tensor Properties:\n";
    ascii += `  Rank: (${thought.tensorProperties.rank[0]}, ${thought.tensorProperties.rank[1]})
`;
    ascii += `  Components: ${thought.tensorProperties.components}
`;
    ascii += `  LaTeX: ${thought.tensorProperties.latex}
`;
    ascii += `  Transformation: ${thought.tensorProperties.transformation}
`;
    if (thought.tensorProperties.indexStructure) {
      ascii += `  Index Structure: ${thought.tensorProperties.indexStructure}
`;
    }
    if (thought.tensorProperties.coordinateSystem) {
      ascii += `  Coordinate System: ${thought.tensorProperties.coordinateSystem}
`;
    }
    if (thought.tensorProperties.symmetries.length > 0) {
      ascii += "  Symmetries:\n";
      thought.tensorProperties.symmetries.forEach((sym, index) => {
        ascii += `    ${index + 1}. ${sym}
`;
      });
    }
    if (thought.tensorProperties.invariants.length > 0) {
      ascii += "  Invariants:\n";
      thought.tensorProperties.invariants.forEach((inv, index) => {
        ascii += `    ${index + 1}. ${inv}
`;
      });
    }
    ascii += "\n";
  }
  if (thought.physicalInterpretation) {
    ascii += "Physical Interpretation:\n";
    ascii += `  Quantity: ${thought.physicalInterpretation.quantity}
`;
    ascii += `  Units: ${thought.physicalInterpretation.units}
`;
    if (thought.physicalInterpretation.conservationLaws.length > 0) {
      ascii += "  Conservation Laws:\n";
      thought.physicalInterpretation.conservationLaws.forEach((law, index) => {
        ascii += `    ${index + 1}. ${law}
`;
      });
    }
    if (thought.physicalInterpretation.constraints && thought.physicalInterpretation.constraints.length > 0) {
      ascii += "  Constraints:\n";
      thought.physicalInterpretation.constraints.forEach((constraint, index) => {
        ascii += `    ${index + 1}. ${constraint}
`;
      });
    }
    if (thought.physicalInterpretation.observables && thought.physicalInterpretation.observables.length > 0) {
      ascii += "  Observables:\n";
      thought.physicalInterpretation.observables.forEach((obs, index) => {
        ascii += `    ${index + 1}. ${obs}
`;
      });
    }
    ascii += "\n";
  }
  if (thought.fieldTheoryContext) {
    ascii += "Field Theory Context:\n";
    ascii += `  Symmetry Group: ${thought.fieldTheoryContext.symmetryGroup}
`;
    if (thought.fieldTheoryContext.fields.length > 0) {
      ascii += "  Fields:\n";
      thought.fieldTheoryContext.fields.forEach((field, index) => {
        ascii += `    ${index + 1}. ${field}
`;
      });
    }
    if (thought.fieldTheoryContext.interactions.length > 0) {
      ascii += "  Interactions:\n";
      thought.fieldTheoryContext.interactions.forEach((interaction, index) => {
        ascii += `    ${index + 1}. ${interaction}
`;
      });
    }
    if (thought.fieldTheoryContext.gaugeSymmetries && thought.fieldTheoryContext.gaugeSymmetries.length > 0) {
      ascii += "  Gauge Symmetries:\n";
      thought.fieldTheoryContext.gaugeSymmetries.forEach((gauge, index) => {
        ascii += `    ${index + 1}. ${gauge}
`;
      });
    }
    ascii += "\n";
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    ascii += "Assumptions:\n";
    thought.assumptions.forEach((assumption, index) => {
      ascii += `  ${index + 1}. ${assumption}
`;
    });
    ascii += "\n";
  }
  if (thought.dependencies && thought.dependencies.length > 0) {
    ascii += "Dependencies:\n";
    thought.dependencies.forEach((dep, index) => {
      ascii += `  ${index + 1}. ${dep}
`;
    });
  }
  return ascii;
}
function physicsToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width,
    svgHeight = DEFAULT_SVG_OPTIONS.height
  } = options;
  const positions = /* @__PURE__ */ new Map();
  const nodeWidth = 150;
  const nodeHeight = 40;
  positions.set("type", {
    id: "type",
    label: includeLabels ? (thought.thoughtType || "Physics").replace(/_/g, " ") : "Physics",
    x: svgWidth / 2,
    y: 80,
    width: nodeWidth,
    height: nodeHeight,
    type: "type"
  });
  if (thought.tensorProperties) {
    positions.set("tensor", {
      id: "tensor",
      label: `Tensor (${thought.tensorProperties.rank[0]},${thought.tensorProperties.rank[1]})`,
      x: 150,
      y: 220,
      width: nodeWidth,
      height: nodeHeight,
      type: "tensor"
    });
  }
  if (thought.physicalInterpretation) {
    positions.set("interpretation", {
      id: "interpretation",
      label: thought.physicalInterpretation.quantity,
      x: svgWidth - 150,
      y: 220,
      width: nodeWidth,
      height: nodeHeight,
      type: "interpretation"
    });
  }
  if (thought.fieldTheoryContext) {
    positions.set("field", {
      id: "field",
      label: "Field Theory",
      x: svgWidth / 2,
      y: 360,
      width: nodeWidth,
      height: nodeHeight,
      type: "field"
    });
  }
  let svg = generateSVGHeader(svgWidth, svgHeight, "Physics Analysis");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  const typePos = positions.get("type");
  const tensorPos = positions.get("tensor");
  const interpPos = positions.get("interpretation");
  const fieldPos = positions.get("field");
  if (typePos && tensorPos) {
    svg += renderEdge(typePos, tensorPos);
  }
  if (typePos && interpPos) {
    svg += renderEdge(typePos, interpPos);
  }
  if (typePos && fieldPos) {
    svg += renderEdge(typePos, fieldPos);
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  const typeColors = getNodeColor("primary", colorScheme);
  const tensorColors = getNodeColor("secondary", colorScheme);
  const interpColors = getNodeColor("tertiary", colorScheme);
  const fieldColors = getNodeColor("neutral", colorScheme);
  for (const [, pos] of positions) {
    if (pos.type === "type") {
      svg += renderStadiumNode(pos, typeColors);
    } else if (pos.type === "tensor") {
      svg += renderEllipseNode(pos, tensorColors);
    } else if (pos.type === "interpretation") {
      svg += renderRectNode(pos, interpColors);
    } else if (pos.type === "field") {
      svg += renderRectNode(pos, fieldColors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Uncertainty", value: `${(thought.uncertainty * 100).toFixed(1)}%` },
      { label: "Assumptions", value: thought.assumptions?.length || 0 }
    ];
    svg += renderMetricsPanel(svgWidth - 180, svgHeight - 110, metrics);
  }
  const legendItems = [
    { label: "Type", color: typeColors, shape: "stadium" },
    { label: "Tensor", color: tensorColors, shape: "ellipse" },
    { label: "Interpretation", color: interpColors },
    { label: "Field Theory", color: fieldColors }
  ];
  svg += renderLegend(20, svgHeight - 130, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function physicsToGraphML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  let edgeCount = 0;
  const typeId = "type";
  nodes.push({
    id: typeId,
    label: includeLabels ? (thought.thoughtType || "Physics").replace(/_/g, " ") : "Physics",
    type: "primary"
  });
  if (thought.tensorProperties) {
    const tensorId = "tensor";
    nodes.push({
      id: tensorId,
      label: `Tensor Rank (${thought.tensorProperties.rank[0]},${thought.tensorProperties.rank[1]})`,
      type: "tensor",
      metadata: {
        description: `Components: ${thought.tensorProperties.components}`
      }
    });
    edges.push({
      id: `e${edgeCount++}`,
      source: typeId,
      target: tensorId,
      label: "has tensor"
    });
    const componentsId = "components";
    nodes.push({
      id: componentsId,
      label: "Components",
      type: "property",
      metadata: {
        description: thought.tensorProperties.components
      }
    });
    edges.push({
      id: `e${edgeCount++}`,
      source: tensorId,
      target: componentsId
    });
    if (thought.tensorProperties.symmetries.length > 0) {
      thought.tensorProperties.symmetries.forEach((sym, index) => {
        const symId = `symmetry_${index}`;
        nodes.push({
          id: symId,
          label: includeLabels ? sym : `Symmetry ${index + 1}`,
          type: "symmetry"
        });
        edges.push({
          id: `e${edgeCount++}`,
          source: tensorId,
          target: symId,
          label: "symmetry"
        });
      });
    }
    if (thought.tensorProperties.invariants.length > 0) {
      thought.tensorProperties.invariants.forEach((inv, index) => {
        const invId = `invariant_${index}`;
        nodes.push({
          id: invId,
          label: includeLabels ? inv : `Invariant ${index + 1}`,
          type: "invariant"
        });
        edges.push({
          id: `e${edgeCount++}`,
          source: tensorId,
          target: invId,
          label: "invariant"
        });
      });
    }
  }
  if (thought.physicalInterpretation) {
    const interpId = "interpretation";
    nodes.push({
      id: interpId,
      label: thought.physicalInterpretation.quantity,
      type: "interpretation",
      metadata: {
        description: `Units: ${thought.physicalInterpretation.units}`
      }
    });
    edges.push({
      id: `e${edgeCount++}`,
      source: typeId,
      target: interpId,
      label: "physical meaning"
    });
    const unitsId = "units";
    nodes.push({
      id: unitsId,
      label: thought.physicalInterpretation.units,
      type: "units"
    });
    edges.push({
      id: `e${edgeCount++}`,
      source: interpId,
      target: unitsId,
      label: "measured in"
    });
    if (thought.physicalInterpretation.conservationLaws.length > 0) {
      thought.physicalInterpretation.conservationLaws.forEach((law, index) => {
        const lawId = `conservation_${index}`;
        nodes.push({
          id: lawId,
          label: includeLabels ? law : `Law ${index + 1}`,
          type: "conservation_law"
        });
        edges.push({
          id: `e${edgeCount++}`,
          source: interpId,
          target: lawId,
          label: "conserves"
        });
      });
    }
  }
  if (thought.fieldTheoryContext) {
    const fieldId = "field_theory";
    nodes.push({
      id: fieldId,
      label: "Field Theory",
      type: "field_theory",
      metadata: {
        description: `Symmetry Group: ${thought.fieldTheoryContext.symmetryGroup}`
      }
    });
    edges.push({
      id: `e${edgeCount++}`,
      source: typeId,
      target: fieldId,
      label: "context"
    });
    thought.fieldTheoryContext.fields.forEach((field, index) => {
      const fId = `field_${index}`;
      nodes.push({
        id: fId,
        label: field,
        type: "field"
      });
      edges.push({
        id: `e${edgeCount++}`,
        source: fieldId,
        target: fId,
        label: "includes field"
      });
    });
    const symGroupId = "symmetry_group";
    nodes.push({
      id: symGroupId,
      label: thought.fieldTheoryContext.symmetryGroup,
      type: "symmetry_group"
    });
    edges.push({
      id: `e${edgeCount++}`,
      source: fieldId,
      target: symGroupId,
      label: "has symmetry"
    });
  }
  if (includeMetrics) {
    const metricsId = "metrics";
    nodes.push({
      id: metricsId,
      label: `Uncertainty: ${(thought.uncertainty * 100).toFixed(1)}%`,
      type: "metric",
      metadata: {
        description: `Assumptions: ${thought.assumptions?.length || 0}`
      }
    });
  }
  const graphmlOptions = {
    graphName: "Physics Visualization"
  };
  return generateGraphML(nodes, edges, graphmlOptions);
}
function physicsToTikZ(thought, options) {
  const { includeLabels = true, includeMetrics = true, colorScheme = "default" } = options;
  const nodes = [];
  const edges = [];
  const typeId = "type";
  nodes.push({
    id: typeId,
    x: 0,
    y: 0,
    label: includeLabels ? (thought.thoughtType || "Physics").replace(/_/g, " ") : "Physics",
    shape: "stadium",
    type: "primary"
  });
  const leftColumn = -4;
  const rightColumn = 4;
  const currentRow = -2;
  if (thought.tensorProperties) {
    const tensorId = "tensor";
    nodes.push({
      id: tensorId,
      x: leftColumn,
      y: currentRow,
      label: `Tensor (${thought.tensorProperties.rank[0]},${thought.tensorProperties.rank[1]})`,
      shape: "ellipse",
      type: "tensor"
    });
    edges.push({
      source: typeId,
      target: tensorId
    });
    const componentsId = "components";
    nodes.push({
      id: componentsId,
      x: leftColumn,
      y: currentRow - 1.5,
      label: "Components",
      shape: "rectangle",
      type: "property"
    });
    edges.push({
      source: tensorId,
      target: componentsId,
      style: "dashed"
    });
    if (thought.tensorProperties.symmetries.length > 0) {
      const symId = "symmetries";
      nodes.push({
        id: symId,
        x: leftColumn - 2,
        y: currentRow - 3,
        label: `Symmetries (${thought.tensorProperties.symmetries.length})`,
        shape: "diamond",
        type: "symmetry"
      });
      edges.push({
        source: tensorId,
        target: symId
      });
    }
    if (thought.tensorProperties.invariants.length > 0) {
      const invId = "invariants";
      nodes.push({
        id: invId,
        x: leftColumn + 2,
        y: currentRow - 3,
        label: `Invariants (${thought.tensorProperties.invariants.length})`,
        shape: "diamond",
        type: "invariant"
      });
      edges.push({
        source: tensorId,
        target: invId
      });
    }
  }
  if (thought.physicalInterpretation) {
    const interpId = "interpretation";
    nodes.push({
      id: interpId,
      x: rightColumn,
      y: currentRow,
      label: thought.physicalInterpretation.quantity,
      shape: "rounded",
      type: "interpretation"
    });
    edges.push({
      source: typeId,
      target: interpId
    });
    const unitsId = "units";
    nodes.push({
      id: unitsId,
      x: rightColumn,
      y: currentRow - 1.5,
      label: thought.physicalInterpretation.units,
      shape: "ellipse",
      type: "units"
    });
    edges.push({
      source: interpId,
      target: unitsId,
      style: "dashed"
    });
    if (thought.physicalInterpretation.conservationLaws.length > 0) {
      thought.physicalInterpretation.conservationLaws.forEach((law, index) => {
        const lawId = `conservation_${index}`;
        const offset = (index - (thought.physicalInterpretation.conservationLaws.length - 1) / 2) * 2;
        nodes.push({
          id: lawId,
          x: rightColumn + offset,
          y: currentRow - 3,
          label: includeLabels ? law.substring(0, 20) : `Law ${index + 1}`,
          shape: "rectangle",
          type: "conservation_law"
        });
        edges.push({
          source: interpId,
          target: lawId
        });
      });
    }
  }
  if (thought.fieldTheoryContext) {
    const fieldId = "field_theory";
    nodes.push({
      id: fieldId,
      x: 0,
      y: currentRow - 5,
      label: "Field Theory",
      shape: "stadium",
      type: "field_theory"
    });
    edges.push({
      source: typeId,
      target: fieldId
    });
    thought.fieldTheoryContext.fields.forEach((field, index) => {
      const fId = `field_${index}`;
      const offset = (index - (thought.fieldTheoryContext.fields.length - 1) / 2) * 2.5;
      nodes.push({
        id: fId,
        x: offset,
        y: currentRow - 6.5,
        label: field,
        shape: "rectangle",
        type: "field"
      });
      edges.push({
        source: fieldId,
        target: fId
      });
    });
    const symGroupId = "symmetry_group";
    nodes.push({
      id: symGroupId,
      x: 0,
      y: currentRow - 8,
      label: thought.fieldTheoryContext.symmetryGroup,
      shape: "diamond",
      type: "symmetry_group"
    });
    edges.push({
      source: fieldId,
      target: symGroupId,
      style: "dashed"
    });
  }
  const tikzOptions = {
    title: "Physics Visualization",
    colorScheme
  };
  let tikz = generateTikZ(nodes, edges, tikzOptions);
  if (includeMetrics) {
    const metrics = [
      { label: "Uncertainty", value: `${(thought.uncertainty * 100).toFixed(1)}%` },
      { label: "Assumptions", value: thought.assumptions?.length || 0 }
    ];
    tikz = tikz.replace("\\end{tikzpicture}", renderTikZMetrics(8, -8, metrics) + "\n\\end{tikzpicture}");
  }
  return tikz;
}
function physicsToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Physics Analysis",
    htmlTheme = "light"
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  html += '<div class="metrics-grid">';
  html += renderMetricCard("Uncertainty", `${(thought.uncertainty * 100).toFixed(1)}%`, "warning");
  if (thought.assumptions) {
    html += renderMetricCard("Assumptions", thought.assumptions.length, "info");
  }
  if (thought.tensorProperties) {
    html += renderMetricCard("Tensor Rank", `(${thought.tensorProperties.rank[0]},${thought.tensorProperties.rank[1]})`, "primary");
  }
  if (thought.physicalInterpretation?.conservationLaws) {
    html += renderMetricCard("Conservation Laws", thought.physicalInterpretation.conservationLaws.length, "success");
  }
  html += "</div>\n";
  const badges = [];
  if (thought.thoughtType) {
    badges.push(renderBadge(thought.thoughtType.replace(/_/g, " "), "primary"));
  }
  if (badges.length > 0) {
    html += `<div class="flex gap-1" style="margin: 1rem 0">${badges.join(" ")}</div>
`;
  }
  if (thought.tensorProperties) {
    const tensorRows = [
      ["Rank", `(${thought.tensorProperties.rank[0]}, ${thought.tensorProperties.rank[1]})`],
      ["Components", thought.tensorProperties.components],
      ["LaTeX", thought.tensorProperties.latex],
      ["Transformation", thought.tensorProperties.transformation]
    ];
    if (thought.tensorProperties.indexStructure) {
      tensorRows.push(["Index Structure", thought.tensorProperties.indexStructure]);
    }
    if (thought.tensorProperties.coordinateSystem) {
      tensorRows.push(["Coordinate System", thought.tensorProperties.coordinateSystem]);
    }
    let tensorContent = renderTable(["Property", "Value"], tensorRows);
    if (thought.tensorProperties.symmetries.length > 0) {
      tensorContent += '<p style="margin-top: 1rem"><strong>Symmetries:</strong></p>';
      tensorContent += '<ul class="list-styled">';
      thought.tensorProperties.symmetries.forEach((sym) => {
        tensorContent += `<li>${escapeHTML(sym)}</li>`;
      });
      tensorContent += "</ul>";
    }
    if (thought.tensorProperties.invariants.length > 0) {
      tensorContent += '<p style="margin-top: 1rem"><strong>Invariants:</strong></p>';
      tensorContent += '<ul class="list-styled">';
      thought.tensorProperties.invariants.forEach((inv) => {
        tensorContent += `<li>${escapeHTML(inv)}</li>`;
      });
      tensorContent += "</ul>";
    }
    html += renderSection("Tensor Properties", tensorContent, "\u{1F522}");
  }
  if (thought.physicalInterpretation) {
    const interpRows = [
      ["Quantity", thought.physicalInterpretation.quantity],
      ["Units", thought.physicalInterpretation.units]
    ];
    let interpContent = renderTable(["Property", "Value"], interpRows);
    if (thought.physicalInterpretation.conservationLaws.length > 0) {
      interpContent += '<p style="margin-top: 1rem"><strong>Conservation Laws:</strong></p>';
      interpContent += '<ul class="list-styled">';
      thought.physicalInterpretation.conservationLaws.forEach((law) => {
        interpContent += `<li>${escapeHTML(law)}</li>`;
      });
      interpContent += "</ul>";
    }
    if (thought.physicalInterpretation.constraints && thought.physicalInterpretation.constraints.length > 0) {
      interpContent += '<p style="margin-top: 1rem"><strong>Constraints:</strong></p>';
      interpContent += '<ul class="list-styled">';
      thought.physicalInterpretation.constraints.forEach((constraint) => {
        interpContent += `<li>${escapeHTML(constraint)}</li>`;
      });
      interpContent += "</ul>";
    }
    if (thought.physicalInterpretation.observables && thought.physicalInterpretation.observables.length > 0) {
      interpContent += '<p style="margin-top: 1rem"><strong>Observables:</strong></p>';
      interpContent += '<ul class="list-styled">';
      thought.physicalInterpretation.observables.forEach((obs) => {
        interpContent += `<li>${escapeHTML(obs)}</li>`;
      });
      interpContent += "</ul>";
    }
    html += renderSection("Physical Interpretation", interpContent, "\u269B\uFE0F");
  }
  if (thought.fieldTheoryContext) {
    let fieldContent = `<p><strong>Symmetry Group:</strong> ${renderBadge(thought.fieldTheoryContext.symmetryGroup, "info")}</p>`;
    if (thought.fieldTheoryContext.fields.length > 0) {
      fieldContent += '<p style="margin-top: 1rem"><strong>Fields:</strong></p>';
      fieldContent += '<ul class="list-styled">';
      thought.fieldTheoryContext.fields.forEach((field) => {
        fieldContent += `<li>${escapeHTML(field)}</li>`;
      });
      fieldContent += "</ul>";
    }
    if (thought.fieldTheoryContext.interactions.length > 0) {
      fieldContent += '<p style="margin-top: 1rem"><strong>Interactions:</strong></p>';
      fieldContent += '<ul class="list-styled">';
      thought.fieldTheoryContext.interactions.forEach((interaction) => {
        fieldContent += `<li>${escapeHTML(interaction)}</li>`;
      });
      fieldContent += "</ul>";
    }
    if (thought.fieldTheoryContext.gaugeSymmetries && thought.fieldTheoryContext.gaugeSymmetries.length > 0) {
      fieldContent += '<p style="margin-top: 1rem"><strong>Gauge Symmetries:</strong></p>';
      fieldContent += '<ul class="list-styled">';
      thought.fieldTheoryContext.gaugeSymmetries.forEach((gauge) => {
        fieldContent += `<li>${escapeHTML(gauge)}</li>`;
      });
      fieldContent += "</ul>";
    }
    html += renderSection("Field Theory Context", fieldContent, "\u{1F30C}");
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    const assumptionsList = thought.assumptions.map((a) => escapeHTML(a));
    html += renderSection("Assumptions", `
      <ul class="list-styled">
        ${assumptionsList.map((a) => `<li>${a}</li>`).join("")}
      </ul>
    `, "\u26A0\uFE0F");
  }
  if (thought.dependencies && thought.dependencies.length > 0) {
    const depsList = thought.dependencies.map((d) => escapeHTML(d));
    html += renderSection("Dependencies", `
      <ul class="list-styled">
        ${depsList.map((d) => `<li>${d}</li>`).join("")}
      </ul>
    `, "\u{1F517}");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function physicsToModelica(thought, options) {
  const { includeMetrics = true } = options;
  const packageName = sanitizeModelicaId(thought.thoughtType || "PhysicsModel");
  let modelica = `package ${packageName}
`;
  modelica += `  "${escapeModelicaString("Physics model for " + (thought.thoughtType || "physical system"))}"

`;
  modelica += `  model PhysicalSystem
`;
  modelica += `    "${escapeModelicaString("Physical system representation")}"

`;
  if (thought.tensorProperties) {
    modelica += `    // Tensor Properties
`;
    modelica += `    parameter Integer tensorRank[2] = {${thought.tensorProperties.rank[0]}, ${thought.tensorProperties.rank[1]}};
`;
    modelica += `    parameter String tensorComponents = "${escapeModelicaString(thought.tensorProperties.components)}";
`;
    modelica += `    parameter String tensorTransformation = "${escapeModelicaString(thought.tensorProperties.transformation)}";
`;
    if (thought.tensorProperties.indexStructure) {
      modelica += `    parameter String indexStructure = "${escapeModelicaString(thought.tensorProperties.indexStructure)}";
`;
    }
    if (thought.tensorProperties.coordinateSystem) {
      modelica += `    parameter String coordinateSystem = "${escapeModelicaString(thought.tensorProperties.coordinateSystem)}";
`;
    }
    modelica += "\n";
  }
  if (thought.physicalInterpretation) {
    modelica += `    // Physical Interpretation
`;
    const quantity = sanitizeModelicaId(thought.physicalInterpretation.quantity);
    const units = thought.physicalInterpretation.units;
    modelica += `    Real ${quantity}(unit="${escapeModelicaString(units)}");
`;
    modelica += `    parameter String physicalQuantity = "${escapeModelicaString(thought.physicalInterpretation.quantity)}";
`;
    if (thought.physicalInterpretation.conservationLaws.length > 0) {
      modelica += `
    // Conservation Laws
`;
      thought.physicalInterpretation.conservationLaws.forEach((law, index) => {
        const lawVar = sanitizeModelicaId(`conservationLaw_${index + 1}`);
        modelica += `    parameter String ${lawVar} = "${escapeModelicaString(law)}";
`;
      });
    }
    if (thought.physicalInterpretation.constraints && thought.physicalInterpretation.constraints.length > 0) {
      modelica += `
    // Constraints
`;
      thought.physicalInterpretation.constraints.forEach((constraint, index) => {
        const constraintVar = sanitizeModelicaId(`constraint_${index + 1}`);
        modelica += `    parameter String ${constraintVar} = "${escapeModelicaString(constraint)}";
`;
      });
    }
    if (thought.physicalInterpretation.observables && thought.physicalInterpretation.observables.length > 0) {
      modelica += `
    // Observables
`;
      thought.physicalInterpretation.observables.forEach((obs, index) => {
        const obsVar = sanitizeModelicaId(`observable_${index + 1}`);
        modelica += `    Real ${obsVar} "${escapeModelicaString(obs)}";
`;
      });
    }
    modelica += "\n";
  }
  if (thought.fieldTheoryContext) {
    modelica += `    // Field Theory Context
`;
    modelica += `    parameter String symmetryGroup = "${escapeModelicaString(thought.fieldTheoryContext.symmetryGroup)}";
`;
    if (thought.fieldTheoryContext.fields.length > 0) {
      modelica += `
    // Fields
`;
      thought.fieldTheoryContext.fields.forEach((field, index) => {
        const fieldVar = sanitizeModelicaId(`field_${index + 1}`);
        modelica += `    Real ${fieldVar} "${escapeModelicaString(field)}";
`;
      });
    }
    if (thought.fieldTheoryContext.interactions.length > 0) {
      modelica += `
    // Interactions
`;
      thought.fieldTheoryContext.interactions.forEach((interaction, index) => {
        const intVar = sanitizeModelicaId(`interaction_${index + 1}`);
        modelica += `    parameter String ${intVar} = "${escapeModelicaString(interaction)}";
`;
      });
    }
    if (thought.fieldTheoryContext.gaugeSymmetries && thought.fieldTheoryContext.gaugeSymmetries.length > 0) {
      modelica += `
    // Gauge Symmetries
`;
      thought.fieldTheoryContext.gaugeSymmetries.forEach((gauge, index) => {
        const gaugeVar = sanitizeModelicaId(`gaugeSymmetry_${index + 1}`);
        modelica += `    parameter String ${gaugeVar} = "${escapeModelicaString(gauge)}";
`;
      });
    }
    modelica += "\n";
  }
  if (includeMetrics) {
    modelica += `    // Metrics
`;
    modelica += `    parameter Real uncertainty = ${thought.uncertainty};
`;
    if (thought.assumptions && thought.assumptions.length > 0) {
      modelica += `    parameter Integer assumptionCount = ${thought.assumptions.length};
`;
    }
    modelica += "\n";
  }
  modelica += `  equation
`;
  if (thought.physicalInterpretation) {
    const quantity = sanitizeModelicaId(thought.physicalInterpretation.quantity);
    modelica += `    // Physical evolution (placeholder)
`;
    modelica += `    der(${quantity}) = 0; // Steady state or define custom dynamics
`;
  }
  modelica += `  end PhysicalSystem;

`;
  modelica += `  annotation(
`;
  modelica += `    Documentation(info="<html>
`;
  modelica += `      <p>Physics model generated from reasoning thought</p>
`;
  modelica += `      <p>Uncertainty: ${(thought.uncertainty * 100).toFixed(1)}%</p>
`;
  if (thought.assumptions && thought.assumptions.length > 0) {
    modelica += `      <p>Assumptions: ${thought.assumptions.length}</p>
`;
  }
  modelica += `    </html>")
`;
  modelica += `  );
`;
  modelica += `end ${packageName};
`;
  return modelica;
}
function physicsToUML(thought, options) {
  const { includeLabels = true } = options;
  const nodes = [];
  const edges = [];
  const mainId = "PhysicsSystem";
  nodes.push({
    id: mainId,
    label: includeLabels ? (thought.thoughtType || "Physics").replace(/_/g, " ") : "PhysicsSystem",
    shape: "class",
    attributes: [
      `uncertainty: Real = ${thought.uncertainty.toFixed(3)}`,
      ...thought.assumptions ? [`assumptions: Integer = ${thought.assumptions.length}`] : []
    ],
    methods: []
  });
  if (thought.tensorProperties) {
    const tensorId = "TensorProperties";
    nodes.push({
      id: tensorId,
      label: "TensorProperties",
      shape: "class",
      attributes: [
        `rank: Integer[2] = [${thought.tensorProperties.rank[0]}, ${thought.tensorProperties.rank[1]}]`,
        `components: String = "${thought.tensorProperties.components.substring(0, 30)}..."`,
        `transformation: String = "${thought.tensorProperties.transformation}"`,
        ...thought.tensorProperties.symmetries.length > 0 ? [`symmetries: Integer = ${thought.tensorProperties.symmetries.length}`] : [],
        ...thought.tensorProperties.invariants.length > 0 ? [`invariants: Integer = ${thought.tensorProperties.invariants.length}`] : []
      ],
      methods: []
    });
    edges.push({
      source: mainId,
      target: tensorId,
      type: "composition",
      label: "has"
    });
  }
  if (thought.physicalInterpretation) {
    const interpId = "PhysicalInterpretation";
    nodes.push({
      id: interpId,
      label: "PhysicalInterpretation",
      shape: "class",
      attributes: [
        `quantity: String = "${thought.physicalInterpretation.quantity}"`,
        `units: String = "${thought.physicalInterpretation.units}"`,
        `conservationLaws: Integer = ${thought.physicalInterpretation.conservationLaws.length}`,
        ...thought.physicalInterpretation.constraints ? [`constraints: Integer = ${thought.physicalInterpretation.constraints.length}`] : [],
        ...thought.physicalInterpretation.observables ? [`observables: Integer = ${thought.physicalInterpretation.observables.length}`] : []
      ],
      methods: [
        "measure(): Real",
        "validate(): Boolean"
      ]
    });
    edges.push({
      source: mainId,
      target: interpId,
      type: "composition",
      label: "interprets as"
    });
    if (thought.physicalInterpretation.conservationLaws.length > 0) {
      const lawsId = "ConservationLaws";
      nodes.push({
        id: lawsId,
        label: "ConservationLaws",
        shape: "class",
        attributes: thought.physicalInterpretation.conservationLaws.map(
          (law, i) => `law${i + 1}: String = "${law.substring(0, 30)}..."`
        ),
        methods: ["verify(): Boolean"]
      });
      edges.push({
        source: interpId,
        target: lawsId,
        type: "association",
        label: "enforces"
      });
    }
  }
  if (thought.fieldTheoryContext) {
    const fieldId = "FieldTheory";
    nodes.push({
      id: fieldId,
      label: "FieldTheory",
      shape: "class",
      attributes: [
        `symmetryGroup: String = "${thought.fieldTheoryContext.symmetryGroup}"`,
        `fields: Integer = ${thought.fieldTheoryContext.fields.length}`,
        `interactions: Integer = ${thought.fieldTheoryContext.interactions.length}`,
        ...thought.fieldTheoryContext.gaugeSymmetries ? [`gaugeSymmetries: Integer = ${thought.fieldTheoryContext.gaugeSymmetries.length}`] : []
      ],
      methods: [
        "computeField(x: Real): Real",
        "applySymmetry(g: Group): Field"
      ]
    });
    edges.push({
      source: mainId,
      target: fieldId,
      type: "composition",
      label: "described by"
    });
    if (thought.fieldTheoryContext.fields.length > 0 && thought.fieldTheoryContext.fields.length <= 3) {
      thought.fieldTheoryContext.fields.forEach((field, index) => {
        const fId = `Field${index + 1}`;
        nodes.push({
          id: fId,
          label: field,
          shape: "class",
          attributes: ["value: Real", "gradient: Real"],
          methods: ["evaluate(x: Real): Real"]
        });
        edges.push({
          source: fieldId,
          target: fId,
          type: "aggregation",
          label: "contains"
        });
      });
    }
  }
  return generateUmlDiagram(nodes, edges, {
    title: "Physics System UML"});
}
function physicsToJSON(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const graph = createJsonGraph("physics_system", "Physics System Model");
  const typeId = "type";
  addNode(graph, {
    id: typeId,
    label: includeLabels ? (thought.thoughtType || "Physics").replace(/_/g, " ") : "Physics",
    type: "thought_type",
    metadata: {
      thoughtType: thought.thoughtType || "physics"
    }
  });
  if (thought.tensorProperties) {
    const tensorId = "tensor";
    addNode(graph, {
      id: tensorId,
      label: `Tensor (${thought.tensorProperties.rank[0]},${thought.tensorProperties.rank[1]})`,
      type: "tensor",
      metadata: {
        rank: thought.tensorProperties.rank,
        components: thought.tensorProperties.components,
        transformation: thought.tensorProperties.transformation,
        indexStructure: thought.tensorProperties.indexStructure,
        coordinateSystem: thought.tensorProperties.coordinateSystem
      }
    });
    addEdge(graph, {
      id: "edge_type_tensor",
      source: typeId,
      target: tensorId,
      label: "has_tensor",
      directed: true
    });
    if (thought.tensorProperties.symmetries.length > 0) {
      thought.tensorProperties.symmetries.forEach((sym, index) => {
        const symId = `symmetry_${index}`;
        addNode(graph, {
          id: symId,
          label: sym,
          type: "symmetry",
          metadata: { description: sym }
        });
        addEdge(graph, {
          id: `edge_tensor_sym_${index}`,
          source: tensorId,
          target: symId,
          label: "has_symmetry",
          directed: true
        });
      });
    }
    if (thought.tensorProperties.invariants.length > 0) {
      thought.tensorProperties.invariants.forEach((inv, index) => {
        const invId = `invariant_${index}`;
        addNode(graph, {
          id: invId,
          label: inv,
          type: "invariant",
          metadata: { description: inv }
        });
        addEdge(graph, {
          id: `edge_tensor_inv_${index}`,
          source: tensorId,
          target: invId,
          label: "has_invariant",
          directed: true
        });
      });
    }
  }
  if (thought.physicalInterpretation) {
    const interpId = "interpretation";
    addNode(graph, {
      id: interpId,
      label: thought.physicalInterpretation.quantity,
      type: "physical_interpretation",
      metadata: {
        quantity: thought.physicalInterpretation.quantity,
        units: thought.physicalInterpretation.units,
        conservationLaws: thought.physicalInterpretation.conservationLaws,
        constraints: thought.physicalInterpretation.constraints,
        observables: thought.physicalInterpretation.observables
      }
    });
    addEdge(graph, {
      id: "edge_type_interp",
      source: typeId,
      target: interpId,
      label: "interprets_as",
      directed: true
    });
    const unitsId = "units";
    addNode(graph, {
      id: unitsId,
      label: thought.physicalInterpretation.units,
      type: "units",
      metadata: { units: thought.physicalInterpretation.units }
    });
    addEdge(graph, {
      id: "edge_interp_units",
      source: interpId,
      target: unitsId,
      label: "measured_in",
      directed: true
    });
    if (thought.physicalInterpretation.conservationLaws.length > 0) {
      thought.physicalInterpretation.conservationLaws.forEach((law, index) => {
        const lawId = `conservation_${index}`;
        addNode(graph, {
          id: lawId,
          label: includeLabels ? law : `Law ${index + 1}`,
          type: "conservation_law",
          metadata: { law }
        });
        addEdge(graph, {
          id: `edge_interp_law_${index}`,
          source: interpId,
          target: lawId,
          label: "conserves",
          directed: true
        });
      });
    }
    if (thought.physicalInterpretation.observables && thought.physicalInterpretation.observables.length > 0) {
      thought.physicalInterpretation.observables.forEach((obs, index) => {
        const obsId = `observable_${index}`;
        addNode(graph, {
          id: obsId,
          label: obs,
          type: "observable",
          metadata: { observable: obs }
        });
        addEdge(graph, {
          id: `edge_interp_obs_${index}`,
          source: interpId,
          target: obsId,
          label: "has_observable",
          directed: true
        });
      });
    }
  }
  if (thought.fieldTheoryContext) {
    const fieldId = "field_theory";
    addNode(graph, {
      id: fieldId,
      label: "Field Theory",
      type: "field_theory",
      metadata: {
        symmetryGroup: thought.fieldTheoryContext.symmetryGroup,
        fields: thought.fieldTheoryContext.fields,
        interactions: thought.fieldTheoryContext.interactions,
        gaugeSymmetries: thought.fieldTheoryContext.gaugeSymmetries
      }
    });
    addEdge(graph, {
      id: "edge_type_field",
      source: typeId,
      target: fieldId,
      label: "has_context",
      directed: true
    });
    thought.fieldTheoryContext.fields.forEach((field, index) => {
      const fId = `field_${index}`;
      addNode(graph, {
        id: fId,
        label: field,
        type: "field",
        metadata: { field }
      });
      addEdge(graph, {
        id: `edge_field_f_${index}`,
        source: fieldId,
        target: fId,
        label: "includes_field",
        directed: true
      });
    });
    const symGroupId = "symmetry_group";
    addNode(graph, {
      id: symGroupId,
      label: thought.fieldTheoryContext.symmetryGroup,
      type: "symmetry_group",
      metadata: { group: thought.fieldTheoryContext.symmetryGroup }
    });
    addEdge(graph, {
      id: "edge_field_symgroup",
      source: fieldId,
      target: symGroupId,
      label: "has_symmetry_group",
      directed: true
    });
  }
  if (includeMetrics) {
    addMetric(graph, "uncertainty", thought.uncertainty);
    if (thought.assumptions) {
      addMetric(graph, "assumption_count", thought.assumptions.length);
    }
    if (thought.dependencies) {
      addMetric(graph, "dependency_count", thought.dependencies.length);
    }
  }
  return serializeGraph(graph);
}
function physicsToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  const typeContent = `**Type:** ${(thought.thoughtType || "physics").replace(/_/g, " ")}`;
  parts.push(section("Overview", typeContent));
  if (thought.tensorProperties) {
    const tensorContent = keyValueSection({
      "Rank": `(${thought.tensorProperties.rank[0]}, ${thought.tensorProperties.rank[1]})`,
      "Components": thought.tensorProperties.components,
      "LaTeX": thought.tensorProperties.latex,
      "Transformation": thought.tensorProperties.transformation,
      ...thought.tensorProperties.indexStructure ? { "Index Structure": thought.tensorProperties.indexStructure } : {},
      ...thought.tensorProperties.coordinateSystem ? { "Coordinate System": thought.tensorProperties.coordinateSystem } : {}
    });
    let tensorFull = tensorContent;
    if (thought.tensorProperties.symmetries.length > 0) {
      tensorFull += "\n\n**Symmetries:**\n\n" + list(thought.tensorProperties.symmetries);
    }
    if (thought.tensorProperties.invariants.length > 0) {
      tensorFull += "\n\n**Invariants:**\n\n" + list(thought.tensorProperties.invariants);
    }
    parts.push(section("Tensor Properties", tensorFull));
  }
  if (thought.physicalInterpretation) {
    const interpContent = keyValueSection({
      "Quantity": thought.physicalInterpretation.quantity,
      "Units": thought.physicalInterpretation.units
    });
    let interpFull = interpContent;
    if (thought.physicalInterpretation.conservationLaws.length > 0) {
      interpFull += "\n\n**Conservation Laws:**\n\n" + list(thought.physicalInterpretation.conservationLaws);
    }
    if (thought.physicalInterpretation.constraints && thought.physicalInterpretation.constraints.length > 0) {
      interpFull += "\n\n**Constraints:**\n\n" + list(thought.physicalInterpretation.constraints);
    }
    if (thought.physicalInterpretation.observables && thought.physicalInterpretation.observables.length > 0) {
      interpFull += "\n\n**Observables:**\n\n" + list(thought.physicalInterpretation.observables);
    }
    parts.push(section("Physical Interpretation", interpFull));
  }
  if (thought.fieldTheoryContext) {
    const fieldContent = keyValueSection({
      "Symmetry Group": thought.fieldTheoryContext.symmetryGroup
    });
    let fieldFull = fieldContent;
    if (thought.fieldTheoryContext.fields.length > 0) {
      fieldFull += "\n\n**Fields:**\n\n" + list(thought.fieldTheoryContext.fields);
    }
    if (thought.fieldTheoryContext.interactions.length > 0) {
      fieldFull += "\n\n**Interactions:**\n\n" + list(thought.fieldTheoryContext.interactions);
    }
    if (thought.fieldTheoryContext.gaugeSymmetries && thought.fieldTheoryContext.gaugeSymmetries.length > 0) {
      fieldFull += "\n\n**Gauge Symmetries:**\n\n" + list(thought.fieldTheoryContext.gaugeSymmetries);
    }
    parts.push(section("Field Theory Context", fieldFull));
  }
  if (includeMetrics) {
    const metricsContent = keyValueSection({
      "Uncertainty": `${(thought.uncertainty * 100).toFixed(1)}%`,
      ...thought.assumptions ? { "Assumptions": thought.assumptions.length } : {},
      ...thought.dependencies ? { "Dependencies": thought.dependencies.length } : {}
    });
    parts.push(section("Metrics", metricsContent + "\n\n" + progressBar(thought.uncertainty * 100)));
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    parts.push(section("Assumptions", list(thought.assumptions)));
  }
  if (thought.dependencies && thought.dependencies.length > 0) {
    parts.push(section("Dependencies", list(thought.dependencies)));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = physicsToMermaid(thought, "default", true, true);
    parts.push(section("Visualization", mermaidBlock(mermaidDiagram)));
  }
  return document("Physics Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "physics",
      thoughtType: thought.thoughtType || "physics",
      uncertainty: thought.uncertainty
    }
  });
}
var init_physics = __esm({
  "src/export/visual/modes/physics.ts"() {
    init_esm_shims();
    init_utils();
    init_svg();
    init_graphml();
    init_tikz();
    init_html();
    init_modelica();
    init_uml();
    init_json();
    init_markdown();
  }
});

// src/export/visual/modes/hybrid.ts
function exportHybridOrchestration(thought, options) {
  const { format, colorScheme = "default", includeMetrics = true } = options;
  const includeLabels = options.includeLabels !== false;
  switch (format) {
    case "mermaid":
      return hybridToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return hybridToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return hybridToASCII(thought);
    case "svg":
      return hybridToSVG(thought, options);
    case "graphml":
      return hybridToGraphML(thought, options);
    case "tikz":
      return hybridToTikZ(thought, options);
    case "html":
      return hybridToHTML(thought, options);
    case "modelica":
      return hybridToModelica(thought, options);
    case "uml":
      return hybridToUML(thought, options);
    case "json":
      return hybridToJSON(thought, options);
    case "markdown":
      return hybridToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function hybridToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TB\n";
  const hybridId = sanitizeId("hybrid_mode");
  mermaid += `  ${hybridId}(("Hybrid Mode"))
`;
  const primaryId = sanitizeId(`primary_${thought.primaryMode}`);
  const primaryLabel = includeLabels ? thought.primaryMode.charAt(0).toUpperCase() + thought.primaryMode.slice(1) : primaryId;
  mermaid += `  ${primaryId}[["${primaryLabel}"]]
`;
  mermaid += `  ${hybridId} ==> ${primaryId}
`;
  if (thought.secondaryFeatures && thought.secondaryFeatures.length > 0) {
    const secondaryId = sanitizeId("secondary_features");
    mermaid += `  ${secondaryId}(["Secondary Features"])
`;
    mermaid += `  ${hybridId} --> ${secondaryId}
`;
    thought.secondaryFeatures.forEach((feature, index) => {
      const featureId = sanitizeId(`feature_${index}`);
      const featureLabel = includeLabels ? feature.slice(0, 30) + (feature.length > 30 ? "..." : "") : `Feature ${index + 1}`;
      mermaid += `  ${featureId}["${featureLabel}"]
`;
      mermaid += `  ${secondaryId} --> ${featureId}
`;
    });
  }
  if (thought.switchReason) {
    const switchId = sanitizeId("switch_reason");
    const switchLabel = includeLabels ? thought.switchReason.slice(0, 40) + (thought.switchReason.length > 40 ? "..." : "") : "Switch Reason";
    mermaid += `  ${switchId}>"${switchLabel}"]
`;
    mermaid += `  ${hybridId} -.-> ${switchId}
`;
  }
  if (thought.stage) {
    const stageId = sanitizeId(`stage_${thought.stage}`);
    const stageLabel = thought.stage.replace(/_/g, " ");
    mermaid += `  ${stageId}{{"Stage: ${stageLabel}"}}
`;
    mermaid += `  ${primaryId} --> ${stageId}
`;
  }
  if (thought.mathematicalModel) {
    const modelId = sanitizeId("math_model");
    const modelLabel = thought.mathematicalModel.symbolic || "Mathematical Model";
    mermaid += `  ${modelId}["${modelLabel}"]
`;
    mermaid += `  ${primaryId} --> ${modelId}
`;
  }
  if (thought.tensorProperties) {
    const tensorId = sanitizeId("tensor");
    const tensorLabel = `Tensor (${thought.tensorProperties.rank[0]},${thought.tensorProperties.rank[1]})`;
    mermaid += `  ${tensorId}[/"${tensorLabel}"/]
`;
    mermaid += `  ${primaryId} --> ${tensorId}
`;
  }
  if (thought.physicalInterpretation) {
    const physId = sanitizeId("physical");
    mermaid += `  ${physId}[/"${thought.physicalInterpretation.quantity}"/]
`;
    mermaid += `  ${primaryId} --> ${physId}
`;
  }
  if (includeMetrics && thought.uncertainty !== void 0) {
    const uncertId = sanitizeId("uncertainty");
    const uncertLabel = `Uncertainty: ${(thought.uncertainty * 100).toFixed(1)}%`;
    mermaid += `  ${uncertId}{{${uncertLabel}}}
`;
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    const assumptionsId = sanitizeId("assumptions");
    mermaid += `  ${assumptionsId}>"Assumptions: ${thought.assumptions.length}"]
`;
  }
  if (thought.dependencies && thought.dependencies.length > 0) {
    const depsId = sanitizeId("dependencies");
    mermaid += `  ${depsId}>"Dependencies: ${thought.dependencies.length}"]
`;
  }
  if (colorScheme !== "monochrome") {
    const colors = colorScheme === "pastel" ? { hybrid: "#e8f4e8", primary: "#e3f2fd", secondary: "#fff3e0" } : { hybrid: "#90EE90", primary: "#87CEEB", secondary: "#FFD700" };
    mermaid += `
  style ${hybridId} fill:${colors.hybrid}
`;
    mermaid += `  style ${primaryId} fill:${colors.primary}
`;
    if (thought.secondaryFeatures && thought.secondaryFeatures.length > 0) {
      mermaid += `  style ${sanitizeId("secondary_features")} fill:${colors.secondary}
`;
    }
  }
  return mermaid;
}
function hybridToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph HybridOrchestration {\n";
  dot += "  rankdir=TB;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  const hybridId = sanitizeId("hybrid_mode");
  dot += `  ${hybridId} [label="Hybrid Mode", shape=doubleoctagon];
`;
  const primaryId = sanitizeId(`primary_${thought.primaryMode}`);
  const primaryLabel = thought.primaryMode.charAt(0).toUpperCase() + thought.primaryMode.slice(1);
  dot += `  ${primaryId} [label="${primaryLabel}", shape=box, style="filled,rounded", fillcolor=lightblue];
`;
  dot += `  ${hybridId} -> ${primaryId} [style=bold, penwidth=2];
`;
  if (thought.secondaryFeatures && thought.secondaryFeatures.length > 0) {
    const secondaryId = sanitizeId("secondary_features");
    dot += `  ${secondaryId} [label="Secondary Features", shape=ellipse];
`;
    dot += `  ${hybridId} -> ${secondaryId};
`;
    thought.secondaryFeatures.forEach((feature, index) => {
      const featureId = sanitizeId(`feature_${index}`);
      const featureLabel = includeLabels ? feature.slice(0, 25).replace(/"/g, '"') : `Feature ${index + 1}`;
      dot += `  ${featureId} [label="${featureLabel}"];
`;
      dot += `  ${secondaryId} -> ${featureId};
`;
    });
  }
  if (thought.switchReason) {
    const switchId = sanitizeId("switch_reason");
    const switchLabel = includeLabels ? thought.switchReason.slice(0, 30).replace(/"/g, '"') : "Switch Reason";
    dot += `  ${switchId} [label="${switchLabel}", shape=note];
`;
    dot += `  ${hybridId} -> ${switchId} [style=dashed];
`;
  }
  if (thought.stage) {
    const stageId = sanitizeId(`stage_${thought.stage}`);
    dot += `  ${stageId} [label="${thought.stage.replace(/_/g, " ")}", shape=diamond];
`;
    dot += `  ${primaryId} -> ${stageId};
`;
  }
  if (thought.mathematicalModel) {
    const modelId = sanitizeId("math_model");
    const modelLabel = thought.mathematicalModel.symbolic ? thought.mathematicalModel.symbolic.slice(0, 25).replace(/"/g, '"') : "Math Model";
    dot += `  ${modelId} [label="${modelLabel}", shape=parallelogram];
`;
    dot += `  ${primaryId} -> ${modelId};
`;
  }
  if (thought.tensorProperties) {
    const tensorId = sanitizeId("tensor");
    dot += `  ${tensorId} [label="Tensor (${thought.tensorProperties.rank[0]},${thought.tensorProperties.rank[1]})", shape=parallelogram];
`;
    dot += `  ${primaryId} -> ${tensorId};
`;
  }
  if (thought.physicalInterpretation) {
    const physId = sanitizeId("physical");
    dot += `  ${physId} [label="${thought.physicalInterpretation.quantity}", shape=parallelogram];
`;
    dot += `  ${primaryId} -> ${physId};
`;
  }
  if (includeMetrics && thought.uncertainty !== void 0) {
    const uncertId = sanitizeId("uncertainty");
    dot += `  ${uncertId} [label="${(thought.uncertainty * 100).toFixed(1)}%", shape=diamond];
`;
  }
  dot += "}\n";
  return dot;
}
function hybridToASCII(thought) {
  let ascii = "Hybrid Mode Orchestration:\n";
  ascii += "==========================\n\n";
  ascii += `Primary Mode: ${thought.primaryMode.charAt(0).toUpperCase() + thought.primaryMode.slice(1)}
`;
  if (thought.stage) {
    ascii += `Current Stage: ${thought.stage.replace(/_/g, " ")}
`;
  }
  if (thought.uncertainty !== void 0) {
    ascii += `Uncertainty: ${(thought.uncertainty * 100).toFixed(1)}%
`;
  }
  ascii += "\n";
  if (thought.switchReason) {
    ascii += `Switch Reason: ${thought.switchReason}

`;
  }
  if (thought.secondaryFeatures && thought.secondaryFeatures.length > 0) {
    ascii += "Secondary Features:\n";
    thought.secondaryFeatures.forEach((feature, index) => {
      ascii += `  ${index + 1}. ${feature}
`;
    });
    ascii += "\n";
  }
  if (thought.mathematicalModel) {
    ascii += "Mathematical Model:\n";
    ascii += `  LaTeX: ${thought.mathematicalModel.latex}
`;
    ascii += `  Symbolic: ${thought.mathematicalModel.symbolic}
`;
    if (thought.mathematicalModel.ascii) {
      ascii += `  ASCII: ${thought.mathematicalModel.ascii}
`;
    }
    ascii += "\n";
  }
  if (thought.tensorProperties) {
    ascii += "Tensor Properties:\n";
    ascii += `  Rank: (${thought.tensorProperties.rank[0]}, ${thought.tensorProperties.rank[1]})
`;
    ascii += `  Components: ${thought.tensorProperties.components}
`;
    ascii += `  Transformation: ${thought.tensorProperties.transformation}
`;
    if (thought.tensorProperties.symmetries.length > 0) {
      ascii += "  Symmetries:\n";
      thought.tensorProperties.symmetries.forEach((sym, index) => {
        ascii += `    ${index + 1}. ${sym}
`;
      });
    }
    ascii += "\n";
  }
  if (thought.physicalInterpretation) {
    ascii += "Physical Interpretation:\n";
    ascii += `  Quantity: ${thought.physicalInterpretation.quantity}
`;
    ascii += `  Units: ${thought.physicalInterpretation.units}
`;
    if (thought.physicalInterpretation.conservationLaws.length > 0) {
      ascii += "  Conservation Laws:\n";
      thought.physicalInterpretation.conservationLaws.forEach((law, index) => {
        ascii += `    ${index + 1}. ${law}
`;
      });
    }
    ascii += "\n";
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    ascii += "Assumptions:\n";
    thought.assumptions.forEach((assumption, index) => {
      ascii += `  ${index + 1}. ${assumption}
`;
    });
    ascii += "\n";
  }
  if (thought.dependencies && thought.dependencies.length > 0) {
    ascii += "Dependencies:\n";
    thought.dependencies.forEach((dep, index) => {
      ascii += `  ${index + 1}. ${dep}
`;
    });
    ascii += "\n";
  }
  if (thought.revisionReason) {
    ascii += `Revision Reason: ${thought.revisionReason}
`;
  }
  return ascii;
}
function hybridToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width,
    svgHeight = DEFAULT_SVG_OPTIONS.height
  } = options;
  const positions = /* @__PURE__ */ new Map();
  const nodeWidth = 150;
  const nodeHeight = 40;
  positions.set("hybrid", {
    id: "hybrid",
    label: "Hybrid Mode",
    x: svgWidth / 2,
    y: 100,
    width: nodeWidth,
    height: nodeHeight,
    type: "hybrid"
  });
  positions.set("primary", {
    id: "primary",
    label: thought.primaryMode.charAt(0).toUpperCase() + thought.primaryMode.slice(1),
    x: svgWidth / 2,
    y: 240,
    width: nodeWidth,
    height: nodeHeight,
    type: "primary"
  });
  if (thought.secondaryFeatures && thought.secondaryFeatures.length > 0) {
    thought.secondaryFeatures.forEach((feature, index) => {
      positions.set(`feature_${index}`, {
        id: `feature_${index}`,
        label: includeLabels ? feature.substring(0, 30) + (feature.length > 30 ? "..." : "") : `Feature ${index + 1}`,
        x: 150 + index * 180,
        y: 380,
        width: nodeWidth,
        height: nodeHeight,
        type: "feature"
      });
    });
  }
  let svg = generateSVGHeader(svgWidth, svgHeight, "Hybrid Mode Orchestration");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  const hybridPos = positions.get("hybrid");
  const primaryPos = positions.get("primary");
  if (hybridPos && primaryPos) {
    svg += renderEdge(hybridPos, primaryPos, { style: "solid" });
  }
  if (thought.secondaryFeatures) {
    thought.secondaryFeatures.forEach((_, index) => {
      const featurePos = positions.get(`feature_${index}`);
      if (hybridPos && featurePos) {
        svg += renderEdge(hybridPos, featurePos);
      }
    });
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  const hybridColors = getNodeColor("success", colorScheme);
  const primaryColors = getNodeColor("primary", colorScheme);
  const featureColors = getNodeColor("secondary", colorScheme);
  for (const [, pos] of positions) {
    if (pos.type === "hybrid") {
      svg += renderEllipseNode(pos, hybridColors);
    } else if (pos.type === "primary") {
      svg += renderStadiumNode(pos, primaryColors);
    } else if (pos.type === "feature") {
      svg += renderRectNode(pos, featureColors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Primary Mode", value: thought.primaryMode },
      { label: "Secondary Features", value: thought.secondaryFeatures?.length || 0 },
      { label: "Uncertainty", value: thought.uncertainty !== void 0 ? `${(thought.uncertainty * 100).toFixed(1)}%` : "N/A" }
    ];
    svg += renderMetricsPanel(svgWidth - 200, svgHeight - 120, metrics);
  }
  const legendItems = [
    { label: "Hybrid Mode", color: hybridColors, shape: "ellipse" },
    { label: "Primary Mode", color: primaryColors, shape: "stadium" },
    { label: "Secondary Feature", color: featureColors }
  ];
  svg += renderLegend(20, svgHeight - 110, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function hybridToGraphML(thought, options) {
  const { includeLabels = true } = options;
  const nodes = [];
  const edges = [];
  nodes.push({
    id: sanitizeId("hybrid_mode"),
    label: includeLabels ? "Hybrid Mode" : "hybrid",
    type: "hybrid"
  });
  const primaryId = sanitizeId(`primary_${thought.primaryMode}`);
  nodes.push({
    id: primaryId,
    label: includeLabels ? thought.primaryMode.charAt(0).toUpperCase() + thought.primaryMode.slice(1) : thought.primaryMode,
    type: "primary"
  });
  edges.push({
    id: "e_hybrid_primary",
    source: sanitizeId("hybrid_mode"),
    target: primaryId,
    directed: true
  });
  if (thought.secondaryFeatures && thought.secondaryFeatures.length > 0) {
    thought.secondaryFeatures.forEach((feature, index) => {
      const featureId = sanitizeId(`feature_${index}`);
      nodes.push({
        id: featureId,
        label: includeLabels ? feature.substring(0, 50) + (feature.length > 50 ? "..." : "") : `Feature ${index + 1}`,
        type: "secondary"
      });
      edges.push({
        id: `e_hybrid_feature_${index}`,
        source: sanitizeId("hybrid_mode"),
        target: featureId,
        directed: true
      });
    });
  }
  if (thought.stage) {
    const stageId = sanitizeId(`stage_${thought.stage}`);
    nodes.push({
      id: stageId,
      label: includeLabels ? thought.stage.replace(/_/g, " ") : "stage",
      type: "stage"
    });
    edges.push({
      id: "e_primary_stage",
      source: primaryId,
      target: stageId,
      directed: true
    });
  }
  return generateGraphML(nodes, edges, {
    graphName: "Hybrid Orchestration",
    directed: true,
    includeLabels
  });
}
function hybridToTikZ(thought, options) {
  const { includeLabels = true, colorScheme = "default" } = options;
  const nodes = [];
  const edges = [];
  nodes.push({
    id: sanitizeId("hybrid_mode"),
    label: includeLabels ? "Hybrid Mode" : "hybrid",
    x: 4,
    y: 0,
    type: "success",
    shape: "ellipse"
  });
  const primaryId = sanitizeId(`primary_${thought.primaryMode}`);
  nodes.push({
    id: primaryId,
    label: includeLabels ? thought.primaryMode.charAt(0).toUpperCase() + thought.primaryMode.slice(1) : thought.primaryMode,
    x: 4,
    y: -2,
    type: "primary",
    shape: "stadium"
  });
  edges.push({
    source: sanitizeId("hybrid_mode"),
    target: primaryId,
    directed: true
  });
  if (thought.secondaryFeatures && thought.secondaryFeatures.length > 0) {
    const featureCount = thought.secondaryFeatures.length;
    const spacing = 3;
    const totalWidth = (featureCount - 1) * spacing;
    const startX = 4 - totalWidth / 2;
    thought.secondaryFeatures.forEach((feature, index) => {
      const featureId = sanitizeId(`feature_${index}`);
      nodes.push({
        id: featureId,
        label: includeLabels ? feature.length > 20 ? feature.substring(0, 20) + "..." : feature : `F${index + 1}`,
        x: startX + index * spacing,
        y: -4,
        type: "secondary",
        shape: "rectangle"
      });
      edges.push({
        source: primaryId,
        target: featureId,
        directed: true
      });
    });
  }
  if (thought.stage) {
    const stageId = sanitizeId(`stage_${thought.stage}`);
    nodes.push({
      id: stageId,
      label: includeLabels ? thought.stage.replace(/_/g, " ") : "stage",
      x: 7,
      y: -2,
      type: "info",
      shape: "diamond"
    });
    edges.push({
      source: primaryId,
      target: stageId,
      directed: true,
      style: "dashed"
    });
  }
  return generateTikZ(nodes, edges, {
    title: "Hybrid Orchestration",
    colorScheme,
    includeLabels
  });
}
function hybridToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Hybrid Mode Orchestration",
    htmlTheme = "light"
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  html += '<div class="metrics-grid">';
  html += renderMetricCard("Primary Mode", thought.primaryMode, "primary");
  if (thought.secondaryFeatures) {
    html += renderMetricCard("Secondary Features", thought.secondaryFeatures.length, "info");
  }
  if (thought.uncertainty !== void 0) {
    html += renderMetricCard("Uncertainty", `${(thought.uncertainty * 100).toFixed(1)}%`, "warning");
  }
  if (thought.stage) {
    html += renderMetricCard("Stage", thought.stage.replace(/_/g, " "), "secondary");
  }
  html += "</div>\n";
  const badges = [];
  badges.push(renderBadge(`Primary: ${thought.primaryMode}`, "primary"));
  if (thought.stage) {
    badges.push(renderBadge(thought.stage.replace(/_/g, " "), "info"));
  }
  html += `<div class="flex gap-1 flex-wrap" style="margin: 1rem 0">${badges.join(" ")}</div>
`;
  if (thought.switchReason) {
    html += renderSection("Mode Switch Reason", `
      <p>${escapeHTML(thought.switchReason)}</p>
    `, "\u{1F504}");
  }
  if (thought.secondaryFeatures && thought.secondaryFeatures.length > 0) {
    const featuresContent = `
      <ul class="list-styled">
        ${thought.secondaryFeatures.map((f) => `<li>${escapeHTML(f)}</li>`).join("")}
      </ul>
    `;
    html += renderSection("Secondary Features", featuresContent, "\u2699\uFE0F");
  }
  if (thought.mathematicalModel) {
    const modelContent = `
      <p><strong>LaTeX:</strong> <code>${escapeHTML(thought.mathematicalModel.latex)}</code></p>
      <p><strong>Symbolic:</strong> <code>${escapeHTML(thought.mathematicalModel.symbolic)}</code></p>
      ${thought.mathematicalModel.ascii ? `<p><strong>ASCII:</strong> <code>${escapeHTML(thought.mathematicalModel.ascii)}</code></p>` : ""}
    `;
    html += renderSection("Mathematical Model", modelContent, "\u{1F4D0}");
  }
  if (thought.tensorProperties) {
    const tensorRows = [
      ["Rank", `(${thought.tensorProperties.rank[0]}, ${thought.tensorProperties.rank[1]})`],
      ["Components", thought.tensorProperties.components],
      ["Transformation", thought.tensorProperties.transformation]
    ];
    let tensorContent = renderTable(["Property", "Value"], tensorRows);
    if (thought.tensorProperties.symmetries.length > 0) {
      tensorContent += '<p style="margin-top: 1rem"><strong>Symmetries:</strong></p>';
      tensorContent += '<ul class="list-styled">';
      thought.tensorProperties.symmetries.forEach((sym) => {
        tensorContent += `<li>${escapeHTML(sym)}</li>`;
      });
      tensorContent += "</ul>";
    }
    html += renderSection("Tensor Properties", tensorContent, "\u{1F522}");
  }
  if (thought.physicalInterpretation) {
    const interpRows = [
      ["Quantity", thought.physicalInterpretation.quantity],
      ["Units", thought.physicalInterpretation.units]
    ];
    let interpContent = renderTable(["Property", "Value"], interpRows);
    if (thought.physicalInterpretation.conservationLaws.length > 0) {
      interpContent += '<p style="margin-top: 1rem"><strong>Conservation Laws:</strong></p>';
      interpContent += '<ul class="list-styled">';
      thought.physicalInterpretation.conservationLaws.forEach((law) => {
        interpContent += `<li>${escapeHTML(law)}</li>`;
      });
      interpContent += "</ul>";
    }
    html += renderSection("Physical Interpretation", interpContent, "\u269B\uFE0F");
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    const assumptionsList = thought.assumptions.map((a) => escapeHTML(a));
    html += renderSection("Assumptions", `
      <ul class="list-styled">
        ${assumptionsList.map((a) => `<li>${a}</li>`).join("")}
      </ul>
    `, "\u26A0\uFE0F");
  }
  if (thought.dependencies && thought.dependencies.length > 0) {
    const depsList = thought.dependencies.map((d) => escapeHTML(d));
    html += renderSection("Dependencies", `
      <ul class="list-styled">
        ${depsList.map((d) => `<li>${d}</li>`).join("")}
      </ul>
    `, "\u{1F517}");
  }
  if (thought.revisionReason) {
    html += renderSection("Revision Reason", `
      <p>${escapeHTML(thought.revisionReason)}</p>
    `, "\u270F\uFE0F");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function hybridToModelica(thought, options) {
  const { includeMetrics = true } = options;
  let modelica = "// Hybrid Mode Orchestration\n";
  modelica += "// Multi-mode reasoning orchestration package\n\n";
  const packageName = sanitizeModelicaId("HybridOrchestration");
  modelica += `package ${packageName}
`;
  modelica += '  "Hybrid mode reasoning orchestration with primary and secondary features"\n\n';
  modelica += "  record ModeConfiguration\n";
  modelica += '    "Configuration for a reasoning mode"\n';
  modelica += '    String modeName "Name of the reasoning mode";\n';
  modelica += '    Real weight "Weight/importance in orchestration (0-1)";\n';
  modelica += '    Boolean isPrimary "Whether this is the primary mode";\n';
  modelica += "  end ModeConfiguration;\n\n";
  modelica += "  model Orchestrator\n";
  modelica += '    "Hybrid mode orchestration controller"\n\n';
  modelica += "    // Mode configuration\n";
  const primaryMode = escapeModelicaString(thought.primaryMode);
  modelica += `    parameter String primaryMode = "${primaryMode}" "Primary reasoning mode";
`;
  if (thought.stage) {
    const stage = escapeModelicaString(thought.stage.replace(/_/g, " "));
    modelica += `    parameter String currentStage = "${stage}" "Current orchestration stage";
`;
  }
  if (includeMetrics && thought.uncertainty !== void 0) {
    modelica += `    parameter Real uncertainty = ${thought.uncertainty.toFixed(4)} "Orchestration uncertainty (0-1)";
`;
  }
  const featureCount = thought.secondaryFeatures?.length || 0;
  modelica += `    parameter Integer secondaryCount = ${featureCount} "Number of secondary features";
`;
  modelica += "\n    // Mode weights\n";
  modelica += '    parameter Real primaryWeight = 0.7 "Primary mode weight";\n';
  modelica += '    parameter Real secondaryWeight = 0.3 "Secondary features weight";\n\n';
  modelica += "    // State variables\n";
  modelica += '    Real orchestrationEfficiency(start=1.0) "Overall orchestration efficiency";\n';
  modelica += '    Real modeBalance "Balance between primary and secondary modes";\n';
  modelica += '    Boolean isActive(start=true) "Whether orchestration is active";\n\n';
  modelica += "  equation\n";
  modelica += "    // Orchestration efficiency decreases with uncertainty\n";
  if (thought.uncertainty !== void 0) {
    modelica += `    orchestrationEfficiency = 1.0 - ${thought.uncertainty.toFixed(4)};
`;
  } else {
    modelica += "    orchestrationEfficiency = 1.0;\n";
  }
  modelica += "    \n";
  modelica += "    // Mode balance based on weights\n";
  modelica += "    modeBalance = primaryWeight / (primaryWeight + secondaryWeight);\n";
  modelica += "    \n";
  modelica += "    // Orchestration is active when efficiency is above threshold\n";
  modelica += "    isActive = orchestrationEfficiency > 0.5;\n\n";
  modelica += "  annotation(\n";
  modelica += '    Documentation(info="<html>\n';
  modelica += `      <p>Hybrid mode orchestration combining ${primaryMode}`;
  if (featureCount > 0) {
    modelica += ` with ${featureCount} secondary features`;
  }
  modelica += ".</p>\n";
  if (thought.switchReason) {
    const switchReason = escapeModelicaString(thought.switchReason);
    modelica += `      <p><b>Switch Reason:</b> ${switchReason}</p>
`;
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    modelica += "      <p><b>Assumptions:</b></p>\n";
    modelica += "      <ul>\n";
    thought.assumptions.forEach((assumption) => {
      const escapedAssumption = escapeModelicaString(assumption);
      modelica += `        <li>${escapedAssumption}</li>
`;
    });
    modelica += "      </ul>\n";
  }
  modelica += '    </html>")\n';
  modelica += "  );\n";
  modelica += "  end Orchestrator;\n\n";
  if (thought.secondaryFeatures && thought.secondaryFeatures.length > 0) {
    modelica += "  // Secondary feature models\n";
    thought.secondaryFeatures.forEach((feature, index) => {
      const featureId = sanitizeModelicaId(`Feature${index + 1}`);
      const featureDesc = escapeModelicaString(feature.substring(0, 60));
      modelica += `  model ${featureId}
`;
      modelica += `    "Secondary feature: ${featureDesc}"
`;
      modelica += '    parameter Real contribution = 0.1 "Contribution to orchestration";\n';
      modelica += '    Real effectiveness "Feature effectiveness";\n';
      modelica += "  equation\n";
      modelica += "    effectiveness = contribution;\n";
      modelica += `  end ${featureId};

`;
    });
  }
  if (thought.mathematicalModel) {
    modelica += "  model MathematicalModel\n";
    modelica += '    "Mathematical model integration"\n';
    const symbolicModel = escapeModelicaString(thought.mathematicalModel.symbolic || "Unknown");
    modelica += `    parameter String symbolic = "${symbolicModel}" "Symbolic representation";
`;
    if (thought.mathematicalModel.ascii) {
      const asciiModel = escapeModelicaString(thought.mathematicalModel.ascii);
      modelica += `    parameter String ascii = "${asciiModel}" "ASCII representation";
`;
    }
    modelica += "  end MathematicalModel;\n\n";
  }
  if (thought.tensorProperties) {
    modelica += "  model TensorProperties\n";
    modelica += '    "Tensor analysis integration"\n';
    modelica += `    parameter Integer rank[2] = {${thought.tensorProperties.rank[0]}, ${thought.tensorProperties.rank[1]}} "Tensor rank";
`;
    const components = escapeModelicaString(thought.tensorProperties.components);
    modelica += `    parameter String components = "${components}" "Tensor components";
`;
    const transformation = escapeModelicaString(thought.tensorProperties.transformation);
    modelica += `    parameter String transformation = "${transformation}" "Transformation rule";
`;
    modelica += "  end TensorProperties;\n\n";
  }
  if (thought.physicalInterpretation) {
    modelica += "  model PhysicalInterpretation\n";
    modelica += '    "Physical meaning of reasoning"\n';
    const quantity = escapeModelicaString(thought.physicalInterpretation.quantity);
    modelica += `    parameter String quantity = "${quantity}" "Physical quantity";
`;
    const units = escapeModelicaString(thought.physicalInterpretation.units);
    modelica += `    parameter String units = "${units}" "Measurement units";
`;
    modelica += "  end PhysicalInterpretation;\n\n";
  }
  modelica += `end ${packageName};
`;
  return modelica;
}
function hybridToUML(thought, options) {
  const { includeLabels = true } = options;
  const nodes = [];
  const edges = [];
  nodes.push({
    id: "hybrid",
    label: includeLabels ? "Hybrid Orchestrator" : "Hybrid",
    shape: "component",
    stereotype: "<<orchestrator>>",
    attributes: [
      `primaryMode: ${thought.primaryMode}`,
      thought.stage ? `stage: ${thought.stage.replace(/_/g, " ")}` : null,
      thought.uncertainty !== void 0 ? `uncertainty: ${(thought.uncertainty * 100).toFixed(1)}%` : null
    ].filter(Boolean)
  });
  const primaryId = sanitizeId(`primary_${thought.primaryMode}`);
  nodes.push({
    id: primaryId,
    label: includeLabels ? thought.primaryMode.charAt(0).toUpperCase() + thought.primaryMode.slice(1) : thought.primaryMode,
    shape: "class",
    stereotype: "<<primary>>",
    attributes: ["weight: 0.7"]
  });
  edges.push({
    source: "hybrid",
    target: primaryId,
    type: "composition",
    label: "orchestrates"
  });
  if (thought.secondaryFeatures && thought.secondaryFeatures.length > 0) {
    thought.secondaryFeatures.forEach((feature, index) => {
      const featureId = sanitizeId(`feature_${index}`);
      nodes.push({
        id: featureId,
        label: includeLabels ? feature.length > 30 ? feature.substring(0, 30) + "..." : feature : `Feature${index + 1}`,
        shape: "class",
        stereotype: "<<secondary>>",
        attributes: ["weight: 0.3"]
      });
      edges.push({
        source: "hybrid",
        target: featureId,
        type: "association",
        label: "uses"
      });
    });
  }
  if (thought.mathematicalModel) {
    nodes.push({
      id: "math_model",
      label: "Mathematical Model",
      shape: "package",
      attributes: [
        `symbolic: ${thought.mathematicalModel.symbolic}`,
        thought.mathematicalModel.ascii ? `ascii: ${thought.mathematicalModel.ascii.substring(0, 30)}` : null
      ].filter(Boolean)
    });
    edges.push({
      source: primaryId,
      target: "math_model",
      type: "dependency",
      label: "applies"
    });
  }
  if (thought.tensorProperties) {
    nodes.push({
      id: "tensor",
      label: "Tensor Properties",
      shape: "interface",
      attributes: [
        `rank: (${thought.tensorProperties.rank[0]}, ${thought.tensorProperties.rank[1]})`,
        `components: ${thought.tensorProperties.components}`
      ]
    });
    edges.push({
      source: primaryId,
      target: "tensor",
      type: "implementation",
      label: "implements"
    });
  }
  if (thought.physicalInterpretation) {
    nodes.push({
      id: "physical",
      label: "Physical Interpretation",
      shape: "component",
      attributes: [
        `quantity: ${thought.physicalInterpretation.quantity}`,
        `units: ${thought.physicalInterpretation.units}`
      ]
    });
    edges.push({
      source: primaryId,
      target: "physical",
      type: "dependency",
      label: "interprets"
    });
  }
  if (thought.switchReason && includeLabels) {
    nodes.push({
      id: "switch_note",
      label: "Switch Reason",
      shape: "rectangle",
      stereotype: "<<note>>",
      attributes: [thought.switchReason.substring(0, 50) + (thought.switchReason.length > 50 ? "..." : "")]
    });
    edges.push({
      source: "hybrid",
      target: "switch_note",
      type: "dependency"
    });
  }
  return generateUmlDiagram(nodes, edges, {
    title: "Hybrid Mode Orchestration"});
}
function hybridToJSON(thought, options) {
  const { includeMetrics = true } = options;
  const graph = createJsonGraph("Hybrid Mode Orchestration", "hybrid_orchestration", {
    includeMetrics,
    includeLegend: true,
    includeLayout: true
  });
  addNode(graph, {
    id: "hybrid",
    label: "Hybrid Mode",
    type: "orchestrator",
    metadata: {
      primaryMode: thought.primaryMode,
      stage: thought.stage || null,
      uncertainty: thought.uncertainty,
      secondaryFeaturesCount: thought.secondaryFeatures?.length || 0
    }
  });
  const primaryId = sanitizeId(`primary_${thought.primaryMode}`);
  addNode(graph, {
    id: primaryId,
    label: thought.primaryMode.charAt(0).toUpperCase() + thought.primaryMode.slice(1),
    type: "primary_mode",
    metadata: {
      name: thought.primaryMode,
      weight: 0.7
    }
  });
  addEdge(graph, {
    id: "e_hybrid_primary",
    source: "hybrid",
    target: primaryId,
    label: "orchestrates",
    type: "primary",
    metadata: {
      strength: 1
    }
  });
  if (thought.secondaryFeatures && thought.secondaryFeatures.length > 0) {
    thought.secondaryFeatures.forEach((feature, index) => {
      const featureId = sanitizeId(`feature_${index}`);
      addNode(graph, {
        id: featureId,
        label: `Feature ${index + 1}`,
        type: "secondary_feature",
        metadata: {
          description: feature,
          index,
          weight: 0.3 / thought.secondaryFeatures.length
        }
      });
      addEdge(graph, {
        id: `e_hybrid_feature_${index}`,
        source: "hybrid",
        target: featureId,
        label: "uses",
        type: "secondary",
        metadata: {
          strength: 0.5
        }
      });
    });
  }
  if (thought.stage) {
    const stageId = sanitizeId(`stage_${thought.stage}`);
    addNode(graph, {
      id: stageId,
      label: thought.stage.replace(/_/g, " "),
      type: "stage",
      metadata: {
        name: thought.stage
      }
    });
    addEdge(graph, {
      id: "e_primary_stage",
      source: primaryId,
      target: stageId,
      label: "in_stage",
      type: "stage_flow"
    });
  }
  if (thought.mathematicalModel) {
    addNode(graph, {
      id: "math_model",
      label: "Mathematical Model",
      type: "mathematical",
      metadata: {
        latex: thought.mathematicalModel.latex,
        symbolic: thought.mathematicalModel.symbolic,
        ascii: thought.mathematicalModel.ascii || null
      }
    });
    addEdge(graph, {
      id: "e_primary_math",
      source: primaryId,
      target: "math_model",
      label: "applies",
      type: "transformation"
    });
  }
  if (thought.tensorProperties) {
    addNode(graph, {
      id: "tensor",
      label: "Tensor Properties",
      type: "tensor",
      metadata: {
        rank: thought.tensorProperties.rank,
        components: thought.tensorProperties.components,
        transformation: thought.tensorProperties.transformation,
        symmetries: thought.tensorProperties.symmetries
      }
    });
    addEdge(graph, {
      id: "e_primary_tensor",
      source: primaryId,
      target: "tensor",
      label: "analyzes",
      type: "analysis"
    });
  }
  if (thought.physicalInterpretation) {
    addNode(graph, {
      id: "physical",
      label: "Physical Interpretation",
      type: "physical",
      metadata: {
        quantity: thought.physicalInterpretation.quantity,
        units: thought.physicalInterpretation.units,
        conservationLaws: thought.physicalInterpretation.conservationLaws
      }
    });
    addEdge(graph, {
      id: "e_primary_physical",
      source: primaryId,
      target: "physical",
      label: "interprets",
      type: "interpretation"
    });
  }
  if (includeMetrics) {
    addMetric(graph, "primary_mode", thought.primaryMode);
    addMetric(graph, "secondary_features_count", thought.secondaryFeatures?.length || 0);
    if (thought.uncertainty !== void 0) {
      addMetric(graph, "uncertainty", thought.uncertainty);
    }
    if (thought.stage) {
      addMetric(graph, "stage", thought.stage);
    }
    if (thought.assumptions) {
      addMetric(graph, "assumptions_count", thought.assumptions.length);
    }
    if (thought.dependencies) {
      addMetric(graph, "dependencies_count", thought.dependencies.length);
    }
  }
  addLegendItem(graph, "Hybrid Orchestrator", "#90EE90");
  addLegendItem(graph, "Primary Mode", "#87CEEB");
  addLegendItem(graph, "Secondary Feature", "#FFD700");
  if (thought.mathematicalModel) {
    addLegendItem(graph, "Mathematical Model", "#DDA0DD");
  }
  if (thought.tensorProperties) {
    addLegendItem(graph, "Tensor Properties", "#F0E68C");
  }
  if (thought.physicalInterpretation) {
    addLegendItem(graph, "Physical Interpretation", "#98FB98");
  }
  return serializeGraph(graph);
}
function hybridToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  const overviewContent = keyValueSection({
    "Primary Mode": thought.primaryMode.charAt(0).toUpperCase() + thought.primaryMode.slice(1),
    ...thought.stage ? { "Stage": thought.stage.replace(/_/g, " ") } : {},
    ...thought.uncertainty !== void 0 ? { "Uncertainty": `${(thought.uncertainty * 100).toFixed(1)}%` } : {}
  });
  parts.push(section("Overview", overviewContent));
  if (thought.switchReason) {
    parts.push(section("Mode Switch Reason", thought.switchReason));
  }
  if (thought.secondaryFeatures && thought.secondaryFeatures.length > 0) {
    parts.push(section("Secondary Features", list(thought.secondaryFeatures)));
  }
  if (thought.mathematicalModel) {
    const mathContent = keyValueSection({
      "LaTeX": thought.mathematicalModel.latex,
      "Symbolic": thought.mathematicalModel.symbolic,
      ...thought.mathematicalModel.ascii ? { "ASCII": thought.mathematicalModel.ascii } : {}
    });
    parts.push(section("Mathematical Model", mathContent));
  }
  if (thought.tensorProperties) {
    const tensorRows = [
      ["Rank", `(${thought.tensorProperties.rank[0]}, ${thought.tensorProperties.rank[1]})`],
      ["Components", thought.tensorProperties.components],
      ["Transformation", thought.tensorProperties.transformation]
    ];
    let tensorContent = table(["Property", "Value"], tensorRows);
    if (thought.tensorProperties.symmetries.length > 0) {
      tensorContent += "\n\n**Symmetries:**\n\n" + list(thought.tensorProperties.symmetries);
    }
    parts.push(section("Tensor Properties", tensorContent));
  }
  if (thought.physicalInterpretation) {
    const interpContent = keyValueSection({
      "Quantity": thought.physicalInterpretation.quantity,
      "Units": thought.physicalInterpretation.units
    });
    let interpFull = interpContent;
    if (thought.physicalInterpretation.conservationLaws.length > 0) {
      interpFull += "\n\n**Conservation Laws:**\n\n" + list(thought.physicalInterpretation.conservationLaws);
    }
    parts.push(section("Physical Interpretation", interpFull));
  }
  if (includeMetrics) {
    const metricsItems = {
      "Primary Mode": thought.primaryMode,
      "Secondary Features": thought.secondaryFeatures?.length || 0
    };
    if (thought.uncertainty !== void 0) {
      metricsItems["Uncertainty"] = `${(thought.uncertainty * 100).toFixed(1)}%`;
    }
    if (thought.assumptions) {
      metricsItems["Assumptions"] = thought.assumptions.length;
    }
    if (thought.dependencies) {
      metricsItems["Dependencies"] = thought.dependencies.length;
    }
    parts.push(section("Metrics", keyValueSection(metricsItems)));
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    parts.push(section("Assumptions", list(thought.assumptions)));
  }
  if (thought.dependencies && thought.dependencies.length > 0) {
    parts.push(section("Dependencies", list(thought.dependencies)));
  }
  if (thought.revisionReason) {
    parts.push(section("Revision Reason", thought.revisionReason));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = hybridToMermaid(thought, "default", true, true);
    parts.push(section("Visualization", mermaidBlock(mermaidDiagram)));
  }
  return document("Hybrid Mode Orchestration", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "hybrid",
      primaryMode: thought.primaryMode,
      secondaryFeatures: thought.secondaryFeatures?.length || 0
    }
  });
}
var init_hybrid = __esm({
  "src/export/visual/modes/hybrid.ts"() {
    init_esm_shims();
    init_utils();
    init_svg();
    init_graphml();
    init_tikz();
    init_html();
    init_modelica();
    init_uml();
    init_json();
    init_markdown();
  }
});

// src/export/visual/modes/causal.ts
function exportCausalGraph(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return causalGraphToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return causalGraphToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return causalGraphToASCII(thought);
    case "svg":
      return causalGraphToSVG(thought, options);
    case "graphml":
      return causalGraphToGraphML(thought, options);
    case "tikz":
      return causalGraphToTikZ(thought, options);
    case "html":
      return causalGraphToHTML(thought, options);
    case "modelica":
      return causalToModelica(thought, options);
    case "uml":
      return causalToUML(thought, options);
    case "json":
      return causalToJSON(thought, options);
    case "markdown":
      return causalToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function causalGraphToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TB\n";
  if (!thought.causalGraph || !thought.causalGraph.nodes) {
    return mermaid + '  NoData["No causal graph data"]\n';
  }
  for (const node of thought.causalGraph.nodes) {
    const nodeId = sanitizeId(node.id);
    const label = includeLabels ? node.name : nodeId;
    let shape;
    switch (node.type) {
      case "cause":
        shape = ["([", "])"];
        break;
      case "effect":
        shape = ["[[", "]]"];
        break;
      case "mediator":
        shape = ["[", "]"];
        break;
      case "confounder":
        shape = ["{", "}"];
        break;
      default:
        shape = ["[", "]"];
    }
    mermaid += `  ${nodeId}${shape[0]}${label}${shape[1]}
`;
  }
  mermaid += "\n";
  for (const edge of thought.causalGraph.edges) {
    const fromId = sanitizeId(edge.from);
    const toId = sanitizeId(edge.to);
    if (includeMetrics && edge.strength !== void 0) {
      mermaid += `  ${fromId} --> |${edge.strength.toFixed(2)}| ${toId}
`;
    } else {
      mermaid += `  ${fromId} --> ${toId}
`;
    }
  }
  if (colorScheme !== "monochrome") {
    mermaid += "\n";
    const causes = thought.causalGraph.nodes.filter((n) => n.type === "cause");
    const effects = thought.causalGraph.nodes.filter((n) => n.type === "effect");
    for (const node of causes) {
      const color = colorScheme === "pastel" ? "#e1f5ff" : "#a8d5ff";
      mermaid += `  style ${sanitizeId(node.id)} fill:${color}
`;
    }
    for (const node of effects) {
      const color = colorScheme === "pastel" ? "#fff3e0" : "#ffd699";
      mermaid += `  style ${sanitizeId(node.id)} fill:${color}
`;
    }
  }
  return mermaid;
}
function causalGraphToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph CausalGraph {\n";
  dot += "  rankdir=TB;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  if (!thought.causalGraph || !thought.causalGraph.nodes) {
    dot += '  NoData [label="No causal graph data"];\n}\n';
    return dot;
  }
  for (const node of thought.causalGraph.nodes) {
    const nodeId = sanitizeId(node.id);
    const label = includeLabels ? node.name : nodeId;
    let shape = "box";
    switch (node.type) {
      case "cause":
        shape = "ellipse";
        break;
      case "effect":
        shape = "doubleoctagon";
        break;
      case "mediator":
        shape = "box";
        break;
      case "confounder":
        shape = "diamond";
        break;
    }
    dot += `  ${nodeId} [label="${label}", shape=${shape}];
`;
  }
  dot += "\n";
  for (const edge of thought.causalGraph.edges) {
    const fromId = sanitizeId(edge.from);
    const toId = sanitizeId(edge.to);
    if (includeMetrics && edge.strength !== void 0) {
      dot += `  ${fromId} -> ${toId} [label="${edge.strength.toFixed(2)}"];
`;
    } else {
      dot += `  ${fromId} -> ${toId};
`;
    }
  }
  dot += "}\n";
  return dot;
}
function causalGraphToASCII(thought) {
  let ascii = "Causal Graph:\n";
  ascii += "=============\n\n";
  if (!thought.causalGraph || !thought.causalGraph.nodes) {
    return ascii + "No causal graph data\n";
  }
  ascii += "Nodes:\n";
  for (const node of thought.causalGraph.nodes) {
    ascii += `  [${node.type.toUpperCase()}] ${node.name}: ${node.description}
`;
  }
  ascii += "\nEdges:\n";
  for (const edge of thought.causalGraph.edges) {
    const fromNode = thought.causalGraph.nodes.find((n) => n.id === edge.from);
    const toNode = thought.causalGraph.nodes.find((n) => n.id === edge.to);
    const strength = edge.strength !== void 0 ? ` (strength: ${edge.strength.toFixed(2)})` : "";
    ascii += `  ${fromNode?.name} --> ${toNode?.name}${strength}
`;
  }
  return ascii;
}
function causalGraphToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width
  } = options;
  if (!thought.causalGraph || !thought.causalGraph.nodes) {
    return generateSVGHeader(svgWidth, 200, "Causal Graph") + '\n  <text x="400" y="100" text-anchor="middle" class="subtitle">No causal graph data</text>\n' + generateSVGFooter();
  }
  const causes = thought.causalGraph.nodes.filter((n) => n.type === "cause");
  const mediators = thought.causalGraph.nodes.filter((n) => n.type === "mediator");
  const confounders = thought.causalGraph.nodes.filter((n) => n.type === "confounder");
  const effects = thought.causalGraph.nodes.filter((n) => n.type === "effect");
  const layers = [
    causes.map((n) => ({ id: n.id, label: includeLabels ? n.name : n.id, type: "cause" })),
    [...mediators, ...confounders].map((n) => ({ id: n.id, label: includeLabels ? n.name : n.id, type: n.type })),
    effects.map((n) => ({ id: n.id, label: includeLabels ? n.name : n.id, type: "effect" }))
  ].filter((layer) => layer.length > 0);
  const positions = layoutNodesInLayers(layers, { width: svgWidth, title: "Causal Graph" });
  const actualHeight = calculateSVGHeight(positions);
  let svg = generateSVGHeader(svgWidth, actualHeight, "Causal Graph");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  for (const edge of thought.causalGraph.edges) {
    const fromPos = positions.get(edge.from);
    const toPos = positions.get(edge.to);
    if (fromPos && toPos) {
      const label = includeMetrics && edge.strength !== void 0 ? edge.strength.toFixed(2) : void 0;
      svg += renderEdge(fromPos, toPos, { label });
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  for (const [, pos] of positions) {
    const colors = getNodeColor(pos.type === "cause" ? "primary" : pos.type === "effect" ? "tertiary" : "neutral", colorScheme);
    switch (pos.type) {
      case "cause":
        svg += renderStadiumNode(pos, colors);
        break;
      case "effect":
        svg += renderEllipseNode(pos, colors);
        break;
      case "confounder":
        svg += renderDiamondNode(pos, colors);
        break;
      default:
        svg += renderRectNode(pos, colors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Nodes", value: thought.causalGraph.nodes.length },
      { label: "Edges", value: thought.causalGraph.edges.length },
      { label: "Causes", value: causes.length },
      { label: "Effects", value: effects.length }
    ];
    svg += renderMetricsPanel(svgWidth - 180, actualHeight - 110, metrics);
  }
  const legendItems = [
    { label: "Cause", color: getNodeColor("primary", colorScheme) },
    { label: "Mediator", color: getNodeColor("neutral", colorScheme) },
    { label: "Confounder", color: getNodeColor("neutral", colorScheme), shape: "diamond" },
    { label: "Effect", color: getNodeColor("tertiary", colorScheme), shape: "ellipse" }
  ];
  svg += renderLegend(20, actualHeight - 100, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function causalGraphToGraphML(thought, options) {
  const { includeMetrics = true } = options;
  if (!thought.causalGraph || !thought.causalGraph.nodes) {
    const emptyNodes = [
      { id: "no_data", label: "No causal graph data", type: "message" }
    ];
    return generateGraphML(emptyNodes, [], { graphName: "Causal Graph" });
  }
  const nodes = thought.causalGraph.nodes.map((node) => ({
    id: node.id,
    label: node.name,
    type: node.type
  }));
  const edges = thought.causalGraph.edges.map((edge, index) => {
    const edgeData = {
      id: `e${index}`,
      source: edge.from,
      target: edge.to
    };
    if (includeMetrics && edge.strength !== void 0) {
      edgeData.metadata = { weight: edge.strength };
    }
    return edgeData;
  });
  const graphmlOptions = {
    graphName: "Causal Graph"
  };
  return generateGraphML(nodes, edges, graphmlOptions);
}
function causalGraphToTikZ(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  if (!thought.causalGraph || !thought.causalGraph.nodes) {
    const emptyNodes = [
      { id: "no_data", x: 0, y: 0, label: "No causal graph data", shape: "rectangle" }
    ];
    return generateTikZ(emptyNodes, [], { title: "Causal Graph" });
  }
  const causes = thought.causalGraph.nodes.filter((n) => n.type === "cause");
  const mediators = thought.causalGraph.nodes.filter((n) => n.type === "mediator");
  const confounders = thought.causalGraph.nodes.filter((n) => n.type === "confounder");
  const effects = thought.causalGraph.nodes.filter((n) => n.type === "effect");
  const nodes = [];
  causes.forEach((node, index) => {
    const spacing = 3;
    const offset = (causes.length - 1) * spacing / 2;
    nodes.push({
      id: node.id,
      x: index * spacing - offset,
      y: 0,
      label: includeLabels ? node.name : node.id,
      shape: "stadium",
      type: node.type
    });
  });
  const middleNodes = [...mediators, ...confounders];
  middleNodes.forEach((node, index) => {
    const spacing = 3;
    const offset = (middleNodes.length - 1) * spacing / 2;
    nodes.push({
      id: node.id,
      x: index * spacing - offset,
      y: -2,
      label: includeLabels ? node.name : node.id,
      shape: node.type === "confounder" ? "diamond" : "rectangle",
      type: node.type
    });
  });
  effects.forEach((node, index) => {
    const spacing = 3;
    const offset = (effects.length - 1) * spacing / 2;
    nodes.push({
      id: node.id,
      x: index * spacing - offset,
      y: -4,
      label: includeLabels ? node.name : node.id,
      shape: "ellipse",
      type: node.type
    });
  });
  const edges = thought.causalGraph.edges.map((edge) => {
    const edgeData = {
      source: edge.from,
      target: edge.to
    };
    if (includeMetrics && edge.strength !== void 0) {
      edgeData.label = edge.strength.toFixed(2);
    }
    return edgeData;
  });
  const tikzOptions = {
    title: "Causal Graph"
  };
  return generateTikZ(nodes, edges, tikzOptions);
}
function causalGraphToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Causal Graph Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  if (!thought.causalGraph || !thought.causalGraph.nodes) {
    html += '<p class="text-secondary">No causal graph data available.</p>\n';
    html += generateHTMLFooter(htmlStandalone);
    return html;
  }
  if (includeMetrics) {
    const causes = thought.causalGraph.nodes.filter((n) => n.type === "cause");
    const effects = thought.causalGraph.nodes.filter((n) => n.type === "effect");
    const mediators = thought.causalGraph.nodes.filter((n) => n.type === "mediator");
    const confounders2 = thought.causalGraph.nodes.filter((n) => n.type === "confounder");
    html += '<div class="metrics-grid">';
    html += renderMetricCard("Total Nodes", thought.causalGraph.nodes.length, "primary");
    html += renderMetricCard("Edges", thought.causalGraph.edges.length, "info");
    html += renderMetricCard("Causes", causes.length, "success");
    html += renderMetricCard("Effects", effects.length, "warning");
    if (mediators.length > 0) {
      html += renderMetricCard("Mediators", mediators.length);
    }
    if (confounders2.length > 0) {
      html += renderMetricCard("Confounders", confounders2.length, "danger");
    }
    html += "</div>\n";
  }
  const nodeRows = thought.causalGraph.nodes.map((node) => {
    const typeBadge = renderBadge(
      node.type,
      node.type === "cause" ? "success" : node.type === "effect" ? "warning" : node.type === "confounder" ? "danger" : "secondary"
    );
    return [node.id, node.name, typeBadge, node.description || "-"];
  });
  html += renderSection("Nodes", renderTable(
    ["ID", "Name", "Type", "Description"],
    nodeRows.map((row) => row.map((cell) => typeof cell === "string" && cell.startsWith("<") ? cell : escapeHTML(String(cell))))
  ), "\u{1F4CA}");
  const edgeRows = thought.causalGraph.edges.map((edge) => {
    const fromNode = thought.causalGraph.nodes.find((n) => n.id === edge.from);
    const toNode = thought.causalGraph.nodes.find((n) => n.id === edge.to);
    return [
      fromNode?.name || edge.from,
      "\u2192",
      toNode?.name || edge.to,
      edge.strength !== void 0 ? edge.strength.toFixed(2) : "-",
      edge.mechanism || "-"
    ];
  });
  html += renderSection("Causal Relationships", renderTable(
    ["From", "", "To", "Strength", "Mechanism"],
    edgeRows
  ), "\u{1F517}");
  const confounders = thought.causalGraph.nodes.filter((n) => n.type === "confounder");
  if (confounders.length > 0) {
    html += renderSection("\u26A0\uFE0F Confounding Variables", `
      <p class="text-warning">The following variables may confound causal inference:</p>
      <ul class="list-styled">
        ${confounders.map((c) => `<li><strong>${escapeHTML(c.name)}</strong>: ${escapeHTML(c.description)}</li>`).join("\n")}
      </ul>
    `);
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function causalToModelica(thought, options) {
  const { modelicaPackageName, modelicaIncludeAnnotations = true, includeMetrics = true } = options;
  const packageName = modelicaPackageName || "CausalGraph";
  const lines = [];
  lines.push(`package ${sanitizeModelicaId(packageName)}`);
  lines.push(`  "Causal analysis graph"`);
  lines.push("");
  if (!thought.causalGraph || !thought.causalGraph.nodes) {
    lines.push("  // No causal graph data");
    lines.push(`end ${sanitizeModelicaId(packageName)};`);
    return lines.join("\n");
  }
  const causes = thought.causalGraph.nodes.filter((n) => n.type === "cause");
  if (causes.length > 0) {
    lines.push("  // Causes");
    for (const cause of causes) {
      const causeId = sanitizeModelicaId(cause.id);
      lines.push(`  record Cause_${causeId}`);
      lines.push(`    constant String description = "${escapeModelicaString(cause.description)}";`);
      lines.push(`    constant String name = "${escapeModelicaString(cause.name)}";`);
      lines.push(`  end Cause_${causeId};`);
      lines.push("");
    }
  }
  const effects = thought.causalGraph.nodes.filter((n) => n.type === "effect");
  if (effects.length > 0) {
    lines.push("  // Effects");
    for (const effect of effects) {
      const effectId = sanitizeModelicaId(effect.id);
      lines.push(`  record Effect_${effectId}`);
      lines.push(`    constant String description = "${escapeModelicaString(effect.description)}";`);
      lines.push(`    constant String name = "${escapeModelicaString(effect.name)}";`);
      lines.push(`  end Effect_${effectId};`);
      lines.push("");
    }
  }
  if (thought.causalGraph.edges && thought.causalGraph.edges.length > 0) {
    lines.push("  // Causal Links");
    for (let i = 0; i < thought.causalGraph.edges.length; i++) {
      const link = thought.causalGraph.edges[i];
      lines.push(`  record Link_${i + 1}`);
      lines.push(`    constant String cause = "${sanitizeModelicaId(link.from)}";`);
      lines.push(`    constant String effect = "${sanitizeModelicaId(link.to)}";`);
      if (link.strength !== void 0 && includeMetrics) {
        lines.push(`    constant Real strength = ${link.strength.toFixed(3)};`);
      }
      if (link.confidence !== void 0 && includeMetrics) {
        lines.push(`    constant Real confidence = ${link.confidence.toFixed(3)};`);
      }
      if (link.mechanism) {
        lines.push(`    constant String mechanism = "${escapeModelicaString(link.mechanism)}";`);
      }
      lines.push(`  end Link_${i + 1};`);
      lines.push("");
    }
  }
  if (modelicaIncludeAnnotations) {
    lines.push("  annotation(");
    lines.push('    Documentation(info="<html>');
    lines.push(`      <p>Causes: ${causes.length}</p>`);
    lines.push(`      <p>Effects: ${effects.length}</p>`);
    lines.push(`      <p>Total Nodes: ${thought.causalGraph.nodes.length}</p>`);
    lines.push(`      <p>Edges: ${thought.causalGraph.edges?.length || 0}</p>`);
    lines.push("      <p>Generated by DeepThinking MCP v7.1.0</p>");
    lines.push('    </html>")');
    lines.push("  );");
  }
  lines.push(`end ${sanitizeModelicaId(packageName)};`);
  return lines.join("\n");
}
function causalToUML(thought, options) {
  const { umlTheme, umlDirection, includeLabels = true, includeMetrics = true } = options;
  if (!thought.causalGraph || !thought.causalGraph.nodes) {
    const emptyNodes = [
      { id: "no_data", label: "No causal graph data", shape: "rectangle" }
    ];
    return generateUmlDiagram(emptyNodes, [], {
      title: "Causal Graph",
      theme: umlTheme,
      direction: umlDirection
    });
  }
  const nodes = [];
  const edges = [];
  const causes = thought.causalGraph.nodes.filter((n) => n.type === "cause");
  for (const cause of causes) {
    const id = sanitizeModelicaId(cause.id);
    nodes.push({
      id: `cause_${id}`,
      label: includeLabels ? cause.name.substring(0, 40) : id,
      shape: "rectangle",
      color: "FFB74D"
    });
  }
  const effects = thought.causalGraph.nodes.filter((n) => n.type === "effect");
  for (const effect of effects) {
    const id = sanitizeModelicaId(effect.id);
    nodes.push({
      id: `effect_${id}`,
      label: includeLabels ? effect.name.substring(0, 40) : id,
      shape: "rectangle",
      color: "4FC3F7"
    });
  }
  const mediators = thought.causalGraph.nodes.filter((n) => n.type === "mediator");
  for (const mediator of mediators) {
    const id = sanitizeModelicaId(mediator.id);
    nodes.push({
      id: `mediator_${id}`,
      label: includeLabels ? mediator.name.substring(0, 40) : id,
      shape: "rectangle",
      color: "81C784"
    });
  }
  const confounders = thought.causalGraph.nodes.filter((n) => n.type === "confounder");
  for (const confounder of confounders) {
    const id = sanitizeModelicaId(confounder.id);
    nodes.push({
      id: `confounder_${id}`,
      label: includeLabels ? confounder.name.substring(0, 40) : id,
      shape: "cloud",
      color: "E57373"
    });
  }
  if (thought.causalGraph.edges) {
    for (const link of thought.causalGraph.edges) {
      const label = includeMetrics && link.strength !== void 0 ? `${link.strength.toFixed(2)}` : void 0;
      const sourceNode = thought.causalGraph.nodes.find((n) => n.id === link.from);
      const targetNode = thought.causalGraph.nodes.find((n) => n.id === link.to);
      const sourcePrefix = sourceNode?.type || "node";
      const targetPrefix = targetNode?.type || "node";
      edges.push({
        source: `${sourcePrefix}_${sanitizeModelicaId(link.from)}`,
        target: `${targetPrefix}_${sanitizeModelicaId(link.to)}`,
        type: "arrow",
        label
      });
    }
  }
  return generateUmlDiagram(nodes, edges, {
    title: "Causal Graph",
    theme: umlTheme,
    direction: umlDirection
  });
}
function causalToJSON(thought, options) {
  const { jsonPrettyPrint = true, jsonIndent = 2, includeMetrics = true } = options;
  if (!thought.causalGraph || !thought.causalGraph.nodes) {
    const emptyData = {
      type: "causal",
      title: "Causal Graph",
      nodes: [],
      edges: []
    };
    return jsonPrettyPrint ? JSON.stringify(emptyData, null, jsonIndent) : JSON.stringify(emptyData);
  }
  const causes = thought.causalGraph.nodes.filter((n) => n.type === "cause").map((c) => ({
    id: sanitizeModelicaId(c.id),
    label: c.name,
    description: c.description
  }));
  const effects = thought.causalGraph.nodes.filter((n) => n.type === "effect").map((e) => ({
    id: sanitizeModelicaId(e.id),
    label: e.name,
    description: e.description
  }));
  const links = (thought.causalGraph.edges || []).map((l) => ({
    cause: sanitizeModelicaId(l.from),
    effect: sanitizeModelicaId(l.to),
    strength: includeMetrics ? l.strength : void 0,
    confidence: includeMetrics ? l.confidence : void 0,
    mechanism: l.mechanism
  }));
  return generateCausalJson(
    "Causal Graph",
    "causal",
    causes,
    effects,
    links,
    {
      prettyPrint: jsonPrettyPrint,
      indent: jsonIndent,
      includeMetrics
    }
  );
}
function causalToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  if (!thought.causalGraph || !thought.causalGraph.nodes) {
    parts.push(section("Status", "No causal graph data available."));
    return document("Causal Graph Analysis", parts.join("\n"), {
      includeFrontmatter: markdownIncludeFrontmatter,
      includeTableOfContents: markdownIncludeToc
    });
  }
  const causes = thought.causalGraph.nodes.filter((n) => n.type === "cause");
  const effects = thought.causalGraph.nodes.filter((n) => n.type === "effect");
  const mediators = thought.causalGraph.nodes.filter((n) => n.type === "mediator");
  const confounders = thought.causalGraph.nodes.filter((n) => n.type === "confounder");
  if (includeMetrics) {
    const metricsContent = keyValueSection({
      "Total Nodes": thought.causalGraph.nodes.length,
      "Edges": thought.causalGraph.edges.length,
      "Causes": causes.length,
      "Effects": effects.length,
      "Mediators": mediators.length,
      "Confounders": confounders.length
    });
    parts.push(section("Metrics", metricsContent));
  }
  const nodeRows = thought.causalGraph.nodes.map((node) => [
    node.id,
    node.name,
    node.type.toUpperCase(),
    node.description || "-"
  ]);
  parts.push(section("Nodes", table(["ID", "Name", "Type", "Description"], nodeRows)));
  const edgeRows = thought.causalGraph.edges.map((edge) => {
    const fromNode = thought.causalGraph.nodes.find((n) => n.id === edge.from);
    const toNode = thought.causalGraph.nodes.find((n) => n.id === edge.to);
    return [
      fromNode?.name || edge.from,
      toNode?.name || edge.to,
      edge.strength !== void 0 ? edge.strength.toFixed(2) : "-",
      edge.mechanism || "-"
    ];
  });
  parts.push(section("Causal Relationships", table(["From", "To", "Strength", "Mechanism"], edgeRows)));
  if (confounders.length > 0) {
    const confounderList = confounders.map((c) => `**${c.name}**: ${c.description}`);
    parts.push(section("\u26A0\uFE0F Confounding Variables", list(confounderList)));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = causalGraphToMermaid(thought, "default", true, true);
    parts.push(section("Causal Graph Diagram", mermaidBlock(mermaidDiagram)));
  }
  return document("Causal Graph Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "causal",
      nodeCount: thought.causalGraph.nodes.length,
      edgeCount: thought.causalGraph.edges.length
    }
  });
}
var init_causal = __esm({
  "src/export/visual/modes/causal.ts"() {
    init_esm_shims();
    init_utils();
    init_svg();
    init_graphml();
    init_tikz();
    init_html();
    init_modelica();
    init_uml();
    init_json();
    init_markdown();
  }
});

// src/export/visual/modes/temporal.ts
function exportTemporalTimeline(thought, options) {
  const { format, includeLabels = true } = options;
  switch (format) {
    case "mermaid":
      return timelineToMermaidGantt(thought, includeLabels);
    case "dot":
      return timelineToDOT(thought, includeLabels);
    case "ascii":
      return timelineToASCII(thought);
    case "svg":
      return timelineToSVG(thought, options);
    case "graphml":
      return timelineToGraphML(thought);
    case "tikz":
      return timelineToTikZ(thought);
    case "html":
      return timelineToHTML(thought, options);
    case "modelica":
      return temporalToModelica(thought);
    case "uml":
      return temporalToUML(thought);
    case "json":
      return temporalToJSON(thought, options);
    case "markdown":
      return temporalToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function timelineToMermaidGantt(thought, includeLabels) {
  let gantt = "gantt\n";
  gantt += `  title ${thought.timeline?.name || "Timeline"}
`;
  gantt += "  dateFormat X\n";
  gantt += "  axisFormat %s\n\n";
  if (!thought.events || thought.events.length === 0) {
    return gantt + "  No events\n";
  }
  gantt += "  section Events\n";
  for (const event of thought.events) {
    const label = includeLabels ? event.name : event.id;
    if (event.type === "instant") {
      gantt += `  ${label} :milestone, ${event.timestamp}, 0s
`;
    } else if (event.type === "interval" && event.duration) {
      gantt += `  ${label} :${event.timestamp}, ${event.duration}s
`;
    }
  }
  return gantt;
}
function timelineToDOT(thought, includeLabels) {
  let dot = "digraph Timeline {\n";
  dot += "  rankdir=LR;\n";
  dot += "  node [shape=box];\n\n";
  if (!thought.events) {
    dot += "}\n";
    return dot;
  }
  const sortedEvents = [...thought.events].sort((a, b) => a.timestamp - b.timestamp);
  for (const event of sortedEvents) {
    const nodeId = sanitizeId(event.id);
    const label = includeLabels ? `${event.name}\\n(t=${event.timestamp})` : nodeId;
    const shape = event.type === "instant" ? "ellipse" : "box";
    dot += `  ${nodeId} [label="${label}", shape=${shape}];
`;
  }
  dot += "\n";
  for (let i = 0; i < sortedEvents.length - 1; i++) {
    const from = sanitizeId(sortedEvents[i].id);
    const to = sanitizeId(sortedEvents[i + 1].id);
    dot += `  ${from} -> ${to};
`;
  }
  if (thought.relations) {
    dot += "\n  // Causal relations\n";
    for (const rel of thought.relations) {
      const from = sanitizeId(rel.from);
      const to = sanitizeId(rel.to);
      dot += `  ${from} -> ${to} [style=dashed, label="${rel.relationType}"];
`;
    }
  }
  dot += "}\n";
  return dot;
}
function timelineToASCII(thought) {
  let ascii = `Timeline: ${thought.timeline?.name || "Untitled"}
`;
  ascii += "=".repeat(40) + "\n\n";
  if (!thought.events || thought.events.length === 0) {
    return ascii + "No events\n";
  }
  const sortedEvents = [...thought.events].sort((a, b) => a.timestamp - b.timestamp);
  for (const event of sortedEvents) {
    const marker = event.type === "instant" ? "\u29BF" : "\u2501";
    ascii += `t=${event.timestamp.toString().padStart(4)} ${marker} ${event.name}
`;
    if (event.duration) {
      ascii += `       ${"\u2514".padStart(5)}\u2192 duration: ${event.duration}
`;
    }
  }
  return ascii;
}
function timelineToGraphML(thought, _options) {
  if (!thought.events || thought.events.length === 0) {
    return createLinearGraphML([], {
      graphName: thought.timeline?.name || "Timeline",
      directed: true
    });
  }
  const sortedEvents = [...thought.events].sort((a, b) => a.timestamp - b.timestamp);
  const labels = sortedEvents.map((event) => event.name);
  return createLinearGraphML(labels, {
    graphName: thought.timeline?.name || "Timeline",
    directed: true
  });
}
function timelineToTikZ(thought, _options) {
  if (!thought.events || thought.events.length === 0) {
    return createLinearTikZ([], {
      title: thought.timeline?.name || "Timeline"
    });
  }
  const sortedEvents = [...thought.events].sort((a, b) => a.timestamp - b.timestamp);
  const labels = sortedEvents.map((event) => event.name);
  return createLinearTikZ(labels, {
    title: thought.timeline?.name || "Timeline"
  });
}
function timelineToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width,
    svgHeight = 300
  } = options;
  const title = thought.timeline?.name || "Timeline";
  if (!thought.events || thought.events.length === 0) {
    return generateSVGHeader(svgWidth, 200, title) + '\n  <text x="400" y="100" text-anchor="middle" class="subtitle">No events</text>\n' + generateSVGFooter();
  }
  const sortedEvents = [...thought.events].sort((a, b) => a.timestamp - b.timestamp);
  const nodes = sortedEvents.map((event) => ({
    id: event.id,
    label: includeLabels ? event.name : event.id,
    type: event.type
  }));
  const positions = layoutNodesHorizontally(nodes, {
    width: svgWidth,
    height: svgHeight,
    nodeWidth: 120,
    nodeHeight: 40,
    nodeSpacing: 30
  });
  let svg = generateSVGHeader(svgWidth, svgHeight, title);
  const axisY = svgHeight / 2 + 40;
  svg += `
  <!-- Timeline Axis -->
  <line x1="40" y1="${axisY}" x2="${svgWidth - 40}" y2="${axisY}" stroke="#333" stroke-width="2" marker-end="url(#arrowhead)"/>`;
  svg += '\n\n  <!-- Edges -->\n  <g class="edges">';
  for (let i = 0; i < sortedEvents.length - 1; i++) {
    const fromPos = positions.get(sortedEvents[i].id);
    const toPos = positions.get(sortedEvents[i + 1].id);
    if (fromPos && toPos) {
      svg += renderHorizontalEdge(fromPos, toPos, {});
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  for (const event of sortedEvents) {
    const pos = positions.get(event.id);
    if (pos) {
      const colors = event.type === "instant" ? getNodeColor("primary", colorScheme) : getNodeColor("secondary", colorScheme);
      if (event.type === "instant") {
        svg += renderEllipseNode(pos, colors);
      } else {
        svg += renderRectNode(pos, colors);
      }
      svg += `
    <text x="${pos.x}" y="${pos.y + pos.height + 15}" text-anchor="middle" class="edge-label">t=${event.timestamp}</text>`;
    }
  }
  svg += "\n  </g>";
  const legendItems = [
    { label: "Instant", color: getNodeColor("primary", colorScheme), shape: "ellipse" },
    { label: "Interval", color: getNodeColor("secondary", colorScheme) }
  ];
  svg += renderLegend(20, svgHeight - 60, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function timelineToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = thought.timeline?.name || "Timeline Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  if (!thought.events || thought.events.length === 0) {
    html += '<p class="text-secondary">No events in timeline.</p>\n';
    html += generateHTMLFooter(htmlStandalone);
    return html;
  }
  const sortedEvents = [...thought.events].sort((a, b) => a.timestamp - b.timestamp);
  if (includeMetrics) {
    const instants = sortedEvents.filter((e) => e.type === "instant");
    const intervals = sortedEvents.filter((e) => e.type === "interval");
    const minTime = sortedEvents[0].timestamp;
    const maxTime = sortedEvents[sortedEvents.length - 1].timestamp;
    html += '<div class="metrics-grid">';
    html += renderMetricCard("Total Events", sortedEvents.length, "primary");
    html += renderMetricCard("Instants", instants.length, "info");
    html += renderMetricCard("Intervals", intervals.length, "success");
    html += renderMetricCard("Time Span", `${minTime} - ${maxTime}`);
    html += "</div>\n";
  }
  const eventRows = sortedEvents.map((event) => {
    const typeBadge = renderBadge(event.type, event.type === "instant" ? "info" : "success");
    return [
      event.timestamp.toString(),
      event.name,
      typeBadge,
      event.duration ? `${event.duration}` : "-",
      event.description || "-"
    ];
  });
  html += renderSection("Events", renderTable(
    ["Timestamp", "Name", "Type", "Duration", "Description"],
    eventRows.map((row) => row.map((cell) => typeof cell === "string" && cell.startsWith("<") ? cell : escapeHTML(String(cell))))
  ), "\u{1F4C5}");
  if (thought.relations && thought.relations.length > 0) {
    const relationRows = thought.relations.map((rel) => {
      const fromEvent = thought.events?.find((e) => e.id === rel.from);
      const toEvent = thought.events?.find((e) => e.id === rel.to);
      return [
        fromEvent?.name || rel.from,
        rel.relationType,
        toEvent?.name || rel.to
      ];
    });
    html += renderSection("Temporal Relations", renderTable(
      ["From", "Relation", "To"],
      relationRows
    ), "\u{1F517}");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function temporalToModelica(thought, _options) {
  const pkgName = sanitizeModelicaId(thought.timeline?.name || "Timeline");
  let modelica = `package ${pkgName}
`;
  modelica += `  "${escapeModelicaString(thought.timeline?.name || "Timeline")} - Temporal Event System"

`;
  if (!thought.events || thought.events.length === 0) {
    modelica += "  // No events\n";
    modelica += `end ${pkgName};
`;
    return modelica;
  }
  const sortedEvents = [...thought.events].sort((a, b) => a.timestamp - b.timestamp);
  modelica += "  // Event Records\n";
  for (const event of sortedEvents) {
    const eventId = sanitizeModelicaId(event.id);
    modelica += `  record ${eventId}
`;
    modelica += `    "${escapeModelicaString(event.name)}"
`;
    modelica += `    parameter Real timestamp = ${event.timestamp} "Event timestamp";
`;
    if (event.duration !== void 0) {
      modelica += `    parameter Real duration = ${event.duration} "Event duration";
`;
    }
    modelica += `    parameter String eventType = "${event.type}" "Event type (instant/interval)";
`;
    if (event.description) {
      modelica += `    parameter String description = "${escapeModelicaString(event.description)}";
`;
    }
    modelica += `  end ${eventId};

`;
  }
  modelica += "  model TimelineModel\n";
  modelica += '    "Temporal event sequence model"\n\n';
  modelica += "    parameter Real timeStart = " + sortedEvents[0].timestamp + ' "Timeline start";\n';
  modelica += "    parameter Real timeEnd = " + sortedEvents[sortedEvents.length - 1].timestamp + ' "Timeline end";\n';
  modelica += `    parameter Integer eventCount = ${sortedEvents.length} "Total number of events";

`;
  modelica += "    // Event instances\n";
  for (const event of sortedEvents) {
    const eventId = sanitizeModelicaId(event.id);
    modelica += `    ${eventId} ${eventId.toLowerCase()}_inst;
`;
  }
  modelica += "\n    // Timeline progression\n";
  modelica += "    discrete Real currentTime(start=timeStart);\n";
  modelica += "  equation\n";
  modelica += "    when time >= timeEnd then\n";
  modelica += "      currentTime = timeEnd;\n";
  modelica += "    end when;\n";
  modelica += "  end TimelineModel;\n\n";
  modelica += `end ${pkgName};
`;
  return modelica;
}
function temporalToUML(thought, _options) {
  if (!thought.events || thought.events.length === 0) {
    return generateStateDiagram([], [], void 0, { title: thought.timeline?.name || "Timeline" });
  }
  const sortedEvents = [...thought.events].sort((a, b) => a.timestamp - b.timestamp);
  const states = sortedEvents.map((event) => event.name);
  const transitions = [];
  for (let i = 0; i < sortedEvents.length - 1; i++) {
    transitions.push({
      from: sortedEvents[i].id,
      to: sortedEvents[i + 1].id,
      event: `\u0394t=${sortedEvents[i + 1].timestamp - sortedEvents[i].timestamp}`
    });
  }
  if (thought.relations) {
    for (const rel of thought.relations) {
      transitions.push({
        from: rel.from,
        to: rel.to,
        event: rel.relationType
      });
    }
  }
  return generateStateDiagram(states, transitions, void 0, { title: thought.timeline?.name || "Timeline" });
}
function temporalToJSON(thought, _options) {
  const graph = createJsonGraph(
    thought.timeline?.name || "Timeline",
    "temporal",
    _options
  );
  if (!thought.events || thought.events.length === 0) {
    return serializeGraph(graph, _options);
  }
  const sortedEvents = [...thought.events].sort((a, b) => a.timestamp - b.timestamp);
  for (const event of sortedEvents) {
    addNode(graph, {
      id: event.id,
      label: event.name,
      type: event.type,
      metadata: {
        timestamp: event.timestamp,
        duration: event.duration,
        description: event.description
      }
    });
  }
  for (let i = 0; i < sortedEvents.length - 1; i++) {
    addEdge(graph, {
      id: `edge_${i}`,
      source: sortedEvents[i].id,
      target: sortedEvents[i + 1].id,
      label: "temporal_next",
      metadata: {
        timeDelta: sortedEvents[i + 1].timestamp - sortedEvents[i].timestamp
      }
    });
  }
  if (thought.relations) {
    let relIdx = sortedEvents.length - 1;
    for (const rel of thought.relations) {
      addEdge(graph, {
        id: `edge_rel_${relIdx++}`,
        source: rel.from,
        target: rel.to,
        label: rel.relationType,
        metadata: {
          edgeType: "causal"
        }
      });
    }
  }
  const instants = sortedEvents.filter((e) => e.type === "instant");
  const intervals = sortedEvents.filter((e) => e.type === "interval");
  addMetric(graph, "totalEvents", sortedEvents.length);
  addMetric(graph, "instantEvents", instants.length);
  addMetric(graph, "intervalEvents", intervals.length);
  addMetric(graph, "timeStart", sortedEvents[0].timestamp);
  addMetric(graph, "timeEnd", sortedEvents[sortedEvents.length - 1].timestamp);
  addMetric(graph, "timeSpan", sortedEvents[sortedEvents.length - 1].timestamp - sortedEvents[0].timestamp);
  return serializeGraph(graph, _options);
}
function temporalToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  const title = thought.timeline?.name || "Timeline";
  if (!thought.events || thought.events.length === 0) {
    parts.push(section("Status", "No events in timeline."));
    return document(`Temporal Analysis: ${title}`, parts.join("\n"), {
      includeFrontmatter: markdownIncludeFrontmatter,
      includeTableOfContents: markdownIncludeToc
    });
  }
  const sortedEvents = [...thought.events].sort((a, b) => a.timestamp - b.timestamp);
  const instants = sortedEvents.filter((e) => e.type === "instant");
  const intervals = sortedEvents.filter((e) => e.type === "interval");
  if (includeMetrics) {
    const metricsContent = keyValueSection({
      "Total Events": sortedEvents.length,
      "Instant Events": instants.length,
      "Interval Events": intervals.length,
      "Time Span": `${sortedEvents[0].timestamp} - ${sortedEvents[sortedEvents.length - 1].timestamp}`
    });
    parts.push(section("Metrics", metricsContent));
  }
  const eventRows = sortedEvents.map((event) => [
    event.timestamp.toString(),
    event.name,
    event.type.toUpperCase(),
    event.duration ? `${event.duration}` : "-",
    event.description || "-"
  ]);
  parts.push(section("Events", table(["Timestamp", "Name", "Type", "Duration", "Description"], eventRows)));
  if (thought.relations && thought.relations.length > 0) {
    const relationRows = thought.relations.map((rel) => {
      const fromEvent = thought.events?.find((e) => e.id === rel.from);
      const toEvent = thought.events?.find((e) => e.id === rel.to);
      return [
        fromEvent?.name || rel.from,
        rel.relationType,
        toEvent?.name || rel.to
      ];
    });
    parts.push(section("Temporal Relations", table(["From", "Relation", "To"], relationRows)));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = timelineToMermaidGantt(thought, true);
    parts.push(section("Timeline Diagram", mermaidBlock(mermaidDiagram)));
  }
  return document(`Temporal Analysis: ${title}`, parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "temporal",
      eventCount: sortedEvents.length
    }
  });
}
var init_temporal = __esm({
  "src/export/visual/modes/temporal.ts"() {
    init_esm_shims();
    init_utils();
    init_svg();
    init_graphml();
    init_tikz();
    init_html();
    init_modelica();
    init_uml();
    init_json();
    init_markdown();
  }
});

// src/export/visual/modes/counterfactual.ts
function exportCounterfactualScenarios(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return counterfactualToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return counterfactualToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return counterfactualToASCII(thought);
    case "svg":
      return counterfactualToSVG(thought, options);
    case "graphml":
      return counterfactualToGraphML(thought, options);
    case "tikz":
      return counterfactualToTikZ(thought, options);
    case "html":
      return counterfactualToHTML(thought, options);
    case "modelica":
      return counterfactualToModelica(thought, options);
    case "uml":
      return counterfactualToUML(thought, options);
    case "json":
      return counterfactualToJSON(thought, options);
    case "markdown":
      return counterfactualToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function counterfactualToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TD\n";
  const interventionId = "intervention";
  mermaid += `  ${interventionId}["${thought.interventionPoint.description}"]
`;
  const actualId = sanitizeId(thought.actual.id);
  const actualLabel = includeLabels ? thought.actual.name : actualId;
  mermaid += `  ${actualId}["Actual: ${actualLabel}"]
`;
  mermaid += `  ${interventionId} -->|no change| ${actualId}
`;
  for (const scenario of thought.counterfactuals) {
    const scenarioId = sanitizeId(scenario.id);
    const label = includeLabels ? scenario.name : scenarioId;
    const likelihoodLabel = includeMetrics && scenario.likelihood ? ` (${scenario.likelihood.toFixed(2)})` : "";
    mermaid += `  ${scenarioId}["CF: ${label}${likelihoodLabel}"]
`;
    mermaid += `  ${interventionId} -->|intervene| ${scenarioId}
`;
  }
  if (colorScheme !== "monochrome") {
    mermaid += "\n";
    const actualColor = colorScheme === "pastel" ? "#fff3e0" : "#ffd699";
    mermaid += `  style ${actualId} fill:${actualColor}
`;
    const cfColor = colorScheme === "pastel" ? "#e1f5ff" : "#a8d5ff";
    for (const scenario of thought.counterfactuals) {
      const scenarioId = sanitizeId(scenario.id);
      mermaid += `  style ${scenarioId} fill:${cfColor}
`;
    }
  }
  return mermaid;
}
function counterfactualToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph CounterfactualScenarios {\n";
  dot += "  rankdir=TD;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  const interventionId = "intervention";
  dot += `  ${interventionId} [label="${thought.interventionPoint.description}", shape=diamond];

`;
  const actualId = sanitizeId(thought.actual.id);
  const actualLabel = includeLabels ? thought.actual.name : actualId;
  dot += `  ${actualId} [label="Actual: ${actualLabel}", style=filled, fillcolor=lightyellow];
`;
  dot += `  ${interventionId} -> ${actualId} [label="no change"];

`;
  for (const scenario of thought.counterfactuals) {
    const scenarioId = sanitizeId(scenario.id);
    const label = includeLabels ? scenario.name : scenarioId;
    const likelihoodLabel = includeMetrics && scenario.likelihood ? ` (${scenario.likelihood.toFixed(2)})` : "";
    dot += `  ${scenarioId} [label="CF: ${label}${likelihoodLabel}", style=filled, fillcolor=lightblue];
`;
    dot += `  ${interventionId} -> ${scenarioId} [label="intervene"];
`;
  }
  dot += "}\n";
  return dot;
}
function counterfactualToASCII(thought) {
  let ascii = "Counterfactual Scenario Tree:\n";
  ascii += "=============================\n\n";
  ascii += `Intervention Point: ${thought.interventionPoint.description}
`;
  ascii += `Timing: ${thought.interventionPoint.timing}
`;
  ascii += `Feasibility: ${thought.interventionPoint.feasibility.toFixed(2)}

`;
  ascii += "\u250C\u2500 Actual Scenario:\n";
  ascii += `\u2502  ${thought.actual.name}
`;
  ascii += `\u2502  ${thought.actual.description}

`;
  ascii += "\u2514\u2500 Counterfactual Scenarios:\n";
  for (const scenario of thought.counterfactuals) {
    const likelihoodStr = scenario.likelihood ? ` (likelihood: ${scenario.likelihood.toFixed(2)})` : "";
    ascii += `   \u251C\u2500 ${scenario.name}${likelihoodStr}
`;
    ascii += `   \u2502  ${scenario.description}
`;
  }
  return ascii;
}
function counterfactualToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width
  } = options;
  const positions = /* @__PURE__ */ new Map();
  const nodeWidth = 150;
  const nodeHeight = 40;
  const interventionId = "intervention";
  positions.set(interventionId, {
    id: interventionId,
    label: includeLabels ? thought.interventionPoint.description : interventionId,
    x: svgWidth / 2,
    y: 80,
    width: nodeWidth,
    height: nodeHeight,
    type: "intervention"
  });
  const actualId = thought.actual.id;
  const actualLabel = includeLabels ? `Actual: ${thought.actual.name}` : actualId;
  positions.set(actualId, {
    id: actualId,
    label: actualLabel,
    x: svgWidth / 4,
    y: 200,
    width: nodeWidth,
    height: nodeHeight,
    type: "actual"
  });
  const cfCount = thought.counterfactuals.length;
  const cfStartY = 200;
  const cfSpacing = 120;
  thought.counterfactuals.forEach((scenario, index) => {
    const cfLabel = includeLabels ? `CF: ${scenario.name}` : scenario.id;
    positions.set(scenario.id, {
      id: scenario.id,
      label: cfLabel,
      x: svgWidth * 3 / 4,
      y: cfStartY + index * cfSpacing,
      width: nodeWidth,
      height: nodeHeight,
      type: "counterfactual"
    });
  });
  const actualHeight = Math.max(DEFAULT_SVG_OPTIONS.height, cfStartY + (cfCount - 1) * cfSpacing + 150);
  let svg = generateSVGHeader(svgWidth, actualHeight, "Counterfactual Scenarios");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  const interventionPos = positions.get(interventionId);
  const actualPos = positions.get(actualId);
  svg += renderEdge(interventionPos, actualPos, { label: "no change" });
  for (const scenario of thought.counterfactuals) {
    const cfPos = positions.get(scenario.id);
    if (cfPos) {
      const label = includeMetrics && scenario.likelihood ? `${scenario.likelihood.toFixed(2)}` : "intervene";
      svg += renderEdge(interventionPos, cfPos, { label });
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  const interventionColors = getNodeColor("warning", colorScheme);
  svg += `
    <polygon points="${interventionPos.x},${interventionPos.y - 30} ${interventionPos.x + 40},${interventionPos.y} ${interventionPos.x},${interventionPos.y + 30} ${interventionPos.x - 40},${interventionPos.y}" fill="${interventionColors.fill}" stroke="${interventionColors.stroke}" stroke-width="2"/>`;
  svg += `
    <text x="${interventionPos.x}" y="${interventionPos.y + 5}" text-anchor="middle" class="node-label">${interventionPos.label}</text>`;
  const actualColors = getNodeColor("tertiary", colorScheme);
  svg += renderRectNode(actualPos, actualColors);
  const cfColors = getNodeColor("primary", colorScheme);
  for (const [id, pos] of positions) {
    if (id !== interventionId && id !== actualId) {
      svg += renderStadiumNode(pos, cfColors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Counterfactuals", value: thought.counterfactuals.length },
      { label: "Feasibility", value: thought.interventionPoint.feasibility.toFixed(2) }
    ];
    svg += renderMetricsPanel(svgWidth - 180, actualHeight - 110, metrics);
  }
  const legendItems = [
    { label: "Intervention", color: interventionColors, shape: "diamond" },
    { label: "Actual", color: actualColors },
    { label: "Counterfactual", color: cfColors, shape: "stadium" }
  ];
  svg += renderLegend(20, actualHeight - 110, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function counterfactualToGraphML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  nodes.push({
    id: "intervention",
    label: includeLabels ? thought.interventionPoint.description : "intervention",
    type: "intervention",
    metadata: {
      timing: thought.interventionPoint.timing,
      feasibility: thought.interventionPoint.feasibility
    }
  });
  nodes.push({
    id: thought.actual.id,
    label: includeLabels ? `Actual: ${thought.actual.name}` : thought.actual.id,
    type: "actual",
    metadata: {
      description: thought.actual.description
    }
  });
  for (const scenario of thought.counterfactuals) {
    nodes.push({
      id: scenario.id,
      label: includeLabels ? `CF: ${scenario.name}` : scenario.id,
      type: "counterfactual",
      metadata: {
        description: scenario.description,
        likelihood: scenario.likelihood
      }
    });
  }
  const edges = [];
  edges.push({
    id: "e_intervention_actual",
    source: "intervention",
    target: thought.actual.id,
    label: "no change"
  });
  for (let i = 0; i < thought.counterfactuals.length; i++) {
    const scenario = thought.counterfactuals[i];
    edges.push({
      id: `e_intervention_cf${i}`,
      source: "intervention",
      target: scenario.id,
      label: "intervene",
      metadata: includeMetrics && scenario.likelihood !== void 0 ? { weight: scenario.likelihood } : void 0
    });
  }
  const graphmlOptions = {
    graphName: "Counterfactual Scenarios"
  };
  return generateGraphML(nodes, edges, graphmlOptions);
}
function counterfactualToTikZ(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  nodes.push({
    id: "intervention",
    label: includeLabels ? thought.interventionPoint.description : "intervention",
    x: 4,
    y: 0,
    type: "intervention",
    shape: "diamond"
  });
  nodes.push({
    id: thought.actual.id,
    label: includeLabels ? `Actual: ${thought.actual.name}` : thought.actual.id,
    x: 2,
    y: -2,
    type: "actual",
    shape: "rectangle"
  });
  const cfCount = thought.counterfactuals.length;
  const cfSpacing = 1.5;
  const cfStartY = -2;
  thought.counterfactuals.forEach((scenario, index) => {
    const yOffset = (cfCount - 1) * cfSpacing / 2;
    nodes.push({
      id: scenario.id,
      label: includeLabels ? `CF: ${scenario.name}` : scenario.id,
      x: 6,
      y: cfStartY - index * cfSpacing + yOffset,
      type: "counterfactual",
      shape: "ellipse"
    });
  });
  const edges = [];
  edges.push({
    source: "intervention",
    target: thought.actual.id,
    label: "no change",
    directed: true
  });
  for (const scenario of thought.counterfactuals) {
    edges.push({
      source: "intervention",
      target: scenario.id,
      label: includeMetrics && scenario.likelihood !== void 0 ? scenario.likelihood.toFixed(2) : "intervene",
      directed: true
    });
  }
  const tikzOptions = {
    title: "Counterfactual Scenarios"
  };
  return generateTikZ(nodes, edges, tikzOptions);
}
function counterfactualToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Counterfactual Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  if (includeMetrics) {
    html += '<div class="metrics-grid">';
    html += renderMetricCard("Counterfactuals", thought.counterfactuals.length, "primary");
    html += renderMetricCard("Feasibility", (thought.interventionPoint.feasibility * 100).toFixed(0) + "%", "info");
    html += renderMetricCard("Expected Impact", (thought.interventionPoint.expectedImpact * 100).toFixed(0) + "%", "success");
    html += "</div>\n";
  }
  html += renderSection("Intervention Point", `
    <p><strong>Description:</strong> ${escapeHTML(thought.interventionPoint.description)}</p>
    <p><strong>Timing:</strong> ${escapeHTML(thought.interventionPoint.timing)}</p>
    <p><strong>Feasibility:</strong> ${(thought.interventionPoint.feasibility * 100).toFixed(0)}%</p>
    <p><strong>Expected Impact:</strong> ${(thought.interventionPoint.expectedImpact * 100).toFixed(0)}%</p>
  `, "\u{1F500}");
  html += renderSection("Actual Outcome", `
    <div class="card">
      <div class="card-header">${escapeHTML(thought.actual.name)}</div>
      <p>${escapeHTML(thought.actual.description)}</p>
    </div>
  `, "\u2713");
  const cfRows = thought.counterfactuals.map((cf) => {
    const primaryOutcome = cf.outcomes[0];
    return [
      cf.name,
      primaryOutcome ? primaryOutcome.description.substring(0, 60) + (primaryOutcome.description.length > 60 ? "..." : "") : "-",
      cf.likelihood !== void 0 ? cf.likelihood.toFixed(2) : "-",
      primaryOutcome?.impact || "-"
    ];
  });
  html += renderSection("Counterfactual Scenarios", renderTable(
    ["Scenario", "Outcome", "Likelihood", "Impact"],
    cfRows
  ), "\u{1F52E}");
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function counterfactualToModelica(thought, options) {
  const { includeMetrics = true } = options;
  let modelica = "package CounterfactualScenarios\n";
  modelica += '  "Counterfactual scenario analysis with original vs. alternative outcomes"\n\n';
  modelica += "  record InterventionPoint\n";
  modelica += '    "The point at which the counterfactual diverges from the actual"\n';
  modelica += `    String description = "${escapeModelicaString(thought.interventionPoint.description)}";
`;
  modelica += `    String timing = "${escapeModelicaString(thought.interventionPoint.timing)}";
`;
  modelica += `    Real feasibility = ${thought.interventionPoint.feasibility};
`;
  modelica += `    Real expectedImpact = ${thought.interventionPoint.expectedImpact};
`;
  modelica += "  end InterventionPoint;\n\n";
  modelica += "  record ActualScenario\n";
  modelica += '    "The actual outcome that occurred"\n';
  modelica += `    String id = "${sanitizeModelicaId(thought.actual.id)}";
`;
  modelica += `    String name = "${escapeModelicaString(thought.actual.name)}";
`;
  modelica += `    String description = "${escapeModelicaString(thought.actual.description)}";
`;
  modelica += "  end ActualScenario;\n\n";
  for (let i = 0; i < thought.counterfactuals.length; i++) {
    const scenario = thought.counterfactuals[i];
    const recordName = sanitizeModelicaId(`CF_${scenario.id}`);
    modelica += `  record ${recordName}
`;
    modelica += `    "Counterfactual: ${escapeModelicaString(scenario.name)}"
`;
    modelica += `    String id = "${sanitizeModelicaId(scenario.id)}";
`;
    modelica += `    String name = "${escapeModelicaString(scenario.name)}";
`;
    modelica += `    String description = "${escapeModelicaString(scenario.description)}";
`;
    if (includeMetrics && scenario.likelihood !== void 0) {
      modelica += `    Real likelihood = ${scenario.likelihood};
`;
    }
    if (scenario.outcomes && scenario.outcomes.length > 0) {
      modelica += `    String outcomes[${scenario.outcomes.length}] = {`;
      modelica += scenario.outcomes.map((o) => `"${escapeModelicaString(o.description)}"`).join(", ");
      modelica += "};\n";
    }
    modelica += `  end ${recordName};

`;
  }
  modelica += "  model ScenarioDivergence\n";
  modelica += '    "Model showing the branching from intervention point to outcomes"\n';
  modelica += "    InterventionPoint intervention;\n";
  modelica += "    ActualScenario actual;\n";
  for (let i = 0; i < thought.counterfactuals.length; i++) {
    const scenario = thought.counterfactuals[i];
    const recordName = sanitizeModelicaId(`CF_${scenario.id}`);
    modelica += `    ${recordName} counterfactual${i + 1};
`;
  }
  if (includeMetrics) {
    modelica += '\n    annotation(Documentation(info="<html>\n';
    modelica += `      <p>Counterfactuals: ${thought.counterfactuals.length}</p>
`;
    modelica += `      <p>Feasibility: ${(thought.interventionPoint.feasibility * 100).toFixed(1)}%</p>
`;
    modelica += `      <p>Expected Impact: ${(thought.interventionPoint.expectedImpact * 100).toFixed(1)}%</p>
`;
    modelica += '    </html>"));\n';
  }
  modelica += "  end ScenarioDivergence;\n";
  modelica += "end CounterfactualScenarios;\n";
  return modelica;
}
function counterfactualToUML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  nodes.push({
    id: "intervention",
    label: includeLabels ? thought.interventionPoint.description : "Intervention",
    shape: "state",
    stereotype: "decision"
  });
  nodes.push({
    id: thought.actual.id,
    label: includeLabels ? `Actual: ${thought.actual.name}` : "Actual",
    shape: "state"
  });
  edges.push({
    source: "intervention",
    target: thought.actual.id,
    label: "no change",
    type: "arrow"
  });
  for (const scenario of thought.counterfactuals) {
    nodes.push({
      id: scenario.id,
      label: includeLabels ? `CF: ${scenario.name}` : scenario.id,
      shape: "state"
    });
    const edgeLabel = includeMetrics && scenario.likelihood !== void 0 ? `intervene (${scenario.likelihood.toFixed(2)})` : "intervene";
    edges.push({
      source: "intervention",
      target: scenario.id,
      label: edgeLabel,
      type: "arrow"
    });
  }
  return generateUmlDiagram(nodes, edges, {
    title: "Counterfactual Scenarios"});
}
function counterfactualToJSON(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const graph = createJsonGraph("counterfactual", "Counterfactual Scenarios");
  addNode(graph, {
    id: "intervention",
    label: includeLabels ? thought.interventionPoint.description : "Intervention",
    type: "intervention",
    metadata: {
      timing: thought.interventionPoint.timing,
      feasibility: thought.interventionPoint.feasibility,
      expectedImpact: thought.interventionPoint.expectedImpact
    }
  });
  addNode(graph, {
    id: thought.actual.id,
    label: includeLabels ? `Actual: ${thought.actual.name}` : thought.actual.id,
    type: "actual",
    metadata: {
      name: thought.actual.name,
      description: thought.actual.description
    }
  });
  addEdge(graph, {
    id: "e_intervention_actual",
    source: "intervention",
    target: thought.actual.id,
    label: "no change",
    type: "no_intervention"
  });
  for (let i = 0; i < thought.counterfactuals.length; i++) {
    const scenario = thought.counterfactuals[i];
    addNode(graph, {
      id: scenario.id,
      label: includeLabels ? `CF: ${scenario.name}` : scenario.id,
      type: "counterfactual",
      metadata: {
        name: scenario.name,
        description: scenario.description,
        likelihood: scenario.likelihood,
        outcomes: scenario.outcomes?.map((o) => ({
          description: o.description,
          impact: o.impact
        }))
      }
    });
    addEdge(graph, {
      id: `e_intervention_cf${i}`,
      source: "intervention",
      target: scenario.id,
      label: "intervene",
      type: "intervention",
      metadata: includeMetrics && scenario.likelihood !== void 0 ? { likelihood: scenario.likelihood } : void 0
    });
  }
  if (includeMetrics) {
    addMetric(graph, "counterfactualCount", thought.counterfactuals.length);
    addMetric(graph, "feasibility", thought.interventionPoint.feasibility);
    addMetric(graph, "expectedImpact", thought.interventionPoint.expectedImpact);
  }
  return serializeGraph(graph);
}
function counterfactualToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  if (includeMetrics) {
    parts.push(section("Metrics", keyValueSection({
      "Counterfactual Scenarios": thought.counterfactuals.length,
      "Intervention Feasibility": (thought.interventionPoint.feasibility * 100).toFixed(0) + "%",
      "Expected Impact": (thought.interventionPoint.expectedImpact * 100).toFixed(0) + "%"
    })));
  }
  parts.push(section("Intervention Point", keyValueSection({
    "Description": thought.interventionPoint.description,
    "Timing": thought.interventionPoint.timing,
    "Feasibility": (thought.interventionPoint.feasibility * 100).toFixed(0) + "%",
    "Expected Impact": (thought.interventionPoint.expectedImpact * 100).toFixed(0) + "%"
  })));
  parts.push(section(
    "Actual Scenario",
    `**Name:** ${thought.actual.name}

**Description:** ${thought.actual.description}`
  ));
  const cfRows = thought.counterfactuals.map((cf) => {
    const primaryOutcome = cf.outcomes[0];
    return [
      cf.name,
      cf.description.substring(0, 50) + (cf.description.length > 50 ? "..." : ""),
      cf.likelihood !== void 0 ? cf.likelihood.toFixed(2) : "N/A",
      primaryOutcome?.impact || "-"
    ];
  });
  parts.push(section("Counterfactual Scenarios", table(
    ["Name", "Description", "Likelihood", "Impact"],
    cfRows
  )));
  if (markdownIncludeMermaid) {
    const mermaid = counterfactualToMermaid(thought, "default", true, includeMetrics);
    parts.push(section("Visualization", mermaidBlock(mermaid)));
  }
  return document("Counterfactual Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: { mode: "counterfactual", scenarios: thought.counterfactuals.length }
  });
}
var init_counterfactual = __esm({
  "src/export/visual/modes/counterfactual.ts"() {
    init_esm_shims();
    init_utils();
    init_svg();
    init_graphml();
    init_tikz();
    init_html();
    init_modelica();
    init_uml();
    init_json();
    init_markdown();
  }
});

// src/export/visual/modes/bayesian.ts
function exportBayesianNetwork(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return bayesianToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return bayesianToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return bayesianToASCII(thought);
    case "svg":
      return bayesianToSVG(thought, options);
    case "graphml":
      return bayesianToGraphML(thought, options);
    case "tikz":
      return bayesianToTikZ(thought, options);
    case "html":
      return bayesianToHTML(thought, options);
    case "modelica":
      return bayesianToModelica(thought, options);
    case "uml":
      return bayesianToUML(thought, options);
    case "json":
      return bayesianToJSON(thought, options);
    case "markdown":
      return bayesianToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function bayesianToMermaid(thought, colorScheme, _includeLabels, includeMetrics) {
  let mermaid = "graph LR\n";
  mermaid += `  H([Hypothesis])
`;
  mermaid += `  Prior[Prior: ${includeMetrics ? thought.prior.probability.toFixed(3) : "?"}]
`;
  mermaid += `  Evidence[Evidence]
`;
  mermaid += `  Posterior[[Posterior: ${includeMetrics ? thought.posterior.probability.toFixed(3) : "?"}]]
`;
  mermaid += "\n";
  mermaid += "  Prior --> H\n";
  mermaid += "  Evidence --> H\n";
  mermaid += "  H --> Posterior\n";
  if (colorScheme !== "monochrome") {
    mermaid += "\n";
    const priorColor = colorScheme === "pastel" ? "#e1f5ff" : "#a8d5ff";
    const posteriorColor = colorScheme === "pastel" ? "#c8e6c9" : "#81c784";
    mermaid += `  style Prior fill:${priorColor}
`;
    mermaid += `  style Posterior fill:${posteriorColor}
`;
  }
  return mermaid;
}
function bayesianToDOT(thought, _includeLabels, includeMetrics) {
  let dot = "digraph BayesianNetwork {\n";
  dot += "  rankdir=LR;\n";
  dot += "  node [shape=ellipse];\n\n";
  const priorProb = includeMetrics ? `: ${thought.prior.probability.toFixed(3)}` : "";
  const posteriorProb = includeMetrics ? `: ${thought.posterior.probability.toFixed(3)}` : "";
  dot += `  Prior [label="Prior${priorProb}"];
`;
  dot += `  Hypothesis [label="Hypothesis", shape=box];
`;
  dot += `  Evidence [label="Evidence"];
`;
  dot += `  Posterior [label="Posterior${posteriorProb}", shape=doublecircle];
`;
  dot += "\n";
  dot += "  Prior -> Hypothesis;\n";
  dot += "  Evidence -> Hypothesis;\n";
  dot += "  Hypothesis -> Posterior;\n";
  dot += "}\n";
  return dot;
}
function bayesianToASCII(thought) {
  let ascii = "Bayesian Network:\n";
  ascii += "=================\n\n";
  ascii += `Hypothesis: ${thought.hypothesis.statement}

`;
  ascii += `Prior Probability: ${thought.prior.probability.toFixed(3)}
`;
  ascii += `  Justification: ${thought.prior.justification}

`;
  if (thought.evidence && thought.evidence.length > 0) {
    ascii += "Evidence:\n";
    for (const ev of thought.evidence) {
      ascii += `  \u2022 ${ev.description}
`;
    }
    ascii += "\n";
  }
  ascii += `Posterior Probability: ${thought.posterior.probability.toFixed(3)}
`;
  ascii += `  Calculation: ${thought.posterior.calculation}
`;
  if (thought.bayesFactor !== void 0) {
    ascii += `
Bayes Factor: ${thought.bayesFactor.toFixed(2)}
`;
  }
  return ascii;
}
function bayesianToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width,
    svgHeight = 400
  } = options;
  const nodeWidth = 140;
  const nodeHeight = 50;
  const centerX = svgWidth / 2;
  const positions = /* @__PURE__ */ new Map();
  positions.set("prior", {
    id: "prior",
    x: centerX - 200,
    y: 80,
    width: nodeWidth,
    height: nodeHeight,
    label: `Prior: ${includeMetrics ? thought.prior.probability.toFixed(3) : "?"}`,
    type: "prior"
  });
  positions.set("evidence", {
    id: "evidence",
    x: centerX + 60,
    y: 80,
    width: nodeWidth,
    height: nodeHeight,
    label: "Evidence",
    type: "evidence"
  });
  positions.set("hypothesis", {
    id: "hypothesis",
    x: centerX - nodeWidth / 2,
    y: 180,
    width: nodeWidth,
    height: nodeHeight,
    label: "Hypothesis",
    type: "hypothesis"
  });
  positions.set("posterior", {
    id: "posterior",
    x: centerX - nodeWidth / 2,
    y: 280,
    width: nodeWidth,
    height: nodeHeight,
    label: `Posterior: ${includeMetrics ? thought.posterior.probability.toFixed(3) : "?"}`,
    type: "posterior"
  });
  let svg = generateSVGHeader(svgWidth, svgHeight, "Bayesian Network");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  svg += renderEdge(positions.get("prior"), positions.get("hypothesis"), {});
  svg += renderEdge(positions.get("evidence"), positions.get("hypothesis"), {});
  svg += renderEdge(positions.get("hypothesis"), positions.get("posterior"), {});
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  svg += renderStadiumNode(positions.get("prior"), getNodeColor("primary", colorScheme));
  svg += renderRectNode(positions.get("evidence"), getNodeColor("info", colorScheme));
  svg += renderEllipseNode(positions.get("hypothesis"), getNodeColor("neutral", colorScheme));
  svg += renderStadiumNode(positions.get("posterior"), getNodeColor("success", colorScheme));
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Prior", value: thought.prior.probability.toFixed(3) },
      { label: "Posterior", value: thought.posterior.probability.toFixed(3) },
      { label: "Bayes Factor", value: thought.bayesFactor?.toFixed(2) || "N/A" }
    ];
    svg += renderMetricsPanel(svgWidth - 180, svgHeight - 100, metrics);
  }
  const legendItems = [
    { label: "Prior", color: getNodeColor("primary", colorScheme) },
    { label: "Evidence", color: getNodeColor("info", colorScheme) },
    { label: "Hypothesis", color: getNodeColor("neutral", colorScheme), shape: "ellipse" },
    { label: "Posterior", color: getNodeColor("success", colorScheme) }
  ];
  svg += renderLegend(20, svgHeight - 100, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function bayesianToGraphML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [
    { id: "prior", label: includeLabels ? `Prior: ${thought.prior.probability.toFixed(3)}` : "Prior", type: "prior" },
    { id: "hypothesis", label: "Hypothesis", type: "hypothesis" },
    { id: "evidence", label: "Evidence", type: "evidence" },
    { id: "posterior", label: includeLabels ? `Posterior: ${thought.posterior.probability.toFixed(3)}` : "Posterior", type: "posterior" }
  ];
  const edges = [
    { id: "e1", source: "prior", target: "hypothesis" },
    { id: "e2", source: "evidence", target: "hypothesis" },
    { id: "e3", source: "hypothesis", target: "posterior" }
  ];
  return generateGraphML(nodes, edges, {
    graphName: "Bayesian Network",
    includeLabels,
    includeMetadata: includeMetrics
  });
}
function bayesianToTikZ(thought, options) {
  const { includeLabels = true, includeMetrics = true, colorScheme = "default" } = options;
  const nodes = [
    { id: "prior", label: includeLabels ? `Prior: ${thought.prior.probability.toFixed(3)}` : "Prior", x: 0, y: 0, type: "primary", shape: "stadium" },
    { id: "evidence", label: "Evidence", x: 4, y: 0, type: "info", shape: "rectangle" },
    { id: "hypothesis", label: "Hypothesis", x: 2, y: -2, type: "neutral", shape: "ellipse" },
    { id: "posterior", label: includeLabels ? `Posterior: ${thought.posterior.probability.toFixed(3)}` : "Posterior", x: 2, y: -4, type: "success", shape: "stadium" }
  ];
  const edges = [
    { source: "prior", target: "hypothesis", directed: true },
    { source: "evidence", target: "hypothesis", directed: true },
    { source: "hypothesis", target: "posterior", directed: true }
  ];
  return generateTikZ(nodes, edges, {
    title: "Bayesian Network",
    includeLabels,
    includeMetrics,
    colorScheme
  });
}
function bayesianToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Bayesian Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  html += renderSection("Hypothesis", `
    <p><strong>${escapeHTML(thought.hypothesis.statement)}</strong></p>
    ${thought.hypothesis.alternatives && thought.hypothesis.alternatives.length > 0 ? `<p class="text-secondary">Alternatives: ${thought.hypothesis.alternatives.join(", ")}</p>` : ""}
  `, "\u{1F3AF}");
  if (includeMetrics) {
    html += '<div class="metrics-grid">';
    html += renderMetricCard("Prior", (thought.prior.probability * 100).toFixed(1) + "%", "primary");
    html += renderMetricCard("Posterior", (thought.posterior.probability * 100).toFixed(1) + "%", "success");
    if (thought.bayesFactor !== void 0) {
      html += renderMetricCard("Bayes Factor", thought.bayesFactor.toFixed(2), "info");
    }
    html += "</div>\n";
    html += '<div class="card">';
    html += '<div class="card-header">Prior Probability</div>';
    html += renderProgressBar(thought.prior.probability * 100, "primary");
    html += `<p class="text-secondary" style="margin-top: 0.5rem">${escapeHTML(thought.prior.justification)}</p>`;
    html += "</div>\n";
    html += '<div class="card">';
    html += '<div class="card-header">Posterior Probability</div>';
    html += renderProgressBar(thought.posterior.probability * 100, "success");
    html += `<p class="text-secondary" style="margin-top: 0.5rem">${escapeHTML(thought.posterior.calculation)}</p>`;
    html += "</div>\n";
  }
  if (thought.evidence && thought.evidence.length > 0) {
    const evidenceRows = thought.evidence.map((ev, i) => [
      (i + 1).toString(),
      ev.description,
      ev.likelihoodGivenHypothesis?.toFixed(3) || "-",
      ev.likelihoodGivenNotHypothesis?.toFixed(3) || "-"
    ]);
    html += renderSection("Evidence", renderTable(
      ["#", "Description", "P(E|H)", "P(E|\xACH)"],
      evidenceRows
    ), "\u{1F4CA}");
  }
  const change = thought.posterior.probability - thought.prior.probability;
  const changeDirection = change > 0 ? "increased" : change < 0 ? "decreased" : "unchanged";
  const changeClass = change > 0 ? "text-success" : change < 0 ? "text-danger" : "text-secondary";
  html += renderSection("Interpretation", `
    <p>The posterior probability has <span class="${changeClass}"><strong>${changeDirection}</strong></span>
    by ${Math.abs(change * 100).toFixed(1)} percentage points from the prior.</p>
    ${thought.bayesFactor !== void 0 ? `
      <p>Bayes Factor of ${thought.bayesFactor.toFixed(2)} indicates
      ${thought.bayesFactor > 3 ? "substantial" : thought.bayesFactor > 1 ? "weak" : "evidence against"}
      support for the hypothesis.</p>
    ` : ""}
  `, "\u{1F4A1}");
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function bayesianToModelica(thought, options) {
  const { modelicaPackageName, modelicaIncludeAnnotations = true, includeMetrics = true } = options;
  const packageName = modelicaPackageName || "BayesianNetwork";
  const lines = [];
  lines.push(`package ${sanitizeModelicaId(packageName)}`);
  lines.push(`  "Bayesian network analysis"`);
  lines.push("");
  lines.push("  record Hypothesis");
  lines.push(`    constant String statement = "${escapeModelicaString(thought.hypothesis.statement)}";`);
  if (thought.hypothesis.alternatives && thought.hypothesis.alternatives.length > 0) {
    lines.push(`    constant Integer alternativeCount = ${thought.hypothesis.alternatives.length};`);
  }
  lines.push("  end Hypothesis;");
  lines.push("");
  lines.push("  // Probability parameters");
  lines.push(`  parameter Real prior = ${thought.prior.probability.toFixed(6)} "Prior probability";`);
  lines.push(`  parameter Real posterior = ${thought.posterior.probability.toFixed(6)} "Posterior probability";`);
  if (thought.bayesFactor !== void 0) {
    lines.push(`  parameter Real bayesFactor = ${thought.bayesFactor.toFixed(6)} "Bayes factor";`);
  }
  lines.push("");
  if (includeMetrics) {
    lines.push("  // Computed metrics");
    lines.push(`  final parameter Real probabilityChange = posterior - prior;`);
    lines.push(`  final parameter Real updateRatio = posterior / max(prior, 1e-10);`);
    lines.push("");
  }
  if (thought.evidence && thought.evidence.length > 0) {
    lines.push("  // Evidence");
    for (let i = 0; i < thought.evidence.length; i++) {
      const ev = thought.evidence[i];
      lines.push(`  record Evidence_${i + 1}`);
      lines.push(`    constant String description = "${escapeModelicaString(ev.description)}";`);
      if (ev.likelihoodGivenHypothesis !== void 0) {
        lines.push(`    constant Real likelihoodGivenH = ${ev.likelihoodGivenHypothesis.toFixed(6)};`);
      }
      if (ev.likelihoodGivenNotHypothesis !== void 0) {
        lines.push(`    constant Real likelihoodGivenNotH = ${ev.likelihoodGivenNotHypothesis.toFixed(6)};`);
      }
      lines.push(`  end Evidence_${i + 1};`);
      lines.push("");
    }
  }
  if (modelicaIncludeAnnotations) {
    lines.push("  annotation(");
    lines.push('    Documentation(info="<html>');
    lines.push(`      <p><b>Prior:</b> ${(thought.prior.probability * 100).toFixed(1)}%</p>`);
    lines.push(`      <p><b>Posterior:</b> ${(thought.posterior.probability * 100).toFixed(1)}%</p>`);
    lines.push("      <p>Generated by DeepThinking MCP v7.1.0</p>");
    lines.push('    </html>")');
    lines.push("  );");
  }
  lines.push(`end ${sanitizeModelicaId(packageName)};`);
  return lines.join("\n");
}
function bayesianToUML(thought, options) {
  const { umlTheme, umlDirection, includeMetrics = true } = options;
  const nodes = [
    {
      id: "prior",
      label: includeMetrics ? `Prior: ${thought.prior.probability.toFixed(3)}` : "Prior",
      shape: "entity"
    },
    {
      id: "evidence",
      label: "Evidence",
      shape: "rectangle"
    },
    {
      id: "hypothesis",
      label: "Hypothesis",
      shape: "usecase"
    },
    {
      id: "posterior",
      label: includeMetrics ? `Posterior: ${thought.posterior.probability.toFixed(3)}` : "Posterior",
      shape: "entity",
      color: "90EE90"
    }
  ];
  const edges = [
    { source: "prior", target: "hypothesis", type: "arrow" },
    { source: "evidence", target: "hypothesis", type: "arrow" },
    { source: "hypothesis", target: "posterior", type: "arrow" }
  ];
  return generateUmlDiagram(nodes, edges, {
    title: "Bayesian Network",
    theme: umlTheme,
    direction: umlDirection
  });
}
function bayesianToJSON(thought, options) {
  const { jsonPrettyPrint = true, jsonIndent = 2 } = options;
  const evidenceDescriptions = thought.evidence?.map((e) => e.description) || [];
  return generateBayesianJson(
    "Bayesian Network",
    thought.prior.probability,
    thought.posterior.probability,
    thought.bayesFactor,
    thought.hypothesis.statement,
    evidenceDescriptions,
    {
      prettyPrint: jsonPrettyPrint,
      indent: jsonIndent
    }
  );
}
function bayesianToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  const hypothesisContent = `**${thought.hypothesis.statement}**

` + (thought.hypothesis.alternatives && thought.hypothesis.alternatives.length > 0 ? `Alternatives: ${thought.hypothesis.alternatives.join(", ")}` : "");
  parts.push(section("Hypothesis", hypothesisContent));
  if (includeMetrics) {
    const priorPct = (thought.prior.probability * 100).toFixed(1);
    const posteriorPct = (thought.posterior.probability * 100).toFixed(1);
    const metricsContent = keyValueSection({
      "Prior Probability": `${priorPct}%`,
      "Posterior Probability": `${posteriorPct}%`,
      ...thought.bayesFactor !== void 0 ? { "Bayes Factor": thought.bayesFactor.toFixed(2) } : {}
    });
    parts.push(section("Probabilities", metricsContent));
    parts.push(section("Prior", `${progressBar(thought.prior.probability * 100)}

${thought.prior.justification}`));
    parts.push(section("Posterior", `${progressBar(thought.posterior.probability * 100)}

${thought.posterior.calculation}`));
  }
  if (thought.evidence && thought.evidence.length > 0) {
    const evidenceRows = thought.evidence.map((ev, i) => [
      (i + 1).toString(),
      ev.description,
      ev.likelihoodGivenHypothesis?.toFixed(3) || "-",
      ev.likelihoodGivenNotHypothesis?.toFixed(3) || "-"
    ]);
    parts.push(section("Evidence", table(["#", "Description", "P(E|H)", "P(E|\xACH)"], evidenceRows)));
  }
  const change = thought.posterior.probability - thought.prior.probability;
  const changeDirection = change > 0 ? "increased" : change < 0 ? "decreased" : "unchanged";
  const interpretation = `The posterior probability has **${changeDirection}** by ${Math.abs(change * 100).toFixed(1)} percentage points from the prior.` + (thought.bayesFactor !== void 0 ? `

Bayes Factor of ${thought.bayesFactor.toFixed(2)} indicates ${thought.bayesFactor > 3 ? "substantial" : thought.bayesFactor > 1 ? "weak" : "evidence against"} support for the hypothesis.` : "");
  parts.push(section("Interpretation", interpretation));
  if (markdownIncludeMermaid) {
    const mermaidDiagram = bayesianToMermaid(thought, "default", true, true);
    parts.push(section("Bayesian Network Diagram", mermaidBlock(mermaidDiagram)));
  }
  return document("Bayesian Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "bayesian",
      prior: thought.prior.probability,
      posterior: thought.posterior.probability
    }
  });
}
var init_bayesian = __esm({
  "src/export/visual/modes/bayesian.ts"() {
    init_esm_shims();
    init_svg();
    init_graphml();
    init_tikz();
    init_html();
    init_modelica();
    init_uml();
    init_json();
    init_markdown();
  }
});

// src/export/visual/modes/evidential.ts
function exportEvidentialBeliefs(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return evidentialToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return evidentialToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return evidentialToASCII(thought);
    case "svg":
      return evidentialToSVG(thought, options);
    case "graphml":
      return evidentialToGraphML(thought, options);
    case "tikz":
      return evidentialToTikZ(thought, options);
    case "html":
      return evidentialToHTML(thought, options);
    case "modelica":
      return evidentialToModelica(thought, options);
    case "uml":
      return evidentialToUML(thought, options);
    case "json":
      return evidentialToJSON(thought, options);
    case "markdown":
      return evidentialToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function evidentialToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TD\n";
  mermaid += '  Frame["Frame of Discernment"]\n';
  if (thought.frameOfDiscernment) {
    for (const hypothesis of thought.frameOfDiscernment) {
      const hypId = sanitizeId(hypothesis);
      const label = includeLabels ? hypothesis : hypId;
      mermaid += `  ${hypId}["${label}"]
`;
      mermaid += `  Frame --> ${hypId}
`;
    }
  }
  if (includeMetrics && thought.massAssignments && thought.massAssignments.length > 0) {
    mermaid += "\n";
    for (const mass of thought.massAssignments) {
      const massId = sanitizeId(mass.subset.join("_"));
      const label = `{${mass.subset.join(", ")}}`;
      mermaid += `  ${massId}["${label}: ${mass.mass.toFixed(3)}"]
`;
    }
  }
  if (colorScheme !== "monochrome" && thought.frameOfDiscernment) {
    mermaid += "\n";
    const color = colorScheme === "pastel" ? "#e1f5ff" : "#a8d5ff";
    for (const hypothesis of thought.frameOfDiscernment) {
      const hypId = sanitizeId(hypothesis);
      mermaid += `  style ${hypId} fill:${color}
`;
    }
  }
  return mermaid;
}
function evidentialToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph EvidentialBeliefs {\n";
  dot += "  rankdir=TD;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  dot += '  Frame [label="Frame of Discernment", shape=ellipse];\n\n';
  if (thought.frameOfDiscernment) {
    for (const hypothesis of thought.frameOfDiscernment) {
      const hypId = sanitizeId(hypothesis);
      const label = includeLabels ? hypothesis : hypId;
      dot += `  ${hypId} [label="${label}"];
`;
      dot += `  Frame -> ${hypId};
`;
    }
  }
  if (includeMetrics && thought.massAssignments && thought.massAssignments.length > 0) {
    dot += "\n";
    for (const mass of thought.massAssignments) {
      const massId = sanitizeId(mass.subset.join("_"));
      const label = `{${mass.subset.join(", ")}}: ${mass.mass.toFixed(3)}`;
      dot += `  ${massId} [label="${label}", shape=note];
`;
    }
  }
  dot += "}\n";
  return dot;
}
function evidentialToASCII(thought) {
  let ascii = "Evidential Belief Visualization:\n";
  ascii += "================================\n\n";
  ascii += "Frame of Discernment:\n";
  if (thought.frameOfDiscernment) {
    ascii += `  {${thought.frameOfDiscernment.join(", ")}}

`;
  } else {
    ascii += "  (not defined)\n\n";
  }
  if (thought.massAssignments && thought.massAssignments.length > 0) {
    ascii += "Mass Assignments:\n";
    for (const mass of thought.massAssignments) {
      ascii += `  m({${mass.subset.join(", ")}}) = ${mass.mass.toFixed(3)}
`;
    }
    ascii += "\n";
  }
  if (thought.beliefFunctions && thought.beliefFunctions.length > 0) {
    ascii += `Belief Functions: ${thought.beliefFunctions.length} defined
`;
  }
  if (thought.plausibilityFunction) {
    ascii += `Plausibility: ${thought.plausibilityFunction.toFixed(3)}
`;
  }
  return ascii;
}
function evidentialToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width
  } = options;
  if (!thought.frameOfDiscernment || thought.frameOfDiscernment.length === 0) {
    return generateSVGHeader(svgWidth, 200, "Evidential Beliefs") + '\n  <text x="400" y="100" text-anchor="middle" class="subtitle">No frame of discernment defined</text>\n' + generateSVGFooter();
  }
  const positions = /* @__PURE__ */ new Map();
  const nodeWidth = 150;
  const nodeHeight = 40;
  positions.set("frame", {
    id: "frame",
    label: "Frame of Discernment",
    x: svgWidth / 2,
    y: 80,
    width: nodeWidth,
    height: nodeHeight,
    type: "frame"
  });
  const hypSpacing = Math.min(200, svgWidth / (thought.frameOfDiscernment.length + 1));
  const hypStartX = (svgWidth - (thought.frameOfDiscernment.length - 1) * hypSpacing) / 2;
  thought.frameOfDiscernment.forEach((hypothesis, index) => {
    const hypId = sanitizeId(hypothesis);
    positions.set(hypId, {
      id: hypId,
      label: includeLabels ? hypothesis : hypId,
      x: hypStartX + index * hypSpacing,
      y: 200,
      width: nodeWidth,
      height: nodeHeight,
      type: "hypothesis"
    });
  });
  const actualHeight = 400;
  let svg = generateSVGHeader(svgWidth, actualHeight, "Evidential Beliefs");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  const framePos = positions.get("frame");
  for (const hypothesis of thought.frameOfDiscernment) {
    const hypPos = positions.get(sanitizeId(hypothesis));
    if (hypPos) {
      svg += renderEdge(framePos, hypPos);
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  const frameColors = getNodeColor("warning", colorScheme);
  const hypColors = getNodeColor("primary", colorScheme);
  svg += renderEllipseNode(framePos, frameColors);
  for (const [id, pos] of positions) {
    if (id !== "frame") {
      svg += renderRectNode(pos, hypColors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Hypotheses", value: thought.frameOfDiscernment.length },
      { label: "Belief Functions", value: thought.beliefFunctions?.length || 0 }
    ];
    svg += renderMetricsPanel(svgWidth - 180, actualHeight - 110, metrics);
  }
  const legendItems = [
    { label: "Frame", color: frameColors, shape: "ellipse" },
    { label: "Hypothesis", color: hypColors }
  ];
  svg += renderLegend(20, actualHeight - 80, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function evidentialToGraphML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  let edgeId = 0;
  if (thought.evidence && thought.evidence.length > 0) {
    for (const evidence of thought.evidence) {
      nodes.push({
        id: evidence.id,
        label: includeLabels ? evidence.description : evidence.id,
        type: "evidence",
        metadata: {
          source: evidence.source,
          reliability: evidence.reliability,
          description: evidence.description
        }
      });
    }
  }
  if (thought.beliefFunctions && thought.beliefFunctions.length > 0) {
    for (const belief of thought.beliefFunctions) {
      const label = includeLabels ? `Belief: ${belief.source}` : belief.id;
      nodes.push({
        id: belief.id,
        label,
        type: "belief",
        metadata: belief.conflictMass !== void 0 ? { conflictMass: belief.conflictMass } : void 0
      });
      if (thought.evidence && thought.evidence.length > 0) {
        const sourceEvidence = thought.evidence.find((e) => e.id === belief.source);
        if (sourceEvidence) {
          edges.push({
            id: `e${edgeId++}`,
            source: sourceEvidence.id,
            target: belief.id,
            label: includeMetrics ? `strength: ${sourceEvidence.reliability.toFixed(3)}` : void 0,
            metadata: includeMetrics ? { weight: sourceEvidence.reliability } : void 0
          });
        }
      }
    }
  }
  if (nodes.length === 0 && thought.frameOfDiscernment && thought.frameOfDiscernment.length > 0) {
    nodes.push({
      id: "frame",
      label: "Frame of Discernment",
      type: "frame"
    });
    for (const hypothesis of thought.frameOfDiscernment) {
      const hypId = sanitizeId(hypothesis);
      nodes.push({
        id: hypId,
        label: includeLabels ? hypothesis : hypId,
        type: "hypothesis"
      });
      edges.push({
        id: `e${edgeId++}`,
        source: "frame",
        target: hypId
      });
    }
  }
  return generateGraphML(nodes, edges, {
    graphName: "Evidential Beliefs",
    includeLabels,
    includeMetadata: includeMetrics
  });
}
function evidentialToTikZ(thought, options) {
  const { includeLabels = true, includeMetrics = true, colorScheme = "default" } = options;
  const nodes = [];
  const edges = [];
  if (thought.evidence && thought.evidence.length > 0) {
    const evidenceCount = thought.evidence.length;
    const evidenceSpacing = Math.min(3, 8 / evidenceCount);
    const startX = (8 - (evidenceCount - 1) * evidenceSpacing) / 2;
    for (let i = 0; i < thought.evidence.length; i++) {
      const evidence = thought.evidence[i];
      const label = includeLabels ? `${evidence.description.substring(0, 20)}${evidence.description.length > 20 ? "..." : ""}` : evidence.id;
      nodes.push({
        id: evidence.id,
        label,
        x: startX + i * evidenceSpacing,
        y: 0,
        type: "evidence",
        shape: "rectangle"
      });
    }
  }
  if (thought.beliefFunctions && thought.beliefFunctions.length > 0) {
    const beliefCount = thought.beliefFunctions.length;
    const beliefSpacing = Math.min(3, 8 / beliefCount);
    const startX = (8 - (beliefCount - 1) * beliefSpacing) / 2;
    for (let i = 0; i < thought.beliefFunctions.length; i++) {
      const belief = thought.beliefFunctions[i];
      const label = includeLabels ? `Belief: ${belief.source}` : belief.id;
      nodes.push({
        id: belief.id,
        label,
        x: startX + i * beliefSpacing,
        y: -3,
        type: "primary",
        shape: "ellipse"
      });
      if (thought.evidence && thought.evidence.length > 0) {
        const sourceEvidence = thought.evidence.find((e) => e.id === belief.source);
        if (sourceEvidence) {
          edges.push({
            source: sourceEvidence.id,
            target: belief.id,
            label: includeMetrics ? sourceEvidence.reliability.toFixed(3) : void 0,
            directed: true
          });
        }
      }
    }
  }
  if (nodes.length === 0 && thought.frameOfDiscernment && thought.frameOfDiscernment.length > 0) {
    nodes.push({
      id: "frame",
      label: "Frame of Discernment",
      x: 4,
      y: 0,
      type: "warning",
      shape: "ellipse"
    });
    const hypCount = thought.frameOfDiscernment.length;
    const hypSpacing = Math.min(2.5, 8 / hypCount);
    const startX = (8 - (hypCount - 1) * hypSpacing) / 2;
    for (let i = 0; i < thought.frameOfDiscernment.length; i++) {
      const hypothesis = thought.frameOfDiscernment[i];
      const hypId = sanitizeId(hypothesis);
      nodes.push({
        id: hypId,
        label: includeLabels ? hypothesis : hypId,
        x: startX + i * hypSpacing,
        y: -2.5,
        type: "info",
        shape: "rectangle"
      });
      edges.push({
        source: "frame",
        target: hypId,
        directed: true
      });
    }
  }
  return generateTikZ(nodes, edges, {
    title: "Evidential Beliefs",
    includeLabels,
    includeMetrics,
    colorScheme
  });
}
function evidentialToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Evidential Reasoning Analysis",
    htmlTheme = "light"
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  if (thought.frameOfDiscernment && thought.frameOfDiscernment.length > 0) {
    html += renderSection("Frame of Discernment", `
      <p>Hypotheses under consideration:</p>
      <ul class="list-styled">
        ${thought.frameOfDiscernment.map((h) => `<li>${escapeHTML(h)}</li>`).join("\n")}
      </ul>
    `, "\u{1F3AF}");
  }
  if (thought.evidence && thought.evidence.length > 0) {
    const evRows = thought.evidence.map((ev) => [
      ev.id,
      ev.description,
      ev.reliability.toFixed(2),
      ev.source || "-"
    ]);
    html += renderSection("Evidence", renderTable(
      ["ID", "Description", "Reliability", "Source"],
      evRows
    ), "\u{1F4CA}");
  }
  if (thought.beliefFunctions && thought.beliefFunctions.length > 0) {
    const bfContent = thought.beliefFunctions.map((bf) => {
      const massRows = bf.massAssignments.map(
        (ma) => `<tr><td>{${ma.hypothesisSet.join(", ")}}</td><td>${ma.mass.toFixed(3)}</td><td>${escapeHTML(ma.justification)}</td></tr>`
      ).join("\n");
      return `
        <div class="card">
          <div class="card-header">Belief from: ${escapeHTML(bf.source)}</div>
          ${bf.conflictMass ? `<p><strong>Conflict Mass:</strong> ${bf.conflictMass.toFixed(3)}</p>` : ""}
          <table class="table">
            <thead><tr><th>Hypothesis Set</th><th>Mass</th><th>Justification</th></tr></thead>
            <tbody>${massRows}</tbody>
          </table>
        </div>
      `;
    }).join("\n");
    html += renderSection("Belief Functions", bfContent, "\u{1F4C8}");
  }
  if (thought.combinedBelief) {
    const massRows = thought.combinedBelief.massAssignments.map(
      (ma) => `<tr><td>{${ma.hypothesisSet.join(", ")}}</td><td>${ma.mass.toFixed(3)}</td><td>${escapeHTML(ma.justification)}</td></tr>`
    ).join("\n");
    html += renderSection("Combined Belief", `
      <table class="table">
        <thead><tr><th>Hypothesis Set</th><th>Mass</th><th>Justification</th></tr></thead>
        <tbody>${massRows}</tbody>
      </table>
      ${thought.combinedBelief.conflictMass ? `<p><strong>Conflict Mass:</strong> ${thought.combinedBelief.conflictMass.toFixed(3)}</p>` : ""}
    `, "\u{1F52E}");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function evidentialToModelica(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  let modelica = "package EvidentialBeliefs\n";
  modelica += '  "Evidential reasoning with belief degrees and evidence"\n\n';
  if (thought.evidence && thought.evidence.length > 0) {
    modelica += "  // Evidence Items\n";
    for (const evidence of thought.evidence) {
      const evId = sanitizeModelicaId(evidence.id);
      const desc = includeLabels ? escapeModelicaString(evidence.description) : "";
      modelica += `  record ${evId}
`;
      modelica += `    "Evidence: ${desc}"
`;
      modelica += `    parameter Real reliability = ${evidence.reliability};
`;
      if (evidence.source) {
        modelica += `    parameter String source = "${escapeModelicaString(evidence.source)}";
`;
      }
      modelica += `    parameter String description = "${desc}";
`;
      modelica += `  end ${evId};

`;
    }
  }
  if (thought.beliefFunctions && thought.beliefFunctions.length > 0) {
    modelica += "  // Belief Functions\n";
    for (const belief of thought.beliefFunctions) {
      const bfId = sanitizeModelicaId(belief.id);
      modelica += `  record ${bfId}
`;
      modelica += `    "Belief function from ${escapeModelicaString(belief.source)}"
`;
      if (belief.massAssignments && belief.massAssignments.length > 0) {
        for (let i = 0; i < belief.massAssignments.length; i++) {
          const ma = belief.massAssignments[i];
          const hypSet = ma.hypothesisSet.map((h) => sanitizeModelicaId(h)).join("_");
          modelica += `    parameter Real mass_${hypSet} = ${ma.mass};
`;
        }
      }
      if (belief.conflictMass !== void 0 && includeMetrics) {
        modelica += `    parameter Real conflictMass = ${belief.conflictMass};
`;
      }
      modelica += `  end ${bfId};

`;
    }
  }
  if (thought.combinedBelief && includeMetrics) {
    modelica += "  // Combined Belief\n";
    modelica += "  record CombinedBelief\n";
    modelica += '    "Result of combining all evidence"\n';
    if (thought.combinedBelief.massAssignments) {
      for (let i = 0; i < thought.combinedBelief.massAssignments.length; i++) {
        const ma = thought.combinedBelief.massAssignments[i];
        const hypSet = ma.hypothesisSet.map((h) => sanitizeModelicaId(h)).join("_");
        modelica += `    parameter Real mass_${hypSet} = ${ma.mass};
`;
      }
    }
    if (thought.combinedBelief.conflictMass !== void 0) {
      modelica += `    parameter Real conflictMass = ${thought.combinedBelief.conflictMass};
`;
    }
    modelica += "  end CombinedBelief;\n\n";
  }
  if (thought.frameOfDiscernment && thought.frameOfDiscernment.length > 0) {
    modelica += "  // Frame of Discernment\n";
    modelica += "  type Hypothesis = enumeration(\n";
    const hypEnums = thought.frameOfDiscernment.map((h) => `    ${sanitizeModelicaId(h)}`);
    modelica += hypEnums.join(",\n");
    modelica += "\n  );\n\n";
  }
  modelica += "end EvidentialBeliefs;\n";
  return modelica;
}
function evidentialToUML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  if (thought.evidence && thought.evidence.length > 0) {
    for (const evidence of thought.evidence) {
      const attributes = [
        `reliability: Real = ${evidence.reliability}`
      ];
      if (includeLabels) {
        attributes.unshift(`description: String = "${evidence.description.substring(0, 30)}${evidence.description.length > 30 ? "..." : ""}"`);
      }
      if (evidence.source) {
        attributes.push(`source: String = "${evidence.source}"`);
      }
      nodes.push({
        id: evidence.id,
        label: evidence.id,
        shape: "class",
        stereotype: "<<evidence>>",
        attributes
      });
    }
  }
  if (thought.beliefFunctions && thought.beliefFunctions.length > 0) {
    for (const belief of thought.beliefFunctions) {
      const attributes = [];
      if (includeMetrics && belief.massAssignments && belief.massAssignments.length > 0) {
        for (const ma of belief.massAssignments) {
          const hypSet = ma.hypothesisSet.join(", ");
          attributes.push(`m({${hypSet}}): Real = ${ma.mass.toFixed(3)}`);
        }
      }
      if (belief.conflictMass !== void 0 && includeMetrics) {
        attributes.push(`conflictMass: Real = ${belief.conflictMass.toFixed(3)}`);
      }
      nodes.push({
        id: belief.id,
        label: includeLabels ? `Belief from ${belief.source}` : belief.id,
        shape: "class",
        stereotype: "<<belief>>",
        attributes
      });
      if (thought.evidence && thought.evidence.length > 0) {
        const sourceEvidence = thought.evidence.find((e) => e.id === belief.source);
        if (sourceEvidence) {
          edges.push({
            source: sourceEvidence.id,
            target: belief.id,
            type: "association",
            label: includeMetrics ? `[${sourceEvidence.reliability.toFixed(3)}]` : "supports"
          });
        }
      }
    }
  }
  if (thought.combinedBelief && includeMetrics) {
    const attributes = [];
    if (thought.combinedBelief.massAssignments) {
      for (const ma of thought.combinedBelief.massAssignments) {
        const hypSet = ma.hypothesisSet.join(", ");
        attributes.push(`m({${hypSet}}): Real = ${ma.mass.toFixed(3)}`);
      }
    }
    if (thought.combinedBelief.conflictMass !== void 0) {
      attributes.push(`conflictMass: Real = ${thought.combinedBelief.conflictMass.toFixed(3)}`);
    }
    nodes.push({
      id: "combined_belief",
      label: "Combined Belief",
      shape: "class",
      stereotype: "<<conclusion>>",
      attributes
    });
    if (thought.beliefFunctions && thought.beliefFunctions.length > 0) {
      for (const belief of thought.beliefFunctions) {
        edges.push({
          source: belief.id,
          target: "combined_belief",
          type: "dependency",
          label: "combines"
        });
      }
    }
  }
  if (nodes.length === 0 && thought.frameOfDiscernment && thought.frameOfDiscernment.length > 0) {
    nodes.push({
      id: "frame",
      label: "Frame of Discernment",
      shape: "class",
      stereotype: "<<enumeration>>",
      attributes: thought.frameOfDiscernment.map((h) => `${sanitizeId(h)}`)
    });
  }
  return generateUmlDiagram(nodes, edges, {
    title: "Evidential Reasoning"});
}
function evidentialToJSON(thought, options) {
  const { includeMetrics = true } = options;
  const graph = createJsonGraph("evidential", "Evidential Beliefs");
  if (thought.evidence && thought.evidence.length > 0) {
    for (const evidence of thought.evidence) {
      addNode(graph, {
        id: evidence.id,
        label: evidence.description,
        type: "evidence",
        metadata: {
          reliability: evidence.reliability,
          source: evidence.source
        }
      });
    }
  }
  if (thought.beliefFunctions && thought.beliefFunctions.length > 0) {
    for (const belief of thought.beliefFunctions) {
      const metadata = {
        source: belief.source
      };
      if (includeMetrics && belief.massAssignments) {
        metadata.massAssignments = belief.massAssignments.map((ma) => ({
          hypothesisSet: ma.hypothesisSet,
          mass: ma.mass,
          justification: ma.justification
        }));
      }
      if (belief.conflictMass !== void 0) {
        metadata.conflictMass = belief.conflictMass;
      }
      addNode(graph, {
        id: belief.id,
        label: `Belief: ${belief.source}`,
        type: "belief",
        metadata
      });
      if (thought.evidence && thought.evidence.length > 0) {
        const sourceEvidence = thought.evidence.find((e) => e.id === belief.source);
        if (sourceEvidence) {
          addEdge(graph, {
            id: `edge_${sourceEvidence.id}_${belief.id}`,
            source: sourceEvidence.id,
            target: belief.id,
            label: "supports",
            weight: sourceEvidence.reliability,
            metadata: includeMetrics ? {
              reliability: sourceEvidence.reliability
            } : void 0
          });
        }
      }
    }
  }
  if (thought.combinedBelief) {
    const metadata = {};
    if (includeMetrics && thought.combinedBelief.massAssignments) {
      metadata.massAssignments = thought.combinedBelief.massAssignments.map((ma) => ({
        hypothesisSet: ma.hypothesisSet,
        mass: ma.mass,
        justification: ma.justification
      }));
    }
    if (thought.combinedBelief.conflictMass !== void 0) {
      metadata.conflictMass = thought.combinedBelief.conflictMass;
    }
    addNode(graph, {
      id: "combined_belief",
      label: "Combined Belief",
      type: "conclusion",
      metadata
    });
    if (thought.beliefFunctions && thought.beliefFunctions.length > 0) {
      for (const belief of thought.beliefFunctions) {
        addEdge(graph, {
          id: `edge_${belief.id}_combined`,
          source: belief.id,
          target: "combined_belief",
          label: "combines"
        });
      }
    }
  }
  if (graph.nodes.length === 0 && thought.frameOfDiscernment && thought.frameOfDiscernment.length > 0) {
    addNode(graph, {
      id: "frame",
      label: "Frame of Discernment",
      type: "frame",
      metadata: {
        hypotheses: thought.frameOfDiscernment
      }
    });
  }
  if (includeMetrics) {
    if (thought.frameOfDiscernment) {
      addMetric(graph, "hypotheses", thought.frameOfDiscernment.length);
    }
    if (thought.evidence) {
      addMetric(graph, "evidenceCount", thought.evidence.length);
    }
    if (thought.beliefFunctions) {
      addMetric(graph, "beliefFunctions", thought.beliefFunctions.length);
    }
    if (thought.combinedBelief) {
      addMetric(graph, "hasCombinedBelief", true);
    }
  }
  return serializeGraph(graph);
}
function evidentialToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  if (includeMetrics) {
    parts.push(section("Metrics", keyValueSection({
      "Hypotheses": thought.frameOfDiscernment?.length || 0,
      "Evidence Items": thought.evidence?.length || 0,
      "Belief Functions": thought.beliefFunctions?.length || 0
    })));
  }
  if (thought.frameOfDiscernment && thought.frameOfDiscernment.length > 0) {
    parts.push(section(
      "Frame of Discernment",
      list(thought.frameOfDiscernment)
    ));
  }
  if (thought.evidence && thought.evidence.length > 0) {
    const evRows = thought.evidence.map((ev) => [
      ev.id,
      ev.description,
      ev.reliability.toFixed(2),
      ev.source || "-"
    ]);
    parts.push(section("Evidence", table(
      ["ID", "Description", "Reliability", "Source"],
      evRows
    )));
  }
  if (thought.beliefFunctions && thought.beliefFunctions.length > 0) {
    const beliefContent = [];
    for (const bf of thought.beliefFunctions) {
      beliefContent.push(`**Source:** ${bf.source}
`);
      if (bf.conflictMass !== void 0) {
        beliefContent.push(`**Conflict Mass:** ${bf.conflictMass.toFixed(3)}
`);
      }
      const massRows = bf.massAssignments.map((ma) => [
        `{${ma.hypothesisSet.join(", ")}}`,
        ma.mass.toFixed(3),
        ma.justification
      ]);
      beliefContent.push(table(
        ["Hypothesis Set", "Mass", "Justification"],
        massRows
      ));
      beliefContent.push("\n");
    }
    parts.push(section("Belief Functions", beliefContent.join("")));
  }
  if (thought.combinedBelief) {
    const massRows = thought.combinedBelief.massAssignments.map((ma) => [
      `{${ma.hypothesisSet.join(", ")}}`,
      ma.mass.toFixed(3),
      ma.justification
    ]);
    let combinedContent = table(
      ["Hypothesis Set", "Mass", "Justification"],
      massRows
    );
    if (thought.combinedBelief.conflictMass !== void 0) {
      combinedContent += `
**Conflict Mass:** ${thought.combinedBelief.conflictMass.toFixed(3)}
`;
    }
    parts.push(section("Combined Belief", combinedContent));
  }
  if (markdownIncludeMermaid) {
    const mermaid = evidentialToMermaid(thought, "default", true, includeMetrics);
    parts.push(section("Visualization", mermaidBlock(mermaid)));
  }
  return document("Evidential Reasoning Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "evidential",
      hypotheses: thought.frameOfDiscernment?.length || 0
    }
  });
}
var init_evidential = __esm({
  "src/export/visual/modes/evidential.ts"() {
    init_esm_shims();
    init_utils();
    init_svg();
    init_graphml();
    init_tikz();
    init_html();
    init_modelica();
    init_uml();
    init_json();
    init_markdown();
  }
});

// src/export/visual/modes/game-theory.ts
function exportGameTree(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return gameTreeToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return gameTreeToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return gameTreeToASCII(thought);
    case "svg":
      return gameTreeToSVG(thought, options);
    case "graphml":
      return gameTreeToGraphML(thought, options);
    case "tikz":
      return gameTreeToTikZ(thought, options);
    case "html":
      return gameTreeToHTML(thought, options);
    case "modelica":
      return gameTheoryToModelica(thought, options);
    case "uml":
      return gameTheoryToUML(thought, options);
    case "json":
      return gameTheoryToJSON(thought, options);
    case "markdown":
      return gameTheoryToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function gameTreeToMermaid(thought, _colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TD\n";
  if (!thought.game) {
    return mermaid + "  root[No game defined]\n";
  }
  if (thought.gameTree && thought.gameTree.nodes) {
    for (const node of thought.gameTree.nodes) {
      const nodeId = sanitizeId(node.id);
      const label = includeLabels ? node.action || node.id : nodeId;
      const shape = node.type === "terminal" ? ["[[", "]]"] : ["[", "]"];
      mermaid += `  ${nodeId}${shape[0]}${label}${shape[1]}
`;
    }
    mermaid += "\n";
    for (const node of thought.gameTree.nodes) {
      if (node.childNodes && node.childNodes.length > 0) {
        for (const childId of node.childNodes) {
          const fromId = sanitizeId(node.id);
          const toId = sanitizeId(childId);
          const childNode = thought.gameTree.nodes.find((n) => n.id === childId);
          if (includeMetrics && childNode?.action) {
            mermaid += `  ${fromId} --> |${childNode.action}| ${toId}
`;
          } else {
            mermaid += `  ${fromId} --> ${toId}
`;
          }
        }
      }
    }
  } else {
    mermaid += "  root[Game]\n";
    if (thought.strategies) {
      for (const strategy of thought.strategies.slice(0, 5)) {
        const stratId = sanitizeId(strategy.id);
        mermaid += `  root --> ${stratId}[${strategy.name}]
`;
      }
    }
  }
  return mermaid;
}
function gameTreeToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph GameTree {\n";
  dot += "  rankdir=TD;\n";
  dot += "  node [shape=circle];\n\n";
  if (!thought.game) {
    dot += '  root [label="No game"];\n}\n';
    return dot;
  }
  if (thought.gameTree && thought.gameTree.nodes) {
    for (const node of thought.gameTree.nodes) {
      const nodeId = sanitizeId(node.id);
      const label = includeLabels ? node.action || node.id : nodeId;
      const shape = node.type === "terminal" ? "doublecircle" : "circle";
      dot += `  ${nodeId} [label="${label}", shape=${shape}];
`;
    }
    dot += "\n";
    for (const node of thought.gameTree.nodes) {
      if (node.childNodes && node.childNodes.length > 0) {
        for (const childId of node.childNodes) {
          const fromId = sanitizeId(node.id);
          const toId = sanitizeId(childId);
          const childNode = thought.gameTree.nodes.find((n) => n.id === childId);
          if (includeMetrics && childNode?.action) {
            dot += `  ${fromId} -> ${toId} [label="${childNode.action}"];
`;
          } else {
            dot += `  ${fromId} -> ${toId};
`;
          }
        }
      }
    }
  }
  dot += "}\n";
  return dot;
}
function gameTreeToASCII(thought) {
  let ascii = `Game: ${thought.game?.name || "Untitled"}
`;
  ascii += "=".repeat(40) + "\n\n";
  if (thought.strategies && thought.strategies.length > 0) {
    ascii += "Strategies:\n";
    for (const strategy of thought.strategies) {
      const strategyType = strategy.isPure ? "Pure" : "Mixed";
      ascii += `  \u2022 ${strategy.name} (${strategyType})
`;
    }
  }
  if (thought.nashEquilibria && thought.nashEquilibria.length > 0) {
    ascii += "\nEquilibria:\n";
    for (const eq of thought.nashEquilibria) {
      ascii += `  \u2696 ${eq.type}: ${eq.strategyProfile.join(", ")}
`;
      ascii += `    Payoffs: [${eq.payoffs.join(", ")}]
`;
    }
  }
  return ascii;
}
function gameTreeToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width,
    svgHeight = 500
  } = options;
  const title = thought.game?.name || "Game Tree";
  if (!thought.game) {
    return generateSVGHeader(svgWidth, 200, title) + '\n  <text x="400" y="100" text-anchor="middle" class="subtitle">No game defined</text>\n' + generateSVGFooter();
  }
  const positions = /* @__PURE__ */ new Map();
  const nodeWidth = 120;
  const nodeHeight = 40;
  if (thought.gameTree && thought.gameTree.nodes) {
    const nodeDepths = /* @__PURE__ */ new Map();
    const rootNodes = thought.gameTree.nodes.filter((n) => !n.parentNode);
    const queue = rootNodes.map((n) => ({ nodeId: n.id, depth: 0 }));
    while (queue.length > 0) {
      const { nodeId, depth } = queue.shift();
      nodeDepths.set(nodeId, depth);
      const node = thought.gameTree.nodes.find((n) => n.id === nodeId);
      if (node) {
        for (const childId of node.childNodes) {
          queue.push({ nodeId: childId, depth: depth + 1 });
        }
      }
    }
    const nodesByDepth = /* @__PURE__ */ new Map();
    for (const node of thought.gameTree.nodes) {
      const depth = nodeDepths.get(node.id) || 0;
      if (!nodesByDepth.has(depth)) {
        nodesByDepth.set(depth, []);
      }
      nodesByDepth.get(depth).push(node);
    }
    const depths = Array.from(nodesByDepth.keys()).sort((a, b) => a - b);
    const verticalSpacing = 100;
    let currentY = 60;
    for (const depth of depths) {
      const nodesAtDepth = nodesByDepth.get(depth);
      const layerWidth = nodesAtDepth.length * (nodeWidth + 20) - 20;
      let startX = (svgWidth - layerWidth) / 2;
      for (const node of nodesAtDepth) {
        const label = includeLabels ? node.action || node.id : sanitizeId(node.id);
        positions.set(node.id, {
          id: node.id,
          x: startX,
          y: currentY,
          width: nodeWidth,
          height: nodeHeight,
          label,
          type: node.type
        });
        startX += nodeWidth + 20;
      }
      currentY += verticalSpacing;
    }
  } else if (thought.strategies) {
    positions.set("root", {
      id: "root",
      x: svgWidth / 2 - nodeWidth / 2,
      y: 60,
      width: nodeWidth,
      height: nodeHeight,
      label: "Game",
      type: "root"
    });
    const stratCount = Math.min(thought.strategies.length, 5);
    const layerWidth = stratCount * (nodeWidth + 20) - 20;
    let startX = (svgWidth - layerWidth) / 2;
    for (let i = 0; i < stratCount; i++) {
      const strategy = thought.strategies[i];
      positions.set(strategy.id, {
        id: strategy.id,
        x: startX,
        y: 180,
        width: nodeWidth,
        height: nodeHeight,
        label: strategy.name,
        type: "strategy"
      });
      startX += nodeWidth + 20;
    }
  }
  let svg = generateSVGHeader(svgWidth, svgHeight, title);
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  if (thought.gameTree && thought.gameTree.nodes) {
    for (const node of thought.gameTree.nodes) {
      if (node.childNodes) {
        for (const childId of node.childNodes) {
          const fromPos = positions.get(node.id);
          const toPos = positions.get(childId);
          if (fromPos && toPos) {
            svg += renderEdge(fromPos, toPos, {});
          }
        }
      }
    }
  } else if (thought.strategies) {
    const rootPos = positions.get("root");
    if (rootPos) {
      for (const strategy of thought.strategies.slice(0, 5)) {
        const stratPos = positions.get(strategy.id);
        if (stratPos) {
          svg += renderEdge(rootPos, stratPos, {});
        }
      }
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  for (const [, pos] of positions) {
    const colors = pos.type === "terminal" ? getNodeColor("success", colorScheme) : pos.type === "root" ? getNodeColor("primary", colorScheme) : getNodeColor("neutral", colorScheme);
    if (pos.type === "terminal") {
      svg += renderEllipseNode(pos, colors);
    } else {
      svg += renderRectNode(pos, colors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics && thought.nashEquilibria) {
    const metrics = [
      { label: "Equilibria", value: thought.nashEquilibria.length },
      { label: "Strategies", value: thought.strategies?.length || 0 }
    ];
    svg += renderMetricsPanel(svgWidth - 180, svgHeight - 80, metrics);
  }
  const legendItems = [
    { label: "Decision", color: getNodeColor("neutral", colorScheme) },
    { label: "Terminal", color: getNodeColor("success", colorScheme), shape: "ellipse" }
  ];
  svg += renderLegend(20, svgHeight - 60, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function gameTreeToGraphML(thought, options) {
  const { includeLabels = true } = options;
  if (!thought.game) {
    const nodes2 = [{ id: "root", label: "No game defined", type: "root" }];
    return generateGraphML(nodes2, [], { graphName: "Empty Game Tree" });
  }
  if (thought.gameTree && thought.gameTree.nodes && thought.gameTree.nodes.length > 0) {
    const nodes2 = thought.gameTree.nodes.map((node) => ({
      id: sanitizeId(node.id),
      label: includeLabels ? node.action || node.id : node.id,
      type: node.type || "node",
      metadata: {
        action: node.action,
        player: node.playerId
      }
    }));
    const edges = [];
    let edgeCount = 0;
    for (const node of thought.gameTree.nodes) {
      if (node.childNodes && node.childNodes.length > 0) {
        for (const childId of node.childNodes) {
          const childNode = thought.gameTree.nodes.find((n) => n.id === childId);
          edges.push({
            id: `e${edgeCount++}`,
            source: sanitizeId(node.id),
            target: sanitizeId(childId),
            label: includeLabels && childNode?.action ? childNode.action : void 0,
            directed: true
          });
        }
      }
    }
    return generateGraphML(nodes2, edges, { graphName: thought.game?.name || "Game Tree" });
  } else if (thought.strategies && thought.strategies.length > 0) {
    const root = {
      id: "root",
      label: "Game",
      children: thought.strategies.slice(0, 5).map((strategy) => ({
        id: sanitizeId(strategy.id),
        label: strategy.name
      }))
    };
    return createTreeGraphML(root, { graphName: thought.game?.name || "Game Tree" });
  }
  const nodes = [{ id: "root", label: "No game tree", type: "root" }];
  return generateGraphML(nodes, [], { graphName: thought.game?.name || "Game Tree" });
}
function gameTreeToTikZ(thought, options) {
  const { includeLabels = true, colorScheme = "default" } = options;
  if (!thought.game) {
    const nodes2 = [{ id: "root", label: "No game defined", x: 4, y: 0, type: "root", shape: "rectangle" }];
    return generateTikZ(nodes2, [], { title: "Empty Game Tree", colorScheme });
  }
  if (thought.gameTree && thought.gameTree.nodes && thought.gameTree.nodes.length > 0) {
    const nodeDepths = /* @__PURE__ */ new Map();
    const rootNodes = thought.gameTree.nodes.filter((n) => !n.parentNode);
    const queue = rootNodes.map((n) => ({ nodeId: n.id, depth: 0 }));
    while (queue.length > 0) {
      const { nodeId, depth } = queue.shift();
      nodeDepths.set(nodeId, depth);
      const node = thought.gameTree.nodes.find((n) => n.id === nodeId);
      if (node && node.childNodes) {
        for (const childId of node.childNodes) {
          queue.push({ nodeId: childId, depth: depth + 1 });
        }
      }
    }
    const nodesByDepth = /* @__PURE__ */ new Map();
    for (const node of thought.gameTree.nodes) {
      const depth = nodeDepths.get(node.id) || 0;
      if (!nodesByDepth.has(depth)) {
        nodesByDepth.set(depth, []);
      }
      nodesByDepth.get(depth).push(node);
    }
    const nodes2 = [];
    const depths = Array.from(nodesByDepth.keys()).sort((a, b) => a - b);
    for (const depth of depths) {
      const nodesAtDepth = nodesByDepth.get(depth);
      const layerWidth = nodesAtDepth.length * 3;
      const startX = (8 - layerWidth) / 2 + 1.5;
      for (let i = 0; i < nodesAtDepth.length; i++) {
        const node = nodesAtDepth[i];
        nodes2.push({
          id: sanitizeId(node.id),
          label: includeLabels ? node.action || node.id : node.id,
          x: startX + i * 3,
          y: -depth * 2,
          // y decreases by 2 per level
          type: node.type || "neutral",
          shape: node.type === "terminal" ? "ellipse" : "rectangle"
          // Use 'ellipse' for terminal nodes
        });
      }
    }
    const edges = [];
    for (const node of thought.gameTree.nodes) {
      if (node.childNodes && node.childNodes.length > 0) {
        for (const childId of node.childNodes) {
          const childNode = thought.gameTree.nodes.find((n) => n.id === childId);
          edges.push({
            source: sanitizeId(node.id),
            target: sanitizeId(childId),
            label: includeLabels && childNode?.action ? childNode.action : void 0,
            directed: true
          });
        }
      }
    }
    return generateTikZ(nodes2, edges, { title: thought.game?.name || "Game Tree", colorScheme });
  } else if (thought.strategies && thought.strategies.length > 0) {
    const root = {
      id: "root",
      label: "Game",
      children: thought.strategies.slice(0, 5).map((strategy) => ({
        id: sanitizeId(strategy.id),
        label: strategy.name
      }))
    };
    return createTreeTikZ(root, { title: thought.game?.name || "Game Tree", colorScheme });
  }
  const nodes = [{ id: "root", label: "No game tree", x: 4, y: 0, type: "root", shape: "rectangle" }];
  return generateTikZ(nodes, [], { title: thought.game?.name || "Game Tree", colorScheme });
}
function gameTreeToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = thought.game?.name || "Game Theory Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  if (!thought.game) {
    html += '<p class="text-secondary">No game defined.</p>\n';
    html += generateHTMLFooter(htmlStandalone);
    return html;
  }
  html += renderSection("Game Information", `
    <p><strong>Type:</strong> ${escapeHTML(thought.game.type)}</p>
    <p><strong>Players:</strong> ${thought.players ? thought.players.map((p) => escapeHTML(p.name)).join(", ") : thought.game.numPlayers}</p>
    ${thought.game.description ? `<p>${escapeHTML(thought.game.description)}</p>` : ""}
  `, "\u{1F3AE}");
  if (includeMetrics) {
    html += '<div class="metrics-grid">';
    html += renderMetricCard("Players", thought.players ? thought.players.length : thought.game.numPlayers, "primary");
    html += renderMetricCard("Strategies", thought.strategies?.length || 0, "info");
    html += renderMetricCard("Equilibria", thought.nashEquilibria?.length || 0, "success");
    html += "</div>\n";
  }
  if (thought.strategies && thought.strategies.length > 0) {
    const strategyRows = thought.strategies.map((strategy) => {
      const typeBadge = renderBadge(strategy.isPure ? "Pure" : "Mixed", strategy.isPure ? "success" : "info");
      return [
        strategy.name,
        typeBadge,
        strategy.description || "-"
      ];
    });
    html += renderSection("Strategies", renderTable(
      ["Name", "Type", "Description"],
      strategyRows.map((row) => row.map((cell) => typeof cell === "string" && cell.startsWith("<") ? cell : escapeHTML(String(cell))))
    ), "\u{1F4CB}");
  }
  if (thought.nashEquilibria && thought.nashEquilibria.length > 0) {
    const eqRows = thought.nashEquilibria.map((eq) => {
      const typeBadge = renderBadge(eq.type, eq.type === "pure" ? "success" : "info");
      return [
        typeBadge,
        eq.strategyProfile.join(", "),
        `[${eq.payoffs.join(", ")}]`,
        eq.isStrict ? "Yes" : "No"
      ];
    });
    html += renderSection("Nash Equilibria", renderTable(
      ["Type", "Strategy Profile", "Payoffs", "Strict"],
      eqRows.map((row) => row.map((cell) => typeof cell === "string" && cell.startsWith("<") ? cell : escapeHTML(String(cell))))
    ), "\u2696\uFE0F");
  }
  if (thought.payoffMatrix) {
    html += renderSection("Payoff Matrix", `
      <p class="text-secondary">Payoff matrix visualization available in other formats.</p>
    `, "\u{1F4CA}");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function gameTheoryToModelica(thought, options) {
  const { includeMetrics = true } = options;
  const gameName = sanitizeModelicaId(thought.game?.name || "Game");
  let modelica = `package ${gameName}
`;
  modelica += `  "Game Theory Analysis: ${escapeModelicaString(thought.game?.name || "Untitled")}"

`;
  if (thought.players && thought.players.length > 0) {
    modelica += "  record Player\n";
    modelica += '    "Player in the game"\n';
    modelica += '    String id "Player identifier";\n';
    modelica += '    String name "Player name";\n';
    modelica += "  end Player;\n\n";
    for (const player of thought.players) {
      const playerId = sanitizeModelicaId(player.id || player.name);
      modelica += `  constant Player ${playerId} = Player(
`;
      modelica += `    id="${escapeModelicaString(player.id || player.name)}",
`;
      modelica += `    name="${escapeModelicaString(player.name)}"
`;
      modelica += "  );\n";
    }
    modelica += "\n";
  }
  if (thought.strategies && thought.strategies.length > 0) {
    modelica += "  type StrategyType = enumeration(\n";
    const strategyNames = thought.strategies.map((s) => sanitizeModelicaId(s.name));
    modelica += strategyNames.map((name) => `    ${name}`).join(",\n");
    modelica += '\n  ) "Available strategies";\n\n';
    modelica += "  record Strategy\n";
    modelica += '    "Strategy definition"\n';
    modelica += '    String id "Strategy identifier";\n';
    modelica += '    String name "Strategy name";\n';
    modelica += '    Boolean isPure "Whether strategy is pure or mixed";\n';
    modelica += "  end Strategy;\n\n";
    for (const strategy of thought.strategies) {
      const stratId = sanitizeModelicaId(strategy.id);
      modelica += `  constant Strategy ${stratId} = Strategy(
`;
      modelica += `    id="${escapeModelicaString(strategy.id)}",
`;
      modelica += `    name="${escapeModelicaString(strategy.name)}",
`;
      modelica += `    isPure=${strategy.isPure ? "true" : "false"}
`;
      modelica += "  );\n";
    }
    modelica += "\n";
  }
  if (thought.nashEquilibria && thought.nashEquilibria.length > 0) {
    modelica += "  record NashEquilibrium\n";
    modelica += '    "Nash equilibrium definition"\n';
    modelica += '    String equilibriumType "Type: pure or mixed";\n';
    modelica += '    String strategyProfile[:] "Strategy profile";\n';
    modelica += '    Real payoffs[:] "Payoffs for each player";\n';
    modelica += '    Boolean isStrict "Whether equilibrium is strict";\n';
    modelica += "  end NashEquilibrium;\n\n";
    for (let i = 0; i < thought.nashEquilibria.length; i++) {
      const eq = thought.nashEquilibria[i];
      modelica += `  constant NashEquilibrium equilibrium${i + 1} = NashEquilibrium(
`;
      modelica += `    equilibriumType="${escapeModelicaString(eq.type)}",
`;
      modelica += `    strategyProfile={${eq.strategyProfile.map((s) => `"${escapeModelicaString(s)}"`).join(", ")}},
`;
      modelica += `    payoffs={${eq.payoffs.join(", ")}},
`;
      modelica += `    isStrict=${eq.isStrict ? "true" : "false"}
`;
      modelica += "  );\n";
    }
    modelica += "\n";
  }
  if (includeMetrics) {
    modelica += "  // Game Metrics\n";
    modelica += `  constant Integer numPlayers = ${thought.players?.length || thought.game?.numPlayers || 0};
`;
    modelica += `  constant Integer numStrategies = ${thought.strategies?.length || 0};
`;
    modelica += `  constant Integer numEquilibria = ${thought.nashEquilibria?.length || 0};
`;
    modelica += `  constant String gameType = "${escapeModelicaString(thought.game?.type || "unknown")}";
`;
  }
  modelica += `end ${gameName};
`;
  return modelica;
}
function gameTheoryToUML(thought, options) {
  const { includeLabels = true } = options;
  const nodes = [];
  const edges = [];
  if (!thought.game) {
    nodes.push({
      id: "nogame",
      label: "No Game Defined",
      shape: "class",
      stereotype: "error"
    });
    return generateUmlDiagram(nodes, edges, { title: "Game Theory Analysis" });
  }
  const gameNode = {
    id: "game",
    label: thought.game.name || "Game",
    shape: "class",
    attributes: [
      `type: ${thought.game.type}`,
      `players: ${thought.players?.length || thought.game.numPlayers}`
    ]
  };
  nodes.push(gameNode);
  if (thought.players && thought.players.length > 0) {
    for (const player of thought.players) {
      const playerId = sanitizeId(player.id || player.name);
      nodes.push({
        id: playerId,
        label: player.name,
        shape: "class",
        stereotype: "player",
        attributes: [`id: ${player.id || player.name}`]
      });
      edges.push({
        source: "game",
        target: playerId,
        type: "association",
        label: includeLabels ? "has player" : void 0
      });
    }
  }
  if (thought.strategies && thought.strategies.length > 0) {
    for (const strategy of thought.strategies.slice(0, 10)) {
      const stratId = sanitizeId(strategy.id);
      nodes.push({
        id: stratId,
        label: strategy.name,
        shape: "class",
        stereotype: strategy.isPure ? "pure strategy" : "mixed strategy",
        attributes: [
          `id: ${strategy.id}`,
          ...strategy.description ? [`description: ${strategy.description}`] : []
        ]
      });
      edges.push({
        source: "game",
        target: stratId,
        type: "association",
        label: includeLabels ? "uses" : void 0
      });
    }
  }
  if (thought.nashEquilibria && thought.nashEquilibria.length > 0) {
    for (let i = 0; i < thought.nashEquilibria.length; i++) {
      const eq = thought.nashEquilibria[i];
      const eqId = `equilibrium_${i}`;
      nodes.push({
        id: eqId,
        label: `Nash Equilibrium ${i + 1}`,
        shape: "class",
        stereotype: eq.type,
        attributes: [
          `profile: [${eq.strategyProfile.join(", ")}]`,
          `payoffs: [${eq.payoffs.join(", ")}]`,
          `strict: ${eq.isStrict}`
        ]
      });
      edges.push({
        source: "game",
        target: eqId,
        type: "dependency",
        label: includeLabels ? "achieves" : void 0
      });
    }
  }
  return generateUmlDiagram(nodes, edges, {
    title: thought.game.name || "Game Theory Analysis",
    direction: "top to bottom"
  });
}
function gameTheoryToJSON(thought, options) {
  const { includeMetrics = true, includeLabels = true } = options;
  const graph = createJsonGraph(
    thought.game?.name || "Game Theory Analysis",
    "game-theory"
  );
  if (!thought.game) {
    addNode(graph, {
      id: "nogame",
      label: "No Game Defined",
      type: "error"
    });
    return serializeGraph(graph);
  }
  addNode(graph, {
    id: "game",
    label: thought.game.name || "Game",
    type: "game",
    metadata: {
      gameType: thought.game.type,
      numPlayers: thought.players?.length || thought.game.numPlayers,
      description: thought.game.description
    }
  });
  let edgeId = 0;
  if (thought.players && thought.players.length > 0) {
    for (const player of thought.players) {
      const playerId = sanitizeId(player.id || player.name);
      addNode(graph, {
        id: playerId,
        label: player.name,
        type: "player",
        metadata: {
          originalId: player.id
        }
      });
      addEdge(graph, {
        id: `edge_${edgeId++}`,
        source: "game",
        target: playerId,
        label: includeLabels ? "has player" : void 0,
        type: "participates"
      });
    }
  }
  if (thought.strategies && thought.strategies.length > 0) {
    for (const strategy of thought.strategies) {
      const stratId = sanitizeId(strategy.id);
      addNode(graph, {
        id: stratId,
        label: strategy.name,
        type: strategy.isPure ? "pure-strategy" : "mixed-strategy",
        metadata: {
          originalId: strategy.id,
          description: strategy.description,
          isPure: strategy.isPure
        }
      });
      addEdge(graph, {
        id: `edge_${edgeId++}`,
        source: "game",
        target: stratId,
        label: includeLabels ? "uses strategy" : void 0,
        type: "strategy"
      });
    }
  }
  if (thought.nashEquilibria && thought.nashEquilibria.length > 0) {
    for (let i = 0; i < thought.nashEquilibria.length; i++) {
      const eq = thought.nashEquilibria[i];
      const eqId = `equilibrium_${i}`;
      addNode(graph, {
        id: eqId,
        label: `Nash Equilibrium ${i + 1}`,
        type: "equilibrium",
        metadata: {
          equilibriumType: eq.type,
          strategyProfile: eq.strategyProfile,
          payoffs: eq.payoffs,
          isStrict: eq.isStrict
        }
      });
      addEdge(graph, {
        id: `edge_${edgeId++}`,
        source: "game",
        target: eqId,
        label: includeLabels ? "achieves" : void 0,
        type: "outcome"
      });
    }
  }
  if (includeMetrics) {
    addMetric(graph, "Players", thought.players?.length || thought.game?.numPlayers || 0);
    addMetric(graph, "Strategies", thought.strategies?.length || 0);
    addMetric(graph, "Nash Equilibria", thought.nashEquilibria?.length || 0);
  }
  addLegendItem(graph, "Game", "#4A90E2");
  addLegendItem(graph, "Player", "#50C878");
  addLegendItem(graph, "Pure Strategy", "#FFD700");
  addLegendItem(graph, "Mixed Strategy", "#FFA500");
  addLegendItem(graph, "Nash Equilibrium", "#9370DB");
  return serializeGraph(graph);
}
function gameTheoryToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  if (!thought.game) {
    parts.push(section("Status", "No game defined."));
    return document("Game Theory Analysis", parts.join("\n"), {
      includeFrontmatter: markdownIncludeFrontmatter,
      includeTableOfContents: markdownIncludeToc
    });
  }
  const gameInfo = keyValueSection({
    "Game Name": thought.game.name || "Untitled",
    "Type": thought.game.type,
    "Players": thought.players ? thought.players.map((p) => p.name).join(", ") : String(thought.game.numPlayers),
    ...thought.game.description ? { "Description": thought.game.description } : {}
  });
  parts.push(section("Game Information", gameInfo));
  if (includeMetrics) {
    const metricsContent = keyValueSection({
      "Players": thought.players?.length || thought.game.numPlayers,
      "Strategies": thought.strategies?.length || 0,
      "Nash Equilibria": thought.nashEquilibria?.length || 0
    });
    parts.push(section("Metrics", metricsContent));
  }
  if (thought.strategies && thought.strategies.length > 0) {
    const strategyRows = thought.strategies.map((strategy) => [
      strategy.name,
      strategy.isPure ? "Pure" : "Mixed",
      strategy.description || "-"
    ]);
    parts.push(section("Strategies", table(["Name", "Type", "Description"], strategyRows)));
  }
  if (thought.nashEquilibria && thought.nashEquilibria.length > 0) {
    const eqRows = thought.nashEquilibria.map((eq) => [
      eq.type,
      eq.strategyProfile.join(", "),
      `[${eq.payoffs.join(", ")}]`,
      eq.isStrict ? "Yes" : "No"
    ]);
    parts.push(section("Nash Equilibria", table(["Type", "Strategy Profile", "Payoffs", "Strict"], eqRows)));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = gameTreeToMermaid(thought, "default", true, true);
    parts.push(section("Game Tree Diagram", mermaidBlock(mermaidDiagram)));
  }
  return document(`Game Theory Analysis: ${thought.game.name || "Untitled"}`, parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "game-theory",
      gameType: thought.game.type,
      playerCount: thought.players?.length || thought.game.numPlayers
    }
  });
}
var init_game_theory = __esm({
  "src/export/visual/modes/game-theory.ts"() {
    init_esm_shims();
    init_utils();
    init_svg();
    init_graphml();
    init_tikz();
    init_html();
    init_modelica();
    init_uml();
    init_json();
    init_markdown();
  }
});

// src/export/visual/modes/optimization.ts
function exportOptimizationSolution(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return optimizationToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return optimizationToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return optimizationToASCII(thought);
    case "svg":
      return optimizationToSVG(thought, options);
    case "graphml":
      return optimizationToGraphML(thought, options);
    case "tikz":
      return optimizationToTikZ(thought, options);
    case "html":
      return optimizationToHTML(thought, options);
    case "modelica":
      return optimizationToModelica(thought, options);
    case "uml":
      return optimizationToUML(thought, options);
    case "json":
      return optimizationToJSON(thought, options);
    case "markdown":
      return optimizationToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function optimizationToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TD\n";
  if (thought.problem) {
    const problemLabel = includeLabels ? `Problem: ${thought.problem.name}` : "Problem";
    mermaid += `  Problem["${problemLabel}"]

`;
  }
  if (thought.variables && thought.variables.length > 0) {
    mermaid += '  subgraph Variables["Decision Variables"]\n';
    for (const variable of thought.variables) {
      const varId = sanitizeId(variable.id);
      const label = includeLabels ? variable.name : varId;
      const domainLabel = includeMetrics && variable.domain ? ` [${variable.domain.lowerBound},${variable.domain.upperBound}]` : "";
      mermaid += `    ${varId}["${label}${domainLabel}"]
`;
    }
    mermaid += "  end\n\n";
  }
  if (thought.optimizationConstraints && thought.optimizationConstraints.length > 0) {
    mermaid += '  subgraph Constraints["Constraints"]\n';
    for (const constraint of thought.optimizationConstraints) {
      const constId = sanitizeId(constraint.id);
      const label = includeLabels ? constraint.name : constId;
      mermaid += `    ${constId}["${label}"]
`;
    }
    mermaid += "  end\n\n";
  }
  if (thought.objectives && thought.objectives.length > 0) {
    for (const objective of thought.objectives) {
      const objId = sanitizeId(objective.id);
      const label = includeLabels ? `${objective.type}: ${objective.name}` : objId;
      mermaid += `  ${objId}["${label}"]
`;
    }
    mermaid += "\n";
  }
  if (thought.solution) {
    const qualityLabel = includeMetrics && thought.solution.quality ? ` (quality: ${thought.solution.quality.toFixed(2)})` : "";
    mermaid += `  Solution["Solution${qualityLabel}"]
`;
    if (thought.objectives) {
      for (const objective of thought.objectives) {
        const objId = sanitizeId(objective.id);
        mermaid += `  ${objId} --> Solution
`;
      }
    }
  }
  if (colorScheme !== "monochrome") {
    mermaid += "\n";
    const solutionColor = colorScheme === "pastel" ? "#e8f5e9" : "#a5d6a7";
    if (thought.solution) {
      mermaid += `  style Solution fill:${solutionColor}
`;
    }
  }
  return mermaid;
}
function optimizationToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph Optimization {\n";
  dot += "  rankdir=TD;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  if (thought.problem) {
    const label = includeLabels ? thought.problem.name : "Problem";
    dot += `  Problem [label="Problem:\\n${label}", shape=ellipse];

`;
  }
  if (thought.variables && thought.variables.length > 0) {
    dot += "  subgraph cluster_variables {\n";
    dot += '    label="Decision Variables";\n';
    for (const variable of thought.variables) {
      const varId = sanitizeId(variable.id);
      const label = includeLabels ? variable.name : varId;
      const domainLabel = includeMetrics && variable.domain ? `\\n[${variable.domain.lowerBound}, ${variable.domain.upperBound}]` : "";
      dot += `    ${varId} [label="${label}${domainLabel}"];
`;
    }
    dot += "  }\n\n";
  }
  if (thought.optimizationConstraints && thought.optimizationConstraints.length > 0) {
    dot += "  subgraph cluster_constraints {\n";
    dot += '    label="Constraints";\n';
    for (const constraint of thought.optimizationConstraints) {
      const constId = sanitizeId(constraint.id);
      const label = includeLabels ? constraint.name : constId;
      dot += `    ${constId} [label="${label}", shape=diamond];
`;
    }
    dot += "  }\n\n";
  }
  if (thought.objectives) {
    for (const objective of thought.objectives) {
      const objId = sanitizeId(objective.id);
      const label = includeLabels ? `${objective.type}:\\n${objective.name}` : objId;
      dot += `  ${objId} [label="${label}"];
`;
    }
  }
  if (thought.solution) {
    const qualityLabel = includeMetrics && thought.solution.quality ? `\\nquality: ${thought.solution.quality.toFixed(2)}` : "";
    dot += `  Solution [label="Solution${qualityLabel}", shape=doubleoctagon, style=filled, fillcolor=lightgreen];
`;
    if (thought.objectives) {
      for (const objective of thought.objectives) {
        const objId = sanitizeId(objective.id);
        dot += `  ${objId} -> Solution;
`;
      }
    }
  }
  dot += "}\n";
  return dot;
}
function optimizationToASCII(thought) {
  let ascii = "Optimization Problem:\n";
  ascii += "====================\n\n";
  if (thought.problem) {
    ascii += `Problem: ${thought.problem.name}
`;
    ascii += `Type: ${thought.problem.type}
`;
    ascii += `${thought.problem.description}

`;
  }
  if (thought.variables && thought.variables.length > 0) {
    ascii += "Decision Variables:\n";
    for (const variable of thought.variables) {
      const varType = variable.type || "unknown";
      ascii += `  ${variable.name} (${varType})
`;
      if (variable.domain) {
        ascii += `    Domain: [${variable.domain.lowerBound}, ${variable.domain.upperBound}]
`;
      }
    }
    ascii += "\n";
  }
  if (thought.optimizationConstraints && thought.optimizationConstraints.length > 0) {
    ascii += "Constraints:\n";
    for (const constraint of thought.optimizationConstraints) {
      ascii += `  ${constraint.name} (${constraint.type})
`;
      ascii += `    ${constraint.formula}
`;
    }
    ascii += "\n";
  }
  if (thought.objectives && thought.objectives.length > 0) {
    ascii += "Objectives:\n";
    for (const objective of thought.objectives) {
      ascii += `  ${objective.type.toUpperCase()}: ${objective.name}
`;
      ascii += `    ${objective.formula}
`;
    }
    ascii += "\n";
  }
  if (thought.solution) {
    ascii += "Solution:\n";
    const solution = thought.solution;
    if (solution.status) {
      ascii += `  Status: ${solution.status}
`;
    }
    if (solution.optimalValue !== void 0) {
      ascii += `  Optimal Value: ${solution.optimalValue}
`;
    }
    if (solution.quality !== void 0) {
      ascii += `  Quality: ${solution.quality.toFixed(2)}
`;
    }
    if (solution.assignments) {
      ascii += "  Assignments:\n";
      for (const [varId, value] of Object.entries(solution.assignments)) {
        ascii += `    ${varId} = ${value}
`;
      }
    }
  }
  return ascii;
}
function optimizationToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width,
    svgHeight = DEFAULT_SVG_OPTIONS.height
  } = options;
  const positions = /* @__PURE__ */ new Map();
  const nodeWidth = 150;
  const nodeHeight = 40;
  if (thought.problem) {
    positions.set("Problem", {
      id: "Problem",
      label: includeLabels ? thought.problem.name : "Problem",
      x: svgWidth / 2,
      y: 80,
      width: nodeWidth,
      height: nodeHeight,
      type: "problem"
    });
  }
  if (thought.variables) {
    thought.variables.forEach((variable, index) => {
      positions.set(variable.id, {
        id: variable.id,
        label: includeLabels ? variable.name : variable.id,
        x: 150,
        y: 200 + index * 80,
        width: nodeWidth,
        height: nodeHeight,
        type: "variable"
      });
    });
  }
  if (thought.objectives) {
    thought.objectives.forEach((objective, index) => {
      positions.set(objective.id, {
        id: objective.id,
        label: includeLabels ? `${objective.type}: ${objective.name}` : objective.id,
        x: svgWidth - 150,
        y: 200 + index * 80,
        width: nodeWidth,
        height: nodeHeight,
        type: "objective"
      });
    });
  }
  if (thought.solution) {
    positions.set("Solution", {
      id: "Solution",
      label: "Solution",
      x: svgWidth / 2,
      y: svgHeight - 100,
      width: nodeWidth,
      height: nodeHeight,
      type: "solution"
    });
  }
  let svg = generateSVGHeader(svgWidth, svgHeight, "Optimization Problem");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  if (thought.objectives && thought.solution) {
    for (const objective of thought.objectives) {
      const objPos = positions.get(objective.id);
      const solPos = positions.get("Solution");
      if (objPos && solPos) {
        svg += renderEdge(objPos, solPos);
      }
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  const problemColors = getNodeColor("warning", colorScheme);
  const variableColors = getNodeColor("neutral", colorScheme);
  const objectiveColors = getNodeColor("primary", colorScheme);
  const solutionColors = getNodeColor("success", colorScheme);
  for (const [, pos] of positions) {
    if (pos.type === "problem") {
      svg += renderEllipseNode(pos, problemColors);
    } else if (pos.type === "variable") {
      svg += renderRectNode(pos, variableColors);
    } else if (pos.type === "objective") {
      svg += renderRectNode(pos, objectiveColors);
    } else if (pos.type === "solution") {
      svg += renderStadiumNode(pos, solutionColors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Variables", value: thought.variables?.length || 0 },
      { label: "Constraints", value: thought.optimizationConstraints?.length || 0 },
      { label: "Objectives", value: thought.objectives?.length || 0 },
      { label: "Quality", value: thought.solution?.quality?.toFixed(2) || "N/A" }
    ];
    svg += renderMetricsPanel(svgWidth - 180, svgHeight - 150, metrics);
  }
  const legendItems = [
    { label: "Problem", color: problemColors, shape: "ellipse" },
    { label: "Variable", color: variableColors },
    { label: "Objective", color: objectiveColors },
    { label: "Solution", color: solutionColors, shape: "stadium" }
  ];
  svg += renderLegend(20, svgHeight - 140, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function optimizationToGraphML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  let edgeCount = 0;
  if (thought.objectives && thought.objectives.length > 0) {
    for (const objective of thought.objectives) {
      nodes.push({
        id: sanitizeId(objective.id),
        label: includeLabels ? `${objective.type}: ${objective.name}` : objective.id,
        type: "objective",
        metadata: {
          description: objective.formula,
          objectiveType: objective.type
        }
      });
    }
  }
  if (thought.optimizationConstraints && thought.optimizationConstraints.length > 0) {
    for (const constraint of thought.optimizationConstraints) {
      nodes.push({
        id: sanitizeId(constraint.id),
        label: includeLabels ? constraint.name : constraint.id,
        type: "constraint",
        metadata: {
          description: constraint.formula,
          constraintType: constraint.type
        }
      });
      if (thought.objectives) {
        for (const objective of thought.objectives) {
          edges.push({
            id: `e${edgeCount++}`,
            source: sanitizeId(constraint.id),
            target: sanitizeId(objective.id),
            label: "constrains"
          });
        }
      }
    }
  }
  if (thought.solution) {
    nodes.push({
      id: "solution",
      label: includeMetrics && thought.solution.quality ? `Solution (quality: ${thought.solution.quality.toFixed(2)})` : "Solution",
      type: "solution",
      metadata: {
        status: thought.solution.status,
        optimalValue: thought.solution.optimalValue,
        quality: thought.solution.quality
      }
    });
    if (thought.objectives) {
      for (const objective of thought.objectives) {
        edges.push({
          id: `e${edgeCount++}`,
          source: sanitizeId(objective.id),
          target: "solution",
          label: "optimizes"
        });
      }
    }
  }
  return generateGraphML(nodes, edges, {
    graphName: "Optimization Solution",
    includeLabels,
    includeMetadata: includeMetrics
  });
}
function optimizationToTikZ(thought, options) {
  const { colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  let yOffset = 0;
  if (thought.objectives && thought.objectives.length > 0) {
    const startX = thought.objectives.length > 1 ? 0 : 4;
    const spacing = thought.objectives.length > 1 ? 8 / thought.objectives.length : 0;
    for (let i = 0; i < thought.objectives.length; i++) {
      const objective = thought.objectives[i];
      const x = thought.objectives.length === 1 ? startX : startX + i * spacing + spacing / 2;
      nodes.push({
        id: sanitizeId(objective.id),
        label: includeLabels ? `${objective.type}: ${objective.name}` : objective.id,
        x,
        y: yOffset,
        type: "primary",
        shape: "rectangle"
      });
    }
    yOffset -= 2;
  }
  if (thought.optimizationConstraints && thought.optimizationConstraints.length > 0) {
    const startX = thought.optimizationConstraints.length > 1 ? 0 : 4;
    const spacing = thought.optimizationConstraints.length > 1 ? 8 / thought.optimizationConstraints.length : 0;
    for (let i = 0; i < thought.optimizationConstraints.length; i++) {
      const constraint = thought.optimizationConstraints[i];
      const x = thought.optimizationConstraints.length === 1 ? startX : startX + i * spacing + spacing / 2;
      const constraintId = sanitizeId(constraint.id);
      nodes.push({
        id: constraintId,
        label: includeLabels ? constraint.name : constraint.id,
        x,
        y: yOffset,
        type: "warning",
        shape: "diamond"
      });
      if (thought.objectives) {
        for (const objective of thought.objectives) {
          edges.push({
            source: constraintId,
            target: sanitizeId(objective.id),
            directed: true
          });
        }
      }
    }
    yOffset -= 2;
  }
  if (thought.solution) {
    const solutionLabel = includeMetrics && thought.solution.quality ? `Solution (${thought.solution.quality.toFixed(2)})` : "Solution";
    nodes.push({
      id: "solution",
      label: solutionLabel,
      x: 4,
      y: yOffset,
      type: "success",
      shape: "ellipse"
    });
    if (thought.objectives) {
      for (const objective of thought.objectives) {
        edges.push({
          source: sanitizeId(objective.id),
          target: "solution",
          directed: true
        });
      }
    }
  }
  return generateTikZ(nodes, edges, {
    title: "Optimization Solution",
    colorScheme,
    includeLabels,
    includeMetrics
  });
}
function optimizationToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Optimization Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  if (thought.problem) {
    const problemContent = `
      <p><strong>Name:</strong> ${escapeHTML(thought.problem.name)}</p>
      <p><strong>Type:</strong> ${renderBadge(thought.problem.type.toUpperCase(), "info")}</p>
      <p>${escapeHTML(thought.problem.description)}</p>
    `;
    html += renderSection("Problem", problemContent, "\u{1F3AF}");
  }
  if (includeMetrics) {
    html += '<div class="metrics-grid">\n';
    html += renderMetricCard("Variables", thought.variables?.length || 0, "primary");
    html += renderMetricCard("Constraints", thought.optimizationConstraints?.length || 0, "warning");
    html += renderMetricCard("Objectives", thought.objectives?.length || 0, "info");
    html += renderMetricCard("Quality", thought.solution?.quality?.toFixed(2) || "N/A", "success");
    html += "</div>\n";
  }
  if (thought.variables && thought.variables.length > 0) {
    const variableRows = thought.variables.map((v) => {
      const varType = v.type || "unknown";
      const domain = v.domain ? `[${v.domain.lowerBound}, ${v.domain.upperBound}]` : "N/A";
      return [v.name, varType, domain, v.description];
    });
    const variablesTable = renderTable(
      ["Name", "Type", "Domain", "Description"],
      variableRows,
      { caption: "Decision Variables" }
    );
    html += renderSection("Decision Variables", variablesTable, "\u{1F522}");
  }
  if (thought.optimizationConstraints && thought.optimizationConstraints.length > 0) {
    let constraintsContent = "";
    for (const constraint of thought.optimizationConstraints) {
      const badge = renderBadge(constraint.type.toUpperCase(), "warning");
      constraintsContent += `
        <div class="card">
          <div class="card-header">${escapeHTML(constraint.name)} ${badge}</div>
          <p><strong>Formula:</strong> <code>${escapeHTML(constraint.formula)}</code></p>
        </div>
      `;
    }
    html += renderSection("Constraints", constraintsContent, "\u26A0\uFE0F");
  }
  if (thought.objectives && thought.objectives.length > 0) {
    let objectivesContent = "";
    for (const objective of thought.objectives) {
      const typeColor = objective.type === "maximize" ? "success" : "info";
      const badge = renderBadge(objective.type.toUpperCase(), typeColor);
      objectivesContent += `
        <div class="card">
          <div class="card-header">${badge} ${escapeHTML(objective.name)}</div>
          <p><strong>Formula:</strong> <code>${escapeHTML(objective.formula)}</code></p>
        </div>
      `;
    }
    html += renderSection("Objectives", objectivesContent, "\u{1F3AF}");
  }
  if (thought.solution) {
    const solution = thought.solution;
    let solutionContent = "";
    if (solution.status) {
      const statusBadge = solution.status === "optimal" ? renderBadge("OPTIMAL", "success") : solution.status === "feasible" ? renderBadge("FEASIBLE", "info") : renderBadge("INFEASIBLE", "danger");
      solutionContent += `<p><strong>Status:</strong> ${statusBadge}</p>`;
    }
    if (solution.optimalValue !== void 0) {
      solutionContent += `<p><strong>Optimal Value:</strong> ${solution.optimalValue}</p>`;
    }
    if (solution.quality !== void 0) {
      solutionContent += `<p><strong>Quality:</strong> ${(solution.quality * 100).toFixed(0)}%</p>`;
    }
    if (solution.assignments) {
      solutionContent += "<h4>Variable Assignments</h4><ul>";
      for (const [varId, value] of Object.entries(solution.assignments)) {
        solutionContent += `<li><strong>${escapeHTML(varId)}:</strong> ${value}</li>`;
      }
      solutionContent += "</ul>";
    }
    html += renderSection("Solution", solutionContent, "\u2705");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function optimizationToModelica(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  let modelica = "// Optimization Problem Model\n";
  const packageName = thought.problem ? sanitizeModelicaId(thought.problem.name) : "OptimizationProblem";
  modelica += `package ${packageName}
`;
  if (thought.problem) {
    modelica += `  annotation(Documentation(info="${escapeModelicaString(thought.problem.description)}"));

`;
  }
  if (thought.variables && thought.variables.length > 0) {
    modelica += "  // Decision Variables\n";
    for (const variable of thought.variables) {
      const varId = sanitizeModelicaId(variable.id);
      const varType = variable.type || "Real";
      const domain = variable.domain ? `(min=${variable.domain.lowerBound}, max=${variable.domain.upperBound})` : "";
      const comment = includeLabels && variable.description ? ` "${escapeModelicaString(variable.description)}"` : "";
      modelica += `  ${varType} ${varId}${domain}${comment};
`;
    }
    modelica += "\n";
  }
  if (thought.objectives && thought.objectives.length > 0) {
    modelica += "  // Objective Functions\n";
    for (const objective of thought.objectives) {
      const objId = sanitizeModelicaId(objective.id);
      const comment = includeLabels ? ` "${objective.type}: ${escapeModelicaString(objective.name)}"` : "";
      modelica += `  Real ${objId}${comment};
`;
      modelica += `  equation
`;
      modelica += `    ${objId} = ${escapeModelicaString(objective.formula)};
`;
    }
    modelica += "\n";
  }
  if (thought.optimizationConstraints && thought.optimizationConstraints.length > 0) {
    modelica += "  // Constraints\n";
    modelica += "  equation\n";
    for (const constraint of thought.optimizationConstraints) {
      const comment = includeLabels ? ` // ${constraint.name} (${constraint.type})` : "";
      modelica += `    ${escapeModelicaString(constraint.formula)};${comment}
`;
    }
    modelica += "\n";
  }
  if (thought.solution) {
    modelica += "  // Solution\n";
    modelica += "  record Solution\n";
    const solution = thought.solution;
    if (solution.status) {
      modelica += `    String status = "${escapeModelicaString(solution.status)}";
`;
    }
    if (solution.optimalValue !== void 0) {
      modelica += `    Real optimalValue = ${solution.optimalValue};
`;
    }
    if (includeMetrics && solution.quality !== void 0) {
      modelica += `    Real quality = ${solution.quality.toFixed(4)};
`;
    }
    if (solution.assignments) {
      modelica += "    // Variable Assignments\n";
      for (const [varId, value] of Object.entries(solution.assignments)) {
        const safeVarId = sanitizeModelicaId(varId);
        modelica += `    Real ${safeVarId}_value = ${value};
`;
      }
    }
    modelica += "  end Solution;\n";
  }
  modelica += `end ${packageName};
`;
  return modelica;
}
function optimizationToUML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  if (thought.problem) {
    nodes.push({
      id: "Problem",
      label: includeLabels ? thought.problem.name : "Problem",
      shape: "package",
      attributes: [
        `type: ${thought.problem.type}`,
        `description: ${thought.problem.description}`
      ]
    });
  }
  if (thought.variables && thought.variables.length > 0) {
    const attributes = thought.variables.map((v) => {
      const varType = v.type || "Real";
      const domain = v.domain ? ` [${v.domain.lowerBound}..${v.domain.upperBound}]` : "";
      return `${v.name}: ${varType}${domain}`;
    });
    nodes.push({
      id: "Variables",
      label: "Decision Variables",
      shape: "class",
      attributes
    });
    if (thought.problem) {
      edges.push({
        source: "Problem",
        target: "Variables",
        type: "composition",
        label: "contains"
      });
    }
  }
  if (thought.optimizationConstraints && thought.optimizationConstraints.length > 0) {
    const methods = thought.optimizationConstraints.map(
      (c) => `${c.name}(): ${c.type} = ${c.formula}`
    );
    nodes.push({
      id: "Constraints",
      label: "Constraints",
      shape: "class",
      stereotype: "constraint",
      methods
    });
    if (thought.problem) {
      edges.push({
        source: "Problem",
        target: "Constraints",
        type: "composition",
        label: "enforces"
      });
    }
    if (thought.variables) {
      edges.push({
        source: "Constraints",
        target: "Variables",
        type: "dependency",
        label: "constrains"
      });
    }
  }
  if (thought.objectives && thought.objectives.length > 0) {
    const methods = thought.objectives.map(
      (o) => `${o.name}(): ${o.type} = ${o.formula}`
    );
    nodes.push({
      id: "Objectives",
      label: "Objective Functions",
      shape: "interface",
      stereotype: "interface",
      methods
    });
    if (thought.problem) {
      edges.push({
        source: "Problem",
        target: "Objectives",
        type: "composition",
        label: "optimizes"
      });
    }
    if (thought.variables) {
      edges.push({
        source: "Objectives",
        target: "Variables",
        type: "dependency",
        label: "uses"
      });
    }
  }
  if (thought.solution) {
    const solution = thought.solution;
    const attributes = [];
    if (solution.status) {
      attributes.push(`status: ${solution.status}`);
    }
    if (solution.optimalValue !== void 0) {
      attributes.push(`optimalValue: ${solution.optimalValue}`);
    }
    if (includeMetrics && solution.quality !== void 0) {
      attributes.push(`quality: ${solution.quality.toFixed(2)}`);
    }
    if (solution.assignments) {
      for (const [varId, value] of Object.entries(solution.assignments)) {
        attributes.push(`${varId} = ${value}`);
      }
    }
    nodes.push({
      id: "Solution",
      label: "Solution",
      shape: "class",
      stereotype: "result",
      attributes
    });
    if (thought.objectives) {
      edges.push({
        source: "Solution",
        target: "Objectives",
        type: "implementation",
        label: "satisfies"
      });
    }
  }
  return generateUmlDiagram(nodes, edges, {
    title: "Optimization Problem Structure"});
}
function optimizationToJSON(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const graph = createJsonGraph("Optimization Problem Graph", "optimization");
  let edgeIdCounter = 0;
  if (thought.problem) {
    addNode(graph, {
      id: "problem",
      label: includeLabels ? thought.problem.name : "Problem",
      type: "problem",
      metadata: {
        problemType: thought.problem.type,
        description: thought.problem.description
      }
    });
  }
  if (thought.variables && thought.variables.length > 0) {
    for (const variable of thought.variables) {
      addNode(graph, {
        id: variable.id,
        label: includeLabels ? variable.name : variable.id,
        type: "variable",
        metadata: {
          variableType: variable.type || "Real",
          domain: variable.domain,
          description: variable.description
        }
      });
      if (thought.problem) {
        addEdge(graph, {
          id: `e${edgeIdCounter++}`,
          source: "problem",
          target: variable.id,
          label: "has_variable"
        });
      }
    }
  }
  if (thought.optimizationConstraints && thought.optimizationConstraints.length > 0) {
    for (const constraint of thought.optimizationConstraints) {
      addNode(graph, {
        id: constraint.id,
        label: includeLabels ? constraint.name : constraint.id,
        type: "constraint",
        metadata: {
          constraintType: constraint.type,
          formula: constraint.formula
        }
      });
      if (thought.problem) {
        addEdge(graph, {
          id: `e${edgeIdCounter++}`,
          source: "problem",
          target: constraint.id,
          label: "enforces"
        });
      }
    }
  }
  if (thought.objectives && thought.objectives.length > 0) {
    for (const objective of thought.objectives) {
      addNode(graph, {
        id: objective.id,
        label: includeLabels ? objective.name : objective.id,
        type: "objective",
        metadata: {
          objectiveType: objective.type,
          formula: objective.formula
        }
      });
      if (thought.problem) {
        addEdge(graph, {
          id: `e${edgeIdCounter++}`,
          source: "problem",
          target: objective.id,
          label: "optimizes"
        });
      }
      if (thought.solution) {
        addEdge(graph, {
          id: `e${edgeIdCounter++}`,
          source: objective.id,
          target: "solution",
          label: "achieved_by"
        });
      }
    }
  }
  if (thought.solution) {
    const solution = thought.solution;
    addNode(graph, {
      id: "solution",
      label: "Solution",
      type: "solution",
      metadata: {
        status: solution.status,
        optimalValue: solution.optimalValue,
        quality: solution.quality,
        assignments: solution.assignments
      }
    });
  }
  if (includeMetrics) {
    addMetric(graph, "variable_count", thought.variables?.length || 0);
    addMetric(graph, "constraint_count", thought.optimizationConstraints?.length || 0);
    addMetric(graph, "objective_count", thought.objectives?.length || 0);
    if (thought.solution?.quality !== void 0) {
      addMetric(graph, "solution_quality", thought.solution.quality);
    }
  }
  return serializeGraph(graph);
}
function optimizationToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  if (thought.problem) {
    const problemContent = keyValueSection({
      "Name": thought.problem.name,
      "Type": thought.problem.type,
      "Description": thought.problem.description
    });
    parts.push(section("Problem", problemContent));
  }
  if (includeMetrics) {
    const metricsContent = keyValueSection({
      "Variables": thought.variables?.length || 0,
      "Constraints": thought.optimizationConstraints?.length || 0,
      "Objectives": thought.objectives?.length || 0,
      "Quality": thought.solution?.quality?.toFixed(2) || "N/A"
    });
    parts.push(section("Metrics", metricsContent));
  }
  if (thought.variables && thought.variables.length > 0) {
    const variableRows = thought.variables.map((v) => {
      const varType = v.type || "unknown";
      const domain = v.domain ? `[${v.domain.lowerBound}, ${v.domain.upperBound}]` : "N/A";
      return [v.name, varType, domain, v.description];
    });
    const variablesTable = table(
      ["Name", "Type", "Domain", "Description"],
      variableRows
    );
    parts.push(section("Decision Variables", variablesTable));
  }
  if (thought.optimizationConstraints && thought.optimizationConstraints.length > 0) {
    const constraintItems = thought.optimizationConstraints.map(
      (c) => `**${c.name}** (${c.type})
  - Formula: \`${c.formula}\``
    );
    parts.push(section("Constraints", list(constraintItems)));
  }
  if (thought.objectives && thought.objectives.length > 0) {
    const objectiveItems = thought.objectives.map(
      (o) => `**${o.type.toUpperCase()}: ${o.name}**
  - Formula: \`${o.formula}\``
    );
    parts.push(section("Objectives", list(objectiveItems)));
  }
  if (thought.solution) {
    const solution = thought.solution;
    let solutionContent = "";
    if (solution.status) {
      solutionContent += `**Status:** ${solution.status}

`;
    }
    const solutionMetrics = {};
    if (solution.optimalValue !== void 0) {
      solutionMetrics["Optimal Value"] = solution.optimalValue;
    }
    if (solution.quality !== void 0) {
      solutionMetrics["Quality"] = `${(solution.quality * 100).toFixed(0)}%`;
    }
    if (Object.keys(solutionMetrics).length > 0) {
      solutionContent += keyValueSection(solutionMetrics);
    }
    if (solution.assignments) {
      solutionContent += "\n**Variable Assignments:**\n\n";
      solutionContent += keyValueSection(solution.assignments);
    }
    parts.push(section("Solution", solutionContent));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = optimizationToMermaid(thought, "default", true, true);
    parts.push(section("Optimization Diagram", mermaidBlock(mermaidDiagram)));
  }
  return document("Optimization Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: { mode: "optimization" }
  });
}
var init_optimization = __esm({
  "src/export/visual/modes/optimization.ts"() {
    init_esm_shims();
    init_utils();
    init_svg();
    init_graphml();
    init_tikz();
    init_html();
    init_modelica();
    init_uml();
    init_json();
    init_markdown();
  }
});

// src/export/visual/modes/abductive.ts
function exportAbductiveHypotheses(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return abductiveToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return abductiveToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return abductiveToASCII(thought);
    case "svg":
      return abductiveToSVG(thought, options);
    case "graphml":
      return abductiveToGraphML(thought, options);
    case "tikz":
      return abductiveToTikZ(thought, options);
    case "html":
      return abductiveToHTML(thought, options);
    case "modelica":
      return abductiveToModelica(thought, options);
    case "uml":
      return abductiveToUML(thought, options);
    case "json":
      return abductiveToJSON(thought, options);
    case "markdown":
      return abductiveToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function abductiveToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TD\n";
  mermaid += '  Observations["Observations"]\n';
  for (const hypothesis of thought.hypotheses) {
    const hypId = sanitizeId(hypothesis.id);
    const label = includeLabels ? hypothesis.explanation.substring(0, 50) + "..." : hypId;
    const scoreLabel = includeMetrics ? ` (${hypothesis.score.toFixed(2)})` : "";
    mermaid += `  ${hypId}["${label}${scoreLabel}"]
`;
    mermaid += `  Observations --> ${hypId}
`;
  }
  if (thought.bestExplanation && colorScheme !== "monochrome") {
    mermaid += "\n";
    const bestId = sanitizeId(thought.bestExplanation.id);
    const color = colorScheme === "pastel" ? "#e1f5ff" : "#a8d5ff";
    mermaid += `  style ${bestId} fill:${color},stroke:#333,stroke-width:3px
`;
  }
  return mermaid;
}
function abductiveToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph AbductiveHypotheses {\n";
  dot += "  rankdir=TD;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  dot += '  Observations [label="Observations", shape=ellipse];\n\n';
  for (const hypothesis of thought.hypotheses) {
    const hypId = sanitizeId(hypothesis.id);
    const label = includeLabels ? hypothesis.explanation.substring(0, 50) + "..." : hypId;
    const scoreLabel = includeMetrics ? ` (${hypothesis.score.toFixed(2)})` : "";
    const isBest = thought.bestExplanation?.id === hypothesis.id;
    const style = isBest ? ", style=filled, fillcolor=lightblue" : "";
    dot += `  ${hypId} [label="${label}${scoreLabel}"${style}];
`;
    dot += `  Observations -> ${hypId};
`;
  }
  dot += "}\n";
  return dot;
}
function abductiveToASCII(thought) {
  let ascii = "Abductive Hypothesis Comparison:\n";
  ascii += "================================\n\n";
  ascii += "Observations:\n";
  for (const obs of thought.observations) {
    ascii += `  \u2022 ${obs.description} (confidence: ${obs.confidence.toFixed(2)})
`;
  }
  ascii += "\nHypotheses:\n";
  for (const hypothesis of thought.hypotheses) {
    const isBest = thought.bestExplanation?.id === hypothesis.id;
    const marker = isBest ? "\u2605" : "\u2022";
    ascii += `  ${marker} ${hypothesis.explanation}
`;
    ascii += `    Score: ${hypothesis.score.toFixed(2)}
`;
    ascii += `    Assumptions: ${hypothesis.assumptions.join(", ")}
`;
    ascii += "\n";
  }
  if (thought.bestExplanation) {
    ascii += `Best Explanation: ${thought.bestExplanation.explanation}
`;
  }
  return ascii;
}
function abductiveToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width,
    svgHeight = 450
  } = options;
  const positions = /* @__PURE__ */ new Map();
  const nodeWidth = 180;
  const nodeHeight = 50;
  const centerX = svgWidth / 2;
  positions.set("observations", {
    id: "observations",
    x: centerX - nodeWidth / 2,
    y: 60,
    width: nodeWidth,
    height: nodeHeight,
    label: "Observations",
    type: "observations"
  });
  const hypCount = thought.hypotheses.length;
  const layerWidth = hypCount * (nodeWidth + 20) - 20;
  let startX = (svgWidth - layerWidth) / 2;
  for (const hypothesis of thought.hypotheses) {
    const hypId = sanitizeId(hypothesis.id);
    const label = includeLabels ? hypothesis.explanation.substring(0, 30) + "..." : hypId;
    const scoreLabel = includeMetrics ? ` (${hypothesis.score.toFixed(2)})` : "";
    positions.set(hypothesis.id, {
      id: hypothesis.id,
      x: startX,
      y: 180,
      width: nodeWidth,
      height: nodeHeight,
      label: label + scoreLabel,
      type: thought.bestExplanation?.id === hypothesis.id ? "best" : "hypothesis"
    });
    startX += nodeWidth + 20;
  }
  let svg = generateSVGHeader(svgWidth, svgHeight, "Abductive Hypotheses");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  const obsPos = positions.get("observations");
  for (const hypothesis of thought.hypotheses) {
    const hypPos = positions.get(hypothesis.id);
    if (obsPos && hypPos) {
      svg += renderEdge(obsPos, hypPos, {});
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  svg += renderEllipseNode(positions.get("observations"), getNodeColor("info", colorScheme));
  for (const hypothesis of thought.hypotheses) {
    const pos = positions.get(hypothesis.id);
    const isBest = thought.bestExplanation?.id === hypothesis.id;
    const colors = isBest ? getNodeColor("success", colorScheme) : getNodeColor("neutral", colorScheme);
    if (isBest) {
      svg += renderStadiumNode(pos, colors);
    } else {
      svg += renderRectNode(pos, colors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Hypotheses", value: thought.hypotheses.length },
      { label: "Observations", value: thought.observations.length },
      { label: "Best Score", value: thought.bestExplanation?.score.toFixed(2) || "N/A" }
    ];
    svg += renderMetricsPanel(svgWidth - 180, svgHeight - 100, metrics);
  }
  const legendItems = [
    { label: "Observations", color: getNodeColor("info", colorScheme), shape: "ellipse" },
    { label: "Hypothesis", color: getNodeColor("neutral", colorScheme) },
    { label: "Best", color: getNodeColor("success", colorScheme) }
  ];
  svg += renderLegend(20, svgHeight - 80, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function abductiveToGraphML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = thought.hypotheses.map((hypothesis) => ({
    id: sanitizeId(hypothesis.id),
    label: includeLabels ? hypothesis.explanation.substring(0, 50) + "..." : hypothesis.id,
    type: "hypothesis",
    metadata: includeMetrics ? {
      description: hypothesis.explanation,
      score: hypothesis.score,
      assumptions: hypothesis.assumptions.join(", ")
    } : void 0
  }));
  if (thought.observations && thought.observations.length > 0) {
    for (const obs of thought.observations) {
      nodes.push({
        id: sanitizeId(`obs_${obs.id}`),
        label: includeLabels ? obs.description : `obs_${obs.id}`,
        type: "observation",
        metadata: includeMetrics ? {
          description: obs.description,
          confidence: obs.confidence
        } : void 0
      });
    }
  }
  const edges = [];
  let edgeId = 0;
  if (thought.observations && thought.observations.length > 0) {
    for (const obs of thought.observations) {
      for (const hypothesis of thought.hypotheses) {
        edges.push({
          id: `e${edgeId++}`,
          source: sanitizeId(`obs_${obs.id}`),
          target: sanitizeId(hypothesis.id),
          metadata: includeMetrics ? { weight: obs.confidence } : void 0
        });
      }
    }
  }
  return generateGraphML(nodes, edges, {
    graphName: "Abductive Hypotheses",
    includeLabels,
    includeMetadata: includeMetrics
  });
}
function abductiveToTikZ(thought, options) {
  const { includeLabels = true, includeMetrics = true, colorScheme = "default" } = options;
  const nodes = [];
  const edges = [];
  const hypCount = thought.hypotheses.length;
  const spacing = 3;
  const totalWidth = (hypCount - 1) * spacing;
  const startX = 4 - totalWidth / 2;
  for (let i = 0; i < thought.hypotheses.length; i++) {
    const hypothesis = thought.hypotheses[i];
    const isBest = thought.bestExplanation?.id === hypothesis.id;
    const label = includeLabels ? hypothesis.explanation.substring(0, 30) + "..." : hypothesis.id;
    const scoreLabel = includeMetrics ? ` (${hypothesis.score.toFixed(2)})` : "";
    nodes.push({
      id: sanitizeId(hypothesis.id),
      label: label + scoreLabel,
      x: startX + i * spacing,
      y: -2,
      type: isBest ? "success" : "hypothesis",
      shape: "ellipse"
    });
  }
  if (thought.observations && thought.observations.length > 0) {
    const obsCount = thought.observations.length;
    const obsSpacing = Math.min(spacing, totalWidth / Math.max(1, obsCount - 1));
    const obsStartX = 4 - (obsCount - 1) * obsSpacing / 2;
    for (let i = 0; i < thought.observations.length; i++) {
      const obs = thought.observations[i];
      nodes.push({
        id: sanitizeId(`obs_${obs.id}`),
        label: includeLabels ? obs.description.substring(0, 30) + "..." : `obs_${obs.id}`,
        x: obsStartX + i * obsSpacing,
        y: 0,
        type: "info",
        shape: "rectangle"
      });
      for (const hypothesis of thought.hypotheses) {
        edges.push({
          source: sanitizeId(`obs_${obs.id}`),
          target: sanitizeId(hypothesis.id),
          directed: true
        });
      }
    }
  }
  return generateTikZ(nodes, edges, {
    title: "Abductive Hypotheses",
    includeLabels,
    includeMetrics,
    colorScheme
  });
}
function abductiveToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Abductive Reasoning Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  if (includeMetrics) {
    html += '<div class="metrics-grid">';
    html += renderMetricCard("Observations", thought.observations.length, "info");
    html += renderMetricCard("Hypotheses", thought.hypotheses.length, "primary");
    if (thought.bestExplanation) {
      html += renderMetricCard("Best Score", thought.bestExplanation.score.toFixed(2), "success");
    }
    html += "</div>\n";
  }
  const obsRows = thought.observations.map((obs, i) => [
    (i + 1).toString(),
    obs.description,
    obs.confidence.toFixed(2),
    obs.timestamp || "-"
  ]);
  html += renderSection("Observations", renderTable(
    ["#", "Description", "Confidence", "Time"],
    obsRows
  ), "\u{1F441}\uFE0F");
  const hypRows = thought.hypotheses.map((hyp) => {
    const isBest = thought.bestExplanation?.id === hyp.id;
    const badge = isBest ? renderBadge("Best", "success") : "";
    return [
      hyp.explanation.substring(0, 60) + (hyp.explanation.length > 60 ? "..." : ""),
      hyp.score.toFixed(2),
      badge,
      hyp.assumptions.slice(0, 3).join(", ") + (hyp.assumptions.length > 3 ? "..." : "")
    ];
  });
  html += renderSection("Hypotheses", renderTable(
    ["Explanation", "Score", "Status", "Key Assumptions"],
    hypRows.map((row) => row.map((cell) => typeof cell === "string" && cell.startsWith("<") ? cell : escapeHTML(String(cell))))
  ), "\u{1F4A1}");
  if (thought.bestExplanation) {
    html += renderSection("Best Explanation", `
      <div class="card">
        <div class="card-header">${escapeHTML(thought.bestExplanation.explanation)}</div>
        <p><strong>Score:</strong> ${thought.bestExplanation.score.toFixed(2)}</p>
        <p><strong>Assumptions:</strong></p>
        <ul class="list-styled">
          ${thought.bestExplanation.assumptions.map((a) => `<li>${escapeHTML(a)}</li>`).join("\n")}
        </ul>
      </div>
    `, "\u2B50");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function abductiveToModelica(thought, options) {
  const { modelicaPackageName, includeMetrics = true } = options;
  const children = thought.hypotheses.map((h) => ({
    name: sanitizeId(h.id),
    description: h.explanation.substring(0, 100),
    score: includeMetrics ? h.score : void 0
  }));
  return generateHierarchyModelica(
    "Observations",
    `Abductive reasoning with ${thought.observations.length} observations`,
    children,
    {
      packageName: modelicaPackageName || "AbductiveHypotheses",
      includeMetrics
    }
  );
}
function abductiveToUML(thought, options) {
  const { umlTheme, umlDirection, includeLabels = true, includeMetrics = true } = options;
  const nodes = [
    {
      id: "observations",
      label: "Observations",
      shape: "database"
    }
  ];
  const edges = [];
  for (const hyp of thought.hypotheses) {
    const isBest = thought.bestExplanation?.id === hyp.id;
    const label = includeLabels ? hyp.explanation.substring(0, 40) + (hyp.explanation.length > 40 ? "..." : "") : hyp.id;
    const scoreLabel = includeMetrics ? ` (${hyp.score.toFixed(2)})` : "";
    nodes.push({
      id: sanitizeId(hyp.id),
      label: label + scoreLabel,
      shape: "class",
      color: isBest ? "90EE90" : void 0,
      stereotype: isBest ? "best" : void 0
    });
    edges.push({
      source: "observations",
      target: sanitizeId(hyp.id),
      type: "arrow"
    });
  }
  return generateUmlDiagram(nodes, edges, {
    title: "Abductive Hypotheses",
    theme: umlTheme,
    direction: umlDirection
  });
}
function abductiveToJSON(thought, options) {
  const { jsonPrettyPrint = true, jsonIndent = 2, includeMetrics = true } = options;
  const children = thought.hypotheses.map((h) => ({
    id: sanitizeId(h.id),
    label: h.explanation.substring(0, 60),
    score: h.score,
    metadata: {
      assumptions: h.assumptions,
      isBest: thought.bestExplanation?.id === h.id
    }
  }));
  let json = generateHierarchyJson(
    "Abductive Hypotheses",
    "abductive",
    { label: "Observations", metadata: { count: thought.observations.length } },
    children,
    {
      prettyPrint: jsonPrettyPrint,
      indent: jsonIndent,
      includeMetrics
    }
  );
  if (includeMetrics) {
    const graph = JSON.parse(json);
    graph.metadata.observationCount = thought.observations.length;
    graph.metadata.hypothesisCount = thought.hypotheses.length;
    if (thought.bestExplanation) {
      graph.metadata.bestHypothesisId = thought.bestExplanation.id;
      graph.metadata.bestScore = thought.bestExplanation.score;
    }
    json = JSON.stringify(graph, null, jsonPrettyPrint !== false ? jsonIndent : 0);
  }
  return json;
}
function abductiveToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  if (includeMetrics) {
    parts.push(section("Metrics", keyValueSection({
      "Total Hypotheses": thought.hypotheses.length,
      "Total Observations": thought.observations.length,
      "Best Hypothesis Score": thought.bestExplanation?.score.toFixed(2) || "N/A"
    })));
  }
  const obsRows = thought.observations.map((obs) => [
    obs.id,
    obs.description,
    obs.confidence.toFixed(2),
    obs.timestamp || "-"
  ]);
  parts.push(section("Observations", table(
    ["ID", "Description", "Confidence", "Timestamp"],
    obsRows
  )));
  const hypRows = thought.hypotheses.map((hyp) => [
    hyp.id,
    hyp.explanation.substring(0, 60) + (hyp.explanation.length > 60 ? "..." : ""),
    hyp.score.toFixed(2),
    thought.bestExplanation?.id === hyp.id ? "\u2605 Best" : ""
  ]);
  parts.push(section("Hypotheses", table(
    ["ID", "Explanation", "Score", "Status"],
    hypRows
  )));
  if (thought.bestExplanation) {
    const assumptions = list(thought.bestExplanation.assumptions);
    parts.push(section(
      "Best Explanation",
      `**Score:** ${thought.bestExplanation.score.toFixed(2)}

**Explanation:** ${thought.bestExplanation.explanation}

**Assumptions:**
${assumptions}`
    ));
  }
  if (markdownIncludeMermaid) {
    const mermaid = abductiveToMermaid(thought, "default", true, includeMetrics);
    parts.push(section("Visualization", mermaidBlock(mermaid)));
  }
  return document("Abductive Reasoning Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: { mode: "abductive", hypotheses: thought.hypotheses.length }
  });
}
var init_abductive = __esm({
  "src/export/visual/modes/abductive.ts"() {
    init_esm_shims();
    init_utils();
    init_svg();
    init_graphml();
    init_tikz();
    init_html();
    init_modelica();
    init_uml();
    init_json();
    init_markdown();
  }
});

// src/export/visual/modes/analogical.ts
function exportAnalogicalMapping(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return analogicalToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return analogicalToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return analogicalToASCII(thought);
    case "svg":
      return analogicalToSVG(thought, options);
    case "graphml":
      return analogicalToGraphML(thought, options);
    case "tikz":
      return analogicalToTikZ(thought, options);
    case "html":
      return analogicalToHTML(thought, options);
    case "modelica":
      return analogicalToModelica(thought, options);
    case "uml":
      return analogicalToUML(thought, options);
    case "json":
      return analogicalToJSON(thought, options);
    case "markdown":
      return analogicalToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function analogicalToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph LR\n";
  mermaid += '  subgraph Source["Source Domain"]\n';
  for (const entity of thought.sourceDomain.entities) {
    const entityId = sanitizeId("src_" + entity.id);
    const label = includeLabels ? entity.name : entityId;
    mermaid += `    ${entityId}["${label}"]
`;
  }
  mermaid += "  end\n\n";
  mermaid += '  subgraph Target["Target Domain"]\n';
  for (const entity of thought.targetDomain.entities) {
    const entityId = sanitizeId("tgt_" + entity.id);
    const label = includeLabels ? entity.name : entityId;
    mermaid += `    ${entityId}["${label}"]
`;
  }
  mermaid += "  end\n\n";
  for (const mapping of thought.mapping) {
    const srcId = sanitizeId("src_" + mapping.sourceEntityId);
    const tgtId = sanitizeId("tgt_" + mapping.targetEntityId);
    const confidenceLabel = includeMetrics ? `|${mapping.confidence.toFixed(2)}|` : "";
    mermaid += `  ${srcId} -.->${confidenceLabel} ${tgtId}
`;
  }
  if (colorScheme !== "monochrome") {
    mermaid += "\n";
    const srcColor = colorScheme === "pastel" ? "#fff3e0" : "#ffd699";
    const tgtColor = colorScheme === "pastel" ? "#e1f5ff" : "#a8d5ff";
    for (const entity of thought.sourceDomain.entities) {
      const entityId = sanitizeId("src_" + entity.id);
      mermaid += `  style ${entityId} fill:${srcColor}
`;
    }
    for (const entity of thought.targetDomain.entities) {
      const entityId = sanitizeId("tgt_" + entity.id);
      mermaid += `  style ${entityId} fill:${tgtColor}
`;
    }
  }
  return mermaid;
}
function analogicalToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph AnalogicalMapping {\n";
  dot += "  rankdir=LR;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  dot += "  subgraph cluster_source {\n";
  dot += '    label="Source Domain";\n';
  dot += "    style=filled;\n";
  dot += "    fillcolor=lightyellow;\n\n";
  for (const entity of thought.sourceDomain.entities) {
    const entityId = sanitizeId("src_" + entity.id);
    const label = includeLabels ? entity.name : entityId;
    dot += `    ${entityId} [label="${label}"];
`;
  }
  dot += "  }\n\n";
  dot += "  subgraph cluster_target {\n";
  dot += '    label="Target Domain";\n';
  dot += "    style=filled;\n";
  dot += "    fillcolor=lightblue;\n\n";
  for (const entity of thought.targetDomain.entities) {
    const entityId = sanitizeId("tgt_" + entity.id);
    const label = includeLabels ? entity.name : entityId;
    dot += `    ${entityId} [label="${label}"];
`;
  }
  dot += "  }\n\n";
  for (const mapping of thought.mapping) {
    const srcId = sanitizeId("src_" + mapping.sourceEntityId);
    const tgtId = sanitizeId("tgt_" + mapping.targetEntityId);
    const confidenceLabel = includeMetrics ? `, label="${mapping.confidence.toFixed(2)}"` : "";
    dot += `  ${srcId} -> ${tgtId} [style=dashed${confidenceLabel}];
`;
  }
  dot += "}\n";
  return dot;
}
function analogicalToASCII(thought) {
  let ascii = "Analogical Domain Mapping:\n";
  ascii += "==========================\n\n";
  ascii += `Source Domain: ${thought.sourceDomain.name}
`;
  ascii += `${thought.sourceDomain.description}

`;
  ascii += `Target Domain: ${thought.targetDomain.name}
`;
  ascii += `${thought.targetDomain.description}

`;
  ascii += "Mappings:\n";
  for (const mapping of thought.mapping) {
    const srcEntity = thought.sourceDomain.entities.find((e) => e.id === mapping.sourceEntityId);
    const tgtEntity = thought.targetDomain.entities.find((e) => e.id === mapping.targetEntityId);
    if (srcEntity && tgtEntity) {
      ascii += `  ${srcEntity.name} \u2190\u2192 ${tgtEntity.name} (confidence: ${mapping.confidence.toFixed(2)})
`;
      ascii += `    ${mapping.justification}
`;
    }
  }
  ascii += `
Analogy Strength: ${thought.analogyStrength.toFixed(2)}
`;
  return ascii;
}
function analogicalToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width
  } = options;
  const positions = /* @__PURE__ */ new Map();
  const sourceY = 100;
  const entitySpacing = 100;
  const nodeWidth = 150;
  const nodeHeight = 40;
  thought.sourceDomain.entities.forEach((entity, index) => {
    const srcId = "src_" + entity.id;
    positions.set(srcId, {
      id: srcId,
      label: includeLabels ? entity.name : srcId,
      x: 150,
      y: sourceY + index * entitySpacing,
      width: nodeWidth,
      height: nodeHeight,
      type: "source"
    });
  });
  const targetY = 100;
  thought.targetDomain.entities.forEach((entity, index) => {
    const tgtId = "tgt_" + entity.id;
    positions.set(tgtId, {
      id: tgtId,
      label: includeLabels ? entity.name : tgtId,
      x: svgWidth - 150,
      y: targetY + index * entitySpacing,
      width: nodeWidth,
      height: nodeHeight,
      type: "target"
    });
  });
  const actualHeight = Math.max(
    DEFAULT_SVG_OPTIONS.height,
    Math.max(thought.sourceDomain.entities.length, thought.targetDomain.entities.length) * entitySpacing + 150
  );
  let svg = generateSVGHeader(svgWidth, actualHeight, "Analogical Domain Mapping");
  svg += '\n  <!-- Mappings -->\n  <g class="edges">';
  for (const mapping of thought.mapping) {
    const srcPos = positions.get("src_" + mapping.sourceEntityId);
    const tgtPos = positions.get("tgt_" + mapping.targetEntityId);
    if (srcPos && tgtPos) {
      const label = includeMetrics ? mapping.confidence.toFixed(2) : void 0;
      svg += renderEdge(srcPos, tgtPos, { label, style: "dashed" });
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  const sourceColors = getNodeColor("tertiary", colorScheme);
  const targetColors = getNodeColor("primary", colorScheme);
  for (const [, pos] of positions) {
    if (pos.type === "source") {
      svg += renderRectNode(pos, sourceColors);
    } else {
      svg += renderRectNode(pos, targetColors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Analogy Strength", value: thought.analogyStrength.toFixed(2) },
      { label: "Mappings", value: thought.mapping.length },
      { label: "Source Entities", value: thought.sourceDomain.entities.length },
      { label: "Target Entities", value: thought.targetDomain.entities.length }
    ];
    svg += renderMetricsPanel(svgWidth - 180, actualHeight - 140, metrics);
  }
  const legendItems = [
    { label: "Source Domain", color: sourceColors },
    { label: "Target Domain", color: targetColors }
  ];
  svg += renderLegend(20, actualHeight - 80, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function analogicalToGraphML(thought, options) {
  const { includeMetrics = true } = options;
  const nodes = [];
  for (const entity of thought.sourceDomain.entities) {
    nodes.push({
      id: "src_" + entity.id,
      label: entity.name,
      type: "source",
      metadata: {
        description: entity.description,
        domain: thought.sourceDomain.name
      }
    });
  }
  for (const entity of thought.targetDomain.entities) {
    nodes.push({
      id: "tgt_" + entity.id,
      label: entity.name,
      type: "target",
      metadata: {
        description: entity.description,
        domain: thought.targetDomain.name
      }
    });
  }
  const edges = thought.mapping.map((mapping, index) => {
    const edge = {
      id: `mapping_${index}`,
      source: "src_" + mapping.sourceEntityId,
      target: "tgt_" + mapping.targetEntityId
    };
    if (includeMetrics) {
      edge.metadata = {
        weight: mapping.confidence,
        type: "mapping"
      };
      edge.label = mapping.confidence.toFixed(2);
    }
    return edge;
  });
  const graphmlOptions = {
    graphName: "Analogical Mapping"
  };
  return generateGraphML(nodes, edges, graphmlOptions);
}
function analogicalToTikZ(thought, options) {
  const { includeLabels = true, includeMetrics = true, colorScheme = "default" } = options;
  const nodes = [];
  thought.sourceDomain.entities.forEach((entity, index) => {
    nodes.push({
      id: "src_" + entity.id,
      x: -3,
      y: -index * 1.5,
      label: includeLabels ? entity.name : entity.id,
      shape: "rectangle",
      type: "tertiary"
    });
  });
  thought.targetDomain.entities.forEach((entity, index) => {
    nodes.push({
      id: "tgt_" + entity.id,
      x: 3,
      y: -index * 1.5,
      label: includeLabels ? entity.name : entity.id,
      shape: "rectangle",
      type: "primary"
    });
  });
  const edges = thought.mapping.map((mapping) => {
    const edge = {
      source: "src_" + mapping.sourceEntityId,
      target: "tgt_" + mapping.targetEntityId,
      style: "dashed"
    };
    if (includeMetrics) {
      edge.label = mapping.confidence.toFixed(2);
    }
    return edge;
  });
  const tikzOptions = {
    title: "Analogical Mapping",
    colorScheme,
    includeLabels,
    includeMetrics
  };
  let tikz = generateTikZ(nodes, edges, tikzOptions);
  if (includeMetrics) {
    const metrics = [
      { label: "Analogy Strength", value: thought.analogyStrength.toFixed(2) },
      { label: "Mappings", value: thought.mapping.length.toString() },
      { label: "Source Entities", value: thought.sourceDomain.entities.length.toString() },
      { label: "Target Entities", value: thought.targetDomain.entities.length.toString() }
    ];
    tikz = tikz.replace(
      /\\end\{tikzpicture\}/,
      renderTikZMetrics(6, -6, metrics) + "\n\\end{tikzpicture}"
    );
  }
  const sourceColors = getTikZColor("tertiary", colorScheme);
  const targetColors = getTikZColor("primary", colorScheme);
  const legendItems = [
    { label: "Source Domain", color: sourceColors },
    { label: "Target Domain", color: targetColors }
  ];
  tikz = tikz.replace(
    /\\end\{tikzpicture\}/,
    renderTikZLegend(-3, -6, legendItems) + "\n\\end{tikzpicture}"
  );
  return tikz;
}
function analogicalToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Analogical Reasoning Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  if (includeMetrics) {
    html += '<div class="metrics-grid">';
    html += renderMetricCard("Analogy Strength", (thought.analogyStrength * 100).toFixed(0) + "%", "primary");
    html += renderMetricCard("Mappings", thought.mapping.length, "info");
    html += renderMetricCard("Source Entities", thought.sourceDomain.entities.length, "success");
    html += renderMetricCard("Target Entities", thought.targetDomain.entities.length, "warning");
    html += "</div>\n";
    html += renderProgressBar(thought.analogyStrength * 100, "primary");
  }
  const srcRows = thought.sourceDomain.entities.map((e) => [e.id, e.name, e.type || "-", e.description || "-"]);
  html += renderSection("Source Domain: " + thought.sourceDomain.name, renderTable(
    ["ID", "Name", "Type", "Description"],
    srcRows
  ), "\u{1F4D8}");
  const tgtRows = thought.targetDomain.entities.map((e) => [e.id, e.name, e.type || "-", e.description || "-"]);
  html += renderSection("Target Domain: " + thought.targetDomain.name, renderTable(
    ["ID", "Name", "Type", "Description"],
    tgtRows
  ), "\u{1F4D7}");
  const mapRows = thought.mapping.map((m) => [
    m.sourceEntityId,
    "\u2192",
    m.targetEntityId,
    (m.confidence * 100).toFixed(0) + "%",
    m.justification || "-"
  ]);
  html += renderSection("Entity Mappings", renderTable(
    ["Source", "", "Target", "Confidence", "Justification"],
    mapRows
  ), "\u{1F517}");
  if (thought.inferences && thought.inferences.length > 0) {
    const infRows = thought.inferences.map((inf, i) => [
      (i + 1).toString(),
      inf.sourcePattern,
      inf.targetPrediction,
      (inf.confidence * 100).toFixed(0) + "%"
    ]);
    html += renderSection("Inferences", renderTable(
      ["#", "Source Pattern", "Target Prediction", "Confidence"],
      infRows
    ), "\u{1F4A1}");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function analogicalToModelica(thought, options) {
  const { includeMetrics = true } = options;
  const pkgName = sanitizeModelicaId("AnalogicalMapping");
  let modelica = `package ${pkgName}
`;
  modelica += `  "${escapeModelicaString("Analogical domain mapping: " + thought.sourceDomain.name + " \u2192 " + thought.targetDomain.name)}"

`;
  modelica += `  record SourceDomain "${escapeModelicaString(thought.sourceDomain.name)}"
`;
  modelica += `    String name = "${escapeModelicaString(thought.sourceDomain.name)}";
`;
  modelica += `    String description = "${escapeModelicaString(thought.sourceDomain.description || "")}";
`;
  thought.sourceDomain.entities.forEach((entity) => {
    const entityId = sanitizeModelicaId(entity.id);
    modelica += `    parameter String entity_${entityId} = "${escapeModelicaString(entity.name)}";
`;
    if (entity.description) {
      modelica += `    parameter String entity_${entityId}_desc = "${escapeModelicaString(entity.description)}";
`;
    }
  });
  modelica += `  end SourceDomain;

`;
  modelica += `  record TargetDomain "${escapeModelicaString(thought.targetDomain.name)}"
`;
  modelica += `    String name = "${escapeModelicaString(thought.targetDomain.name)}";
`;
  modelica += `    String description = "${escapeModelicaString(thought.targetDomain.description || "")}";
`;
  thought.targetDomain.entities.forEach((entity) => {
    const entityId = sanitizeModelicaId(entity.id);
    modelica += `    parameter String entity_${entityId} = "${escapeModelicaString(entity.name)}";
`;
    if (entity.description) {
      modelica += `    parameter String entity_${entityId}_desc = "${escapeModelicaString(entity.description)}";
`;
    }
  });
  modelica += `  end TargetDomain;

`;
  modelica += `  record Mapping "Entity mapping with confidence"
`;
  thought.mapping.forEach((mapping, index) => {
    const srcId = sanitizeModelicaId(mapping.sourceEntityId);
    const tgtId = sanitizeModelicaId(mapping.targetEntityId);
    modelica += `    parameter String map_${index}_source = "${escapeModelicaString(srcId)}";
`;
    modelica += `    parameter String map_${index}_target = "${escapeModelicaString(tgtId)}";
`;
    modelica += `    parameter Real map_${index}_confidence = ${mapping.confidence.toFixed(3)};
`;
    if (mapping.justification) {
      modelica += `    parameter String map_${index}_justification = "${escapeModelicaString(mapping.justification)}";
`;
    }
  });
  modelica += `  end Mapping;

`;
  if (includeMetrics) {
    modelica += `  record Metrics "Analogy metrics"
`;
    modelica += `    parameter Real analogyStrength = ${thought.analogyStrength.toFixed(3)};
`;
    modelica += `    parameter Integer mappingCount = ${thought.mapping.length};
`;
    modelica += `    parameter Integer sourceEntityCount = ${thought.sourceDomain.entities.length};
`;
    modelica += `    parameter Integer targetEntityCount = ${thought.targetDomain.entities.length};
`;
    modelica += `  end Metrics;

`;
  }
  modelica += `  model AnalogicalSystem "Complete analogical mapping system"
`;
  modelica += `    SourceDomain source;
`;
  modelica += `    TargetDomain target;
`;
  modelica += `    Mapping mappings;
`;
  if (includeMetrics) {
    modelica += `    Metrics metrics;
`;
  }
  modelica += `  end AnalogicalSystem;

`;
  modelica += `  annotation(Documentation(info="<html>
`;
  modelica += `    <p>Analogical mapping between ${escapeModelicaString(thought.sourceDomain.name)} and ${escapeModelicaString(thought.targetDomain.name)}</p>
`;
  modelica += `    <p>Analogy strength: ${(thought.analogyStrength * 100).toFixed(1)}%</p>
`;
  modelica += `  </html>"));
`;
  modelica += `end ${pkgName};
`;
  return modelica;
}
function analogicalToUML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  nodes.push({
    id: "source_domain",
    label: thought.sourceDomain.name,
    shape: "package",
    stereotype: "source"
  });
  thought.sourceDomain.entities.forEach((entity) => {
    const nodeId = "src_" + entity.id;
    nodes.push({
      id: nodeId,
      label: includeLabels ? entity.name : entity.id,
      shape: "rectangle",
      color: "FFE0B2",
      attributes: entity.description ? [entity.description] : []
    });
  });
  nodes.push({
    id: "target_domain",
    label: thought.targetDomain.name,
    shape: "package",
    stereotype: "target"
  });
  thought.targetDomain.entities.forEach((entity) => {
    const nodeId = "tgt_" + entity.id;
    nodes.push({
      id: nodeId,
      label: includeLabels ? entity.name : entity.id,
      shape: "rectangle",
      color: "B3E5FC",
      attributes: entity.description ? [entity.description] : []
    });
  });
  thought.mapping.forEach((mapping) => {
    const srcId = "src_" + mapping.sourceEntityId;
    const tgtId = "tgt_" + mapping.targetEntityId;
    edges.push({
      source: srcId,
      target: tgtId,
      type: "dependency",
      label: includeMetrics ? `${mapping.confidence.toFixed(2)}` : void 0
    });
  });
  if (includeMetrics) {
    nodes.push({
      id: "metrics_info",
      label: `Metrics
Analogy Strength: ${(thought.analogyStrength * 100).toFixed(1)}%
Mappings: ${thought.mapping.length}`,
      shape: "rectangle",
      color: "E8EAF6"
    });
  }
  return generateUmlDiagram(nodes, edges, {
    title: "Analogical Domain Mapping"});
}
function analogicalToJSON(thought, options) {
  const { includeMetrics = true } = options;
  const graph = createJsonGraph("Analogical Domain Mapping", "analogical");
  graph.metadata.sourceDomainName = thought.sourceDomain.name;
  graph.metadata.sourceDomainDescription = thought.sourceDomain.description;
  graph.metadata.targetDomainName = thought.targetDomain.name;
  graph.metadata.targetDomainDescription = thought.targetDomain.description;
  thought.sourceDomain.entities.forEach((entity) => {
    addNode(graph, {
      id: "src_" + entity.id,
      label: entity.name,
      type: "source_entity",
      metadata: {
        originalId: entity.id,
        description: entity.description,
        entityType: entity.type,
        domain: "source"
      }
    });
  });
  thought.targetDomain.entities.forEach((entity) => {
    addNode(graph, {
      id: "tgt_" + entity.id,
      label: entity.name,
      type: "target_entity",
      metadata: {
        originalId: entity.id,
        description: entity.description,
        entityType: entity.type,
        domain: "target"
      }
    });
  });
  thought.mapping.forEach((mapping, index) => {
    addEdge(graph, {
      id: `mapping_${index}`,
      source: "src_" + mapping.sourceEntityId,
      target: "tgt_" + mapping.targetEntityId,
      label: `confidence: ${mapping.confidence.toFixed(2)}`,
      type: "mapping",
      metadata: {
        confidence: mapping.confidence,
        justification: mapping.justification
      }
    });
  });
  if (includeMetrics) {
    addMetric(graph, "analogyStrength", thought.analogyStrength);
    addMetric(graph, "mappingCount", thought.mapping.length);
    addMetric(graph, "sourceEntityCount", thought.sourceDomain.entities.length);
    addMetric(graph, "targetEntityCount", thought.targetDomain.entities.length);
    if (thought.mapping.length > 0) {
      const avgConfidence = thought.mapping.reduce((sum, m) => sum + m.confidence, 0) / thought.mapping.length;
      addMetric(graph, "averageMappingConfidence", avgConfidence);
    }
  }
  if (thought.inferences && thought.inferences.length > 0) {
    graph.metadata.inferences = thought.inferences.map((inf) => ({
      sourcePattern: inf.sourcePattern,
      targetPrediction: inf.targetPrediction,
      confidence: inf.confidence
    }));
    if (includeMetrics) {
      addMetric(graph, "inferenceCount", thought.inferences.length);
    }
  }
  return serializeGraph(graph);
}
function analogicalToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  if (includeMetrics) {
    parts.push(section("Metrics", keyValueSection({
      "Analogy Strength": (thought.analogyStrength * 100).toFixed(0) + "%",
      "Mappings": thought.mapping.length,
      "Source Entities": thought.sourceDomain.entities.length,
      "Target Entities": thought.targetDomain.entities.length
    })));
  }
  parts.push(section(
    "Source Domain",
    `**Name:** ${thought.sourceDomain.name}

**Description:** ${thought.sourceDomain.description || "N/A"}

**Entities:**
${list(thought.sourceDomain.entities.map((e) => `${e.name}: ${e.description || "N/A"}`))}`
  ));
  parts.push(section(
    "Target Domain",
    `**Name:** ${thought.targetDomain.name}

**Description:** ${thought.targetDomain.description || "N/A"}

**Entities:**
${list(thought.targetDomain.entities.map((e) => `${e.name}: ${e.description || "N/A"}`))}`
  ));
  const mapRows = thought.mapping.map((m) => [
    m.sourceEntityId,
    "\u2192",
    m.targetEntityId,
    (m.confidence * 100).toFixed(0) + "%",
    m.justification || "-"
  ]);
  parts.push(section("Entity Mappings", table(
    ["Source", "", "Target", "Confidence", "Justification"],
    mapRows
  )));
  if (thought.inferences && thought.inferences.length > 0) {
    const infRows = thought.inferences.map((inf) => [
      inf.sourcePattern,
      inf.targetPrediction,
      (inf.confidence * 100).toFixed(0) + "%"
    ]);
    parts.push(section("Inferences", table(
      ["Source Pattern", "Target Prediction", "Confidence"],
      infRows
    )));
  }
  if (markdownIncludeMermaid) {
    const mermaid = analogicalToMermaid(thought, "default", true, includeMetrics);
    parts.push(section("Visualization", mermaidBlock(mermaid)));
  }
  return document("Analogical Reasoning Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "analogical",
      mappings: thought.mapping.length,
      analogyStrength: thought.analogyStrength.toFixed(2)
    }
  });
}
var init_analogical = __esm({
  "src/export/visual/modes/analogical.ts"() {
    init_esm_shims();
    init_utils();
    init_svg();
    init_graphml();
    init_tikz();
    init_html();
    init_modelica();
    init_uml();
    init_json();
    init_markdown();
  }
});

// src/export/visual/modes/first-principles.ts
function exportFirstPrinciplesDerivation(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return firstPrinciplesToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return firstPrinciplesToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return firstPrinciplesToASCII(thought);
    case "svg":
      return firstPrinciplesToSVG(thought, options);
    case "graphml":
      return firstPrinciplesToGraphML(thought, options);
    case "tikz":
      return firstPrinciplesToTikZ(thought, options);
    case "html":
      return firstPrinciplesToHTML(thought, options);
    case "modelica":
      return firstPrinciplesToModelica(thought, options);
    case "uml":
      return firstPrinciplesToUML(thought, options);
    case "json":
      return firstPrinciplesToJSON(thought, options);
    case "markdown":
      return firstPrinciplesToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function firstPrinciplesToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TD\n";
  mermaid += `  Q["Question: ${thought.question}"]
`;
  mermaid += "\n";
  for (const principle of thought.principles) {
    const principleId = sanitizeId(principle.id);
    const label = includeLabels ? `${principle.type.toUpperCase()}: ${principle.statement.substring(0, 50)}...` : principleId;
    let shape;
    switch (principle.type) {
      case "axiom":
        shape = ["([", "])"];
        break;
      case "definition":
        shape = ["[[", "]]"];
        break;
      case "observation":
        shape = ["[(", ")]"];
        break;
      case "logical_inference":
        shape = ["[", "]"];
        break;
      case "assumption":
        shape = ["{", "}"];
        break;
      default:
        shape = ["[", "]"];
    }
    mermaid += `  ${principleId}${shape[0]}${label}${shape[1]}
`;
    if (principle.dependsOn) {
      for (const depId of principle.dependsOn) {
        const sanitizedDepId = sanitizeId(depId);
        mermaid += `  ${sanitizedDepId} --> ${principleId}
`;
      }
    }
  }
  mermaid += "\n";
  for (const step of thought.derivationSteps) {
    const stepId = `Step${step.stepNumber}`;
    const principleId = sanitizeId(step.principle);
    const label = includeLabels ? `Step ${step.stepNumber}: ${step.inference.substring(0, 50)}...` : stepId;
    mermaid += `  ${stepId}["${label}"]
`;
    mermaid += `  ${principleId} -.->|applies| ${stepId}
`;
    if (includeMetrics && step.confidence !== void 0) {
      mermaid += `  ${stepId} -.->|conf: ${step.confidence.toFixed(2)}| ${stepId}
`;
    }
  }
  mermaid += "\n";
  const conclusionLabel = includeLabels ? `Conclusion: ${thought.conclusion.statement.substring(0, 50)}...` : "Conclusion";
  mermaid += `  C["${conclusionLabel}"]
`;
  for (const stepNum of thought.conclusion.derivationChain) {
    mermaid += `  Step${stepNum} --> C
`;
  }
  if (includeMetrics) {
    mermaid += `  C -.->|certainty: ${thought.conclusion.certainty.toFixed(2)}| C
`;
  }
  if (colorScheme !== "monochrome") {
    mermaid += "\n";
    const axiomColor = colorScheme === "pastel" ? "#e1f5ff" : "#a8d5ff";
    const definitionColor = colorScheme === "pastel" ? "#f3e5f5" : "#ce93d8";
    const observationColor = colorScheme === "pastel" ? "#fff3e0" : "#ffd699";
    const inferenceColor = colorScheme === "pastel" ? "#e8f5e9" : "#a5d6a7";
    const assumptionColor = colorScheme === "pastel" ? "#ffebee" : "#ef9a9a";
    for (const principle of thought.principles) {
      const principleId = sanitizeId(principle.id);
      let color = axiomColor;
      switch (principle.type) {
        case "axiom":
          color = axiomColor;
          break;
        case "definition":
          color = definitionColor;
          break;
        case "observation":
          color = observationColor;
          break;
        case "logical_inference":
          color = inferenceColor;
          break;
        case "assumption":
          color = assumptionColor;
          break;
      }
      mermaid += `  style ${principleId} fill:${color}
`;
    }
    const conclusionColor = colorScheme === "pastel" ? "#c8e6c9" : "#66bb6a";
    mermaid += `  style C fill:${conclusionColor}
`;
  }
  return mermaid;
}
function firstPrinciplesToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph FirstPrinciples {\n";
  dot += "  rankdir=TD;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  dot += `  Q [label="Question:\\n${thought.question}", shape=ellipse, style=bold];

`;
  for (const principle of thought.principles) {
    const principleId = sanitizeId(principle.id);
    const label = includeLabels ? `${principle.type.toUpperCase()}:\\n${principle.statement.substring(0, 60)}...` : principleId;
    let shape = "box";
    switch (principle.type) {
      case "axiom":
        shape = "ellipse";
        break;
      case "definition":
        shape = "box";
        break;
      case "observation":
        shape = "cylinder";
        break;
      case "logical_inference":
        shape = "box";
        break;
      case "assumption":
        shape = "diamond";
        break;
    }
    const confidenceLabel = includeMetrics && principle.confidence ? `\\nconf: ${principle.confidence.toFixed(2)}` : "";
    dot += `  ${principleId} [label="${label}${confidenceLabel}", shape=${shape}];
`;
    if (principle.dependsOn) {
      for (const depId of principle.dependsOn) {
        const sanitizedDepId = sanitizeId(depId);
        dot += `  ${sanitizedDepId} -> ${principleId};
`;
      }
    }
  }
  dot += "\n";
  for (const step of thought.derivationSteps) {
    const stepId = `Step${step.stepNumber}`;
    const principleId = sanitizeId(step.principle);
    const label = includeLabels ? `Step ${step.stepNumber}:\\n${step.inference.substring(0, 60)}...` : stepId;
    const confidenceLabel = includeMetrics ? `\\nconf: ${step.confidence.toFixed(2)}` : "";
    dot += `  ${stepId} [label="${label}${confidenceLabel}"];
`;
    dot += `  ${principleId} -> ${stepId} [style=dashed, label="applies"];
`;
  }
  dot += "\n";
  const conclusionLabel = includeLabels ? `Conclusion:\\n${thought.conclusion.statement.substring(0, 60)}...` : "Conclusion";
  const certaintyLabel = includeMetrics ? `\\ncertainty: ${thought.conclusion.certainty.toFixed(2)}` : "";
  dot += `  C [label="${conclusionLabel}${certaintyLabel}", shape=doubleoctagon, style=bold];
`;
  for (const stepNum of thought.conclusion.derivationChain) {
    dot += `  Step${stepNum} -> C;
`;
  }
  dot += "}\n";
  return dot;
}
function firstPrinciplesToASCII(thought) {
  let ascii = "First-Principles Derivation:\n";
  ascii += "============================\n\n";
  ascii += `Question: ${thought.question}

`;
  ascii += "Foundational Principles:\n";
  ascii += "------------------------\n";
  for (const principle of thought.principles) {
    ascii += `[${principle.id}] ${principle.type.toUpperCase()}
`;
    ascii += `  Statement: ${principle.statement}
`;
    ascii += `  Justification: ${principle.justification}
`;
    if (principle.dependsOn && principle.dependsOn.length > 0) {
      ascii += `  Depends on: ${principle.dependsOn.join(", ")}
`;
    }
    if (principle.confidence !== void 0) {
      ascii += `  Confidence: ${principle.confidence.toFixed(2)}
`;
    }
    ascii += "\n";
  }
  ascii += "Derivation Chain:\n";
  ascii += "----------------\n";
  for (const step of thought.derivationSteps) {
    ascii += `Step ${step.stepNumber} (using principle: ${step.principle})
`;
    ascii += `  Inference: ${step.inference}
`;
    if (step.logicalForm) {
      ascii += `  Logical form: ${step.logicalForm}
`;
    }
    ascii += `  Confidence: ${step.confidence.toFixed(2)}
`;
    ascii += "\n";
  }
  ascii += "Conclusion:\n";
  ascii += "----------\n";
  ascii += `${thought.conclusion.statement}
`;
  ascii += `Derivation chain: Steps [${thought.conclusion.derivationChain.join(", ")}]
`;
  ascii += `Certainty: ${thought.conclusion.certainty.toFixed(2)}
`;
  if (thought.conclusion.limitations && thought.conclusion.limitations.length > 0) {
    ascii += "\nLimitations:\n";
    for (const limitation of thought.conclusion.limitations) {
      ascii += `  - ${limitation}
`;
    }
  }
  if (thought.alternativeInterpretations && thought.alternativeInterpretations.length > 0) {
    ascii += "\nAlternative Interpretations:\n";
    for (const alt of thought.alternativeInterpretations) {
      ascii += `  - ${alt}
`;
    }
  }
  return ascii;
}
function firstPrinciplesToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width
  } = options;
  const positions = /* @__PURE__ */ new Map();
  const nodeWidth = 150;
  const nodeHeight = 40;
  const principleY = 100;
  const principleSpacing = Math.min(180, svgWidth / (thought.principles.length + 1));
  const principleStartX = (svgWidth - (thought.principles.length - 1) * principleSpacing) / 2;
  thought.principles.forEach((p, index) => {
    positions.set(p.id, {
      id: p.id,
      label: includeLabels ? `${p.type}: ${p.statement.substring(0, 30)}...` : p.id,
      x: principleStartX + index * principleSpacing,
      y: principleY,
      width: nodeWidth,
      height: nodeHeight,
      type: p.type
    });
  });
  const stepY = 250;
  thought.derivationSteps.forEach((step, index) => {
    const stepId = `Step${step.stepNumber}`;
    positions.set(stepId, {
      id: stepId,
      label: includeLabels ? `Step ${step.stepNumber}` : stepId,
      x: 150 + index * 200,
      y: stepY,
      width: nodeWidth,
      height: nodeHeight,
      type: "step"
    });
  });
  positions.set("conclusion", {
    id: "conclusion",
    label: includeLabels ? `Conclusion: ${thought.conclusion.statement.substring(0, 30)}...` : "Conclusion",
    x: svgWidth / 2,
    y: stepY + 150,
    width: nodeWidth,
    height: nodeHeight,
    type: "conclusion"
  });
  const actualHeight = calculateSVGHeight(positions);
  let svg = generateSVGHeader(svgWidth, actualHeight, "First Principles Derivation");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  for (const step of thought.derivationSteps) {
    const principlePos = positions.get(step.principle);
    const stepPos = positions.get(`Step${step.stepNumber}`);
    if (principlePos && stepPos) {
      svg += renderEdge(principlePos, stepPos, { style: "dashed", label: "applies" });
    }
  }
  const conclusionPos = positions.get("conclusion");
  for (const stepNum of thought.conclusion.derivationChain) {
    const stepPos = positions.get(`Step${stepNum}`);
    if (stepPos) {
      svg += renderEdge(stepPos, conclusionPos);
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  const axiomColors = getNodeColor("primary", colorScheme);
  const stepColors = getNodeColor("neutral", colorScheme);
  const conclusionColors = getNodeColor("success", colorScheme);
  for (const [id, pos] of positions) {
    if (id === "conclusion") {
      svg += renderStadiumNode(pos, conclusionColors);
    } else if (id.startsWith("Step")) {
      svg += renderRectNode(pos, stepColors);
    } else {
      svg += renderEllipseNode(pos, axiomColors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Principles", value: thought.principles.length },
      { label: "Steps", value: thought.derivationSteps.length },
      { label: "Certainty", value: thought.conclusion.certainty.toFixed(2) }
    ];
    svg += renderMetricsPanel(svgWidth - 180, actualHeight - 110, metrics);
  }
  const legendItems = [
    { label: "Principle", color: axiomColors, shape: "ellipse" },
    { label: "Derivation Step", color: stepColors },
    { label: "Conclusion", color: conclusionColors, shape: "stadium" }
  ];
  svg += renderLegend(20, actualHeight - 100, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function firstPrinciplesToGraphML(thought, options) {
  const { includeLabels = true } = options;
  const nodes = [];
  const edges = [];
  let edgeCount = 0;
  nodes.push({
    id: "question",
    label: includeLabels ? `Question: ${thought.question}` : "Question",
    type: "question"
  });
  for (const principle of thought.principles) {
    const principleId = sanitizeId(principle.id);
    nodes.push({
      id: principleId,
      label: includeLabels ? `${principle.type.toUpperCase()}: ${principle.statement.substring(0, 60)}...` : principleId,
      type: principle.type,
      metadata: {
        justification: principle.justification,
        confidence: principle.confidence
      }
    });
    if (principle.dependsOn) {
      for (const depId of principle.dependsOn) {
        const sanitizedDepId = sanitizeId(depId);
        edges.push({
          id: `e${edgeCount++}`,
          source: sanitizedDepId,
          target: principleId,
          label: "depends on",
          directed: true
        });
      }
    }
  }
  for (const step of thought.derivationSteps) {
    const stepId = `Step${step.stepNumber}`;
    nodes.push({
      id: stepId,
      label: includeLabels ? `Step ${step.stepNumber}: ${step.inference.substring(0, 60)}...` : stepId,
      type: "derivation_step",
      metadata: {
        logicalForm: step.logicalForm,
        confidence: step.confidence
      }
    });
    const principleId = sanitizeId(step.principle);
    edges.push({
      id: `e${edgeCount++}`,
      source: principleId,
      target: stepId,
      label: "applies",
      directed: true
    });
  }
  nodes.push({
    id: "conclusion",
    label: includeLabels ? `Conclusion: ${thought.conclusion.statement.substring(0, 60)}...` : "Conclusion",
    type: "conclusion",
    metadata: {
      certainty: thought.conclusion.certainty,
      limitations: thought.conclusion.limitations
    }
  });
  for (const stepNum of thought.conclusion.derivationChain) {
    edges.push({
      id: `e${edgeCount++}`,
      source: `Step${stepNum}`,
      target: "conclusion",
      directed: true
    });
  }
  return generateGraphML(nodes, edges, {
    graphName: "First Principles Derivation",
    directed: true,
    includeLabels
  });
}
function firstPrinciplesToTikZ(thought, options) {
  const { includeLabels = true, colorScheme = "default" } = options;
  const nodes = [];
  const edges = [];
  const principleCount = thought.principles.length;
  thought.principles.forEach((principle, index) => {
    const principleId = sanitizeId(principle.id);
    nodes.push({
      id: principleId,
      label: includeLabels ? `${principle.type}: ${principle.statement.substring(0, 25)}...` : principleId,
      x: index * 3,
      y: 0,
      type: principle.type === "axiom" ? "primary" : "secondary",
      shape: "stadium"
    });
    if (principle.dependsOn) {
      for (const depId of principle.dependsOn) {
        const sanitizedDepId = sanitizeId(depId);
        edges.push({
          source: sanitizedDepId,
          target: principleId,
          directed: true,
          style: "dashed"
        });
      }
    }
  });
  const stepY = -2;
  thought.derivationSteps.forEach((step, index) => {
    const stepId = `Step${step.stepNumber}`;
    const principleId = sanitizeId(step.principle);
    nodes.push({
      id: stepId,
      label: includeLabels ? `Step ${step.stepNumber}` : stepId,
      x: index * 3,
      y: stepY,
      type: "neutral",
      shape: "rectangle"
    });
    edges.push({
      source: principleId,
      target: stepId,
      label: "applies",
      directed: true,
      style: "dashed"
    });
  });
  const conclusionX = (principleCount - 1) * 3 / 2;
  nodes.push({
    id: "conclusion",
    label: includeLabels ? "Conclusion" : "C",
    x: conclusionX,
    y: -4,
    type: "success",
    shape: "stadium"
  });
  for (const stepNum of thought.conclusion.derivationChain) {
    edges.push({
      source: `Step${stepNum}`,
      target: "conclusion",
      directed: true
    });
  }
  return generateTikZ(nodes, edges, {
    title: "First Principles Derivation",
    colorScheme,
    includeLabels
  });
}
function firstPrinciplesToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "First Principles Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  html += renderSection("Question", `<p class="text-primary"><strong>${escapeHTML(thought.question)}</strong></p>`, "\u2753");
  if (includeMetrics) {
    html += '<div class="metrics-grid">';
    html += renderMetricCard("Principles", thought.principles.length, "primary");
    html += renderMetricCard("Derivation Steps", thought.derivationSteps.length, "info");
    html += renderMetricCard("Certainty", (thought.conclusion.certainty * 100).toFixed(0) + "%", "success");
    html += "</div>\n";
  }
  const principleRows = thought.principles.map((p) => {
    const typeBadge = renderBadge(p.type, p.type === "axiom" ? "primary" : p.type === "observation" ? "info" : "secondary");
    return [
      p.id,
      typeBadge,
      p.statement,
      p.confidence !== void 0 ? (p.confidence * 100).toFixed(0) + "%" : "N/A"
    ];
  });
  html += renderSection("First Principles", renderTable(
    ["ID", "Type", "Statement", "Confidence"],
    principleRows.map((row) => row.map((cell) => typeof cell === "string" && cell.startsWith("<") ? cell : escapeHTML(String(cell))))
  ), "\u{1F3DB}\uFE0F");
  const stepRows = thought.derivationSteps.map((s) => [
    s.stepNumber.toString(),
    s.principle,
    s.inference,
    s.logicalForm || "-"
  ]);
  html += renderSection("Derivation Chain", renderTable(
    ["Step", "Principle", "Inference", "Logical Form"],
    stepRows
  ), "\u{1F517}");
  html += renderSection("Conclusion", `
    <div class="card">
      <div class="card-header">${escapeHTML(thought.conclusion.statement)}</div>
      <p><strong>Certainty:</strong> ${(thought.conclusion.certainty * 100).toFixed(0)}%</p>
      <p><strong>Derivation Chain:</strong> Steps ${thought.conclusion.derivationChain.join(" \u2192 ")}</p>
      ${thought.conclusion.limitations && thought.conclusion.limitations.length > 0 ? `
        <p><strong>Limitations:</strong></p>
        ${renderList(thought.conclusion.limitations)}
      ` : ""}
    </div>
  `, "\u2713");
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function firstPrinciplesToModelica(thought, options) {
  const { includeMetrics = true } = options;
  const packageName = "FirstPrinciplesDerivation";
  let modelica = generateModelicaPackageHeader(
    packageName,
    `First principles derivation: ${thought.question}`
  );
  modelica += "  // Fundamental Principles\n";
  for (const principle of thought.principles) {
    const fields = [
      { name: "id", type: "String", value: `"${escapeModelicaString(principle.id)}"` },
      { name: "principleType", type: "String", value: `"${escapeModelicaString(principle.type)}"` },
      { name: "statement", type: "String", value: `"${escapeModelicaString(principle.statement)}"` },
      { name: "justification", type: "String", value: `"${escapeModelicaString(principle.justification)}"` }
    ];
    if (includeMetrics && principle.confidence !== void 0) {
      fields.push({
        name: "confidence",
        type: "Real",
        value: principle.confidence.toFixed(3),
        description: "Confidence level in this principle"
      });
    }
    modelica += generateModelicaRecord(
      sanitizeModelicaId(principle.id),
      `${principle.type}: ${principle.statement.substring(0, 60)}`,
      fields
    );
  }
  modelica += "  // Derivation Process\n";
  modelica += "  model Derivation\n";
  modelica += `    "Derivation chain from principles to conclusion"
`;
  modelica += "\n";
  modelica += "    // Principle instances\n";
  for (const principle of thought.principles) {
    const safeId = sanitizeModelicaId(principle.id);
    modelica += `    ${safeId} ${safeId}_instance;
`;
  }
  modelica += "\n";
  modelica += "    // Derivation steps\n";
  for (const step of thought.derivationSteps) {
    const stepId = `step_${step.stepNumber}`;
    modelica += `    parameter String ${stepId}_principle = "${escapeModelicaString(step.principle)}";
`;
    modelica += `    parameter String ${stepId}_inference = "${escapeModelicaString(step.inference)}";
`;
    if (step.logicalForm) {
      modelica += `    parameter String ${stepId}_logicalForm = "${escapeModelicaString(step.logicalForm)}";
`;
    }
    if (includeMetrics) {
      modelica += `    parameter Real ${stepId}_confidence = ${step.confidence.toFixed(3)};
`;
    }
  }
  modelica += "\n";
  modelica += "    // Conclusion\n";
  modelica += `    parameter String conclusion = "${escapeModelicaString(thought.conclusion.statement)}";
`;
  if (includeMetrics) {
    modelica += `    parameter Real certainty = ${thought.conclusion.certainty.toFixed(3)};
`;
  }
  modelica += `    parameter Integer derivationChainLength = ${thought.conclusion.derivationChain.length};
`;
  modelica += "\n";
  modelica += "    annotation(\n";
  modelica += '      Documentation(info="<html>\n';
  modelica += `        <h3>Question</h3>
`;
  modelica += `        <p>${escapeModelicaString(thought.question)}</p>
`;
  modelica += `        <h3>Principles</h3>
`;
  modelica += `        <p>Count: ${thought.principles.length}</p>
`;
  modelica += `        <h3>Derivation Steps</h3>
`;
  modelica += `        <p>Count: ${thought.derivationSteps.length}</p>
`;
  modelica += `        <h3>Conclusion</h3>
`;
  modelica += `        <p>${escapeModelicaString(thought.conclusion.statement)}</p>
`;
  if (includeMetrics) {
    modelica += `        <p>Certainty: ${(thought.conclusion.certainty * 100).toFixed(1)}%</p>
`;
  }
  modelica += '      </html>")\n';
  modelica += "    );\n";
  modelica += "  end Derivation;\n";
  modelica += "\n";
  modelica += generateModelicaPackageFooter(packageName, { includeAnnotations: true, version: "7.1.0" });
  return modelica;
}
function firstPrinciplesToUML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  for (const principle of thought.principles) {
    const attributes = [
      `type: ${principle.type}`,
      `statement: "${principle.statement.substring(0, 40)}..."`,
      `justification: "${principle.justification.substring(0, 40)}..."`
    ];
    if (includeMetrics && principle.confidence !== void 0) {
      attributes.push(`confidence: ${principle.confidence.toFixed(2)}`);
    }
    nodes.push({
      id: sanitizeUmlId(principle.id),
      label: includeLabels ? principle.id : sanitizeUmlId(principle.id),
      shape: principle.type === "axiom" ? "class" : "rectangle",
      stereotype: principle.type,
      attributes
    });
    if (principle.dependsOn && principle.dependsOn.length > 0) {
      for (const depId of principle.dependsOn) {
        edges.push({
          source: sanitizeUmlId(depId),
          target: sanitizeUmlId(principle.id),
          type: "dependency",
          label: "depends on"
        });
      }
    }
  }
  for (const step of thought.derivationSteps) {
    const stepId = `Step${step.stepNumber}`;
    const attributes = [
      `inference: "${step.inference.substring(0, 40)}..."`
    ];
    if (step.logicalForm) {
      attributes.push(`logicalForm: "${step.logicalForm.substring(0, 30)}..."`);
    }
    if (includeMetrics) {
      attributes.push(`confidence: ${step.confidence.toFixed(2)}`);
    }
    nodes.push({
      id: stepId,
      label: includeLabels ? `Step ${step.stepNumber}` : stepId,
      shape: "component",
      attributes
    });
    edges.push({
      source: sanitizeUmlId(step.principle),
      target: stepId,
      type: "dashed",
      label: "applies"
    });
  }
  const conclusionAttributes = [
    `statement: "${thought.conclusion.statement.substring(0, 40)}..."`,
    `derivationChain: [${thought.conclusion.derivationChain.join(", ")}]`
  ];
  if (includeMetrics) {
    conclusionAttributes.push(`certainty: ${thought.conclusion.certainty.toFixed(2)}`);
  }
  if (thought.conclusion.limitations && thought.conclusion.limitations.length > 0) {
    conclusionAttributes.push(`limitations: ${thought.conclusion.limitations.length} items`);
  }
  nodes.push({
    id: "Conclusion",
    label: "Conclusion",
    shape: "class",
    stereotype: "conclusion",
    attributes: conclusionAttributes
  });
  for (const stepNum of thought.conclusion.derivationChain) {
    edges.push({
      source: `Step${stepNum}`,
      target: "Conclusion",
      type: "arrow"
    });
  }
  let uml = generateUmlHeader({
    title: "First Principles Derivation",
    direction: "top to bottom"
  });
  uml += `' Question: ${escapeUml(thought.question)}

`;
  uml += "' Principles\n";
  for (const node of nodes.filter((n) => !n.id.startsWith("Step") && n.id !== "Conclusion")) {
    uml += renderUmlNode(node) + "\n";
  }
  uml += "\n' Derivation Steps\n";
  for (const node of nodes.filter((n) => n.id.startsWith("Step"))) {
    uml += renderUmlNode(node) + "\n";
  }
  uml += "\n' Conclusion\n";
  const conclusionNode = nodes.find((n) => n.id === "Conclusion");
  if (conclusionNode) {
    uml += renderUmlNode(conclusionNode) + "\n";
  }
  uml += "\n' Relationships\n";
  for (const edge of edges) {
    uml += renderUmlEdge(edge) + "\n";
  }
  uml += "\n" + generateUmlFooter();
  return uml;
}
function firstPrinciplesToJSON(thought, options) {
  const { includeMetrics = true, includeLabels = true } = options;
  const graph = createJsonGraph(
    "First Principles Derivation",
    "first-principles",
    { includeMetrics, includeLayout: true, includeLegend: true }
  );
  if (graph.layout) {
    graph.layout.type = "hierarchical";
    graph.layout.direction = "TB";
  }
  graph.metadata.question = thought.question;
  const principleSpacing = 150;
  const principleStartX = -((thought.principles.length - 1) * principleSpacing) / 2;
  for (let i = 0; i < thought.principles.length; i++) {
    const principle = thought.principles[i];
    const principleId = sanitizeId(principle.id);
    let color = "#e0e0e0";
    switch (principle.type) {
      case "axiom":
        color = "#a8d5ff";
        break;
      case "definition":
        color = "#ce93d8";
        break;
      case "observation":
        color = "#ffd699";
        break;
      case "logical_inference":
        color = "#a5d6a7";
        break;
      case "assumption":
        color = "#ef9a9a";
        break;
    }
    addNode(graph, {
      id: principleId,
      label: includeLabels ? `${principle.type}: ${principle.statement.substring(0, 30)}...` : principleId,
      type: principle.type,
      x: principleStartX + i * principleSpacing,
      y: 0,
      width: 140,
      height: 60,
      color,
      shape: principle.type === "axiom" ? "ellipse" : "rectangle",
      metadata: {
        statement: principle.statement,
        justification: principle.justification,
        confidence: principle.confidence,
        dependsOn: principle.dependsOn
      }
    });
    if (principle.dependsOn && principle.dependsOn.length > 0) {
      for (const depId of principle.dependsOn) {
        addEdge(graph, {
          id: `edge_${sanitizeId(depId)}_${principleId}`,
          source: sanitizeId(depId),
          target: principleId,
          label: "depends on",
          directed: true,
          style: "dashed"
        });
      }
    }
  }
  const stepY = 150;
  const stepSpacing = 200;
  const stepStartX = -((thought.derivationSteps.length - 1) * stepSpacing) / 2;
  for (let i = 0; i < thought.derivationSteps.length; i++) {
    const step = thought.derivationSteps[i];
    const stepId = `step_${step.stepNumber}`;
    addNode(graph, {
      id: stepId,
      label: includeLabels ? `Step ${step.stepNumber}: ${step.inference.substring(0, 30)}...` : `Step ${step.stepNumber}`,
      type: "derivation_step",
      x: stepStartX + i * stepSpacing,
      y: stepY,
      width: 180,
      height: 50,
      color: "#81c784",
      shape: "rectangle",
      metadata: {
        inference: step.inference,
        logicalForm: step.logicalForm,
        confidence: step.confidence,
        principle: step.principle
      }
    });
    addEdge(graph, {
      id: `edge_${sanitizeId(step.principle)}_${stepId}`,
      source: sanitizeId(step.principle),
      target: stepId,
      label: "applies",
      directed: true,
      style: "dashed"
    });
  }
  addNode(graph, {
    id: "conclusion",
    label: includeLabels ? `Conclusion: ${thought.conclusion.statement.substring(0, 40)}...` : "Conclusion",
    type: "conclusion",
    x: 0,
    y: stepY + 150,
    width: 200,
    height: 60,
    color: "#66bb6a",
    shape: "stadium",
    metadata: {
      statement: thought.conclusion.statement,
      certainty: thought.conclusion.certainty,
      derivationChain: thought.conclusion.derivationChain,
      limitations: thought.conclusion.limitations
    }
  });
  for (const stepNum of thought.conclusion.derivationChain) {
    addEdge(graph, {
      id: `edge_step${stepNum}_conclusion`,
      source: `step_${stepNum}`,
      target: "conclusion",
      directed: true,
      style: "solid"
    });
  }
  if (includeMetrics && graph.metrics) {
    addMetric(graph, "principleCount", thought.principles.length);
    addMetric(graph, "derivationStepCount", thought.derivationSteps.length);
    addMetric(graph, "certainty", thought.conclusion.certainty);
    addMetric(graph, "axiomCount", thought.principles.filter((p) => p.type === "axiom").length);
    addMetric(graph, "definitionCount", thought.principles.filter((p) => p.type === "definition").length);
    addMetric(graph, "observationCount", thought.principles.filter((p) => p.type === "observation").length);
  }
  if (graph.legend) {
    addLegendItem(graph, "Axiom", "#a8d5ff", "ellipse");
    addLegendItem(graph, "Definition", "#ce93d8", "rectangle");
    addLegendItem(graph, "Observation", "#ffd699", "rectangle");
    addLegendItem(graph, "Logical Inference", "#a5d6a7", "rectangle");
    addLegendItem(graph, "Assumption", "#ef9a9a", "rectangle");
    addLegendItem(graph, "Derivation Step", "#81c784", "rectangle");
    addLegendItem(graph, "Conclusion", "#66bb6a", "stadium");
  }
  return serializeGraph(graph, { prettyPrint: true, indent: 2 });
}
function firstPrinciplesToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  parts.push(section("Question", thought.question));
  if (includeMetrics) {
    parts.push(section("Metrics", keyValueSection({
      "Principles": thought.principles.length,
      "Derivation Steps": thought.derivationSteps.length,
      "Certainty": (thought.conclusion.certainty * 100).toFixed(0) + "%",
      "Axioms": thought.principles.filter((p) => p.type === "axiom").length,
      "Definitions": thought.principles.filter((p) => p.type === "definition").length,
      "Observations": thought.principles.filter((p) => p.type === "observation").length
    })));
  }
  const principleRows = thought.principles.map((p) => [
    p.id,
    p.type,
    p.statement.substring(0, 60) + (p.statement.length > 60 ? "..." : ""),
    p.dependsOn?.join(", ") || "-",
    p.confidence !== void 0 ? (p.confidence * 100).toFixed(0) + "%" : "N/A"
  ]);
  parts.push(section("Foundational Principles", table(
    ["ID", "Type", "Statement", "Depends On", "Confidence"],
    principleRows
  )));
  const stepRows = thought.derivationSteps.map((s) => [
    s.stepNumber.toString(),
    s.principle,
    s.inference.substring(0, 60) + (s.inference.length > 60 ? "..." : ""),
    s.logicalForm || "-",
    (s.confidence * 100).toFixed(0) + "%"
  ]);
  parts.push(section("Derivation Chain", table(
    ["Step", "Principle", "Inference", "Logical Form", "Confidence"],
    stepRows
  )));
  let conclusionContent = `**Statement:** ${thought.conclusion.statement}

`;
  conclusionContent += `**Certainty:** ${(thought.conclusion.certainty * 100).toFixed(0)}%

`;
  conclusionContent += `**Derivation Chain:** Steps ${thought.conclusion.derivationChain.join(" \u2192 ")}
`;
  if (thought.conclusion.limitations && thought.conclusion.limitations.length > 0) {
    conclusionContent += `
**Limitations:**
${list(thought.conclusion.limitations)}`;
  }
  parts.push(section("Conclusion", conclusionContent));
  if (thought.alternativeInterpretations && thought.alternativeInterpretations.length > 0) {
    parts.push(section("Alternative Interpretations", list(thought.alternativeInterpretations)));
  }
  if (markdownIncludeMermaid) {
    const mermaid = firstPrinciplesToMermaid(thought, "default", true, includeMetrics);
    parts.push(section("Visualization", mermaidBlock(mermaid)));
  }
  return document("First Principles Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "first-principles",
      principles: thought.principles.length,
      certainty: thought.conclusion.certainty.toFixed(2)
    }
  });
}
var init_first_principles = __esm({
  "src/export/visual/modes/first-principles.ts"() {
    init_esm_shims();
    init_utils();
    init_svg();
    init_graphml();
    init_tikz();
    init_html();
    init_modelica();
    init_uml();
    init_json();
    init_markdown();
  }
});

// src/export/visual/modes/metareasoning.ts
function exportMetaReasoningVisualization(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return metaReasoningToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return metaReasoningToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return metaReasoningToASCII(thought);
    case "svg":
      return metaReasoningToSVG(thought, options);
    case "graphml":
      return metaReasoningToGraphML(thought, options);
    case "tikz":
      return metaReasoningToTikZ(thought, options);
    case "html":
      return metaReasoningToHTML(thought, options);
    case "modelica":
      return metaReasoningToModelica(thought, options);
    case "uml":
      return metaReasoningToUML(thought, options);
    case "json":
      return metaReasoningToJSON(thought, options);
    case "markdown":
      return metaReasoningToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function metaReasoningToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TB\n";
  const metaId = sanitizeId("meta_reasoning");
  mermaid += `  ${metaId}(("Meta-Reasoning"))
`;
  const currentId = sanitizeId("current_strategy");
  const currentLabel = includeLabels ? thought.currentStrategy.approach : "Current Strategy";
  mermaid += `  ${currentId}[["${currentLabel}"]]
`;
  mermaid += `  ${metaId} ==> ${currentId}
`;
  const modeId = sanitizeId("current_mode");
  mermaid += `  ${modeId}(["Mode: ${thought.currentStrategy.mode}"])
`;
  mermaid += `  ${currentId} --> ${modeId}
`;
  const evalId = sanitizeId("evaluation");
  mermaid += `  ${evalId}{{"Effectiveness: ${(thought.strategyEvaluation.effectiveness * 100).toFixed(0)}%"}}
`;
  mermaid += `  ${currentId} --> ${evalId}
`;
  if (thought.strategyEvaluation.issues.length > 0) {
    const issuesId = sanitizeId("issues");
    mermaid += `  ${issuesId}>"Issues: ${thought.strategyEvaluation.issues.length}"]
`;
    mermaid += `  ${evalId} --> ${issuesId}
`;
  }
  if (thought.strategyEvaluation.strengths.length > 0) {
    const strengthsId = sanitizeId("strengths");
    mermaid += `  ${strengthsId}>"Strengths: ${thought.strategyEvaluation.strengths.length}"]
`;
    mermaid += `  ${evalId} --> ${strengthsId}
`;
  }
  if (thought.alternativeStrategies.length > 0) {
    const altsId = sanitizeId("alternatives");
    mermaid += `  ${altsId}(["Alternative Strategies"])
`;
    mermaid += `  ${metaId} --> ${altsId}
`;
    thought.alternativeStrategies.forEach((alt, index) => {
      const altId = sanitizeId(`alt_${index}`);
      const altLabel = includeLabels ? `${alt.mode}: ${(alt.recommendationScore * 100).toFixed(0)}%` : `Alt ${index + 1}`;
      mermaid += `  ${altId}["${altLabel}"]
`;
      mermaid += `  ${altsId} --> ${altId}
`;
    });
  }
  const recId = sanitizeId("recommendation");
  const recLabel = `${thought.recommendation.action}${thought.recommendation.targetMode ? ` \u2192 ${thought.recommendation.targetMode}` : ""}`;
  mermaid += `  ${recId}[/"${recLabel}"/]
`;
  mermaid += `  ${metaId} ==> ${recId}
`;
  if (includeMetrics) {
    const confId = sanitizeId("rec_confidence");
    mermaid += `  ${confId}{{"Confidence: ${(thought.recommendation.confidence * 100).toFixed(0)}%"}}
`;
    mermaid += `  ${recId} --> ${confId}
`;
  }
  if (includeMetrics) {
    const qualityId = sanitizeId("quality");
    const qualityLabel = `Quality: ${(thought.qualityMetrics.overallQuality * 100).toFixed(0)}%`;
    mermaid += `  ${qualityId}{{"${qualityLabel}"}}
`;
    mermaid += `  ${metaId} -.-> ${qualityId}
`;
  }
  const resourceId = sanitizeId("resources");
  mermaid += `  ${resourceId}[("Complexity: ${thought.resourceAllocation.complexityLevel}")]
`;
  mermaid += `  ${metaId} -.-> ${resourceId}
`;
  const sessionId = sanitizeId("session");
  mermaid += `  ${sessionId}>"Thoughts: ${thought.sessionContext.totalThoughts}"]
`;
  mermaid += `  ${metaId} -.-> ${sessionId}
`;
  if (colorScheme !== "monochrome") {
    const colors = colorScheme === "pastel" ? { meta: "#f3e5f5", current: "#e3f2fd", rec: "#e8f5e9", alt: "#fff3e0" } : { meta: "#DDA0DD", current: "#87CEEB", rec: "#90EE90", alt: "#FFD700" };
    mermaid += `
  style ${metaId} fill:${colors.meta}
`;
    mermaid += `  style ${currentId} fill:${colors.current}
`;
    mermaid += `  style ${recId} fill:${colors.rec}
`;
    if (thought.alternativeStrategies.length > 0) {
      mermaid += `  style ${sanitizeId("alternatives")} fill:${colors.alt}
`;
    }
  }
  return mermaid;
}
function metaReasoningToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph MetaReasoning {\n";
  dot += "  rankdir=TB;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  dot += "  subgraph cluster_current {\n";
  dot += '    label="Current Strategy";\n';
  dot += "    style=filled;\n";
  dot += "    fillcolor=lightblue;\n";
  const currentId = sanitizeId("current_strategy");
  const currentLabel = includeLabels ? thought.currentStrategy.approach.slice(0, 30).replace(/"/g, '"') : "Current Strategy";
  dot += `    ${currentId} [label="${currentLabel}"];
`;
  const modeId = sanitizeId("current_mode");
  dot += `    ${modeId} [label="${thought.currentStrategy.mode}", shape=ellipse];
`;
  dot += `    ${currentId} -> ${modeId};
`;
  if (includeMetrics) {
    const evalId = sanitizeId("evaluation");
    dot += `    ${evalId} [label="Eff: ${(thought.strategyEvaluation.effectiveness * 100).toFixed(0)}%", shape=diamond];
`;
    dot += `    ${currentId} -> ${evalId};
`;
  }
  dot += "  }\n\n";
  if (thought.alternativeStrategies.length > 0) {
    dot += "  subgraph cluster_alternatives {\n";
    dot += '    label="Alternatives";\n';
    dot += "    style=filled;\n";
    dot += "    fillcolor=lightyellow;\n";
    thought.alternativeStrategies.forEach((alt, index) => {
      const altId = sanitizeId(`alt_${index}`);
      const altLabel = `${alt.mode}\\n${(alt.recommendationScore * 100).toFixed(0)}%`;
      dot += `    ${altId} [label="${altLabel}"];
`;
    });
    dot += "  }\n\n";
  }
  const recId = sanitizeId("recommendation");
  const recLabel = `${thought.recommendation.action}${thought.recommendation.targetMode ? `\\n\u2192 ${thought.recommendation.targetMode}` : ""}`;
  dot += `  ${recId} [label="${recLabel}", shape=hexagon, style="filled", fillcolor=lightgreen];
`;
  if (includeMetrics) {
    const qualityId = sanitizeId("quality");
    const qualityLabel = `Quality: ${(thought.qualityMetrics.overallQuality * 100).toFixed(0)}%`;
    dot += `  ${qualityId} [label="${qualityLabel}", shape=diamond];
`;
  }
  dot += `  ${currentId} -> ${recId} [style=bold, penwidth=2];
`;
  thought.alternativeStrategies.forEach((_, index) => {
    const altId = sanitizeId(`alt_${index}`);
    dot += `  ${altId} -> ${recId} [style=dashed];
`;
  });
  dot += "}\n";
  return dot;
}
function metaReasoningToASCII(thought) {
  let ascii = "Meta-Reasoning Analysis:\n";
  ascii += "========================\n\n";
  ascii += "CURRENT STRATEGY\n";
  ascii += "----------------\n";
  ascii += `Mode: ${thought.currentStrategy.mode}
`;
  ascii += `Approach: ${thought.currentStrategy.approach}
`;
  ascii += `Thoughts Spent: ${thought.currentStrategy.thoughtsSpent}
`;
  if (thought.currentStrategy.progressIndicators.length > 0) {
    ascii += "Progress Indicators:\n";
    thought.currentStrategy.progressIndicators.forEach((ind, index) => {
      ascii += `  ${index + 1}. ${ind}
`;
    });
  }
  ascii += "\n";
  ascii += "STRATEGY EVALUATION\n";
  ascii += "-------------------\n";
  ascii += `Effectiveness: ${(thought.strategyEvaluation.effectiveness * 100).toFixed(1)}%
`;
  ascii += `Efficiency: ${(thought.strategyEvaluation.efficiency * 100).toFixed(1)}%
`;
  ascii += `Confidence: ${(thought.strategyEvaluation.confidence * 100).toFixed(1)}%
`;
  ascii += `Progress Rate: ${thought.strategyEvaluation.progressRate.toFixed(2)} insights/thought
`;
  ascii += `Quality Score: ${(thought.strategyEvaluation.qualityScore * 100).toFixed(1)}%
`;
  if (thought.strategyEvaluation.strengths.length > 0) {
    ascii += "Strengths:\n";
    thought.strategyEvaluation.strengths.forEach((s, index) => {
      ascii += `  + ${index + 1}. ${s}
`;
    });
  }
  if (thought.strategyEvaluation.issues.length > 0) {
    ascii += "Issues:\n";
    thought.strategyEvaluation.issues.forEach((issue, index) => {
      ascii += `  - ${index + 1}. ${issue}
`;
    });
  }
  ascii += "\n";
  if (thought.alternativeStrategies.length > 0) {
    ascii += "ALTERNATIVE STRATEGIES\n";
    ascii += "----------------------\n";
    thought.alternativeStrategies.forEach((alt, index) => {
      ascii += `[${index + 1}] ${alt.mode}
`;
      ascii += `    Reasoning: ${alt.reasoning}
`;
      ascii += `    Expected Benefit: ${alt.expectedBenefit}
`;
      ascii += `    Switching Cost: ${(alt.switchingCost * 100).toFixed(0)}%
`;
      ascii += `    Recommendation Score: ${(alt.recommendationScore * 100).toFixed(0)}%
`;
    });
    ascii += "\n";
  }
  ascii += "RECOMMENDATION\n";
  ascii += "--------------\n";
  ascii += `Action: ${thought.recommendation.action}
`;
  if (thought.recommendation.targetMode) {
    ascii += `Target Mode: ${thought.recommendation.targetMode}
`;
  }
  ascii += `Justification: ${thought.recommendation.justification}
`;
  ascii += `Confidence: ${(thought.recommendation.confidence * 100).toFixed(1)}%
`;
  ascii += `Expected Improvement: ${thought.recommendation.expectedImprovement}
`;
  ascii += "\n";
  ascii += "RESOURCE ALLOCATION\n";
  ascii += "-------------------\n";
  ascii += `Time Spent: ${thought.resourceAllocation.timeSpent}ms
`;
  ascii += `Thoughts Remaining: ${thought.resourceAllocation.thoughtsRemaining}
`;
  ascii += `Complexity: ${thought.resourceAllocation.complexityLevel}
`;
  ascii += `Urgency: ${thought.resourceAllocation.urgency}
`;
  ascii += `Recommendation: ${thought.resourceAllocation.recommendation}
`;
  ascii += "\n";
  ascii += "QUALITY METRICS\n";
  ascii += "---------------\n";
  ascii += `Logical Consistency: ${(thought.qualityMetrics.logicalConsistency * 100).toFixed(1)}%
`;
  ascii += `Evidence Quality: ${(thought.qualityMetrics.evidenceQuality * 100).toFixed(1)}%
`;
  ascii += `Completeness: ${(thought.qualityMetrics.completeness * 100).toFixed(1)}%
`;
  ascii += `Originality: ${(thought.qualityMetrics.originality * 100).toFixed(1)}%
`;
  ascii += `Clarity: ${(thought.qualityMetrics.clarity * 100).toFixed(1)}%
`;
  ascii += `Overall Quality: ${(thought.qualityMetrics.overallQuality * 100).toFixed(1)}%
`;
  ascii += "\n";
  ascii += "SESSION CONTEXT\n";
  ascii += "---------------\n";
  ascii += `Session ID: ${thought.sessionContext.sessionId}
`;
  ascii += `Total Thoughts: ${thought.sessionContext.totalThoughts}
`;
  ascii += `Mode Switches: ${thought.sessionContext.modeSwitches}
`;
  ascii += `Problem Type: ${thought.sessionContext.problemType}
`;
  ascii += `Modes Used: ${thought.sessionContext.modesUsed.join(", ")}
`;
  if (thought.sessionContext.historicalEffectiveness !== void 0) {
    ascii += `Historical Effectiveness: ${(thought.sessionContext.historicalEffectiveness * 100).toFixed(1)}%
`;
  }
  return ascii;
}
function metaReasoningToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width,
    svgHeight = DEFAULT_SVG_OPTIONS.height
  } = options;
  const positions = /* @__PURE__ */ new Map();
  const nodeWidth = 150;
  const nodeHeight = 40;
  positions.set("meta", {
    id: "meta",
    label: "Meta-Reasoning",
    x: svgWidth / 2,
    y: 80,
    width: nodeWidth,
    height: nodeHeight,
    type: "meta"
  });
  positions.set("current", {
    id: "current",
    label: includeLabels ? thought.currentStrategy.approach : "Current Strategy",
    x: 200,
    y: 220,
    width: nodeWidth,
    height: nodeHeight,
    type: "current"
  });
  positions.set("recommendation", {
    id: "recommendation",
    label: thought.recommendation.action,
    x: svgWidth - 200,
    y: 220,
    width: nodeWidth,
    height: nodeHeight,
    type: "recommendation"
  });
  if (thought.alternativeStrategies && thought.alternativeStrategies.length > 0) {
    thought.alternativeStrategies.forEach((alt, index) => {
      positions.set(`alt_${index}`, {
        id: `alt_${index}`,
        label: includeLabels ? `${alt.mode}: ${(alt.recommendationScore * 100).toFixed(0)}%` : `Alt ${index + 1}`,
        x: 150 + index * 180,
        y: 380,
        width: nodeWidth,
        height: nodeHeight,
        type: "alternative"
      });
    });
  }
  let svg = generateSVGHeader(svgWidth, svgHeight, "Meta-Reasoning Analysis");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  const metaPos = positions.get("meta");
  const currentPos = positions.get("current");
  const recPos = positions.get("recommendation");
  if (metaPos && currentPos) {
    svg += renderEdge(metaPos, currentPos, { style: "solid" });
  }
  if (metaPos && recPos) {
    svg += renderEdge(metaPos, recPos, { style: "solid" });
  }
  if (thought.alternativeStrategies) {
    thought.alternativeStrategies.forEach((_, index) => {
      const altPos = positions.get(`alt_${index}`);
      if (metaPos && altPos) {
        svg += renderEdge(metaPos, altPos, { style: "dashed" });
      }
    });
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  const metaColors = getNodeColor("warning", colorScheme);
  const currentColors = getNodeColor("primary", colorScheme);
  const recColors = getNodeColor("success", colorScheme);
  const altColors = getNodeColor("secondary", colorScheme);
  for (const [, pos] of positions) {
    if (pos.type === "meta") {
      svg += renderEllipseNode(pos, metaColors);
    } else if (pos.type === "current") {
      svg += renderStadiumNode(pos, currentColors);
    } else if (pos.type === "recommendation") {
      svg += renderStadiumNode(pos, recColors);
    } else if (pos.type === "alternative") {
      svg += renderRectNode(pos, altColors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Effectiveness", value: `${(thought.strategyEvaluation.effectiveness * 100).toFixed(0)}%` },
      { label: "Quality", value: `${(thought.qualityMetrics.overallQuality * 100).toFixed(0)}%` },
      { label: "Alternatives", value: thought.alternativeStrategies.length },
      { label: "Rec Confidence", value: `${(thought.recommendation.confidence * 100).toFixed(0)}%` }
    ];
    svg += renderMetricsPanel(svgWidth - 190, svgHeight - 140, metrics);
  }
  const legendItems = [
    { label: "Meta-Reasoning", color: metaColors, shape: "ellipse" },
    { label: "Current Strategy", color: currentColors, shape: "stadium" },
    { label: "Recommendation", color: recColors, shape: "stadium" },
    { label: "Alternative", color: altColors }
  ];
  svg += renderLegend(20, svgHeight - 140, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function metaReasoningToGraphML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  nodes.push({
    id: "meta",
    label: "Meta-Reasoning",
    type: "meta"
  });
  const currentLabel = includeLabels ? thought.currentStrategy.approach : "Current Strategy";
  nodes.push({
    id: "current_strategy",
    label: currentLabel,
    type: "current",
    metadata: {
      mode: thought.currentStrategy.mode,
      thoughtsSpent: thought.currentStrategy.thoughtsSpent
    }
  });
  edges.push({
    id: "e_meta_current",
    source: "meta",
    target: "current_strategy",
    directed: true
  });
  if (includeMetrics) {
    nodes.push({
      id: "evaluation",
      label: `Effectiveness: ${(thought.strategyEvaluation.effectiveness * 100).toFixed(0)}%`,
      type: "evaluation",
      metadata: {
        effectiveness: thought.strategyEvaluation.effectiveness,
        efficiency: thought.strategyEvaluation.efficiency,
        confidence: thought.strategyEvaluation.confidence,
        progressRate: thought.strategyEvaluation.progressRate,
        qualityScore: thought.strategyEvaluation.qualityScore
      }
    });
    edges.push({
      id: "e_current_eval",
      source: "current_strategy",
      target: "evaluation",
      directed: true
    });
    if (thought.strategyEvaluation.issues.length > 0) {
      nodes.push({
        id: "issues",
        label: `Issues: ${thought.strategyEvaluation.issues.length}`,
        type: "issue",
        metadata: {
          issues: thought.strategyEvaluation.issues
        }
      });
      edges.push({
        id: "e_eval_issues",
        source: "evaluation",
        target: "issues",
        directed: true
      });
    }
    if (thought.strategyEvaluation.strengths.length > 0) {
      nodes.push({
        id: "strengths",
        label: `Strengths: ${thought.strategyEvaluation.strengths.length}`,
        type: "strength",
        metadata: {
          strengths: thought.strategyEvaluation.strengths
        }
      });
      edges.push({
        id: "e_eval_strengths",
        source: "evaluation",
        target: "strengths",
        directed: true
      });
    }
  }
  if (thought.alternativeStrategies.length > 0) {
    thought.alternativeStrategies.forEach((alt, index) => {
      const altLabel = includeLabels ? `${alt.mode}: ${(alt.recommendationScore * 100).toFixed(0)}%` : `Alternative ${index + 1}`;
      nodes.push({
        id: `alt_${index}`,
        label: altLabel,
        type: "alternative",
        metadata: {
          mode: alt.mode,
          reasoning: alt.reasoning,
          expectedBenefit: alt.expectedBenefit,
          switchingCost: alt.switchingCost,
          recommendationScore: alt.recommendationScore
        }
      });
      edges.push({
        id: `e_meta_alt_${index}`,
        source: "meta",
        target: `alt_${index}`,
        directed: true
      });
    });
  }
  const recLabel = `${thought.recommendation.action}${thought.recommendation.targetMode ? ` \u2192 ${thought.recommendation.targetMode}` : ""}`;
  nodes.push({
    id: "recommendation",
    label: recLabel,
    type: "recommendation",
    metadata: {
      action: thought.recommendation.action,
      targetMode: thought.recommendation.targetMode,
      justification: thought.recommendation.justification,
      confidence: thought.recommendation.confidence,
      expectedImprovement: thought.recommendation.expectedImprovement
    }
  });
  edges.push({
    id: "e_meta_rec",
    source: "meta",
    target: "recommendation",
    directed: true
  });
  if (includeMetrics) {
    nodes.push({
      id: "quality",
      label: `Quality: ${(thought.qualityMetrics.overallQuality * 100).toFixed(0)}%`,
      type: "quality",
      metadata: {
        logicalConsistency: thought.qualityMetrics.logicalConsistency,
        evidenceQuality: thought.qualityMetrics.evidenceQuality,
        completeness: thought.qualityMetrics.completeness,
        originality: thought.qualityMetrics.originality,
        clarity: thought.qualityMetrics.clarity,
        overallQuality: thought.qualityMetrics.overallQuality
      }
    });
    edges.push({
      id: "e_meta_quality",
      source: "meta",
      target: "quality",
      directed: true
    });
  }
  const graphmlOptions = {
    graphName: "MetaReasoning Visualization",
    directed: true,
    includeLabels
  };
  return generateGraphML(nodes, edges, graphmlOptions);
}
function metaReasoningToTikZ(thought, options) {
  const { includeLabels = true, includeMetrics = true, colorScheme = "default" } = options;
  const nodes = [];
  const edges = [];
  nodes.push({
    id: "meta",
    label: "Meta-Reasoning",
    x: 0,
    y: 0,
    shape: "ellipse",
    type: "meta"
  });
  const currentLabel = includeLabels ? thought.currentStrategy.approach : "Current Strategy";
  nodes.push({
    id: "current_strategy",
    label: currentLabel.substring(0, 30),
    // Truncate for readability
    x: -4,
    y: -2,
    shape: "stadium",
    type: "current"
  });
  edges.push({
    source: "meta",
    target: "current_strategy",
    directed: true
  });
  const recLabel = `${thought.recommendation.action}${thought.recommendation.targetMode ? ` \u2192 ${thought.recommendation.targetMode}` : ""}`;
  nodes.push({
    id: "recommendation",
    label: recLabel.substring(0, 30),
    x: 4,
    y: -2,
    shape: "stadium",
    type: "recommendation"
  });
  edges.push({
    source: "meta",
    target: "recommendation",
    directed: true
  });
  if (includeMetrics) {
    nodes.push({
      id: "evaluation",
      label: `Eff: ${(thought.strategyEvaluation.effectiveness * 100).toFixed(0)}%`,
      x: -4,
      y: -4,
      shape: "diamond",
      type: "evaluation"
    });
    edges.push({
      source: "current_strategy",
      target: "evaluation",
      directed: true
    });
  }
  if (thought.alternativeStrategies.length > 0) {
    const altCount = thought.alternativeStrategies.length;
    const spacing = 2.5;
    const totalWidth = (altCount - 1) * spacing;
    const offset = totalWidth / 2;
    thought.alternativeStrategies.forEach((alt, index) => {
      const altLabel = includeLabels ? `${alt.mode}: ${(alt.recommendationScore * 100).toFixed(0)}%` : `Alt ${index + 1}`;
      nodes.push({
        id: `alt_${index}`,
        label: altLabel,
        x: index * spacing - offset,
        y: -5,
        shape: "rectangle",
        type: "alternative"
      });
      edges.push({
        source: "meta",
        target: `alt_${index}`,
        directed: true,
        style: "dashed"
      });
    });
  }
  if (includeMetrics) {
    nodes.push({
      id: "quality",
      label: `Quality: ${(thought.qualityMetrics.overallQuality * 100).toFixed(0)}%`,
      x: 4,
      y: -4,
      shape: "diamond",
      type: "quality"
    });
    edges.push({
      source: "meta",
      target: "quality",
      directed: true,
      style: "dashed"
    });
  }
  const tikzOptions = {
    title: "MetaReasoning Visualization",
    colorScheme,
    includeLabels
  };
  return generateTikZ(nodes, edges, tikzOptions);
}
function metaReasoningToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Meta-Reasoning Analysis",
    htmlTheme = "light"
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  html += '<div class="metrics-grid">';
  html += renderMetricCard("Effectiveness", `${(thought.strategyEvaluation.effectiveness * 100).toFixed(0)}%`, "primary");
  html += renderMetricCard("Quality", `${(thought.qualityMetrics.overallQuality * 100).toFixed(0)}%`, "success");
  html += renderMetricCard("Alternatives", thought.alternativeStrategies.length, "info");
  html += renderMetricCard("Confidence", `${(thought.recommendation.confidence * 100).toFixed(0)}%`, "warning");
  html += "</div>\n";
  const strategyContent = `
    <p><strong>Mode:</strong> ${renderBadge(thought.currentStrategy.mode, "primary")}</p>
    <p><strong>Approach:</strong> ${escapeHTML(thought.currentStrategy.approach)}</p>
    <p><strong>Thoughts Spent:</strong> ${thought.currentStrategy.thoughtsSpent}</p>
    ${thought.currentStrategy.progressIndicators.length > 0 ? `
      <p style="margin-top: 1rem"><strong>Progress Indicators:</strong></p>
      <ul class="list-styled">
        ${thought.currentStrategy.progressIndicators.map((ind) => `<li>${escapeHTML(ind)}</li>`).join("")}
      </ul>
    ` : ""}
  `;
  html += renderSection("Current Strategy", strategyContent, "\u{1F3AF}");
  const evalRows = [
    ["Effectiveness", `${(thought.strategyEvaluation.effectiveness * 100).toFixed(1)}%`],
    ["Efficiency", `${(thought.strategyEvaluation.efficiency * 100).toFixed(1)}%`],
    ["Confidence", `${(thought.strategyEvaluation.confidence * 100).toFixed(1)}%`],
    ["Progress Rate", `${thought.strategyEvaluation.progressRate.toFixed(2)} insights/thought`],
    ["Quality Score", `${(thought.strategyEvaluation.qualityScore * 100).toFixed(1)}%`]
  ];
  let evalContent = renderTable(["Metric", "Value"], evalRows);
  evalContent += '<p style="margin-top: 1rem"><strong>Effectiveness:</strong></p>';
  evalContent += renderProgressBar(thought.strategyEvaluation.effectiveness * 100, "primary");
  if (thought.strategyEvaluation.strengths.length > 0) {
    evalContent += '<p style="margin-top: 1rem"><strong>Strengths:</strong></p>';
    evalContent += '<ul class="list-styled">';
    thought.strategyEvaluation.strengths.forEach((s) => {
      evalContent += `<li class="text-success">\u2713 ${escapeHTML(s)}</li>`;
    });
    evalContent += "</ul>";
  }
  if (thought.strategyEvaluation.issues.length > 0) {
    evalContent += '<p style="margin-top: 1rem"><strong>Issues:</strong></p>';
    evalContent += '<ul class="list-styled">';
    thought.strategyEvaluation.issues.forEach((issue) => {
      evalContent += `<li class="text-danger">\u2717 ${escapeHTML(issue)}</li>`;
    });
    evalContent += "</ul>";
  }
  html += renderSection("Strategy Evaluation", evalContent, "\u{1F4CA}");
  if (thought.alternativeStrategies.length > 0) {
    const altsContent = thought.alternativeStrategies.map((alt) => `
      <div class="card">
        <div class="card-header">
          ${renderBadge(alt.mode, "info")}
          ${renderBadge(`Score: ${(alt.recommendationScore * 100).toFixed(0)}%`, "secondary")}
        </div>
        <p><strong>Reasoning:</strong> ${escapeHTML(alt.reasoning)}</p>
        <p><strong>Expected Benefit:</strong> ${escapeHTML(alt.expectedBenefit)}</p>
        <p><strong>Switching Cost:</strong></p>
        ${renderProgressBar(alt.switchingCost * 100, "warning")}
        <p style="margin-top: 0.5rem"><strong>Recommendation Score:</strong></p>
        ${renderProgressBar(alt.recommendationScore * 100, "success")}
      </div>
    `).join("");
    html += renderSection("Alternative Strategies", altsContent, "\u{1F500}");
  }
  const recContent = `
    <p><strong>Action:</strong> ${renderBadge(thought.recommendation.action, "warning")}</p>
    ${thought.recommendation.targetMode ? `<p><strong>Target Mode:</strong> ${renderBadge(thought.recommendation.targetMode, "primary")}</p>` : ""}
    <p><strong>Justification:</strong> ${escapeHTML(thought.recommendation.justification)}</p>
    <p><strong>Expected Improvement:</strong> ${escapeHTML(thought.recommendation.expectedImprovement)}</p>
    <p style="margin-top: 1rem"><strong>Confidence:</strong></p>
    ${renderProgressBar(thought.recommendation.confidence * 100, "success")}
  `;
  html += renderSection("Recommendation", recContent, "\u{1F4A1}");
  const resourceRows = [
    ["Time Spent", `${thought.resourceAllocation.timeSpent}ms`],
    ["Thoughts Remaining", thought.resourceAllocation.thoughtsRemaining],
    ["Complexity Level", thought.resourceAllocation.complexityLevel],
    ["Urgency", thought.resourceAllocation.urgency]
  ];
  let resourceContent = renderTable(["Resource", "Value"], resourceRows);
  resourceContent += `<p style="margin-top: 1rem"><strong>Recommendation:</strong> ${escapeHTML(thought.resourceAllocation.recommendation)}</p>`;
  html += renderSection("Resource Allocation", resourceContent, "\u26A1");
  const qualityRows = [
    ["Logical Consistency", `${(thought.qualityMetrics.logicalConsistency * 100).toFixed(1)}%`],
    ["Evidence Quality", `${(thought.qualityMetrics.evidenceQuality * 100).toFixed(1)}%`],
    ["Completeness", `${(thought.qualityMetrics.completeness * 100).toFixed(1)}%`],
    ["Originality", `${(thought.qualityMetrics.originality * 100).toFixed(1)}%`],
    ["Clarity", `${(thought.qualityMetrics.clarity * 100).toFixed(1)}%`],
    ["Overall Quality", `${(thought.qualityMetrics.overallQuality * 100).toFixed(1)}%`]
  ];
  let qualityContent = renderTable(["Metric", "Value"], qualityRows);
  qualityContent += '<p style="margin-top: 1rem"><strong>Overall Quality:</strong></p>';
  qualityContent += renderProgressBar(thought.qualityMetrics.overallQuality * 100, "success");
  html += renderSection("Quality Metrics", qualityContent, "\u2B50");
  const sessionRows = [
    ["Session ID", thought.sessionContext.sessionId],
    ["Total Thoughts", thought.sessionContext.totalThoughts],
    ["Mode Switches", thought.sessionContext.modeSwitches],
    ["Problem Type", thought.sessionContext.problemType]
  ];
  if (thought.sessionContext.historicalEffectiveness !== void 0) {
    sessionRows.push(["Historical Effectiveness", `${(thought.sessionContext.historicalEffectiveness * 100).toFixed(1)}%`]);
  }
  let sessionContent = renderTable(["Property", "Value"], sessionRows);
  if (thought.sessionContext.modesUsed.length > 0) {
    sessionContent += '<p style="margin-top: 1rem"><strong>Modes Used:</strong></p>';
    sessionContent += '<div class="flex gap-1 flex-wrap">';
    thought.sessionContext.modesUsed.forEach((mode) => {
      sessionContent += renderBadge(mode, "info");
      sessionContent += " ";
    });
    sessionContent += "</div>";
  }
  html += renderSection("Session Context", sessionContent, "\u{1F4CB}");
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function metaReasoningToModelica(thought, options) {
  const { includeMetrics = true } = options;
  let modelica = "package MetaReasoning\n";
  modelica += '  "Meta-reasoning analysis model for strategy evaluation and recommendation"\n\n';
  modelica += "  record CurrentStrategy\n";
  modelica += '    "Current reasoning strategy being employed"\n';
  const modeId = sanitizeModelicaId(thought.currentStrategy.mode);
  modelica += `    parameter String mode = "${escapeModelicaString(modeId)}";
`;
  modelica += `    parameter String approach = "${escapeModelicaString(thought.currentStrategy.approach)}";
`;
  modelica += `    parameter Integer thoughtsSpent = ${thought.currentStrategy.thoughtsSpent};
`;
  if (thought.currentStrategy.progressIndicators.length > 0) {
    modelica += `    parameter Integer progressIndicatorCount = ${thought.currentStrategy.progressIndicators.length};
`;
  }
  modelica += "  end CurrentStrategy;\n\n";
  modelica += "  record StrategyEvaluation\n";
  modelica += '    "Evaluation metrics for current strategy"\n';
  modelica += `    parameter Real effectiveness(min=0.0, max=1.0) = ${thought.strategyEvaluation.effectiveness.toFixed(4)};
`;
  modelica += `    parameter Real efficiency(min=0.0, max=1.0) = ${thought.strategyEvaluation.efficiency.toFixed(4)};
`;
  modelica += `    parameter Real confidence(min=0.0, max=1.0) = ${thought.strategyEvaluation.confidence.toFixed(4)};
`;
  modelica += `    parameter Real progressRate = ${thought.strategyEvaluation.progressRate.toFixed(4)};
`;
  modelica += `    parameter Real qualityScore(min=0.0, max=1.0) = ${thought.strategyEvaluation.qualityScore.toFixed(4)};
`;
  modelica += `    parameter Integer issueCount = ${thought.strategyEvaluation.issues.length};
`;
  modelica += `    parameter Integer strengthCount = ${thought.strategyEvaluation.strengths.length};
`;
  modelica += "  end StrategyEvaluation;\n\n";
  if (thought.alternativeStrategies.length > 0) {
    thought.alternativeStrategies.forEach((alt, index) => {
      modelica += `  record AlternativeStrategy${index + 1}
`;
      modelica += `    "Alternative reasoning strategy option ${index + 1}"
`;
      const altModeId = sanitizeModelicaId(alt.mode);
      modelica += `    parameter String mode = "${escapeModelicaString(altModeId)}";
`;
      modelica += `    parameter String reasoning = "${escapeModelicaString(alt.reasoning)}";
`;
      modelica += `    parameter String expectedBenefit = "${escapeModelicaString(alt.expectedBenefit)}";
`;
      modelica += `    parameter Real switchingCost(min=0.0, max=1.0) = ${alt.switchingCost.toFixed(4)};
`;
      modelica += `    parameter Real recommendationScore(min=0.0, max=1.0) = ${alt.recommendationScore.toFixed(4)};
`;
      modelica += `  end AlternativeStrategy${index + 1};

`;
    });
  }
  modelica += "  record Recommendation\n";
  modelica += '    "Strategic recommendation from meta-reasoning"\n';
  modelica += `    parameter String action = "${escapeModelicaString(thought.recommendation.action)}";
`;
  if (thought.recommendation.targetMode) {
    const targetModeId = sanitizeModelicaId(thought.recommendation.targetMode);
    modelica += `    parameter String targetMode = "${escapeModelicaString(targetModeId)}";
`;
  }
  modelica += `    parameter String justification = "${escapeModelicaString(thought.recommendation.justification)}";
`;
  modelica += `    parameter Real confidence(min=0.0, max=1.0) = ${thought.recommendation.confidence.toFixed(4)};
`;
  modelica += `    parameter String expectedImprovement = "${escapeModelicaString(thought.recommendation.expectedImprovement)}";
`;
  modelica += "  end Recommendation;\n\n";
  if (includeMetrics) {
    modelica += "  record QualityMetrics\n";
    modelica += '    "Quality assessment metrics for reasoning session"\n';
    modelica += `    parameter Real logicalConsistency(min=0.0, max=1.0) = ${thought.qualityMetrics.logicalConsistency.toFixed(4)};
`;
    modelica += `    parameter Real evidenceQuality(min=0.0, max=1.0) = ${thought.qualityMetrics.evidenceQuality.toFixed(4)};
`;
    modelica += `    parameter Real completeness(min=0.0, max=1.0) = ${thought.qualityMetrics.completeness.toFixed(4)};
`;
    modelica += `    parameter Real originality(min=0.0, max=1.0) = ${thought.qualityMetrics.originality.toFixed(4)};
`;
    modelica += `    parameter Real clarity(min=0.0, max=1.0) = ${thought.qualityMetrics.clarity.toFixed(4)};
`;
    modelica += `    parameter Real overallQuality(min=0.0, max=1.0) = ${thought.qualityMetrics.overallQuality.toFixed(4)};
`;
    modelica += "  end QualityMetrics;\n\n";
  }
  modelica += "  record ResourceAllocation\n";
  modelica += '    "Resource allocation and complexity assessment"\n';
  modelica += `    parameter Real timeSpent = ${thought.resourceAllocation.timeSpent};
`;
  modelica += `    parameter Integer thoughtsRemaining = ${thought.resourceAllocation.thoughtsRemaining};
`;
  modelica += `    parameter String complexityLevel = "${escapeModelicaString(thought.resourceAllocation.complexityLevel)}";
`;
  modelica += `    parameter String urgency = "${escapeModelicaString(thought.resourceAllocation.urgency)}";
`;
  modelica += `    parameter String recommendation = "${escapeModelicaString(thought.resourceAllocation.recommendation)}";
`;
  modelica += "  end ResourceAllocation;\n\n";
  modelica += "  record SessionContext\n";
  modelica += '    "Session context and historical information"\n';
  modelica += `    parameter String sessionId = "${escapeModelicaString(thought.sessionContext.sessionId)}";
`;
  modelica += `    parameter Integer totalThoughts = ${thought.sessionContext.totalThoughts};
`;
  modelica += `    parameter Integer modeSwitches = ${thought.sessionContext.modeSwitches};
`;
  modelica += `    parameter String problemType = "${escapeModelicaString(thought.sessionContext.problemType)}";
`;
  modelica += `    parameter Integer modesUsedCount = ${thought.sessionContext.modesUsed.length};
`;
  if (thought.sessionContext.historicalEffectiveness !== void 0) {
    modelica += `    parameter Real historicalEffectiveness(min=0.0, max=1.0) = ${thought.sessionContext.historicalEffectiveness.toFixed(4)};
`;
  }
  modelica += "  end SessionContext;\n\n";
  modelica += "  model MetaReasoningAnalysis\n";
  modelica += '    "Complete meta-reasoning analysis model"\n';
  modelica += "    CurrentStrategy currentStrategy;\n";
  modelica += "    StrategyEvaluation strategyEvaluation;\n";
  modelica += "    Recommendation recommendation;\n";
  if (includeMetrics) {
    modelica += "    QualityMetrics qualityMetrics;\n";
  }
  modelica += "    ResourceAllocation resourceAllocation;\n";
  modelica += "    SessionContext sessionContext;\n";
  if (thought.alternativeStrategies.length > 0) {
    thought.alternativeStrategies.forEach((_, index) => {
      modelica += `    AlternativeStrategy${index + 1} alternativeStrategy${index + 1};
`;
    });
  }
  modelica += "  end MetaReasoningAnalysis;\n\n";
  modelica += "end MetaReasoning;\n";
  return modelica;
}
function metaReasoningToUML(thought, options) {
  const { includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  nodes.push({
    id: "MetaReasoning",
    label: "MetaReasoning",
    shape: "class",
    attributes: [
      `mode: ${thought.currentStrategy.mode}`,
      `sessionId: ${thought.sessionContext.sessionId}`,
      `totalThoughts: ${thought.sessionContext.totalThoughts}`
    ],
    methods: [
      "evaluateStrategy()",
      "generateRecommendation()",
      "allocateResources()"
    ]
  });
  nodes.push({
    id: "CurrentStrategy",
    label: "CurrentStrategy",
    shape: "class",
    attributes: [
      `mode: ${thought.currentStrategy.mode}`,
      `approach: ${thought.currentStrategy.approach.substring(0, 30)}...`,
      `thoughtsSpent: ${thought.currentStrategy.thoughtsSpent}`,
      `progressIndicators: ${thought.currentStrategy.progressIndicators.length}`
    ]
  });
  edges.push({
    source: "MetaReasoning",
    target: "CurrentStrategy",
    label: "employs",
    type: "composition"
  });
  nodes.push({
    id: "StrategyEvaluation",
    label: "StrategyEvaluation",
    shape: "class",
    attributes: [
      `effectiveness: ${(thought.strategyEvaluation.effectiveness * 100).toFixed(1)}%`,
      `efficiency: ${(thought.strategyEvaluation.efficiency * 100).toFixed(1)}%`,
      `confidence: ${(thought.strategyEvaluation.confidence * 100).toFixed(1)}%`,
      `progressRate: ${thought.strategyEvaluation.progressRate.toFixed(2)}`,
      `qualityScore: ${(thought.strategyEvaluation.qualityScore * 100).toFixed(1)}%`,
      `issues: ${thought.strategyEvaluation.issues.length}`,
      `strengths: ${thought.strategyEvaluation.strengths.length}`
    ]
  });
  edges.push({
    source: "MetaReasoning",
    target: "StrategyEvaluation",
    label: "evaluates",
    type: "association"
  });
  nodes.push({
    id: "Recommendation",
    label: "Recommendation",
    shape: "class",
    attributes: [
      `action: ${thought.recommendation.action}`,
      thought.recommendation.targetMode ? `targetMode: ${thought.recommendation.targetMode}` : void 0,
      `confidence: ${(thought.recommendation.confidence * 100).toFixed(1)}%`,
      `justification: ${thought.recommendation.justification.substring(0, 40)}...`
    ].filter(Boolean)
  });
  edges.push({
    source: "MetaReasoning",
    target: "Recommendation",
    label: "produces",
    type: "association"
  });
  if (thought.alternativeStrategies.length > 0) {
    nodes.push({
      id: "AlternativeStrategy",
      label: "<<interface>>\\nAlternativeStrategy",
      shape: "interface",
      attributes: [
        "mode: ThinkingMode",
        "reasoning: string",
        "expectedBenefit: string",
        "switchingCost: number",
        "recommendationScore: number"
      ]
    });
    edges.push({
      source: "MetaReasoning",
      target: "AlternativeStrategy",
      label: `considers (${thought.alternativeStrategies.length})`,
      type: "association"
    });
    thought.alternativeStrategies.slice(0, 3).forEach((alt, index) => {
      nodes.push({
        id: `Alt${index + 1}`,
        label: `${alt.mode}Strategy`,
        shape: "class",
        attributes: [
          `score: ${(alt.recommendationScore * 100).toFixed(0)}%`,
          `cost: ${(alt.switchingCost * 100).toFixed(0)}%`
        ]
      });
      edges.push({
        source: `Alt${index + 1}`,
        target: "AlternativeStrategy",
        type: "implementation"
      });
    });
  }
  if (includeMetrics) {
    nodes.push({
      id: "QualityMetrics",
      label: "QualityMetrics",
      shape: "class",
      attributes: [
        `logicalConsistency: ${(thought.qualityMetrics.logicalConsistency * 100).toFixed(1)}%`,
        `evidenceQuality: ${(thought.qualityMetrics.evidenceQuality * 100).toFixed(1)}%`,
        `completeness: ${(thought.qualityMetrics.completeness * 100).toFixed(1)}%`,
        `originality: ${(thought.qualityMetrics.originality * 100).toFixed(1)}%`,
        `clarity: ${(thought.qualityMetrics.clarity * 100).toFixed(1)}%`,
        `overallQuality: ${(thought.qualityMetrics.overallQuality * 100).toFixed(1)}%`
      ]
    });
    edges.push({
      source: "MetaReasoning",
      target: "QualityMetrics",
      label: "monitors",
      type: "association"
    });
  }
  nodes.push({
    id: "ResourceAllocation",
    label: "ResourceAllocation",
    shape: "class",
    attributes: [
      `timeSpent: ${thought.resourceAllocation.timeSpent}ms`,
      `thoughtsRemaining: ${thought.resourceAllocation.thoughtsRemaining}`,
      `complexity: ${thought.resourceAllocation.complexityLevel}`,
      `urgency: ${thought.resourceAllocation.urgency}`
    ]
  });
  edges.push({
    source: "MetaReasoning",
    target: "ResourceAllocation",
    label: "manages",
    type: "composition"
  });
  return generateUmlDiagram(nodes, edges, {
    title: "MetaReasoning Structure",
    direction: "top to bottom"
  });
}
function metaReasoningToJSON(thought, options) {
  const { includeMetrics = true } = options;
  const graph = createJsonGraph(
    "MetaReasoning",
    "Meta-reasoning analysis graph showing strategy evaluation and recommendations",
    { includeMetrics, includeLayout: true }
  );
  addNode(graph, {
    id: "meta",
    label: "Meta-Reasoning",
    type: "meta",
    metadata: {
      mode: thought.currentStrategy.mode,
      sessionId: thought.sessionContext.sessionId
    }
  });
  addNode(graph, {
    id: "current_strategy",
    label: "Current Strategy",
    type: "strategy",
    metadata: {
      mode: thought.currentStrategy.mode,
      approach: thought.currentStrategy.approach,
      thoughtsSpent: thought.currentStrategy.thoughtsSpent,
      progressIndicatorCount: thought.currentStrategy.progressIndicators.length,
      progressIndicators: thought.currentStrategy.progressIndicators
    }
  });
  addEdge(graph, {
    id: "e_meta_current",
    source: "meta",
    target: "current_strategy",
    label: "employs",
    metadata: {
      relationship: "current"
    }
  });
  addNode(graph, {
    id: "evaluation",
    label: "Strategy Evaluation",
    type: "evaluation",
    metadata: {
      effectiveness: thought.strategyEvaluation.effectiveness,
      efficiency: thought.strategyEvaluation.efficiency,
      confidence: thought.strategyEvaluation.confidence,
      progressRate: thought.strategyEvaluation.progressRate,
      qualityScore: thought.strategyEvaluation.qualityScore,
      issueCount: thought.strategyEvaluation.issues.length,
      strengthCount: thought.strategyEvaluation.strengths.length,
      issues: thought.strategyEvaluation.issues,
      strengths: thought.strategyEvaluation.strengths
    }
  });
  addEdge(graph, {
    id: "e_current_eval",
    source: "current_strategy",
    target: "evaluation",
    label: "evaluated_by"
  });
  thought.alternativeStrategies.forEach((alt, index) => {
    addNode(graph, {
      id: `alt_${index}`,
      label: `Alternative: ${alt.mode}`,
      type: "alternative",
      metadata: {
        mode: alt.mode,
        reasoning: alt.reasoning,
        expectedBenefit: alt.expectedBenefit,
        switchingCost: alt.switchingCost,
        recommendationScore: alt.recommendationScore
      }
    });
    addEdge(graph, {
      id: `e_meta_alt_${index}`,
      source: "meta",
      target: `alt_${index}`,
      label: "considers",
      metadata: {
        score: alt.recommendationScore
      }
    });
  });
  addNode(graph, {
    id: "recommendation",
    label: "Recommendation",
    type: "recommendation",
    metadata: {
      action: thought.recommendation.action,
      targetMode: thought.recommendation.targetMode,
      justification: thought.recommendation.justification,
      confidence: thought.recommendation.confidence,
      expectedImprovement: thought.recommendation.expectedImprovement
    }
  });
  addEdge(graph, {
    id: "e_eval_rec",
    source: "evaluation",
    target: "recommendation",
    label: "produces",
    metadata: {
      confidence: thought.recommendation.confidence
    }
  });
  if (includeMetrics) {
    addNode(graph, {
      id: "quality",
      label: "Quality Metrics",
      type: "metrics",
      metadata: {
        logicalConsistency: thought.qualityMetrics.logicalConsistency,
        evidenceQuality: thought.qualityMetrics.evidenceQuality,
        completeness: thought.qualityMetrics.completeness,
        originality: thought.qualityMetrics.originality,
        clarity: thought.qualityMetrics.clarity,
        overallQuality: thought.qualityMetrics.overallQuality
      }
    });
    addEdge(graph, {
      id: "e_meta_quality",
      source: "meta",
      target: "quality",
      label: "monitors"
    });
    addMetric(graph, "effectiveness", thought.strategyEvaluation.effectiveness);
    addMetric(graph, "overallQuality", thought.qualityMetrics.overallQuality);
    addMetric(graph, "recommendationConfidence", thought.recommendation.confidence);
  }
  addNode(graph, {
    id: "resources",
    label: "Resource Allocation",
    type: "resources",
    metadata: {
      timeSpent: thought.resourceAllocation.timeSpent,
      thoughtsRemaining: thought.resourceAllocation.thoughtsRemaining,
      complexityLevel: thought.resourceAllocation.complexityLevel,
      urgency: thought.resourceAllocation.urgency,
      recommendation: thought.resourceAllocation.recommendation
    }
  });
  addEdge(graph, {
    id: "e_meta_resources",
    source: "meta",
    target: "resources",
    label: "manages"
  });
  graph.metadata = {
    ...graph.metadata,
    sessionContext: {
      sessionId: thought.sessionContext.sessionId,
      totalThoughts: thought.sessionContext.totalThoughts,
      modeSwitches: thought.sessionContext.modeSwitches,
      problemType: thought.sessionContext.problemType,
      modesUsed: thought.sessionContext.modesUsed,
      historicalEffectiveness: thought.sessionContext.historicalEffectiveness
    }
  };
  return serializeGraph(graph);
}
function metaReasoningToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  const strategyContent = keyValueSection({
    "Mode": thought.currentStrategy.mode,
    "Approach": thought.currentStrategy.approach,
    "Thoughts Spent": thought.currentStrategy.thoughtsSpent
  });
  let strategyFull = strategyContent;
  if (thought.currentStrategy.progressIndicators.length > 0) {
    strategyFull += "\n\n**Progress Indicators:**\n\n" + list(thought.currentStrategy.progressIndicators);
  }
  parts.push(section("Current Strategy", strategyFull));
  if (includeMetrics) {
    const evalRows = [
      ["Effectiveness", `${(thought.strategyEvaluation.effectiveness * 100).toFixed(1)}%`],
      ["Efficiency", `${(thought.strategyEvaluation.efficiency * 100).toFixed(1)}%`],
      ["Confidence", `${(thought.strategyEvaluation.confidence * 100).toFixed(1)}%`],
      ["Progress Rate", `${thought.strategyEvaluation.progressRate.toFixed(2)} insights/thought`],
      ["Quality Score", `${(thought.strategyEvaluation.qualityScore * 100).toFixed(1)}%`]
    ];
    let evalContent = table(["Metric", "Value"], evalRows);
    evalContent += "\n\n**Effectiveness:**\n\n" + progressBar(thought.strategyEvaluation.effectiveness * 100);
    if (thought.strategyEvaluation.strengths.length > 0) {
      evalContent += "\n\n**Strengths:**\n\n" + list(thought.strategyEvaluation.strengths.map((s) => `\u2713 ${s}`));
    }
    if (thought.strategyEvaluation.issues.length > 0) {
      evalContent += "\n\n**Issues:**\n\n" + list(thought.strategyEvaluation.issues.map((i) => `\u2717 ${i}`));
    }
    parts.push(section("Strategy Evaluation", evalContent));
  }
  if (thought.alternativeStrategies.length > 0) {
    const altRows = thought.alternativeStrategies.map((alt) => [
      alt.mode,
      alt.reasoning.substring(0, 50) + (alt.reasoning.length > 50 ? "..." : ""),
      alt.expectedBenefit.substring(0, 40) + (alt.expectedBenefit.length > 40 ? "..." : ""),
      `${(alt.switchingCost * 100).toFixed(0)}%`,
      `${(alt.recommendationScore * 100).toFixed(0)}%`
    ]);
    parts.push(section("Alternative Strategies", table(
      ["Mode", "Reasoning", "Expected Benefit", "Switching Cost", "Score"],
      altRows
    )));
  }
  const recContent = keyValueSection({
    "Action": thought.recommendation.action,
    ...thought.recommendation.targetMode ? { "Target Mode": thought.recommendation.targetMode } : {},
    "Confidence": `${(thought.recommendation.confidence * 100).toFixed(1)}%`,
    "Expected Improvement": thought.recommendation.expectedImprovement
  });
  let recFull = recContent;
  recFull += "\n\n**Justification:**\n\n" + thought.recommendation.justification;
  recFull += "\n\n**Confidence Level:**\n\n" + progressBar(thought.recommendation.confidence * 100);
  parts.push(section("Recommendation", recFull));
  const resourceContent = keyValueSection({
    "Time Spent": `${thought.resourceAllocation.timeSpent}ms`,
    "Thoughts Remaining": thought.resourceAllocation.thoughtsRemaining,
    "Complexity Level": thought.resourceAllocation.complexityLevel,
    "Urgency": thought.resourceAllocation.urgency,
    "Recommendation": thought.resourceAllocation.recommendation
  });
  parts.push(section("Resource Allocation", resourceContent));
  if (includeMetrics) {
    const qualityRows = [
      ["Logical Consistency", `${(thought.qualityMetrics.logicalConsistency * 100).toFixed(1)}%`],
      ["Evidence Quality", `${(thought.qualityMetrics.evidenceQuality * 100).toFixed(1)}%`],
      ["Completeness", `${(thought.qualityMetrics.completeness * 100).toFixed(1)}%`],
      ["Originality", `${(thought.qualityMetrics.originality * 100).toFixed(1)}%`],
      ["Clarity", `${(thought.qualityMetrics.clarity * 100).toFixed(1)}%`],
      ["Overall Quality", `${(thought.qualityMetrics.overallQuality * 100).toFixed(1)}%`]
    ];
    let qualityContent = table(["Metric", "Value"], qualityRows);
    qualityContent += "\n\n**Overall Quality:**\n\n" + progressBar(thought.qualityMetrics.overallQuality * 100);
    parts.push(section("Quality Metrics", qualityContent));
  }
  const sessionContent = keyValueSection({
    "Session ID": thought.sessionContext.sessionId,
    "Total Thoughts": thought.sessionContext.totalThoughts,
    "Mode Switches": thought.sessionContext.modeSwitches,
    "Problem Type": thought.sessionContext.problemType,
    "Modes Used": thought.sessionContext.modesUsed.join(", "),
    ...thought.sessionContext.historicalEffectiveness !== void 0 ? { "Historical Effectiveness": `${(thought.sessionContext.historicalEffectiveness * 100).toFixed(1)}%` } : {}
  });
  parts.push(section("Session Context", sessionContent));
  if (markdownIncludeMermaid) {
    const mermaidDiagram = metaReasoningToMermaid(thought, "default", true, true);
    parts.push(section("Visualization", mermaidBlock(mermaidDiagram)));
  }
  return document("Meta-Reasoning Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "metareasoning",
      currentMode: thought.currentStrategy.mode,
      recommendedAction: thought.recommendation.action,
      overallQuality: thought.qualityMetrics.overallQuality
    }
  });
}
var init_metareasoning = __esm({
  "src/export/visual/modes/metareasoning.ts"() {
    init_esm_shims();
    init_utils();
    init_svg();
    init_graphml();
    init_tikz();
    init_html();
    init_modelica();
    init_uml();
    init_json();
    init_markdown();
  }
});

// src/export/visual/modes/systems-thinking.ts
function exportSystemsThinkingCausalLoops(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return systemsThinkingToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return systemsThinkingToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return systemsThinkingToASCII(thought);
    case "svg":
      return systemsThinkingToSVG(thought, options);
    case "graphml":
      return systemsThinkingToGraphML(thought, options);
    case "tikz":
      return systemsThinkingToTikZ(thought, options);
    case "html":
      return systemsThinkingToHTML(thought, options);
    case "modelica":
      return systemsThinkingToModelica(thought, options);
    case "uml":
      return systemsThinkingToUML(thought, options);
    case "json":
      return systemsThinkingToJSON(thought, options);
    case "markdown":
      return systemsThinkingToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function systemsThinkingToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TB\n";
  if (thought.system) {
    mermaid += `  System["${thought.system.name}"]

`;
  }
  if (thought.components && thought.components.length > 0) {
    for (const component of thought.components) {
      const compId = sanitizeId(component.id);
      const label = includeLabels ? component.name : compId;
      const shape = component.type === "stock" ? ["[[", "]]"] : ["[", "]"];
      mermaid += `  ${compId}${shape[0]}${label}${shape[1]}
`;
    }
    mermaid += "\n";
  }
  if (thought.feedbackLoops && thought.feedbackLoops.length > 0) {
    for (const loop of thought.feedbackLoops) {
      const loopComponents = loop.components;
      for (let i = 0; i < loopComponents.length; i++) {
        const fromId = sanitizeId(loopComponents[i]);
        const toId = sanitizeId(loopComponents[(i + 1) % loopComponents.length]);
        const edgeLabel = includeMetrics ? `|${loop.type} (${loop.strength.toFixed(2)})| ` : `|${loop.type}| `;
        const edgeStyle = loop.type === "reinforcing" ? "-->" : "-..->";
        mermaid += `  ${fromId} ${edgeStyle}${edgeLabel}${toId}
`;
      }
    }
    mermaid += "\n";
  }
  if (colorScheme !== "monochrome" && thought.components) {
    const stockColor = colorScheme === "pastel" ? "#e1f5ff" : "#a8d5ff";
    const flowColor = colorScheme === "pastel" ? "#fff3e0" : "#ffd699";
    for (const component of thought.components) {
      const compId = sanitizeId(component.id);
      const color = component.type === "stock" ? stockColor : flowColor;
      mermaid += `  style ${compId} fill:${color}
`;
    }
  }
  return mermaid;
}
function systemsThinkingToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph SystemsThinking {\n";
  dot += "  rankdir=TB;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  if (thought.components && thought.components.length > 0) {
    for (const component of thought.components) {
      const compId = sanitizeId(component.id);
      const label = includeLabels ? component.name : compId;
      const shape = component.type === "stock" ? "box" : "ellipse";
      dot += `  ${compId} [label="${label}", shape=${shape}];
`;
    }
    dot += "\n";
  }
  if (thought.feedbackLoops && thought.feedbackLoops.length > 0) {
    for (const loop of thought.feedbackLoops) {
      const loopComponents = loop.components;
      for (let i = 0; i < loopComponents.length; i++) {
        const fromId = sanitizeId(loopComponents[i]);
        const toId = sanitizeId(loopComponents[(i + 1) % loopComponents.length]);
        const edgeLabel = includeMetrics ? `, label="${loop.type} (${loop.strength.toFixed(2)})"` : `, label="${loop.type}"`;
        const edgeStyle = loop.type === "reinforcing" ? "solid" : "dashed";
        dot += `  ${fromId} -> ${toId} [style=${edgeStyle}${edgeLabel}];
`;
      }
    }
  }
  dot += "}\n";
  return dot;
}
function systemsThinkingToASCII(thought) {
  let ascii = "Systems Thinking Model:\n";
  ascii += "======================\n\n";
  if (thought.system) {
    ascii += `System: ${thought.system.name}
`;
    ascii += `${thought.system.description}

`;
  }
  if (thought.components && thought.components.length > 0) {
    ascii += "Components:\n";
    for (const component of thought.components) {
      const typeIcon = component.type === "stock" ? "[\u25A0]" : "(\u25CB)";
      ascii += `  ${typeIcon} ${component.name}: ${component.description}
`;
    }
    ascii += "\n";
  }
  if (thought.feedbackLoops && thought.feedbackLoops.length > 0) {
    ascii += "Feedback Loops:\n";
    for (const loop of thought.feedbackLoops) {
      const loopIcon = loop.type === "reinforcing" ? "\u2295" : "\u2296";
      ascii += `  ${loopIcon} ${loop.name} (${loop.type})
`;
      ascii += `    Strength: ${loop.strength.toFixed(2)}
`;
      ascii += `    Components: ${loop.components.join(" \u2192 ")}
`;
    }
    ascii += "\n";
  }
  if (thought.leveragePoints && thought.leveragePoints.length > 0) {
    ascii += "Leverage Points:\n";
    for (const point of thought.leveragePoints) {
      ascii += `  \u2605 ${point.location} (effectiveness: ${point.effectiveness.toFixed(2)})
`;
      ascii += `    ${point.description}
`;
    }
  }
  return ascii;
}
function systemsThinkingToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width,
    svgHeight = DEFAULT_SVG_OPTIONS.height
  } = options;
  if (!thought.components || thought.components.length === 0) {
    return generateSVGHeader(svgWidth, 200, "Systems Thinking") + '\n  <text x="400" y="100" text-anchor="middle" class="subtitle">No system components defined</text>\n' + generateSVGFooter();
  }
  const positions = /* @__PURE__ */ new Map();
  const nodeWidth = 150;
  const nodeHeight = 40;
  const centerX = svgWidth / 2;
  const centerY = svgHeight / 2;
  const radius = Math.min(centerX, centerY) - 100;
  thought.components.forEach((component, index) => {
    const angle = 2 * Math.PI * index / (thought.components?.length || 1);
    const x = centerX + radius * Math.cos(angle - Math.PI / 2);
    const y = centerY + radius * Math.sin(angle - Math.PI / 2);
    positions.set(component.id, {
      id: component.id,
      label: includeLabels ? component.name : component.id,
      x,
      y,
      width: nodeWidth,
      height: nodeHeight,
      type: component.type
    });
  });
  let svg = generateSVGHeader(svgWidth, svgHeight, "Systems Thinking Model");
  svg += '\n  <!-- Feedback Loops -->\n  <g class="edges">';
  if (thought.feedbackLoops) {
    for (const loop of thought.feedbackLoops) {
      for (let i = 0; i < loop.components.length; i++) {
        const fromId = loop.components[i];
        const toId = loop.components[(i + 1) % loop.components.length];
        const fromPos = positions.get(fromId);
        const toPos = positions.get(toId);
        if (fromPos && toPos) {
          const label = includeMetrics ? `${loop.type[0].toUpperCase()} (${loop.strength.toFixed(1)})` : void 0;
          const style = loop.type === "reinforcing" ? "solid" : "dashed";
          svg += renderEdge(fromPos, toPos, { label, style });
        }
      }
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Components -->\n  <g class="nodes">';
  const stockColors = getNodeColor("primary", colorScheme);
  const flowColors = getNodeColor("secondary", colorScheme);
  for (const [, pos] of positions) {
    if (pos.type === "stock") {
      svg += renderRectNode(pos, stockColors);
    } else {
      svg += renderEllipseNode(pos, flowColors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Components", value: thought.components.length },
      { label: "Feedback Loops", value: thought.feedbackLoops?.length || 0 },
      { label: "Leverage Points", value: thought.leveragePoints?.length || 0 }
    ];
    svg += renderMetricsPanel(svgWidth - 180, svgHeight - 110, metrics);
  }
  const legendItems = [
    { label: "Stock", color: stockColors },
    { label: "Flow", color: flowColors, shape: "ellipse" }
  ];
  svg += renderLegend(20, svgHeight - 80, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function systemsThinkingToGraphML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  if (thought.components && thought.components.length > 0) {
    for (const component of thought.components) {
      nodes.push({
        id: sanitizeId(component.id),
        label: component.name,
        type: component.type,
        metadata: {
          description: component.description,
          unit: component.unit,
          initialValue: component.initialValue
        }
      });
    }
  }
  if (thought.feedbackLoops && thought.feedbackLoops.length > 0) {
    let edgeCount = 0;
    for (const loop of thought.feedbackLoops) {
      const loopComponents = loop.components;
      for (let i = 0; i < loopComponents.length; i++) {
        const fromId = sanitizeId(loopComponents[i]);
        const toId = sanitizeId(loopComponents[(i + 1) % loopComponents.length]);
        const label = includeLabels && includeMetrics ? `${loop.type} (${loop.strength.toFixed(2)})` : includeLabels ? loop.type : void 0;
        edges.push({
          id: `e${edgeCount++}`,
          source: fromId,
          target: toId,
          label,
          directed: true,
          metadata: {
            type: loop.type,
            weight: loop.strength,
            polarity: loop.polarity,
            loopName: loop.name
          }
        });
      }
    }
  }
  return generateGraphML(nodes, edges, {
    graphName: "Systems Thinking Causal Loops",
    directed: true,
    includeLabels,
    includeMetadata: includeMetrics
  });
}
function systemsThinkingToTikZ(thought, options) {
  const { colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  if (thought.components && thought.components.length > 0) {
    const numComponents = thought.components.length;
    const radius = 4;
    thought.components.forEach((component, index) => {
      const angle = 2 * Math.PI * index / numComponents;
      const x = 4 + radius * Math.cos(angle - Math.PI / 2);
      const y = -2 + radius * Math.sin(angle - Math.PI / 2);
      nodes.push({
        id: sanitizeId(component.id),
        label: component.name,
        x,
        y,
        type: component.type === "stock" ? "primary" : "secondary",
        shape: component.type === "stock" ? "rectangle" : "ellipse"
      });
    });
  }
  if (thought.feedbackLoops && thought.feedbackLoops.length > 0) {
    for (const loop of thought.feedbackLoops) {
      const loopComponents = loop.components;
      for (let i = 0; i < loopComponents.length; i++) {
        const fromId = sanitizeId(loopComponents[i]);
        const toId = sanitizeId(loopComponents[(i + 1) % loopComponents.length]);
        const label = includeLabels && includeMetrics ? `${loop.type[0].toUpperCase()} (${loop.strength.toFixed(2)})` : includeLabels ? loop.type[0].toUpperCase() : void 0;
        const style = loop.type === "reinforcing" ? "solid" : "dashed";
        const bend = loop.type === "reinforcing" ? "left" : "right";
        edges.push({
          source: fromId,
          target: toId,
          label,
          style,
          directed: true,
          bend
        });
      }
    }
  }
  return generateTikZ(nodes, edges, {
    title: "Systems Thinking Causal Loops",
    colorScheme,
    includeLabels,
    includeMetrics
  });
}
function systemsThinkingToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Systems Thinking Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  if (thought.system) {
    const systemContent = `
      <p><strong>Name:</strong> ${escapeHTML(thought.system.name)}</p>
      <p>${escapeHTML(thought.system.description)}</p>
    `;
    html += renderSection("System Overview", systemContent, "\u{1F50D}");
  }
  if (includeMetrics) {
    html += '<div class="metrics-grid">\n';
    html += renderMetricCard("Components", thought.components?.length || 0, "primary");
    html += renderMetricCard("Feedback Loops", thought.feedbackLoops?.length || 0, "info");
    html += renderMetricCard("Leverage Points", thought.leveragePoints?.length || 0, "success");
    html += "</div>\n";
  }
  if (thought.components && thought.components.length > 0) {
    const componentRows = thought.components.map((c) => [
      c.name,
      c.type,
      c.description,
      c.unit || "N/A",
      c.initialValue !== void 0 ? String(c.initialValue) : "N/A"
    ]);
    const componentsTable = renderTable(
      ["Name", "Type", "Description", "Unit", "Initial Value"],
      componentRows,
      { caption: "System Components" }
    );
    html += renderSection("Components", componentsTable, "\u{1F527}");
  }
  if (thought.feedbackLoops && thought.feedbackLoops.length > 0) {
    let loopsContent = "";
    for (const loop of thought.feedbackLoops) {
      const loopType = loop.type === "reinforcing" ? "success" : "warning";
      const badge = renderBadge(loop.type.toUpperCase(), loopType);
      loopsContent += `
        <div class="card">
          <div class="card-header">${escapeHTML(loop.name)} ${badge}</div>
          <p><strong>Polarity:</strong> ${escapeHTML(loop.polarity)}</p>
          <p><strong>Strength:</strong> ${loop.strength.toFixed(2)}</p>
          <p><strong>Components:</strong> ${loop.components.map((c) => escapeHTML(c)).join(" \u2192 ")}</p>
          ${loop.description ? `<p>${escapeHTML(loop.description)}</p>` : ""}
        </div>
      `;
    }
    html += renderSection("Feedback Loops", loopsContent, "\u{1F504}");
  }
  if (thought.leveragePoints && thought.leveragePoints.length > 0) {
    const leverageRows = thought.leveragePoints.map((lp) => [
      lp.location,
      lp.effectiveness.toFixed(2),
      lp.description
    ]);
    const leverageTable = renderTable(
      ["Location", "Effectiveness", "Description"],
      leverageRows,
      { caption: "Leverage Points" }
    );
    html += renderSection("Leverage Points", leverageTable, "\u2B50");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function systemsThinkingToModelica(thought, options) {
  const { includeMetrics = true } = options;
  const systemName = thought.system ? sanitizeModelicaId(thought.system.name) : "SystemsThinking";
  let modelica = `package ${systemName}
`;
  modelica += `  "${thought.system?.description || "Systems thinking model with feedback loops"}"

`;
  if (thought.components && thought.components.length > 0) {
    modelica += "  // System Components\n";
    for (const component of thought.components) {
      const compName = sanitizeModelicaId(component.name);
      const unit = component.unit ? escapeModelicaString(component.unit) : "";
      const initialValue = component.initialValue !== void 0 ? component.initialValue : 0;
      if (component.type === "stock") {
        modelica += `  model ${compName}
`;
        modelica += `    "${escapeModelicaString(component.description)}"
`;
        modelica += `    parameter Real initial_value = ${initialValue}${unit ? ` "${unit}"` : ""};
`;
        modelica += `    Real value(start=initial_value)${unit ? `(unit="${unit}")` : ""};
`;
        modelica += `    input Real inflow${unit ? `(unit="${unit}/s")` : ""};
`;
        modelica += `    input Real outflow${unit ? `(unit="${unit}/s")` : ""};
`;
        modelica += "  equation\n";
        modelica += "    der(value) = inflow - outflow;\n";
        modelica += "  end " + compName + ";\n\n";
      } else {
        modelica += `  model ${compName}
`;
        modelica += `    "${escapeModelicaString(component.description)}"
`;
        modelica += `    output Real flow_rate${unit ? `(unit="${unit}/s")` : ""};
`;
        modelica += `    input Real source_value${unit ? `(unit="${unit}")` : ""};
`;
        modelica += `    input Real sink_value${unit ? `(unit="${unit}")` : ""};
`;
        modelica += `    parameter Real coefficient = 1.0;
`;
        modelica += "  equation\n";
        modelica += "    flow_rate = coefficient * (source_value - sink_value);\n";
        modelica += "  end " + compName + ";\n\n";
      }
    }
  }
  if (thought.feedbackLoops && thought.feedbackLoops.length > 0) {
    modelica += "  // Feedback Loop Models\n";
    for (const loop of thought.feedbackLoops) {
      const loopName = sanitizeModelicaId(loop.name);
      const loopType = loop.type === "reinforcing" ? "Reinforcing" : "Balancing";
      modelica += `  model ${loopName}
`;
      modelica += `    "${loopType} feedback loop: ${escapeModelicaString(loop.description || loop.name)}"
`;
      if (includeMetrics) {
        modelica += `    // Strength: ${loop.strength.toFixed(3)}
`;
        modelica += `    // Polarity: ${loop.polarity}
`;
      }
      modelica += `    parameter Real strength = ${loop.strength.toFixed(3)};
`;
      modelica += `    parameter String loop_type = "${loop.type}";
`;
      const loopComponents = loop.components.map((c) => sanitizeModelicaId(c));
      modelica += `    // Components in loop: ${loopComponents.join(" \u2192 ")}
`;
      modelica += "  equation\n";
      modelica += `    // ${loopType} feedback loop dynamics
`;
      modelica += "    // Loop components interact with strength factor\n";
      modelica += "  end " + loopName + ";\n\n";
    }
  }
  modelica += `  model ${systemName}_Complete
`;
  modelica += `    "${thought.system?.description || "Complete systems thinking model"}"
`;
  if (includeMetrics && thought.leveragePoints && thought.leveragePoints.length > 0) {
    modelica += "\n    // Leverage Points:\n";
    for (const lp of thought.leveragePoints) {
      modelica += `    // - ${lp.location} (effectiveness: ${lp.effectiveness.toFixed(2)})
`;
      modelica += `    //   ${lp.description}
`;
    }
  }
  modelica += "\n    // Integrate component models and feedback loops here\n";
  modelica += "  end " + systemName + "_Complete;\n\n";
  modelica += "end " + systemName + ";\n";
  return modelica;
}
function systemsThinkingToUML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  if (thought.components && thought.components.length > 0) {
    for (const component of thought.components) {
      const attributes = [];
      if (component.unit) {
        attributes.push(`unit: ${component.unit}`);
      }
      if (component.initialValue !== void 0) {
        attributes.push(`initialValue: ${component.initialValue}`);
      }
      if (includeMetrics) {
        attributes.push(`type: ${component.type}`);
      }
      nodes.push({
        id: sanitizeId(component.id),
        label: component.name,
        shape: component.type === "stock" ? "class" : "component",
        stereotype: component.type,
        attributes
      });
    }
  }
  if (thought.feedbackLoops && thought.feedbackLoops.length > 0) {
    for (const loop of thought.feedbackLoops) {
      const loopComponents = loop.components;
      for (let i = 0; i < loopComponents.length; i++) {
        const fromId = sanitizeId(loopComponents[i]);
        const toId = sanitizeId(loopComponents[(i + 1) % loopComponents.length]);
        const label = includeLabels && includeMetrics ? `${loop.type} (${loop.strength.toFixed(2)})` : includeLabels ? loop.type : void 0;
        const edgeType = loop.type === "reinforcing" ? "association" : "dependency";
        edges.push({
          source: fromId,
          target: toId,
          type: edgeType,
          label
        });
      }
    }
  }
  return generateUmlDiagram(nodes, edges, {
    title: "Systems Thinking Causal Loop Diagram"});
}
function systemsThinkingToJSON(thought, options) {
  const { includeMetrics = true } = options;
  const graph = createJsonGraph("Systems Thinking Causal Loop Diagram", "systems-thinking", {
    includeMetrics
  });
  if (thought.system) {
    graph.metadata.systemName = thought.system.name;
    graph.metadata.systemDescription = thought.system.description;
  }
  if (thought.components && thought.components.length > 0) {
    for (const component of thought.components) {
      addNode(graph, {
        id: component.id,
        label: component.name,
        type: component.type,
        shape: component.type === "stock" ? "rectangle" : "ellipse",
        metadata: {
          description: component.description,
          unit: component.unit,
          initialValue: component.initialValue
        }
      });
    }
  }
  if (thought.feedbackLoops && thought.feedbackLoops.length > 0) {
    let edgeCount = 0;
    for (const loop of thought.feedbackLoops) {
      const loopComponents = loop.components;
      for (let i = 0; i < loopComponents.length; i++) {
        const fromId = loopComponents[i];
        const toId = loopComponents[(i + 1) % loopComponents.length];
        addEdge(graph, {
          id: `edge_${edgeCount++}`,
          source: fromId,
          target: toId,
          label: `${loop.type} (${loop.strength.toFixed(2)})`,
          type: loop.type,
          weight: loop.strength,
          style: loop.type === "reinforcing" ? "solid" : "dashed",
          directed: true,
          metadata: {
            loopName: loop.name,
            polarity: loop.polarity,
            description: loop.description
          }
        });
      }
    }
  }
  if (includeMetrics) {
    addMetric(graph, "components", thought.components?.length || 0);
    addMetric(graph, "feedbackLoops", thought.feedbackLoops?.length || 0);
    addMetric(graph, "leveragePoints", thought.leveragePoints?.length || 0);
    if (thought.feedbackLoops && thought.feedbackLoops.length > 0) {
      const avgStrength = thought.feedbackLoops.reduce((sum, loop) => sum + loop.strength, 0) / thought.feedbackLoops.length;
      addMetric(graph, "averageLoopStrength", parseFloat(avgStrength.toFixed(3)));
    }
    if (thought.feedbackLoops && thought.feedbackLoops.length > 0) {
      const reinforcingCount = thought.feedbackLoops.filter((l) => l.type === "reinforcing").length;
      const balancingCount = thought.feedbackLoops.filter((l) => l.type === "balancing").length;
      addMetric(graph, "reinforcingLoops", reinforcingCount);
      addMetric(graph, "balancingLoops", balancingCount);
    }
  }
  addLegendItem(graph, "stock", "#a8d5ff");
  addLegendItem(graph, "flow", "#ffd699");
  addLegendItem(graph, "reinforcing", "#90ee90", "solid");
  addLegendItem(graph, "balancing", "#ffb3ba", "dashed");
  if (thought.leveragePoints && thought.leveragePoints.length > 0) {
    graph.metadata.leveragePoints = thought.leveragePoints.map((lp) => ({
      location: lp.location,
      effectiveness: lp.effectiveness,
      description: lp.description
    }));
  }
  return serializeGraph(graph);
}
function systemsThinkingToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  if (thought.system) {
    const systemContent = keyValueSection({
      "Name": thought.system.name,
      "Description": thought.system.description
    });
    parts.push(section("System Overview", systemContent));
  }
  if (includeMetrics) {
    const metricsContent = keyValueSection({
      "Components": thought.components?.length || 0,
      "Feedback Loops": thought.feedbackLoops?.length || 0,
      "Leverage Points": thought.leveragePoints?.length || 0
    });
    parts.push(section("Metrics", metricsContent));
  }
  if (thought.components && thought.components.length > 0) {
    const componentRows = thought.components.map((c) => [
      c.name,
      c.type,
      c.description,
      c.unit || "N/A",
      c.initialValue !== void 0 ? String(c.initialValue) : "N/A"
    ]);
    const componentsTable = table(
      ["Name", "Type", "Description", "Unit", "Initial Value"],
      componentRows
    );
    parts.push(section("Components", componentsTable));
  }
  if (thought.feedbackLoops && thought.feedbackLoops.length > 0) {
    const loopItems = thought.feedbackLoops.map(
      (loop) => `**${loop.name}** (${loop.type})
  - Strength: ${loop.strength.toFixed(2)}
  - Polarity: ${loop.polarity}
  - Components: ${loop.components.join(" \u2192 ")}`
    );
    parts.push(section("Feedback Loops", list(loopItems)));
  }
  if (thought.leveragePoints && thought.leveragePoints.length > 0) {
    const leverageRows = thought.leveragePoints.map((lp) => [
      lp.location,
      lp.effectiveness.toFixed(2),
      lp.description
    ]);
    const leverageTable = table(
      ["Location", "Effectiveness", "Description"],
      leverageRows
    );
    parts.push(section("Leverage Points", leverageTable));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = systemsThinkingToMermaid(thought, "default", true, true);
    parts.push(section("Causal Loop Diagram", mermaidBlock(mermaidDiagram)));
  }
  return document("Systems Thinking Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: { mode: "systems-thinking" }
  });
}
var init_systems_thinking = __esm({
  "src/export/visual/modes/systems-thinking.ts"() {
    init_esm_shims();
    init_utils();
    init_svg();
    init_graphml();
    init_tikz();
    init_html();
    init_modelica();
    init_uml();
    init_json();
    init_markdown();
  }
});

// src/export/visual/modes/scientific-method.ts
function exportScientificMethodExperiment(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return scientificMethodToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return scientificMethodToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return scientificMethodToASCII(thought);
    case "svg":
      return scientificMethodToSVG(thought, options);
    case "graphml":
      return scientificMethodToGraphML(thought, options);
    case "tikz":
      return scientificMethodToTikZ(thought, options);
    case "html":
      return scientificMethodToHTML(thought, options);
    case "modelica":
      return scientificMethodToModelica(thought, options);
    case "uml":
      return scientificMethodToUML(thought, options);
    case "json":
      return scientificMethodToJSON(thought, options);
    case "markdown":
      return scientificMethodToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function scientificMethodToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TD\n";
  if (thought.researchQuestion) {
    mermaid += `  RQ["Research Question: ${thought.researchQuestion.question.substring(0, 60)}..."]
`;
    mermaid += "\n";
  }
  if (thought.scientificHypotheses && thought.scientificHypotheses.length > 0) {
    for (const hypothesis of thought.scientificHypotheses) {
      const hypId = sanitizeId(hypothesis.id);
      const label = includeLabels ? hypothesis.statement.substring(0, 50) + "..." : hypId;
      mermaid += `  ${hypId}["H: ${label}"]
`;
      if (thought.researchQuestion) {
        mermaid += `  RQ --> ${hypId}
`;
      }
    }
    mermaid += "\n";
  }
  if (thought.experiment) {
    mermaid += `  Exp["Experiment: ${thought.experiment.design}"]
`;
    if (thought.scientificHypotheses && thought.scientificHypotheses.length > 0) {
      for (const hypothesis of thought.scientificHypotheses) {
        const hypId = sanitizeId(hypothesis.id);
        mermaid += `  ${hypId} --> Exp
`;
      }
    }
    mermaid += "\n";
  }
  if (thought.data) {
    mermaid += `  Data["Data Collection: ${thought.experiment?.sampleSize || 0} samples"]
`;
    if (thought.experiment) {
      mermaid += `  Exp --> Data
`;
    }
    mermaid += "\n";
  }
  if (thought.analysis) {
    mermaid += `  Stats["Statistical Analysis"]
`;
    if (thought.data) {
      mermaid += `  Data --> Stats
`;
    }
    mermaid += "\n";
  }
  if (thought.conclusion) {
    const conclusionId = "Conclusion";
    const supportLabel = includeMetrics && thought.conclusion.confidence ? ` (conf: ${thought.conclusion.confidence.toFixed(2)})` : "";
    mermaid += `  ${conclusionId}["Conclusion: ${thought.conclusion.statement.substring(0, 50)}...${supportLabel}"]
`;
    if (thought.analysis) {
      mermaid += `  Stats --> ${conclusionId}
`;
    }
  }
  if (colorScheme !== "monochrome") {
    mermaid += "\n";
    const questionColor = colorScheme === "pastel" ? "#fff3e0" : "#ffd699";
    const hypothesisColor = colorScheme === "pastel" ? "#e1f5ff" : "#a8d5ff";
    const conclusionColor = colorScheme === "pastel" ? "#e8f5e9" : "#a5d6a7";
    if (thought.researchQuestion) {
      mermaid += `  style RQ fill:${questionColor}
`;
    }
    if (thought.scientificHypotheses) {
      for (const hypothesis of thought.scientificHypotheses) {
        const hypId = sanitizeId(hypothesis.id);
        mermaid += `  style ${hypId} fill:${hypothesisColor}
`;
      }
    }
    if (thought.conclusion) {
      mermaid += `  style Conclusion fill:${conclusionColor}
`;
    }
  }
  return mermaid;
}
function scientificMethodToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph ScientificMethod {\n";
  dot += "  rankdir=TD;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  if (thought.researchQuestion) {
    const label = includeLabels ? thought.researchQuestion.question.substring(0, 60) + "..." : "RQ";
    dot += `  RQ [label="Research Question:\\n${label}", shape=ellipse];

`;
  }
  if (thought.scientificHypotheses && thought.scientificHypotheses.length > 0) {
    for (const hypothesis of thought.scientificHypotheses) {
      const hypId = sanitizeId(hypothesis.id);
      const label = includeLabels ? hypothesis.statement.substring(0, 50) + "..." : hypId;
      dot += `  ${hypId} [label="Hypothesis:\\n${label}"];
`;
      if (thought.researchQuestion) {
        dot += `  RQ -> ${hypId};
`;
      }
    }
    dot += "\n";
  }
  if (thought.experiment) {
    const label = includeLabels ? thought.experiment.design : "Exp";
    dot += `  Exp [label="Experiment:\\n${label}"];
`;
    if (thought.scientificHypotheses) {
      for (const hypothesis of thought.scientificHypotheses) {
        const hypId = sanitizeId(hypothesis.id);
        dot += `  ${hypId} -> Exp;
`;
      }
    }
    dot += "\n";
  }
  if (thought.data) {
    const sampleLabel = includeMetrics ? `\\nSamples: ${thought.experiment?.sampleSize || 0}` : "";
    dot += `  Data [label="Data Collection${sampleLabel}"];
`;
    if (thought.experiment) {
      dot += `  Exp -> Data;
`;
    }
  }
  if (thought.analysis) {
    dot += `  Stats [label="Statistical Analysis"];
`;
    if (thought.data) {
      dot += `  Data -> Stats;
`;
    }
  }
  if (thought.conclusion) {
    const label = includeLabels ? thought.conclusion.statement.substring(0, 50) + "..." : "Conclusion";
    const confLabel = includeMetrics && thought.conclusion.confidence ? `\\nconf: ${thought.conclusion.confidence.toFixed(2)}` : "";
    dot += `  Conclusion [label="Conclusion:\\n${label}${confLabel}", shape=doubleoctagon];
`;
    if (thought.analysis) {
      dot += `  Stats -> Conclusion;
`;
    }
  }
  dot += "}\n";
  return dot;
}
function scientificMethodToASCII(thought) {
  let ascii = "Scientific Method Process:\n";
  ascii += "==========================\n\n";
  if (thought.researchQuestion) {
    ascii += `Research Question: ${thought.researchQuestion.question}
`;
    ascii += `Background: ${thought.researchQuestion.background}

`;
  }
  if (thought.scientificHypotheses && thought.scientificHypotheses.length > 0) {
    ascii += "Hypotheses:\n";
    for (const hypothesis of thought.scientificHypotheses) {
      const typeIcon = hypothesis.type === "null" ? "H\u2080" : "H\u2081";
      ascii += `  ${typeIcon} ${hypothesis.statement}
`;
      if (hypothesis.prediction) {
        ascii += `    Prediction: ${hypothesis.prediction}
`;
      }
    }
    ascii += "\n";
  }
  if (thought.experiment) {
    ascii += `Experiment: ${thought.experiment.design}
`;
    ascii += `Type: ${thought.experiment.type}
`;
    ascii += `Design: ${thought.experiment.design}

`;
  }
  if (thought.data) {
    ascii += "Data Collection:\n";
    ascii += `  Sample Size: ${thought.experiment?.sampleSize || 0}
`;
    ascii += `  Method: ${thought.data.method}
`;
    if (thought.data.dataQuality) {
      ascii += `  Quality:
`;
      ascii += `    Completeness: ${thought.data.dataQuality.completeness.toFixed(2)}
`;
      ascii += `    Reliability: ${thought.data.dataQuality.reliability.toFixed(2)}
`;
    }
    ascii += "\n";
  }
  if (thought.analysis && thought.analysis.tests) {
    ascii += "Statistical Tests:\n";
    for (const test of thought.analysis.tests) {
      ascii += `  \u2022 ${test.name}
`;
      ascii += `    p-value: ${test.pValue.toFixed(4)}, \u03B1: ${test.alpha}
`;
      ascii += `    Result: ${test.result}
`;
    }
    ascii += "\n";
  }
  if (thought.conclusion) {
    ascii += "Conclusion:\n";
    ascii += `${thought.conclusion.statement}
`;
    if (thought.conclusion.supportedHypotheses) {
      ascii += `Supported hypotheses: ${thought.conclusion.supportedHypotheses.join(", ")}
`;
    }
    if (thought.conclusion.confidence) {
      ascii += `Confidence: ${thought.conclusion.confidence.toFixed(2)}
`;
    }
  }
  return ascii;
}
function scientificMethodToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width
  } = options;
  const positions = /* @__PURE__ */ new Map();
  const nodeWidth = 150;
  const nodeHeight = 40;
  const nodeSpacing = 120;
  let currentY = 80;
  if (thought.researchQuestion) {
    positions.set("RQ", {
      id: "RQ",
      label: includeLabels ? `RQ: ${thought.researchQuestion.question.substring(0, 40)}...` : "Research Question",
      x: svgWidth / 2,
      y: currentY,
      width: nodeWidth,
      height: nodeHeight,
      type: "question"
    });
    currentY += nodeSpacing;
  }
  if (thought.scientificHypotheses && thought.scientificHypotheses.length > 0) {
    thought.scientificHypotheses.forEach((hypothesis) => {
      positions.set(hypothesis.id, {
        id: hypothesis.id,
        label: includeLabels ? `H: ${hypothesis.statement.substring(0, 30)}...` : hypothesis.id,
        x: svgWidth / 2,
        y: currentY,
        width: nodeWidth,
        height: nodeHeight,
        type: "hypothesis"
      });
      currentY += nodeSpacing;
    });
  }
  if (thought.experiment) {
    positions.set("Exp", {
      id: "Exp",
      label: "Experiment",
      x: svgWidth / 2,
      y: currentY,
      width: nodeWidth,
      height: nodeHeight,
      type: "experiment"
    });
    currentY += nodeSpacing;
  }
  if (thought.data) {
    positions.set("Data", {
      id: "Data",
      label: "Data Collection",
      x: svgWidth / 2,
      y: currentY,
      width: nodeWidth,
      height: nodeHeight,
      type: "data"
    });
    currentY += nodeSpacing;
  }
  if (thought.analysis) {
    positions.set("Stats", {
      id: "Stats",
      label: "Statistical Analysis",
      x: svgWidth / 2,
      y: currentY,
      width: nodeWidth,
      height: nodeHeight,
      type: "analysis"
    });
    currentY += nodeSpacing;
  }
  if (thought.conclusion) {
    positions.set("Conclusion", {
      id: "Conclusion",
      label: includeLabels ? `Conclusion: ${thought.conclusion.statement.substring(0, 30)}...` : "Conclusion",
      x: svgWidth / 2,
      y: currentY,
      width: nodeWidth,
      height: nodeHeight,
      type: "conclusion"
    });
  }
  const actualHeight = Math.max(DEFAULT_SVG_OPTIONS.height, currentY + 100);
  let svg = generateSVGHeader(svgWidth, actualHeight, "Scientific Method Process");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  const nodeIds = ["RQ", ...thought.scientificHypotheses?.map((h) => h.id) || [], "Exp", "Data", "Stats", "Conclusion"];
  for (let i = 0; i < nodeIds.length - 1; i++) {
    const fromPos = positions.get(nodeIds[i]);
    const toPos = positions.get(nodeIds[i + 1]);
    if (fromPos && toPos) {
      svg += renderEdge(fromPos, toPos);
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  const questionColors = getNodeColor("tertiary", colorScheme);
  const hypothesisColors = getNodeColor("primary", colorScheme);
  const conclusionColors = getNodeColor("success", colorScheme);
  const neutralColors = getNodeColor("neutral", colorScheme);
  for (const [, pos] of positions) {
    if (pos.type === "question") {
      svg += renderEllipseNode(pos, questionColors);
    } else if (pos.type === "hypothesis") {
      svg += renderRectNode(pos, hypothesisColors);
    } else if (pos.type === "conclusion") {
      svg += renderStadiumNode(pos, conclusionColors);
    } else {
      svg += renderRectNode(pos, neutralColors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Hypotheses", value: thought.scientificHypotheses?.length || 0 },
      { label: "Confidence", value: thought.conclusion?.confidence?.toFixed(2) || "N/A" }
    ];
    svg += renderMetricsPanel(svgWidth - 180, actualHeight - 110, metrics);
  }
  const legendItems = [
    { label: "Research Question", color: questionColors, shape: "ellipse" },
    { label: "Hypothesis", color: hypothesisColors },
    { label: "Conclusion", color: conclusionColors, shape: "stadium" }
  ];
  svg += renderLegend(20, actualHeight - 110, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function scientificMethodToGraphML(thought, options) {
  const { includeLabels = true } = options;
  const nodes = [];
  const edges = [];
  let edgeIndex = 0;
  const stages2 = [];
  if (thought.researchQuestion) {
    stages2.push({
      id: "RQ",
      label: includeLabels ? `Research Question: ${thought.researchQuestion.question.substring(0, 60)}...` : "Research Question",
      type: "question",
      exists: true
    });
  }
  if (thought.scientificHypotheses && thought.scientificHypotheses.length > 0) {
    const hypLabel = includeLabels ? `Hypothesis: ${thought.scientificHypotheses[0].statement.substring(0, 60)}...` : "Hypothesis";
    stages2.push({
      id: "Hypothesis",
      label: hypLabel,
      type: "hypothesis",
      exists: true
    });
  }
  if (thought.experiment) {
    stages2.push({
      id: "Experiment",
      label: includeLabels ? `Experiment: ${thought.experiment.design}` : "Experiment",
      type: "experiment",
      exists: true
    });
  }
  if (thought.data) {
    const sampleSize = thought.experiment?.sampleSize || 0;
    stages2.push({
      id: "Data",
      label: includeLabels ? `Data Collection: ${sampleSize} samples` : "Data Collection",
      type: "data",
      exists: true
    });
  }
  if (thought.analysis) {
    stages2.push({
      id: "Analysis",
      label: "Statistical Analysis",
      type: "analysis",
      exists: true
    });
  }
  if (thought.conclusion) {
    const confLabel = thought.conclusion.confidence ? ` (confidence: ${thought.conclusion.confidence.toFixed(2)})` : "";
    stages2.push({
      id: "Conclusion",
      label: includeLabels ? `Conclusion: ${thought.conclusion.statement.substring(0, 60)}...${confLabel}` : "Conclusion",
      type: "conclusion",
      exists: true
    });
  }
  for (const stage of stages2) {
    nodes.push({
      id: stage.id,
      label: stage.label,
      type: stage.type
    });
  }
  for (let i = 0; i < stages2.length - 1; i++) {
    edges.push({
      id: `e${edgeIndex++}`,
      source: stages2[i].id,
      target: stages2[i + 1].id,
      directed: true
    });
  }
  return generateGraphML(nodes, edges, {
    graphName: "Scientific Method Experiment",
    directed: true,
    includeLabels
  });
}
function scientificMethodToTikZ(thought, options) {
  const { includeLabels = true, colorScheme = "default" } = options;
  const nodes = [];
  const edges = [];
  let xPosition = 0;
  const xSpacing = 3;
  const stages2 = [];
  if (thought.researchQuestion) {
    stages2.push({
      id: "RQ",
      label: includeLabels ? "Research\nQuestion" : "RQ",
      type: "tertiary",
      shape: "ellipse"
    });
  }
  if (thought.scientificHypotheses && thought.scientificHypotheses.length > 0) {
    stages2.push({
      id: "Hypothesis",
      label: includeLabels ? `Hypothesis
(${thought.scientificHypotheses.length})` : "H",
      type: "info",
      shape: "rectangle"
    });
  }
  if (thought.experiment) {
    stages2.push({
      id: "Experiment",
      label: "Experiment",
      type: "neutral",
      shape: "rectangle"
    });
  }
  if (thought.data) {
    stages2.push({
      id: "Data",
      label: "Data\nCollection",
      type: "neutral",
      shape: "rectangle"
    });
  }
  if (thought.analysis) {
    stages2.push({
      id: "Analysis",
      label: "Statistical\nAnalysis",
      type: "primary",
      shape: "rectangle"
    });
  }
  if (thought.conclusion) {
    stages2.push({
      id: "Conclusion",
      label: "Conclusion",
      type: "success",
      shape: "stadium"
    });
  }
  for (const stage of stages2) {
    nodes.push({
      id: stage.id,
      label: stage.label,
      x: xPosition,
      y: 0,
      type: stage.type,
      shape: stage.shape || "rectangle"
    });
    xPosition += xSpacing;
  }
  for (let i = 0; i < stages2.length - 1; i++) {
    edges.push({
      source: stages2[i].id,
      target: stages2[i + 1].id,
      directed: true
    });
  }
  return generateTikZ(nodes, edges, {
    title: "Scientific Method Experiment",
    colorScheme,
    includeLabels
  });
}
function scientificMethodToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Scientific Method Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  if (thought.researchQuestion) {
    const questionContent = `
      <p><strong>Question:</strong> ${escapeHTML(thought.researchQuestion.question)}</p>
      <p><strong>Background:</strong> ${escapeHTML(thought.researchQuestion.background)}</p>
      ${thought.researchQuestion.significance ? `<p><strong>Significance:</strong> ${escapeHTML(thought.researchQuestion.significance)}</p>` : ""}
    `;
    html += renderSection("Research Question", questionContent, "\u2753");
  }
  if (includeMetrics) {
    html += '<div class="metrics-grid">\n';
    html += renderMetricCard("Hypotheses", thought.scientificHypotheses?.length || 0, "primary");
    html += renderMetricCard("Tests", thought.analysis?.tests?.length || 0, "info");
    html += renderMetricCard("Confidence", thought.conclusion?.confidence?.toFixed(2) || "N/A", "success");
    html += "</div>\n";
  }
  if (thought.scientificHypotheses && thought.scientificHypotheses.length > 0) {
    let hypothesesContent = "";
    for (const hypothesis of thought.scientificHypotheses) {
      const typeColor = hypothesis.type === "null" ? "secondary" : "primary";
      const badge = renderBadge(hypothesis.type.toUpperCase(), typeColor);
      hypothesesContent += `
        <div class="card">
          <div class="card-header">${badge} ${escapeHTML(hypothesis.statement)}</div>
          ${hypothesis.prediction ? `<p><strong>Prediction:</strong> ${escapeHTML(hypothesis.prediction)}</p>` : ""}
          ${hypothesis.rationale ? `<p><strong>Rationale:</strong> ${escapeHTML(hypothesis.rationale)}</p>` : ""}
        </div>
      `;
    }
    html += renderSection("Hypotheses", hypothesesContent, "\u{1F4A1}");
  }
  if (thought.experiment) {
    const experimentContent = `
      <p><strong>Type:</strong> ${escapeHTML(thought.experiment.type)}</p>
      <p><strong>Design:</strong> ${escapeHTML(thought.experiment.design)}</p>
      ${thought.experiment.sampleSize ? `<p><strong>Sample Size:</strong> ${thought.experiment.sampleSize}</p>` : ""}
    `;
    html += renderSection("Experiment", experimentContent, "\u{1F52C}");
  }
  if (thought.data) {
    const dataContent = `
      <p><strong>Method:</strong> ${escapeHTML(thought.data.method.join(", "))}</p>
      ${thought.data.dataQuality ? `
        <p><strong>Quality Metrics:</strong></p>
        <ul>
          <li>Completeness: ${(thought.data.dataQuality.completeness * 100).toFixed(0)}%</li>
          <li>Reliability: ${(thought.data.dataQuality.reliability * 100).toFixed(0)}%</li>
        </ul>
      ` : ""}
    `;
    html += renderSection("Data Collection", dataContent, "\u{1F4CA}");
  }
  if (thought.analysis && thought.analysis.tests) {
    const testRows = thought.analysis.tests.map((test) => [
      test.name,
      test.pValue.toFixed(4),
      test.alpha.toString(),
      test.result
    ]);
    const testsTable = renderTable(
      ["Test", "p-value", "\u03B1", "Result"],
      testRows,
      { caption: "Statistical Tests" }
    );
    html += renderSection("Statistical Analysis", testsTable, "\u{1F4C8}");
  }
  if (thought.conclusion) {
    const conclusionBadge = thought.conclusion.confidence && thought.conclusion.confidence > 0.8 ? renderBadge("HIGH CONFIDENCE", "success") : thought.conclusion.confidence && thought.conclusion.confidence > 0.5 ? renderBadge("MODERATE CONFIDENCE", "warning") : renderBadge("LOW CONFIDENCE", "danger");
    const conclusionContent = `
      <p>${conclusionBadge}</p>
      <p>${escapeHTML(thought.conclusion.statement)}</p>
      ${thought.conclusion.confidence ? `<p><strong>Confidence:</strong> ${(thought.conclusion.confidence * 100).toFixed(0)}%</p>` : ""}
      ${thought.conclusion.supportedHypotheses ? `<p><strong>Supported Hypotheses:</strong> ${thought.conclusion.supportedHypotheses.join(", ")}</p>` : ""}
    `;
    html += renderSection("Conclusion", conclusionContent, "\u2705");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function scientificMethodToModelica(thought, options) {
  const { includeMetrics = true } = options;
  const lines = [];
  lines.push("package ScientificMethodExperiment");
  lines.push('  "Scientific method experiment modeling package"');
  lines.push("");
  const stages2 = [];
  if (thought.researchQuestion) stages2.push("ResearchQuestion");
  if (thought.scientificHypotheses && thought.scientificHypotheses.length > 0) stages2.push("Hypothesis");
  if (thought.experiment) stages2.push("Experiment");
  if (thought.data) stages2.push("DataCollection");
  if (thought.analysis) stages2.push("Analysis");
  if (thought.conclusion) stages2.push("Conclusion");
  if (stages2.length > 0) {
    lines.push("  type Stage = enumeration(");
    for (let i = 0; i < stages2.length; i++) {
      const comma = i < stages2.length - 1 ? "," : "";
      lines.push(`    ${stages2[i]} "${stages2[i]}"${comma}`);
    }
    lines.push("  );");
    lines.push("");
  }
  if (thought.researchQuestion) {
    lines.push("  record ResearchQuestionData");
    lines.push('    "Research question information"');
    lines.push(`    parameter String question = "${escapeModelicaString(thought.researchQuestion.question)}";`);
    lines.push(`    parameter String background = "${escapeModelicaString(thought.researchQuestion.background)}";`);
    if (thought.researchQuestion.significance) {
      lines.push(`    parameter String significance = "${escapeModelicaString(thought.researchQuestion.significance)}";`);
    }
    lines.push("  end ResearchQuestionData;");
    lines.push("");
  }
  if (thought.scientificHypotheses && thought.scientificHypotheses.length > 0) {
    lines.push("  record HypothesisData");
    lines.push('    "Hypothesis information"');
    lines.push(`    parameter Integer count = ${thought.scientificHypotheses.length};`);
    lines.push(`    parameter String primaryHypothesis = "${escapeModelicaString(thought.scientificHypotheses[0].statement)}";`);
    lines.push(`    parameter String hypothesisType = "${thought.scientificHypotheses[0].type}";`);
    lines.push("  end HypothesisData;");
    lines.push("");
  }
  if (thought.experiment) {
    lines.push("  record ExperimentData");
    lines.push('    "Experiment design information"');
    lines.push(`    parameter String experimentType = "${escapeModelicaString(thought.experiment.type)}";`);
    lines.push(`    parameter String design = "${escapeModelicaString(thought.experiment.design)}";`);
    const sampleSize = thought.experiment?.sampleSize || 0;
    if (sampleSize > 0) {
      lines.push(`    parameter Integer sampleSize = ${sampleSize};`);
    }
    lines.push("  end ExperimentData;");
    lines.push("");
  }
  if (thought.data) {
    lines.push("  record DataCollectionInfo");
    lines.push('    "Data collection and quality metrics"');
    lines.push(`    parameter String method = "${escapeModelicaString(thought.data.method.join(", "))}";`);
    if (thought.data.dataQuality) {
      lines.push(`    parameter Real completeness = ${thought.data.dataQuality.completeness.toFixed(3)};`);
      lines.push(`    parameter Real reliability = ${thought.data.dataQuality.reliability.toFixed(3)};`);
    }
    lines.push("  end DataCollectionInfo;");
    lines.push("");
  }
  if (thought.analysis && thought.analysis.tests) {
    lines.push("  record AnalysisData");
    lines.push('    "Statistical analysis results"');
    lines.push(`    parameter Integer testCount = ${thought.analysis.tests.length};`);
    if (thought.analysis.tests.length > 0) {
      lines.push(`    parameter String primaryTest = "${escapeModelicaString(thought.analysis.tests[0].name)}";`);
      lines.push(`    parameter Real primaryPValue = ${thought.analysis.tests[0].pValue.toFixed(4)};`);
    }
    lines.push("  end AnalysisData;");
    lines.push("");
  }
  if (thought.conclusion) {
    lines.push("  record ConclusionData");
    lines.push('    "Final conclusion and confidence"');
    lines.push(`    parameter String statement = "${escapeModelicaString(thought.conclusion.statement)}";`);
    if (thought.conclusion.confidence) {
      lines.push(`    parameter Real confidence = ${thought.conclusion.confidence.toFixed(3)};`);
    }
    lines.push("  end ConclusionData;");
    lines.push("");
  }
  if (includeMetrics && stages2.length > 0) {
    const currentStageIndex = stages2.length;
    lines.push("  // Progress metrics");
    lines.push(`  parameter Integer totalStages = ${stages2.length};`);
    lines.push(`  parameter Integer completedStages = ${currentStageIndex};`);
    lines.push(`  parameter Real progress = ${(currentStageIndex / stages2.length).toFixed(3)};`);
    lines.push("");
  }
  lines.push("  annotation(");
  lines.push('    Documentation(info="<html>');
  lines.push("      <p>Scientific Method Experiment Flow</p>");
  if (includeMetrics) {
    lines.push(`      <p>Stages: ${stages2.length}</p>`);
    if (thought.scientificHypotheses) {
      lines.push(`      <p>Hypotheses: ${thought.scientificHypotheses.length}</p>`);
    }
    if (thought.conclusion?.confidence) {
      lines.push(`      <p>Confidence: ${(thought.conclusion.confidence * 100).toFixed(0)}%</p>`);
    }
  }
  lines.push("      <p>Generated by DeepThinking MCP v7.1.0</p>");
  lines.push('    </html>"),');
  lines.push('    version="1.0.0"');
  lines.push("  );");
  lines.push("end ScientificMethodExperiment;");
  return lines.join("\n");
}
function scientificMethodToUML(thought, options) {
  const { includeLabels = true } = options;
  const activities = [];
  if (thought.researchQuestion) {
    const label = includeLabels ? `Research Question: ${thought.researchQuestion.question.substring(0, 40)}...` : "Research Question";
    activities.push(label);
  }
  if (thought.scientificHypotheses && thought.scientificHypotheses.length > 0) {
    const label = includeLabels ? `Hypotheses (${thought.scientificHypotheses.length})` : "Hypotheses";
    activities.push(label);
  }
  if (thought.experiment) {
    const label = includeLabels ? `Experiment: ${thought.experiment.design.substring(0, 40)}` : "Experiment";
    activities.push(label);
  }
  if (thought.data) {
    activities.push("Data Collection");
  }
  if (thought.analysis) {
    const label = includeLabels && thought.analysis.tests ? `Statistical Analysis (${thought.analysis.tests.length} tests)` : "Statistical Analysis";
    activities.push(label);
  }
  if (thought.conclusion) {
    const label = includeLabels ? `Conclusion: ${thought.conclusion.statement.substring(0, 40)}...` : "Conclusion";
    activities.push(label);
  }
  const currentActivity = thought.conclusion ? activities[activities.length - 1] : void 0;
  return generateActivityDiagram(activities, currentActivity, {
    title: "Scientific Method Experiment Flow",
    includeLabels
  });
}
function scientificMethodToJSON(thought, options) {
  const { includeMetrics = true } = options;
  const graph = createJsonGraph("Scientific Method Experiment", "scientific-method", options);
  if (graph.layout) {
    graph.layout.type = "linear";
    graph.layout.direction = "TB";
  }
  let yPosition = 0;
  const ySpacing = 100;
  let edgeId = 0;
  const nodeIds = [];
  if (thought.researchQuestion) {
    addNode(graph, {
      id: "research_question",
      label: thought.researchQuestion.question.substring(0, 60) + "...",
      type: "question",
      y: yPosition,
      x: 200,
      color: "#ffd699",
      shape: "ellipse",
      metadata: {
        question: thought.researchQuestion.question,
        background: thought.researchQuestion.background,
        significance: thought.researchQuestion.significance
      }
    });
    nodeIds.push("research_question");
    yPosition += ySpacing;
  }
  if (thought.scientificHypotheses && thought.scientificHypotheses.length > 0) {
    addNode(graph, {
      id: "hypotheses",
      label: `Hypotheses (${thought.scientificHypotheses.length})`,
      type: "hypothesis",
      y: yPosition,
      x: 200,
      color: "#a8d5ff",
      shape: "rectangle",
      metadata: {
        count: thought.scientificHypotheses.length,
        hypotheses: thought.scientificHypotheses.map((h) => ({
          id: h.id,
          statement: h.statement,
          type: h.type
        }))
      }
    });
    nodeIds.push("hypotheses");
    yPosition += ySpacing;
  }
  if (thought.experiment) {
    addNode(graph, {
      id: "experiment",
      label: `Experiment: ${thought.experiment.design.substring(0, 30)}...`,
      type: "experiment",
      y: yPosition,
      x: 200,
      color: "#e0e0e0",
      shape: "rectangle",
      metadata: {
        type: thought.experiment.type,
        design: thought.experiment.design,
        sampleSize: thought.experiment?.sampleSize
      }
    });
    nodeIds.push("experiment");
    yPosition += ySpacing;
  }
  if (thought.data) {
    addNode(graph, {
      id: "data_collection",
      label: "Data Collection",
      type: "data",
      y: yPosition,
      x: 200,
      color: "#e0e0e0",
      shape: "rectangle",
      metadata: {
        method: thought.data.method,
        dataQuality: thought.data.dataQuality
      }
    });
    nodeIds.push("data_collection");
    yPosition += ySpacing;
  }
  if (thought.analysis) {
    const testCount = thought.analysis.tests?.length || 0;
    addNode(graph, {
      id: "analysis",
      label: `Statistical Analysis (${testCount} tests)`,
      type: "analysis",
      y: yPosition,
      x: 200,
      color: "#e0e0e0",
      shape: "rectangle",
      metadata: {
        testCount,
        tests: thought.analysis.tests
      }
    });
    nodeIds.push("analysis");
    yPosition += ySpacing;
  }
  if (thought.conclusion) {
    addNode(graph, {
      id: "conclusion",
      label: `Conclusion: ${thought.conclusion.statement.substring(0, 40)}...`,
      type: "conclusion",
      y: yPosition,
      x: 200,
      color: "#a5d6a7",
      shape: "stadium",
      metadata: {
        statement: thought.conclusion.statement,
        confidence: thought.conclusion.confidence,
        supportedHypotheses: thought.conclusion.supportedHypotheses
      }
    });
    nodeIds.push("conclusion");
  }
  for (let i = 0; i < nodeIds.length - 1; i++) {
    addEdge(graph, {
      id: `edge_${edgeId++}`,
      source: nodeIds[i],
      target: nodeIds[i + 1],
      directed: true,
      style: "solid"
    });
  }
  if (includeMetrics && graph.metrics) {
    addMetric(graph, "totalStages", nodeIds.length);
    addMetric(graph, "completedStages", nodeIds.length);
    addMetric(graph, "progress", 1);
    addMetric(graph, "hypothesisCount", thought.scientificHypotheses?.length || 0);
    if (thought.conclusion?.confidence) {
      addMetric(graph, "confidence", thought.conclusion.confidence);
    }
    if (thought.analysis?.tests) {
      addMetric(graph, "testCount", thought.analysis.tests.length);
    }
  }
  return serializeGraph(graph, options);
}
function scientificMethodToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  if (thought.researchQuestion) {
    const questionContent = keyValueSection({
      "Question": thought.researchQuestion.question,
      "Background": thought.researchQuestion.background,
      "Significance": thought.researchQuestion.significance || "N/A"
    });
    parts.push(section("Research Question", questionContent));
  }
  if (includeMetrics) {
    const metricsContent = keyValueSection({
      "Hypotheses": thought.scientificHypotheses?.length || 0,
      "Tests": thought.analysis?.tests?.length || 0,
      "Confidence": thought.conclusion?.confidence?.toFixed(2) || "N/A"
    });
    parts.push(section("Metrics", metricsContent));
  }
  if (thought.scientificHypotheses && thought.scientificHypotheses.length > 0) {
    const hypothesisItems = thought.scientificHypotheses.map(
      (h) => `**${h.type === "null" ? "H\u2080" : "H\u2081"}**: ${h.statement}${h.prediction ? `
  - Prediction: ${h.prediction}` : ""}`
    );
    parts.push(section("Hypotheses", list(hypothesisItems)));
  }
  if (thought.experiment) {
    const experimentContent = keyValueSection({
      "Type": thought.experiment.type,
      "Design": thought.experiment.design,
      "Sample Size": thought.experiment?.sampleSize || "N/A"
    });
    parts.push(section("Experiment", experimentContent));
  }
  if (thought.data) {
    const dataContent = keyValueSection({
      "Method": thought.data.method.join(", "),
      "Completeness": thought.data.dataQuality ? `${(thought.data.dataQuality.completeness * 100).toFixed(0)}%` : "N/A",
      "Reliability": thought.data.dataQuality ? `${(thought.data.dataQuality.reliability * 100).toFixed(0)}%` : "N/A"
    });
    parts.push(section("Data Collection", dataContent));
  }
  if (thought.analysis && thought.analysis.tests) {
    const testRows = thought.analysis.tests.map((test) => [
      test.name,
      test.pValue.toFixed(4),
      test.alpha.toString(),
      test.result
    ]);
    const testsTable = table(
      ["Test", "p-value", "\u03B1", "Result"],
      testRows
    );
    parts.push(section("Statistical Analysis", testsTable));
  }
  if (thought.conclusion) {
    const conclusionContent = `${thought.conclusion.statement}

` + keyValueSection({
      "Confidence": thought.conclusion.confidence ? `${(thought.conclusion.confidence * 100).toFixed(0)}%` : "N/A",
      "Supported Hypotheses": thought.conclusion.supportedHypotheses?.join(", ") || "N/A"
    });
    parts.push(section("Conclusion", conclusionContent));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = scientificMethodToMermaid(thought, "default", true, true);
    parts.push(section("Experiment Flow Diagram", mermaidBlock(mermaidDiagram)));
  }
  return document("Scientific Method Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: { mode: "scientific-method" }
  });
}
var init_scientific_method = __esm({
  "src/export/visual/modes/scientific-method.ts"() {
    init_esm_shims();
    init_utils();
    init_svg();
    init_graphml();
    init_tikz();
    init_html();
    init_modelica();
    init_uml();
    init_json();
    init_markdown();
  }
});

// src/export/visual/modes/formal-logic.ts
function exportFormalLogicProof(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return formalLogicToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return formalLogicToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return formalLogicToASCII(thought);
    case "svg":
      return formalLogicToSVG(thought, options);
    case "graphml":
      return formalLogicToGraphML(thought, options);
    case "tikz":
      return formalLogicToTikZ(thought, options);
    case "html":
      return formalLogicToHTML(thought, options);
    case "modelica":
      return formalLogicToModelica(thought, options);
    case "uml":
      return formalLogicToUML(thought, options);
    case "json":
      return formalLogicToJSON(thought, options);
    case "markdown":
      return formalLogicToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function formalLogicToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TD\n";
  if (thought.propositions && thought.propositions.length > 0) {
    mermaid += '  subgraph Propositions["Propositions"]\n';
    for (const proposition of thought.propositions) {
      const propId = sanitizeId(proposition.id);
      const label = includeLabels ? `${proposition.symbol}: ${proposition.statement.substring(0, 40)}...` : proposition.symbol;
      const shape = proposition.type === "atomic" ? ["[", "]"] : ["[[", "]]"];
      mermaid += `    ${propId}${shape[0]}${label}${shape[1]}
`;
    }
    mermaid += "  end\n\n";
  }
  if (thought.proof && thought.proof.steps && thought.proof.steps.length > 0) {
    mermaid += '  Theorem["Theorem"]\n';
    for (const step of thought.proof.steps) {
      const stepId = `Step${step.stepNumber}`;
      const label = includeLabels ? `${step.stepNumber}. ${step.statement.substring(0, 40)}...` : `Step ${step.stepNumber}`;
      mermaid += `  ${stepId}["${label}"]
`;
      if (step.referencesSteps && step.referencesSteps.length > 0) {
        for (const refStep of step.referencesSteps) {
          mermaid += `  Step${refStep} --> ${stepId}
`;
        }
      }
    }
    const lastStep = thought.proof.steps[thought.proof.steps.length - 1];
    mermaid += `  Step${lastStep.stepNumber} --> Theorem
`;
    if (includeMetrics) {
      const completeness = (thought.proof.completeness * 100).toFixed(0);
      mermaid += `
  Completeness["Completeness: ${completeness}%"]
`;
      mermaid += `  Completeness -.-> Theorem
`;
    }
  }
  if (thought.logicalInferences && thought.logicalInferences.length > 0) {
    mermaid += "\n";
    for (const inference of thought.logicalInferences) {
      const infId = sanitizeId(inference.id);
      const label = includeLabels ? inference.rule : infId;
      mermaid += `  ${infId}{{"${label}"}}
`;
      if (inference.premises) {
        for (const premiseId of inference.premises) {
          const propId = sanitizeId(premiseId);
          mermaid += `  ${propId} --> ${infId}
`;
        }
      }
      const conclusionId = sanitizeId(inference.conclusion);
      mermaid += `  ${infId} --> ${conclusionId}
`;
    }
  }
  if (colorScheme !== "monochrome") {
    mermaid += "\n";
    const atomicColor = colorScheme === "pastel" ? "#e1f5ff" : "#a8d5ff";
    const compoundColor = colorScheme === "pastel" ? "#fff3e0" : "#ffd699";
    if (thought.propositions) {
      for (const proposition of thought.propositions) {
        const propId = sanitizeId(proposition.id);
        const color = proposition.type === "atomic" ? atomicColor : compoundColor;
        mermaid += `  style ${propId} fill:${color}
`;
      }
    }
  }
  return mermaid;
}
function formalLogicToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph FormalLogic {\n";
  dot += "  rankdir=TD;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  if (thought.propositions && thought.propositions.length > 0) {
    dot += "  subgraph cluster_propositions {\n";
    dot += '    label="Propositions";\n';
    for (const proposition of thought.propositions) {
      const propId = sanitizeId(proposition.id);
      const label = includeLabels ? `${proposition.symbol}:\\n${proposition.statement.substring(0, 40)}...` : proposition.symbol;
      const shape = proposition.type === "atomic" ? "ellipse" : "box";
      dot += `    ${propId} [label="${label}", shape=${shape}];
`;
    }
    dot += "  }\n\n";
  }
  if (thought.proof && thought.proof.steps && thought.proof.steps.length > 0) {
    dot += `  Theorem [label="Theorem:\\n${thought.proof.theorem.substring(0, 50)}...", shape=doubleoctagon, style=bold];

`;
    for (const step of thought.proof.steps) {
      const stepId = `Step${step.stepNumber}`;
      const label = includeLabels ? `${step.stepNumber}. ${step.statement.substring(0, 40)}...` : `Step ${step.stepNumber}`;
      const ruleLabel = step.rule ? `\\n(${step.rule})` : "";
      dot += `  ${stepId} [label="${label}${ruleLabel}"];
`;
      if (step.referencesSteps) {
        for (const refStep of step.referencesSteps) {
          dot += `  Step${refStep} -> ${stepId};
`;
        }
      }
    }
    const lastStep = thought.proof.steps[thought.proof.steps.length - 1];
    dot += `  Step${lastStep.stepNumber} -> Theorem;
`;
    if (includeMetrics) {
      const completeness = (thought.proof.completeness * 100).toFixed(0);
      dot += `
  Completeness [label="Completeness: ${completeness}%", shape=note];
`;
    }
  }
  if (thought.logicalInferences && thought.logicalInferences.length > 0) {
    dot += "\n";
    for (const inference of thought.logicalInferences) {
      const infId = sanitizeId(inference.id);
      const label = includeLabels ? inference.rule : infId;
      dot += `  ${infId} [label="${label}", shape=diamond];
`;
      if (inference.premises) {
        for (const premiseId of inference.premises) {
          const propId = sanitizeId(premiseId);
          dot += `  ${propId} -> ${infId};
`;
        }
      }
      const conclusionId = sanitizeId(inference.conclusion);
      dot += `  ${infId} -> ${conclusionId};
`;
    }
  }
  dot += "}\n";
  return dot;
}
function formalLogicToASCII(thought) {
  let ascii = "Formal Logic Proof:\n";
  ascii += "==================\n\n";
  if (thought.propositions && thought.propositions.length > 0) {
    ascii += "Propositions:\n";
    for (const proposition of thought.propositions) {
      const typeMarker = proposition.type === "atomic" ? "\u25CF" : "\u25C6";
      ascii += `  ${typeMarker} ${proposition.symbol}: ${proposition.statement}
`;
    }
    ascii += "\n";
  }
  if (thought.logicalInferences && thought.logicalInferences.length > 0) {
    ascii += "Inferences:\n";
    for (const inference of thought.logicalInferences) {
      ascii += `  [${inference.rule}]
`;
      ascii += `    Premises: ${inference.premises.join(", ")}
`;
      ascii += `    Conclusion: ${inference.conclusion}
`;
      ascii += `    Valid: ${inference.valid ? "\u2713" : "\u2717"}
`;
    }
    ascii += "\n";
  }
  if (thought.proof) {
    ascii += `Proof: ${thought.proof.theorem}
`;
    ascii += `Technique: ${thought.proof.technique}
`;
    ascii += `Completeness: ${(thought.proof.completeness * 100).toFixed(0)}%

`;
    if (thought.proof.steps && thought.proof.steps.length > 0) {
      ascii += "Proof Steps:\n";
      for (const step of thought.proof.steps) {
        ascii += `  ${step.stepNumber}. ${step.statement}
`;
        ascii += `     Justification: ${step.justification}
`;
      }
      ascii += "\n";
    }
    ascii += `Conclusion: ${thought.proof.conclusion}
`;
    ascii += `Valid: ${thought.proof.valid ? "\u2713" : "\u2717"}
`;
  }
  if (thought.truthTable) {
    ascii += "\nTruth Table:\n";
    ascii += `  Tautology: ${thought.truthTable.isTautology ? "\u2713" : "\u2717"}
`;
    ascii += `  Contradiction: ${thought.truthTable.isContradiction ? "\u2713" : "\u2717"}
`;
    ascii += `  Contingent: ${thought.truthTable.isContingent ? "\u2713" : "\u2717"}
`;
  }
  return ascii;
}
function formalLogicToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width,
    svgHeight = DEFAULT_SVG_OPTIONS.height
  } = options;
  const positions = /* @__PURE__ */ new Map();
  const nodeWidth = 150;
  const nodeHeight = 40;
  if (thought.propositions) {
    const propSpacing = Math.min(180, svgWidth / (thought.propositions.length + 1));
    const propStartX = (svgWidth - (thought.propositions.length - 1) * propSpacing) / 2;
    thought.propositions.forEach((prop, index) => {
      positions.set(prop.id, {
        id: prop.id,
        label: includeLabels ? `${prop.symbol}: ${prop.statement.substring(0, 20)}...` : prop.symbol,
        x: propStartX + index * propSpacing,
        y: 80,
        width: nodeWidth,
        height: nodeHeight,
        type: prop.type
      });
    });
  }
  if (thought.proof && thought.proof.steps) {
    thought.proof.steps.forEach((step, index) => {
      const stepId = `Step${step.stepNumber}`;
      positions.set(stepId, {
        id: stepId,
        label: includeLabels ? `${step.stepNumber}. ${step.statement.substring(0, 25)}...` : `Step ${step.stepNumber}`,
        x: 150 + index * 180,
        y: 250,
        width: nodeWidth,
        height: nodeHeight,
        type: "step"
      });
    });
  }
  if (thought.proof) {
    positions.set("Theorem", {
      id: "Theorem",
      label: "Theorem",
      x: svgWidth / 2,
      y: 420,
      width: nodeWidth,
      height: nodeHeight,
      type: "theorem"
    });
  }
  let svg = generateSVGHeader(svgWidth, svgHeight, "Formal Logic Proof");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  if (thought.proof && thought.proof.steps) {
    const theoremPos = positions.get("Theorem");
    for (const step of thought.proof.steps) {
      const stepPos = positions.get(`Step${step.stepNumber}`);
      if (stepPos && theoremPos) {
        svg += renderEdge(stepPos, theoremPos);
      }
      if (step.referencesSteps) {
        for (const refStepNum of step.referencesSteps) {
          const refStepPos = positions.get(`Step${refStepNum}`);
          if (refStepPos && stepPos) {
            svg += renderEdge(refStepPos, stepPos, { style: "dashed" });
          }
        }
      }
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  const atomicColors = getNodeColor("primary", colorScheme);
  const compoundColors = getNodeColor("secondary", colorScheme);
  const stepColors = getNodeColor("neutral", colorScheme);
  const theoremColors = getNodeColor("success", colorScheme);
  for (const [, pos] of positions) {
    if (pos.type === "theorem") {
      svg += renderStadiumNode(pos, theoremColors);
    } else if (pos.type === "step") {
      svg += renderRectNode(pos, stepColors);
    } else if (pos.type === "atomic") {
      svg += renderEllipseNode(pos, atomicColors);
    } else {
      svg += renderRectNode(pos, compoundColors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Propositions", value: thought.propositions?.length || 0 },
      { label: "Proof Steps", value: thought.proof?.steps?.length || 0 },
      { label: "Completeness", value: thought.proof ? `${(thought.proof.completeness * 100).toFixed(0)}%` : "N/A" }
    ];
    svg += renderMetricsPanel(svgWidth - 180, svgHeight - 110, metrics);
  }
  const legendItems = [
    { label: "Atomic", color: atomicColors, shape: "ellipse" },
    { label: "Compound", color: compoundColors },
    { label: "Proof Step", color: stepColors },
    { label: "Theorem", color: theoremColors, shape: "stadium" }
  ];
  svg += renderLegend(20, svgHeight - 130, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function formalLogicToGraphML(thought, options) {
  const { includeLabels = true } = options;
  const nodes = [];
  const edges = [];
  let edgeCount = 0;
  if (thought.propositions && thought.propositions.length > 0) {
    for (const proposition of thought.propositions) {
      nodes.push({
        id: sanitizeId(proposition.id),
        label: includeLabels ? `${proposition.symbol}: ${proposition.statement}` : proposition.symbol,
        type: "premise",
        metadata: {
          propositionType: proposition.type,
          description: proposition.statement
        }
      });
    }
  }
  if (thought.logicalInferences && thought.logicalInferences.length > 0) {
    for (const inference of thought.logicalInferences) {
      const infId = sanitizeId(inference.id);
      nodes.push({
        id: infId,
        label: includeLabels ? inference.rule : infId,
        type: "inference",
        metadata: {
          rule: inference.rule,
          valid: inference.valid
        }
      });
      if (inference.premises) {
        for (const premiseId of inference.premises) {
          edges.push({
            id: `e${edgeCount++}`,
            source: sanitizeId(premiseId),
            target: infId,
            directed: true,
            metadata: { type: "premise-to-inference" }
          });
        }
      }
      edges.push({
        id: `e${edgeCount++}`,
        source: infId,
        target: sanitizeId(inference.conclusion),
        directed: true,
        metadata: { type: "inference-to-conclusion" }
      });
    }
  }
  if (thought.proof && thought.proof.steps && thought.proof.steps.length > 0) {
    for (const step of thought.proof.steps) {
      const stepId = `Step${step.stepNumber}`;
      nodes.push({
        id: stepId,
        label: includeLabels ? `${step.stepNumber}. ${step.statement}` : `Step ${step.stepNumber}`,
        type: "proof-step",
        metadata: {
          stepNumber: step.stepNumber,
          justification: step.justification,
          rule: step.rule
        }
      });
      if (step.referencesSteps && step.referencesSteps.length > 0) {
        for (const refStep of step.referencesSteps) {
          edges.push({
            id: `e${edgeCount++}`,
            source: `Step${refStep}`,
            target: stepId,
            directed: true,
            metadata: { type: "step-reference" }
          });
        }
      }
    }
    nodes.push({
      id: "Theorem",
      label: includeLabels ? thought.proof.theorem : "Theorem",
      type: "conclusion",
      metadata: {
        theorem: thought.proof.theorem,
        valid: thought.proof.valid,
        completeness: thought.proof.completeness
      }
    });
    const lastStep = thought.proof.steps[thought.proof.steps.length - 1];
    edges.push({
      id: `e${edgeCount++}`,
      source: `Step${lastStep.stepNumber}`,
      target: "Theorem",
      directed: true,
      metadata: { type: "step-to-theorem" }
    });
  }
  return generateGraphML(nodes, edges, {
    graphName: "Formal Logic Proof",
    directed: true,
    includeLabels
  });
}
function formalLogicToTikZ(thought, options) {
  const { includeLabels = true, colorScheme = "default" } = options;
  const nodes = [];
  const edges = [];
  let currentY = 0;
  if (thought.propositions && thought.propositions.length > 0) {
    thought.propositions.forEach((proposition, index) => {
      nodes.push({
        id: sanitizeId(proposition.id),
        label: includeLabels ? `${proposition.symbol}: ${proposition.statement.substring(0, 30)}...` : proposition.symbol,
        x: index * 3,
        y: currentY,
        type: "premise",
        shape: "stadium"
      });
    });
    currentY -= 2.5;
  }
  if (thought.logicalInferences && thought.logicalInferences.length > 0) {
    thought.logicalInferences.forEach((inference, index) => {
      const infId = sanitizeId(inference.id);
      nodes.push({
        id: infId,
        label: includeLabels ? inference.rule : infId,
        x: index * 3,
        y: currentY,
        type: "inference",
        shape: "rectangle"
      });
      if (inference.premises) {
        for (const premiseId of inference.premises) {
          edges.push({
            source: sanitizeId(premiseId),
            target: infId,
            directed: true
          });
        }
      }
      edges.push({
        source: infId,
        target: sanitizeId(inference.conclusion),
        directed: true
      });
    });
    currentY -= 2.5;
  }
  if (thought.proof && thought.proof.steps && thought.proof.steps.length > 0) {
    thought.proof.steps.forEach((step, index) => {
      const stepId = `Step${step.stepNumber}`;
      nodes.push({
        id: stepId,
        label: includeLabels ? `${step.stepNumber}. ${step.statement.substring(0, 20)}...` : `Step ${step.stepNumber}`,
        x: index * 3,
        y: currentY,
        type: "neutral",
        shape: "rectangle"
      });
      if (step.referencesSteps && step.referencesSteps.length > 0) {
        for (const refStep of step.referencesSteps) {
          edges.push({
            source: `Step${refStep}`,
            target: stepId,
            directed: true,
            style: "dashed"
          });
        }
      }
    });
    currentY -= 2.5;
    nodes.push({
      id: "Theorem",
      label: includeLabels ? "Theorem" : "T",
      x: (thought.proof.steps.length - 1) * 1.5,
      y: currentY,
      type: "conclusion",
      shape: "ellipse"
    });
    const lastStep = thought.proof.steps[thought.proof.steps.length - 1];
    edges.push({
      source: `Step${lastStep.stepNumber}`,
      target: "Theorem",
      directed: true
    });
  }
  return generateTikZ(nodes, edges, {
    title: "Formal Logic Proof",
    colorScheme,
    includeLabels
  });
}
function formalLogicToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Formal Logic Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  if (thought.proof) {
    const validBadge = thought.proof.valid ? renderBadge("VALID", "success") : renderBadge("INVALID", "danger");
    const proofContent = `
      <p><strong>Theorem:</strong> ${escapeHTML(thought.proof.theorem)}</p>
      <p><strong>Technique:</strong> ${escapeHTML(thought.proof.technique)}</p>
      <p><strong>Validity:</strong> ${validBadge}</p>
      <p><strong>Completeness:</strong> ${(thought.proof.completeness * 100).toFixed(0)}%</p>
      ${renderProgressBar(thought.proof.completeness * 100, "primary")}
    `;
    html += renderSection("Proof", proofContent, "\u{1F4CB}");
  }
  if (includeMetrics) {
    html += '<div class="metrics-grid">\n';
    html += renderMetricCard("Propositions", thought.propositions?.length || 0, "primary");
    html += renderMetricCard("Inferences", thought.logicalInferences?.length || 0, "info");
    html += renderMetricCard("Proof Steps", thought.proof?.steps?.length || 0, "secondary");
    html += renderMetricCard("Completeness", thought.proof ? `${(thought.proof.completeness * 100).toFixed(0)}%` : "N/A", "success");
    html += "</div>\n";
  }
  if (thought.propositions && thought.propositions.length > 0) {
    const propositionRows = thought.propositions.map((p) => [
      p.symbol,
      p.type,
      p.statement,
      p.truthValue !== void 0 ? String(p.truthValue) : "N/A"
    ]);
    const propositionsTable = renderTable(
      ["Symbol", "Type", "Statement", "Truth Value"],
      propositionRows,
      { caption: "Propositions" }
    );
    html += renderSection("Propositions", propositionsTable, "\u{1F4AD}");
  }
  if (thought.logicalInferences && thought.logicalInferences.length > 0) {
    let inferencesContent = "";
    for (const inference of thought.logicalInferences) {
      const validBadge = inference.valid ? renderBadge("VALID", "success") : renderBadge("INVALID", "danger");
      inferencesContent += `
        <div class="card">
          <div class="card-header">${escapeHTML(inference.rule)} ${validBadge}</div>
          <p><strong>Premises:</strong> ${inference.premises.map((p) => escapeHTML(p)).join(", ")}</p>
          <p><strong>Conclusion:</strong> ${escapeHTML(inference.conclusion)}</p>
        </div>
      `;
    }
    html += renderSection("Logical Inferences", inferencesContent, "\u{1F517}");
  }
  if (thought.proof && thought.proof.steps && thought.proof.steps.length > 0) {
    let stepsContent = "<ol>";
    for (const step of thought.proof.steps) {
      stepsContent += `
        <li>
          <strong>${escapeHTML(step.statement)}</strong>
          <p><em>Justification:</em> ${escapeHTML(step.justification)}</p>
          ${step.rule ? `<p><em>Rule:</em> ${renderBadge(step.rule, "info")}</p>` : ""}
          ${step.referencesSteps && step.referencesSteps.length > 0 ? `<p><em>References steps:</em> ${step.referencesSteps.join(", ")}</p>` : ""}
        </li>
      `;
    }
    stepsContent += "</ol>";
    html += renderSection("Proof Steps", stepsContent, "\u{1F4DD}");
  }
  if (thought.proof) {
    const conclusionBadge = thought.proof.valid ? renderBadge("PROVEN", "success") : renderBadge("NOT PROVEN", "danger");
    const conclusionContent = `
      <p>${conclusionBadge}</p>
      <p>${escapeHTML(thought.proof.conclusion)}</p>
    `;
    html += renderSection("Conclusion", conclusionContent, "\u2705");
  }
  if (thought.truthTable) {
    const truthTableContent = `
      <p><strong>Tautology:</strong> ${thought.truthTable.isTautology ? "\u2713" : "\u2717"}</p>
      <p><strong>Contradiction:</strong> ${thought.truthTable.isContradiction ? "\u2713" : "\u2717"}</p>
      <p><strong>Contingent:</strong> ${thought.truthTable.isContingent ? "\u2713" : "\u2717"}</p>
    `;
    html += renderSection("Truth Table", truthTableContent, "\u{1F4CA}");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function formalLogicToModelica(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  let modelica = "package FormalLogicProof\n";
  modelica += '  "Formal logic proof representation"\n\n';
  if (thought.propositions && thought.propositions.length > 0) {
    modelica += "  // Logical Propositions\n";
    for (const proposition of thought.propositions) {
      const propId = sanitizeModelicaId(proposition.id);
      const comment = includeLabels ? ` "${escapeModelicaString(proposition.symbol)}: ${escapeModelicaString(proposition.statement)}"` : "";
      const truthValue = proposition.truthValue !== void 0 ? String(proposition.truthValue) : "false";
      modelica += `  parameter Boolean ${propId} = ${truthValue}${comment};
`;
    }
    modelica += "\n";
  }
  if (thought.logicalInferences && thought.logicalInferences.length > 0) {
    modelica += "  // Inference Rules\n";
    for (const inference of thought.logicalInferences) {
      const ruleName = sanitizeModelicaId(inference.rule.replace(/[^a-zA-Z0-9]/g, "_"));
      modelica += `  function ${ruleName}
`;
      modelica += `    "${escapeModelicaString(inference.rule)}"
`;
      if (inference.premises && inference.premises.length > 0) {
        for (let i = 0; i < inference.premises.length; i++) {
          const premiseId = sanitizeModelicaId(inference.premises[i]);
          modelica += `    input Boolean premise${i + 1} "${escapeModelicaString(premiseId)}";
`;
        }
      }
      modelica += `    output Boolean conclusion "${escapeModelicaString(inference.conclusion)}";
`;
      modelica += `  algorithm
`;
      if (inference.premises && inference.premises.length > 0) {
        const conditions = inference.premises.map((_, i) => `premise${i + 1}`).join(" and ");
        modelica += `    conclusion := ${conditions};
`;
      } else {
        modelica += `    conclusion := false;
`;
      }
      modelica += `  end ${ruleName};

`;
    }
  }
  if (thought.proof && thought.proof.steps && thought.proof.steps.length > 0) {
    modelica += "  // Proof Steps\n";
    modelica += `  model ProofSequence
`;
    modelica += `    "${escapeModelicaString(thought.proof.theorem)}"

`;
    for (const step of thought.proof.steps) {
      const stepId = sanitizeModelicaId(`Step${step.stepNumber}`);
      const comment = includeLabels ? ` "${escapeModelicaString(step.statement)}"` : "";
      modelica += `    parameter Boolean ${stepId} = true${comment};
`;
      if (step.rule) {
        modelica += `    // Rule: ${escapeModelicaString(step.rule)}
`;
      }
      if (step.justification) {
        modelica += `    // Justification: ${escapeModelicaString(step.justification)}
`;
      }
    }
    modelica += "\n";
    const validStr = thought.proof.valid ? "true" : "false";
    modelica += `    parameter Boolean theoremProven = ${validStr} "Theorem is proven";
`;
    if (includeMetrics) {
      const completeness = thought.proof.completeness.toFixed(4);
      modelica += `    parameter Real completeness = ${completeness} "Proof completeness (0-1)";
`;
    }
    modelica += `  end ProofSequence;

`;
  }
  if (includeMetrics) {
    modelica += "  // Proof Metrics\n";
    modelica += `  constant Integer propositionCount = ${thought.propositions?.length || 0};
`;
    modelica += `  constant Integer inferenceCount = ${thought.logicalInferences?.length || 0};
`;
    modelica += `  constant Integer proofStepCount = ${thought.proof?.steps?.length || 0};
`;
    if (thought.truthTable) {
      modelica += `  constant Boolean isTautology = ${thought.truthTable.isTautology};
`;
      modelica += `  constant Boolean isContradiction = ${thought.truthTable.isContradiction};
`;
      modelica += `  constant Boolean isContingent = ${thought.truthTable.isContingent};
`;
    }
  }
  modelica += "end FormalLogicProof;\n";
  return modelica;
}
function formalLogicToUML(thought, options) {
  const { includeLabels = true } = options;
  const nodes = [];
  const edges = [];
  if (thought.propositions && thought.propositions.length > 0) {
    for (const proposition of thought.propositions) {
      const propId = sanitizeId(proposition.id);
      const attributes = [];
      if (includeLabels) {
        attributes.push(`symbol: ${proposition.symbol}`);
        attributes.push(`type: ${proposition.type}`);
        if (proposition.truthValue !== void 0) {
          attributes.push(`truth: ${proposition.truthValue}`);
        }
      }
      nodes.push({
        id: propId,
        label: includeLabels ? proposition.symbol : propId,
        shape: "class",
        stereotype: "premise",
        attributes
      });
    }
  }
  if (thought.logicalInferences && thought.logicalInferences.length > 0) {
    for (const inference of thought.logicalInferences) {
      const infId = sanitizeId(inference.id);
      const operations = [];
      if (includeLabels) {
        operations.push(`apply(): Boolean`);
      }
      nodes.push({
        id: infId,
        label: includeLabels ? inference.rule : infId,
        shape: "class",
        stereotype: "inference",
        attributes: [`valid: ${inference.valid}`],
        methods: operations
      });
      if (inference.premises) {
        for (const premiseId of inference.premises) {
          const propId = sanitizeId(premiseId);
          edges.push({
            source: propId,
            target: infId,
            type: "dependency",
            label: "premise"
          });
        }
      }
      const conclusionId = sanitizeId(inference.conclusion);
      edges.push({
        source: infId,
        target: conclusionId,
        type: "implementation",
        label: "derives"
      });
    }
  }
  if (thought.proof && thought.proof.steps && thought.proof.steps.length > 0) {
    for (const step of thought.proof.steps) {
      const stepId = `Step${step.stepNumber}`;
      const attributes = [];
      if (includeLabels) {
        attributes.push(`number: ${step.stepNumber}`);
        if (step.rule) {
          attributes.push(`rule: ${step.rule}`);
        }
      }
      nodes.push({
        id: stepId,
        label: includeLabels ? `Step ${step.stepNumber}` : stepId,
        shape: "class",
        stereotype: "proof-step",
        attributes
      });
      if (step.referencesSteps && step.referencesSteps.length > 0) {
        for (const refStep of step.referencesSteps) {
          edges.push({
            source: `Step${refStep}`,
            target: stepId,
            type: "dependency",
            label: "uses"
          });
        }
      }
    }
    nodes.push({
      id: "Theorem",
      label: includeLabels ? "Theorem" : "T",
      shape: "class",
      stereotype: "conclusion",
      attributes: [
        `valid: ${thought.proof.valid}`,
        `completeness: ${(thought.proof.completeness * 100).toFixed(0)}%`
      ]
    });
    const lastStep = thought.proof.steps[thought.proof.steps.length - 1];
    edges.push({
      source: `Step${lastStep.stepNumber}`,
      target: "Theorem",
      type: "implementation",
      label: "proves"
    });
  }
  return generateUmlDiagram(nodes, edges, {
    title: "Formal Logic Proof"});
}
function formalLogicToJSON(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const graph = createJsonGraph("Formal Logic Proof", "formal-logic", { includeMetrics });
  if (thought.propositions && thought.propositions.length > 0) {
    for (const proposition of thought.propositions) {
      addNode(graph, {
        id: proposition.id,
        label: includeLabels ? `${proposition.symbol}: ${proposition.statement}` : proposition.symbol,
        type: "premise",
        metadata: {
          symbol: proposition.symbol,
          propositionType: proposition.type,
          statement: proposition.statement,
          truthValue: proposition.truthValue
        }
      });
    }
  }
  let edgeId = 0;
  if (thought.logicalInferences && thought.logicalInferences.length > 0) {
    for (const inference of thought.logicalInferences) {
      const infId = inference.id;
      addNode(graph, {
        id: infId,
        label: includeLabels ? inference.rule : infId,
        type: "inference",
        metadata: {
          rule: inference.rule,
          valid: inference.valid,
          premises: inference.premises,
          conclusion: inference.conclusion
        }
      });
      if (inference.premises) {
        for (const premiseId of inference.premises) {
          addEdge(graph, {
            id: `edge_${edgeId++}`,
            source: premiseId,
            target: infId,
            label: "premise",
            metadata: { type: "premise-to-inference" }
          });
        }
      }
      addEdge(graph, {
        id: `edge_${edgeId++}`,
        source: infId,
        target: inference.conclusion,
        label: "derives",
        metadata: { type: "inference-to-conclusion" }
      });
    }
  }
  if (thought.proof && thought.proof.steps && thought.proof.steps.length > 0) {
    for (const step of thought.proof.steps) {
      const stepId = `Step${step.stepNumber}`;
      addNode(graph, {
        id: stepId,
        label: includeLabels ? `${step.stepNumber}. ${step.statement}` : `Step ${step.stepNumber}`,
        type: "proof-step",
        metadata: {
          stepNumber: step.stepNumber,
          statement: step.statement,
          justification: step.justification,
          rule: step.rule,
          referencesSteps: step.referencesSteps
        }
      });
      if (step.referencesSteps && step.referencesSteps.length > 0) {
        for (const refStep of step.referencesSteps) {
          addEdge(graph, {
            id: `edge_${edgeId++}`,
            source: `Step${refStep}`,
            target: stepId,
            label: "uses",
            metadata: { type: "step-reference" }
          });
        }
      }
    }
    addNode(graph, {
      id: "Theorem",
      label: includeLabels ? thought.proof.theorem : "Theorem",
      type: "conclusion",
      metadata: {
        theorem: thought.proof.theorem,
        technique: thought.proof.technique,
        valid: thought.proof.valid,
        completeness: thought.proof.completeness,
        conclusion: thought.proof.conclusion
      }
    });
    const lastStep = thought.proof.steps[thought.proof.steps.length - 1];
    addEdge(graph, {
      id: `edge_${edgeId++}`,
      source: `Step${lastStep.stepNumber}`,
      target: "Theorem",
      label: "proves",
      metadata: { type: "step-to-theorem" }
    });
  }
  if (includeMetrics) {
    addMetric(graph, "propositionCount", thought.propositions?.length || 0);
    addMetric(graph, "inferenceCount", thought.logicalInferences?.length || 0);
    addMetric(graph, "proofStepCount", thought.proof?.steps?.length || 0);
    if (thought.proof) {
      addMetric(graph, "proofValid", thought.proof.valid);
      addMetric(graph, "proofCompleteness", thought.proof.completeness);
    }
    if (thought.truthTable) {
      addMetric(graph, "isTautology", thought.truthTable.isTautology);
      addMetric(graph, "isContradiction", thought.truthTable.isContradiction);
      addMetric(graph, "isContingent", thought.truthTable.isContingent);
    }
  }
  return serializeGraph(graph);
}
function formalLogicToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  if (thought.proof) {
    const proofContent = keyValueSection({
      "Theorem": thought.proof.theorem,
      "Technique": thought.proof.technique,
      "Valid": thought.proof.valid ? "Yes" : "No",
      "Completeness": `${(thought.proof.completeness * 100).toFixed(0)}%`
    });
    parts.push(section("Proof", proofContent));
  }
  if (includeMetrics) {
    const metricsContent = keyValueSection({
      "Propositions": thought.propositions?.length || 0,
      "Inferences": thought.logicalInferences?.length || 0,
      "Proof Steps": thought.proof?.steps?.length || 0,
      "Completeness": thought.proof ? `${(thought.proof.completeness * 100).toFixed(0)}%` : "N/A"
    });
    parts.push(section("Metrics", metricsContent));
  }
  if (thought.propositions && thought.propositions.length > 0) {
    const propositionRows = thought.propositions.map((p) => [
      p.symbol,
      p.type,
      p.statement,
      p.truthValue !== void 0 ? String(p.truthValue) : "N/A"
    ]);
    const propositionsTable = table(
      ["Symbol", "Type", "Statement", "Truth Value"],
      propositionRows
    );
    parts.push(section("Propositions", propositionsTable));
  }
  if (thought.logicalInferences && thought.logicalInferences.length > 0) {
    const inferenceItems = thought.logicalInferences.map(
      (inf) => `**${inf.rule}** (${inf.valid ? "Valid" : "Invalid"})
  - Premises: ${inf.premises.join(", ")}
  - Conclusion: ${inf.conclusion}`
    );
    parts.push(section("Logical Inferences", list(inferenceItems)));
  }
  if (thought.proof && thought.proof.steps && thought.proof.steps.length > 0) {
    const stepItems = thought.proof.steps.map(
      (step) => `**${step.stepNumber}. ${step.statement}**
  - Justification: ${step.justification}${step.rule ? `
  - Rule: ${step.rule}` : ""}${step.referencesSteps && step.referencesSteps.length > 0 ? `
  - References steps: ${step.referencesSteps.join(", ")}` : ""}`
    );
    parts.push(section("Proof Steps", list(stepItems)));
  }
  if (thought.proof) {
    const conclusionContent = `${thought.proof.conclusion}

**Status:** ${thought.proof.valid ? "PROVEN" : "NOT PROVEN"}`;
    parts.push(section("Conclusion", conclusionContent));
  }
  if (thought.truthTable) {
    const truthTableContent = keyValueSection({
      "Tautology": thought.truthTable.isTautology ? "Yes" : "No",
      "Contradiction": thought.truthTable.isContradiction ? "Yes" : "No",
      "Contingent": thought.truthTable.isContingent ? "Yes" : "No"
    });
    parts.push(section("Truth Table", truthTableContent));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = formalLogicToMermaid(thought, "default", true, true);
    parts.push(section("Proof Tree Diagram", mermaidBlock(mermaidDiagram)));
  }
  return document("Formal Logic Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: { mode: "formal-logic" }
  });
}
var init_formal_logic = __esm({
  "src/export/visual/modes/formal-logic.ts"() {
    init_esm_shims();
    init_utils();
    init_svg();
    init_graphml();
    init_tikz();
    init_html();
    init_modelica();
    init_uml();
    init_json();
    init_markdown();
  }
});

// src/export/visual/modes/engineering.ts
function exportEngineeringAnalysis(thought, options) {
  const { format } = options;
  switch (format) {
    case "mermaid":
      return engineeringToMermaid(thought, options);
    case "dot":
      return engineeringToDOT(thought, options);
    case "ascii":
      return engineeringToASCII(thought);
    case "svg":
      return engineeringToSVG(thought, options);
    case "graphml":
      return engineeringToGraphML(thought, options);
    case "tikz":
      return engineeringToTikZ(thought, options);
    case "modelica":
      return engineeringToModelica(thought, options);
    case "html":
      return engineeringToHTML(thought, options);
    case "uml":
      return engineeringToUML(thought, options);
    case "json":
      return engineeringToJSON(thought, options);
    case "markdown":
      return engineeringToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function engineeringToMermaid(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const lines = ["flowchart TB"];
  lines.push(`  title["\u{1F527} ${thought.analysisType.toUpperCase()} Analysis"]`);
  lines.push(`  title --> challenge["${thought.designChallenge.slice(0, 50)}${thought.designChallenge.length > 50 ? "..." : ""}"]`);
  if (thought.requirements && thought.requirements.requirements.length > 0) {
    lines.push("");
    lines.push('  subgraph Requirements ["\u{1F4CB} Requirements"]');
    for (const req of thought.requirements.requirements.slice(0, 5)) {
      const label = includeLabels ? req.title.slice(0, 30) : req.id;
      const status = req.status === "verified" ? "\u2713" : req.status === "implemented" ? "\u2699" : "\u25CB";
      lines.push(`    ${sanitizeId(req.id)}["${status} ${label}"]`);
    }
    if (thought.requirements.requirements.length > 5) {
      lines.push(`    reqMore["... +${thought.requirements.requirements.length - 5} more"]`);
    }
    lines.push("  end");
    lines.push("  challenge --> Requirements");
  }
  if (thought.tradeStudy) {
    lines.push("");
    lines.push('  subgraph TradeStudy ["\u2696\uFE0F Trade Study"]');
    for (const alt of thought.tradeStudy.alternatives.slice(0, 4)) {
      const isRecommended = alt.id === thought.tradeStudy.recommendation;
      const icon = isRecommended ? "\u2605" : "\u25CB";
      const label = includeLabels ? alt.name.slice(0, 25) : alt.id;
      lines.push(`    ${sanitizeId(alt.id)}["${icon} ${label}"]`);
    }
    if (thought.tradeStudy.alternatives.length > 4) {
      lines.push(`    altMore["... +${thought.tradeStudy.alternatives.length - 4} more"]`);
    }
    lines.push("  end");
    lines.push("  challenge --> TradeStudy");
  }
  if (thought.fmea && thought.fmea.failureModes.length > 0) {
    lines.push("");
    lines.push('  subgraph FMEA ["\u26A0\uFE0F Failure Modes"]');
    const sortedModes = [...thought.fmea.failureModes].sort((a, b) => b.rpn - a.rpn);
    for (const fm of sortedModes.slice(0, 4)) {
      const risk = fm.rpn >= thought.fmea.rpnThreshold ? "\u{1F534}" : fm.rpn >= 100 ? "\u{1F7E1}" : "\u{1F7E2}";
      const label = includeMetrics ? `${fm.failureMode.slice(0, 20)} (RPN:${fm.rpn})` : fm.failureMode.slice(0, 25);
      lines.push(`    ${sanitizeId(fm.id)}{{"${risk} ${label}"}}`);
    }
    if (thought.fmea.failureModes.length > 4) {
      lines.push(`    fmMore["... +${thought.fmea.failureModes.length - 4} more"]`);
    }
    lines.push("  end");
    lines.push("  challenge --> FMEA");
  }
  if (thought.designDecisions && thought.designDecisions.decisions.length > 0) {
    lines.push("");
    lines.push('  subgraph Decisions ["\u{1F4DD} Design Decisions"]');
    for (const dec of thought.designDecisions.decisions.slice(0, 4)) {
      const status = dec.status === "accepted" ? "\u2713" : dec.status === "proposed" ? "?" : "\u2717";
      const label = includeLabels ? dec.title.slice(0, 25) : dec.id;
      lines.push(`    ${sanitizeId(dec.id)}(["${status} ${label}"])`);
    }
    if (thought.designDecisions.decisions.length > 4) {
      lines.push(`    decMore["... +${thought.designDecisions.decisions.length - 4} more"]`);
    }
    lines.push("  end");
    lines.push("  challenge --> Decisions");
  }
  if (includeMetrics && thought.assessment) {
    lines.push("");
    lines.push(`  metrics["\u{1F4CA} Confidence: ${(thought.assessment.confidence * 100).toFixed(0)}%"]`);
    lines.push("  challenge --> metrics");
  }
  return lines.join("\n");
}
function engineeringToDOT(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const lines = [
    "digraph EngineeringAnalysis {",
    "  rankdir=TB;",
    '  node [fontname="Arial", fontsize=10];',
    '  edge [fontname="Arial", fontsize=9];',
    ""
  ];
  lines.push(`  challenge [label="${thought.designChallenge.slice(0, 40)}", shape=box, style=filled, fillcolor=lightblue];`);
  if (thought.requirements && thought.requirements.requirements.length > 0) {
    lines.push("");
    lines.push("  subgraph cluster_requirements {");
    lines.push('    label="Requirements";');
    lines.push("    style=filled;");
    lines.push("    fillcolor=lightyellow;");
    for (const req of thought.requirements.requirements) {
      const label = includeLabels ? `${req.id}\\n${req.title.slice(0, 20)}` : req.id;
      const color = req.status === "verified" ? "green" : req.status === "implemented" ? "blue" : "gray";
      lines.push(`    ${sanitizeId(req.id)} [label="${label}", color=${color}];`);
    }
    lines.push("  }");
    lines.push("  challenge -> " + sanitizeId(thought.requirements.requirements[0]?.id || "req") + ";");
  }
  if (thought.tradeStudy) {
    lines.push("");
    lines.push("  subgraph cluster_trade {");
    lines.push('    label="Trade Study";');
    lines.push("    style=filled;");
    lines.push("    fillcolor=lightgreen;");
    for (const alt of thought.tradeStudy.alternatives) {
      const label = includeLabels ? `${alt.id}\\n${alt.name.slice(0, 20)}` : alt.id;
      const style = alt.id === thought.tradeStudy.recommendation ? "bold" : "solid";
      const color = alt.id === thought.tradeStudy.recommendation ? "gold" : "white";
      lines.push(`    ${sanitizeId(alt.id)} [label="${label}", style="${style},filled", fillcolor=${color}];`);
    }
    lines.push("  }");
    lines.push("  challenge -> " + sanitizeId(thought.tradeStudy.alternatives[0]?.id || "alt") + ";");
  }
  if (thought.fmea && thought.fmea.failureModes.length > 0) {
    lines.push("");
    lines.push("  subgraph cluster_fmea {");
    lines.push('    label="FMEA";');
    lines.push("    style=filled;");
    lines.push("    fillcolor=mistyrose;");
    for (const fm of thought.fmea.failureModes) {
      const label = includeMetrics ? `${fm.id}\\n${fm.failureMode.slice(0, 15)}\\nRPN:${fm.rpn}` : `${fm.id}\\n${fm.failureMode.slice(0, 20)}`;
      const color = fm.rpn >= thought.fmea.rpnThreshold ? "red" : fm.rpn >= 100 ? "orange" : "green";
      lines.push(`    ${sanitizeId(fm.id)} [label="${label}", shape=diamond, color=${color}];`);
    }
    lines.push("  }");
    lines.push("  challenge -> " + sanitizeId(thought.fmea.failureModes[0]?.id || "fm") + ";");
  }
  if (thought.designDecisions && thought.designDecisions.decisions.length > 0) {
    lines.push("");
    lines.push("  subgraph cluster_decisions {");
    lines.push('    label="Design Decisions";');
    lines.push("    style=filled;");
    lines.push("    fillcolor=lavender;");
    for (const dec of thought.designDecisions.decisions) {
      const label = includeLabels ? `${dec.id}\\n${dec.title.slice(0, 20)}` : dec.id;
      const shape = dec.status === "accepted" ? "box" : "ellipse";
      lines.push(`    ${sanitizeId(dec.id)} [label="${label}", shape=${shape}];`);
    }
    lines.push("  }");
    lines.push("  challenge -> " + sanitizeId(thought.designDecisions.decisions[0]?.id || "dec") + ";");
  }
  lines.push("}");
  return lines.join("\n");
}
function engineeringToASCII(thought) {
  const lines = [];
  const width = 60;
  lines.push("\u2554" + "\u2550".repeat(width - 2) + "\u2557");
  lines.push("\u2551" + ` \u{1F527} ENGINEERING: ${thought.analysisType.toUpperCase()} `.padEnd(width - 2) + "\u2551");
  lines.push("\u2560" + "\u2550".repeat(width - 2) + "\u2563");
  lines.push("\u2551" + ` Challenge: ${thought.designChallenge.slice(0, width - 14)}`.padEnd(width - 2) + "\u2551");
  lines.push("\u2560" + "\u2500".repeat(width - 2) + "\u2563");
  if (thought.requirements && thought.requirements.requirements.length > 0) {
    lines.push("\u2551" + " \u{1F4CB} REQUIREMENTS".padEnd(width - 2) + "\u2551");
    lines.push("\u2551" + "\u2500".repeat(width - 2) + "\u2551");
    for (const req of thought.requirements.requirements.slice(0, 5)) {
      const status = req.status === "verified" ? "[\u2713]" : req.status === "implemented" ? "[\u2699]" : "[ ]";
      const line = ` ${status} ${req.id}: ${req.title.slice(0, width - 20)}`;
      lines.push("\u2551" + line.padEnd(width - 2) + "\u2551");
    }
    if (thought.requirements.requirements.length > 5) {
      lines.push("\u2551" + `   ... +${thought.requirements.requirements.length - 5} more`.padEnd(width - 2) + "\u2551");
    }
    lines.push("\u2551" + `   Coverage: ${thought.requirements.coverage.verified}/${thought.requirements.coverage.total} verified`.padEnd(width - 2) + "\u2551");
    lines.push("\u2560" + "\u2500".repeat(width - 2) + "\u2563");
  }
  if (thought.tradeStudy) {
    lines.push("\u2551" + " \u2696\uFE0F TRADE STUDY".padEnd(width - 2) + "\u2551");
    lines.push("\u2551" + "\u2500".repeat(width - 2) + "\u2551");
    for (const alt of thought.tradeStudy.alternatives) {
      const isRec = alt.id === thought.tradeStudy.recommendation;
      const marker = isRec ? "\u2605" : "\u25CB";
      const line = ` ${marker} ${alt.name.slice(0, width - 8)}`;
      lines.push("\u2551" + line.padEnd(width - 2) + "\u2551");
    }
    lines.push("\u2551" + `   Recommended: ${thought.tradeStudy.recommendation}`.padEnd(width - 2) + "\u2551");
    lines.push("\u2560" + "\u2500".repeat(width - 2) + "\u2563");
  }
  if (thought.fmea && thought.fmea.failureModes.length > 0) {
    lines.push("\u2551" + " \u26A0\uFE0F FAILURE MODES (FMEA)".padEnd(width - 2) + "\u2551");
    lines.push("\u2551" + "\u2500".repeat(width - 2) + "\u2551");
    const sortedModes = [...thought.fmea.failureModes].sort((a, b) => b.rpn - a.rpn);
    for (const fm of sortedModes.slice(0, 5)) {
      const risk = fm.rpn >= thought.fmea.rpnThreshold ? "\u{1F534}" : fm.rpn >= 100 ? "\u{1F7E1}" : "\u{1F7E2}";
      const line = ` ${risk} ${fm.failureMode.slice(0, width - 25)} RPN:${fm.rpn}`;
      lines.push("\u2551" + line.padEnd(width - 2) + "\u2551");
    }
    if (thought.fmea.failureModes.length > 5) {
      lines.push("\u2551" + `   ... +${thought.fmea.failureModes.length - 5} more`.padEnd(width - 2) + "\u2551");
    }
    lines.push("\u2551" + `   Critical: ${thought.fmea.summary.criticalModes} modes above threshold`.padEnd(width - 2) + "\u2551");
    lines.push("\u2560" + "\u2500".repeat(width - 2) + "\u2563");
  }
  if (thought.designDecisions && thought.designDecisions.decisions.length > 0) {
    lines.push("\u2551" + " \u{1F4DD} DESIGN DECISIONS".padEnd(width - 2) + "\u2551");
    lines.push("\u2551" + "\u2500".repeat(width - 2) + "\u2551");
    for (const dec of thought.designDecisions.decisions.slice(0, 5)) {
      const status = dec.status === "accepted" ? "[\u2713]" : dec.status === "proposed" ? "[?]" : "[\u2717]";
      const line = ` ${status} ${dec.id}: ${dec.title.slice(0, width - 20)}`;
      lines.push("\u2551" + line.padEnd(width - 2) + "\u2551");
    }
    if (thought.designDecisions.decisions.length > 5) {
      lines.push("\u2551" + `   ... +${thought.designDecisions.decisions.length - 5} more`.padEnd(width - 2) + "\u2551");
    }
    lines.push("\u2560" + "\u2500".repeat(width - 2) + "\u2563");
  }
  if (thought.assessment) {
    lines.push("\u2551" + " \u{1F4CA} ASSESSMENT".padEnd(width - 2) + "\u2551");
    lines.push("\u2551" + `   Confidence: ${(thought.assessment.confidence * 100).toFixed(0)}%`.padEnd(width - 2) + "\u2551");
    if (thought.assessment.keyRisks.length > 0) {
      lines.push("\u2551" + `   Key Risks: ${thought.assessment.keyRisks.length}`.padEnd(width - 2) + "\u2551");
    }
    if (thought.assessment.openIssues.length > 0) {
      lines.push("\u2551" + `   Open Issues: ${thought.assessment.openIssues.length}`.padEnd(width - 2) + "\u2551");
    }
  }
  lines.push("\u255A" + "\u2550".repeat(width - 2) + "\u255D");
  return lines.join("\n");
}
function engineeringToSVG(thought, options) {
  const { colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  const svgOptions = { ...DEFAULT_SVG_OPTIONS, ...options };
  const nodePositions = /* @__PURE__ */ new Map();
  let currentY = 60;
  const centerX = (svgOptions.svgWidth || 800) / 2;
  const challengePos = {
    id: "challenge",
    label: thought.designChallenge.slice(0, 40),
    x: centerX - 100,
    y: currentY,
    width: 200,
    height: 40,
    type: "primary"
  };
  nodePositions.set("challenge", challengePos);
  currentY += 80;
  const sections = [];
  if (thought.requirements && thought.requirements.requirements.length > 0) {
    const label = includeLabels ? `Requirements (${thought.requirements.requirements.length})` : "Reqs";
    sections.push({ id: "requirements", label, type: "info" });
  }
  if (thought.tradeStudy) {
    const label = includeLabels ? `Trade Study (${thought.tradeStudy.alternatives.length} alts)` : "Trade";
    sections.push({ id: "tradeStudy", label, type: "secondary" });
  }
  if (thought.fmea && thought.fmea.failureModes.length > 0) {
    const label = includeLabels ? `FMEA (${thought.fmea.failureModes.length} modes)` : "FMEA";
    sections.push({ id: "fmea", label, type: "danger" });
  }
  if (thought.designDecisions && thought.designDecisions.decisions.length > 0) {
    const label = includeLabels ? `Decisions (${thought.designDecisions.decisions.length})` : "Decisions";
    sections.push({ id: "decisions", label, type: "tertiary" });
  }
  const sectionWidth = 150;
  const totalWidth = sections.length * (sectionWidth + 20);
  let startX = centerX - totalWidth / 2;
  for (const section2 of sections) {
    const pos = {
      id: section2.id,
      label: section2.label,
      x: startX,
      y: currentY,
      width: sectionWidth,
      height: 40,
      type: section2.type
    };
    nodePositions.set(section2.id, pos);
    startX += sectionWidth + 20;
  }
  const svgHeight = currentY + 120;
  let svg = generateSVGHeader(svgOptions.svgWidth || 800, svgHeight, `Engineering: ${thought.analysisType}`);
  const challengeColors = getNodeColor("primary", colorScheme);
  svg += renderStadiumNode(challengePos, challengeColors);
  for (const section2 of sections) {
    const pos = nodePositions.get(section2.id);
    const colors = getNodeColor(section2.type, colorScheme);
    svg += renderRectNode(pos, colors, 5);
    svg += renderEdge(challengePos, pos, { color: "#666666" });
  }
  if (includeMetrics && thought.assessment) {
    const metrics = [
      { label: "Confidence", value: `${(thought.assessment.confidence * 100).toFixed(0)}%` },
      { label: "Key Risks", value: thought.assessment.keyRisks.length },
      { label: "Open Issues", value: thought.assessment.openIssues.length }
    ];
    svg += renderMetricsPanel((svgOptions.svgWidth || 800) - 150, 20, metrics);
  }
  svg += generateSVGFooter();
  return svg;
}
function engineeringToGraphML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  let edgeId = 0;
  nodes.push({
    id: "challenge",
    label: includeLabels ? thought.designChallenge : "Challenge",
    type: "challenge",
    metadata: { analysisType: thought.analysisType }
  });
  if (thought.requirements) {
    for (const req of thought.requirements.requirements) {
      nodes.push({
        id: sanitizeId(req.id),
        label: includeLabels ? req.title : req.id,
        type: "requirement",
        metadata: {
          priority: req.priority,
          status: req.status,
          source: req.source
        }
      });
      edges.push({
        id: `e${edgeId++}`,
        source: "challenge",
        target: sanitizeId(req.id),
        label: "requires"
      });
      if (req.tracesTo) {
        for (const parentId of req.tracesTo) {
          edges.push({
            id: `e${edgeId++}`,
            source: sanitizeId(req.id),
            target: sanitizeId(parentId),
            label: "traces to"
          });
        }
      }
    }
  }
  if (thought.tradeStudy) {
    nodes.push({
      id: "tradeStudy",
      label: thought.tradeStudy.title,
      type: "trade-study"
    });
    edges.push({
      id: `e${edgeId++}`,
      source: "challenge",
      target: "tradeStudy"
    });
    for (const alt of thought.tradeStudy.alternatives) {
      const isRecommended = alt.id === thought.tradeStudy.recommendation;
      nodes.push({
        id: sanitizeId(alt.id),
        label: includeLabels ? alt.name : alt.id,
        type: isRecommended ? "recommended" : "alternative",
        metadata: {
          riskLevel: alt.riskLevel,
          estimatedCost: alt.estimatedCost
        }
      });
      edges.push({
        id: `e${edgeId++}`,
        source: "tradeStudy",
        target: sanitizeId(alt.id),
        label: isRecommended ? "recommended" : "alternative"
      });
    }
  }
  if (thought.fmea) {
    for (const fm of thought.fmea.failureModes) {
      nodes.push({
        id: sanitizeId(fm.id),
        label: includeLabels ? fm.failureMode : fm.id,
        type: fm.rpn >= thought.fmea.rpnThreshold ? "critical-failure" : "failure-mode",
        metadata: includeMetrics ? {
          severity: fm.severity,
          occurrence: fm.occurrence,
          detection: fm.detection,
          rpn: fm.rpn,
          component: fm.component
        } : void 0
      });
      edges.push({
        id: `e${edgeId++}`,
        source: "challenge",
        target: sanitizeId(fm.id),
        label: "failure mode",
        metadata: includeMetrics ? { weight: fm.rpn } : void 0
      });
    }
  }
  if (thought.designDecisions) {
    for (const dec of thought.designDecisions.decisions) {
      nodes.push({
        id: sanitizeId(dec.id),
        label: includeLabels ? dec.title : dec.id,
        type: `decision-${dec.status}`,
        metadata: {
          status: dec.status,
          context: dec.context
        }
      });
      edges.push({
        id: `e${edgeId++}`,
        source: "challenge",
        target: sanitizeId(dec.id),
        label: "decision"
      });
      if (dec.relatedDecisions) {
        for (const relId of dec.relatedDecisions) {
          edges.push({
            id: `e${edgeId++}`,
            source: sanitizeId(dec.id),
            target: sanitizeId(relId),
            label: "related to"
          });
        }
      }
    }
  }
  return generateGraphML(nodes, edges, { graphName: "Engineering Analysis", directed: true });
}
function engineeringToTikZ(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  nodes.push({
    id: "challenge",
    label: thought.designChallenge.slice(0, 30),
    x: 4,
    y: 0,
    type: "primary",
    shape: "stadium"
  });
  let sectionX = 0;
  const sectionY = -2;
  if (thought.requirements && thought.requirements.requirements.length > 0) {
    nodes.push({
      id: "reqs",
      label: includeLabels ? `Reqs (${thought.requirements.requirements.length})` : "Requirements",
      x: sectionX,
      y: sectionY,
      type: "info",
      shape: "rectangle"
    });
    edges.push({ source: "challenge", target: "reqs", directed: true });
    sectionX += 2.5;
  }
  if (thought.tradeStudy) {
    nodes.push({
      id: "trade",
      label: includeLabels ? `Trade (${thought.tradeStudy.alternatives.length})` : "Trade Study",
      x: sectionX,
      y: sectionY,
      type: "secondary",
      shape: "rectangle"
    });
    edges.push({ source: "challenge", target: "trade", directed: true });
    sectionX += 2.5;
  }
  if (thought.fmea && thought.fmea.failureModes.length > 0) {
    const criticalCount = thought.fmea.summary.criticalModes;
    nodes.push({
      id: "fmea",
      label: includeMetrics ? `FMEA (${criticalCount} crit)` : "FMEA",
      x: sectionX,
      y: sectionY,
      type: "danger",
      shape: "diamond"
    });
    edges.push({ source: "challenge", target: "fmea", directed: true });
    sectionX += 2.5;
  }
  if (thought.designDecisions && thought.designDecisions.decisions.length > 0) {
    nodes.push({
      id: "decisions",
      label: includeLabels ? `Decisions (${thought.designDecisions.decisions.length})` : "Decisions",
      x: sectionX,
      y: sectionY,
      type: "tertiary",
      shape: "ellipse"
    });
    edges.push({ source: "challenge", target: "decisions", directed: true });
  }
  if (thought.assessment && includeMetrics) {
    nodes.push({
      id: "assessment",
      label: `${(thought.assessment.confidence * 100).toFixed(0)}% conf`,
      x: 4,
      y: -4,
      type: "success",
      shape: "ellipse"
    });
    edges.push({ source: "challenge", target: "assessment", style: "dashed", directed: true });
  }
  return generateTikZ(nodes, edges, { title: `Engineering: ${thought.analysisType}` });
}
function sanitizeModelicaId2(id) {
  let sanitized = id.replace(/[-\s]/g, "_");
  sanitized = sanitized.replace(/[^a-zA-Z0-9_]/g, "");
  if (!/^[a-zA-Z]/.test(sanitized)) {
    sanitized = "id_" + sanitized;
  }
  return sanitized;
}
function escapeModelicaString2(str) {
  return str.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
}
function engineeringToModelica(thought, options) {
  const { includeMetrics = true, modelicaPackageName, modelicaIncludeAnnotations = true } = options;
  const packageName = modelicaPackageName || sanitizeModelicaId2(thought.designChallenge.slice(0, 30)) || "EngineeringAnalysis";
  const lines = [];
  lines.push(`package ${packageName}`);
  lines.push(`  "Engineering Analysis: ${escapeModelicaString2(thought.designChallenge)}"`);
  lines.push("");
  if (thought.requirements && thought.requirements.requirements.length > 0) {
    lines.push("  // ==========================================================================");
    lines.push("  // Requirements Traceability");
    lines.push("  // ==========================================================================");
    lines.push("");
    lines.push("  record Requirements");
    lines.push(`    "Requirements traceability for ${escapeModelicaString2(thought.designChallenge)}"`);
    lines.push("");
    for (const req of thought.requirements.requirements) {
      const reqId = sanitizeModelicaId2(req.id);
      const priority = req.priority.toUpperCase();
      const status = req.status;
      lines.push(`    // ${req.id}: ${escapeModelicaString2(req.title)}`);
      lines.push(`    parameter Boolean ${reqId}_satisfied = ${status === "verified" || status === "implemented" ? "true" : "false"}`);
      if (modelicaIncludeAnnotations) {
        lines.push(`      annotation(Dialog(group="${priority}", tab="Requirements"),`);
        lines.push(`               Documentation(info="<html><p>${escapeModelicaString2(req.description)}</p></html>"));`);
      } else {
        lines.push("      ;");
      }
      lines.push("");
    }
    if (includeMetrics) {
      const cov = thought.requirements.coverage;
      lines.push(`    // Coverage Metrics`);
      lines.push(`    final parameter Integer totalRequirements = ${cov.total};`);
      lines.push(`    final parameter Integer verifiedRequirements = ${cov.verified};`);
      lines.push(`    final parameter Real coverageRatio = ${(cov.verified / Math.max(cov.total, 1)).toFixed(3)};`);
      lines.push("");
    }
    lines.push("  end Requirements;");
    lines.push("");
  }
  if (thought.tradeStudy) {
    lines.push("  // ==========================================================================");
    lines.push("  // Trade Study");
    lines.push("  // ==========================================================================");
    lines.push("");
    lines.push("  model TradeStudy");
    lines.push(`    "${escapeModelicaString2(thought.tradeStudy.title)}"`);
    lines.push("");
    const altIds = thought.tradeStudy.alternatives.map((a) => sanitizeModelicaId2(a.id));
    lines.push(`    type Alternative = enumeration(`);
    for (let i = 0; i < altIds.length; i++) {
      const alt = thought.tradeStudy.alternatives[i];
      const comma = i < altIds.length - 1 ? "," : "";
      lines.push(`      ${altIds[i]} "${escapeModelicaString2(alt.name)}"${comma}`);
    }
    lines.push("    );");
    lines.push("");
    const recId = sanitizeModelicaId2(thought.tradeStudy.recommendation);
    lines.push(`    parameter Alternative selectedAlternative = Alternative.${recId}`);
    lines.push(`      "Selected alternative based on trade study";`);
    lines.push("");
    lines.push("    // Criteria Weights (sum to 1.0)");
    for (const crit of thought.tradeStudy.criteria) {
      const critId = sanitizeModelicaId2(crit.id);
      lines.push(`    parameter Real weight_${critId} = ${crit.weight.toFixed(3)} "${escapeModelicaString2(crit.name)}";`);
    }
    lines.push("");
    lines.push("    // Scores for selected alternative");
    const recScores = thought.tradeStudy.scores.filter((s) => s.alternativeId === thought.tradeStudy.recommendation);
    for (const score of recScores) {
      const critId = sanitizeModelicaId2(score.criteriaId);
      lines.push(`    final parameter Real score_${critId} = ${score.score};`);
    }
    lines.push("");
    if (modelicaIncludeAnnotations) {
      lines.push('    annotation(Documentation(info="<html>');
      lines.push(`      <h3>Objective</h3><p>${escapeModelicaString2(thought.tradeStudy.objective)}</p>`);
      lines.push(`      <h3>Justification</h3><p>${escapeModelicaString2(thought.tradeStudy.justification)}</p>`);
      lines.push('    </html>"));');
    }
    lines.push("  end TradeStudy;");
    lines.push("");
  }
  if (thought.fmea && thought.fmea.failureModes.length > 0) {
    lines.push("  // ==========================================================================");
    lines.push("  // Failure Mode and Effects Analysis (FMEA)");
    lines.push("  // ==========================================================================");
    lines.push("");
    lines.push("  model FMEA");
    lines.push(`    "FMEA for ${escapeModelicaString2(thought.fmea.system)}"`);
    lines.push("");
    lines.push(`    parameter Integer rpnThreshold = ${thought.fmea.rpnThreshold} "Action required above this RPN";`);
    lines.push("");
    for (const fm of thought.fmea.failureModes) {
      const fmId = sanitizeModelicaId2(fm.id);
      const isCritical = fm.rpn >= thought.fmea.rpnThreshold;
      lines.push(`    // Failure Mode: ${fm.id}`);
      lines.push(`    record ${fmId}`);
      lines.push(`      "${escapeModelicaString2(fm.failureMode)}"`);
      lines.push(`      constant String component = "${escapeModelicaString2(fm.component)}";`);
      lines.push(`      constant String cause = "${escapeModelicaString2(fm.cause)}";`);
      lines.push(`      constant String effect = "${escapeModelicaString2(fm.effect)}";`);
      lines.push(`      constant Integer severity = ${fm.severity} "1-10 scale";`);
      lines.push(`      constant Integer occurrence = ${fm.occurrence} "1-10 scale";`);
      lines.push(`      constant Integer detection = ${fm.detection} "1-10 scale";`);
      lines.push(`      constant Integer rpn = ${fm.rpn} "Risk Priority Number";`);
      lines.push(`      constant Boolean isCritical = ${isCritical};`);
      if (fm.mitigation) {
        lines.push(`      constant String mitigation = "${escapeModelicaString2(fm.mitigation)}";`);
      }
      lines.push(`    end ${fmId};`);
      lines.push("");
    }
    if (includeMetrics) {
      const sum = thought.fmea.summary;
      lines.push("    // Summary Statistics");
      lines.push(`    final parameter Integer totalModes = ${sum.totalModes};`);
      lines.push(`    final parameter Integer criticalModes = ${sum.criticalModes};`);
      lines.push(`    final parameter Real averageRpn = ${sum.averageRpn.toFixed(1)};`);
      lines.push(`    final parameter Integer maxRpn = ${sum.maxRpn};`);
      lines.push("");
    }
    lines.push("  end FMEA;");
    lines.push("");
  }
  if (thought.designDecisions && thought.designDecisions.decisions.length > 0) {
    lines.push("  // ==========================================================================");
    lines.push("  // Design Decision Records");
    lines.push("  // ==========================================================================");
    lines.push("");
    lines.push("  package DesignDecisions");
    if (thought.designDecisions.projectName) {
      lines.push(`    "Design decisions for ${escapeModelicaString2(thought.designDecisions.projectName)}"`);
    }
    lines.push("");
    for (const dec of thought.designDecisions.decisions) {
      const decId = sanitizeModelicaId2(dec.id);
      lines.push(`    record ${decId}`);
      lines.push(`      "${escapeModelicaString2(dec.title)}"`);
      lines.push(`      constant String status = "${dec.status}";`);
      lines.push(`      constant String context = "${escapeModelicaString2(dec.context.slice(0, 200))}";`);
      lines.push(`      constant String decision = "${escapeModelicaString2(dec.decision.slice(0, 200))}";`);
      lines.push(`      constant String rationale = "${escapeModelicaString2(dec.rationale.slice(0, 200))}";`);
      if (dec.date) {
        lines.push(`      constant String date = "${dec.date}";`);
      }
      if (dec.supersededBy) {
        lines.push(`      constant String supersededBy = "${sanitizeModelicaId2(dec.supersededBy)}";`);
      }
      if (modelicaIncludeAnnotations && dec.consequences.length > 0) {
        lines.push('      annotation(Documentation(info="<html>');
        lines.push("        <h4>Consequences</h4><ul>");
        for (const cons of dec.consequences) {
          lines.push(`          <li>${escapeModelicaString2(cons)}</li>`);
        }
        lines.push('        </ul></html>"));');
      }
      lines.push(`    end ${decId};`);
      lines.push("");
    }
    lines.push("  end DesignDecisions;");
    lines.push("");
  }
  if (thought.assessment && includeMetrics) {
    lines.push("  // ==========================================================================");
    lines.push("  // Assessment");
    lines.push("  // ==========================================================================");
    lines.push("");
    lines.push("  record Assessment");
    lines.push('    "Overall engineering assessment"');
    lines.push(`    constant Real confidence = ${thought.assessment.confidence.toFixed(3)};`);
    lines.push(`    constant Integer keyRisksCount = ${thought.assessment.keyRisks.length};`);
    lines.push(`    constant Integer openIssuesCount = ${thought.assessment.openIssues.length};`);
    if (modelicaIncludeAnnotations) {
      lines.push('    annotation(Documentation(info="<html>');
      if (thought.assessment.keyRisks.length > 0) {
        lines.push("      <h4>Key Risks</h4><ul>");
        for (const risk of thought.assessment.keyRisks) {
          lines.push(`        <li>${escapeModelicaString2(risk)}</li>`);
        }
        lines.push("      </ul>");
      }
      if (thought.assessment.nextSteps.length > 0) {
        lines.push("      <h4>Next Steps</h4><ul>");
        for (const step of thought.assessment.nextSteps) {
          lines.push(`        <li>${escapeModelicaString2(step)}</li>`);
        }
        lines.push("      </ul>");
      }
      lines.push('    </html>"));');
    }
    lines.push("  end Assessment;");
    lines.push("");
  }
  if (modelicaIncludeAnnotations) {
    lines.push(`  annotation(`);
    lines.push(`    Documentation(info="<html>`);
    lines.push(`      <h2>Engineering Analysis: ${escapeModelicaString2(thought.analysisType)}</h2>`);
    lines.push(`      <p><b>Design Challenge:</b> ${escapeModelicaString2(thought.designChallenge)}</p>`);
    lines.push(`      <p>Generated by DeepThinking MCP v7.1.0</p>`);
    lines.push(`    </html>"),`);
    lines.push(`    version="1.0.0"`);
    lines.push(`  );`);
  }
  lines.push(`end ${packageName};`);
  return lines.join("\n");
}
function engineeringToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Engineering Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  const typeBadge = renderBadge(thought.analysisType, "primary");
  html += `<p>Analysis Type: ${typeBadge}</p>
`;
  html += renderSection("Design Challenge", `
    <p class="text-primary"><strong>${escapeHTML(thought.designChallenge)}</strong></p>
  `, "\u{1F527}");
  if (thought.requirements && thought.requirements.requirements.length > 0) {
    if (includeMetrics) {
      const cov = thought.requirements.coverage;
      const coveragePercent = cov.verified / Math.max(cov.total, 1) * 100;
      html += '<div class="metrics-grid">';
      html += renderMetricCard("Total Requirements", cov.total, "primary");
      html += renderMetricCard("Verified", cov.verified, "success");
      html += renderMetricCard("Traced to Source", cov.tracedToSource, "info");
      html += renderMetricCard("Allocated", cov.allocatedToDesign, "warning");
      html += "</div>\n";
      html += renderProgressBar(coveragePercent, "success");
    }
    const reqRows = thought.requirements.requirements.map((req) => {
      const statusBadge = renderBadge(
        req.status,
        req.status === "verified" ? "success" : req.status === "implemented" ? "info" : req.status === "approved" ? "primary" : "secondary"
      );
      const priorityBadge = renderBadge(
        req.priority,
        req.priority === "must" ? "danger" : req.priority === "should" ? "warning" : "secondary"
      );
      return [
        req.id,
        req.title,
        priorityBadge,
        statusBadge,
        req.source
      ];
    });
    html += renderSection("Requirements Traceability", renderTable(
      ["ID", "Title", "Priority", "Status", "Source"],
      reqRows.map((row) => row.map((cell) => typeof cell === "string" && cell.startsWith("<") ? cell : escapeHTML(String(cell))))
    ), "\u{1F4CB}");
  }
  if (thought.tradeStudy) {
    html += renderSection("Trade Study: " + thought.tradeStudy.title, `
      <p><strong>Objective:</strong> ${escapeHTML(thought.tradeStudy.objective)}</p>
      <h4>Criteria</h4>
    ` + renderTable(
      ["Criterion", "Weight", "Description"],
      thought.tradeStudy.criteria.map((c) => [c.name, (c.weight * 100).toFixed(0) + "%", c.description || "-"])
    ) + `
      <h4>Alternatives</h4>
    ` + renderTable(
      ["Alternative", "Description", "Risk Level"],
      thought.tradeStudy.alternatives.map((a) => [
        a.id === thought.tradeStudy.recommendation ? "\u2B50 " + a.name : a.name,
        a.description,
        a.riskLevel || "-"
      ])
    ) + `
      <div class="card" style="margin-top: 1rem; border-color: var(--success-color);">
        <div class="card-header text-success">Recommendation: ${escapeHTML(thought.tradeStudy.recommendation)}</div>
        <p>${escapeHTML(thought.tradeStudy.justification)}</p>
      </div>
    `, "\u2696\uFE0F");
  }
  if (thought.fmea && thought.fmea.failureModes.length > 0) {
    if (includeMetrics) {
      html += '<div class="metrics-grid">';
      html += renderMetricCard("Failure Modes", thought.fmea.summary.totalModes, "primary");
      html += renderMetricCard("Critical Modes", thought.fmea.summary.criticalModes, "danger");
      html += renderMetricCard("Average RPN", thought.fmea.summary.averageRpn.toFixed(1), "warning");
      html += renderMetricCard("Max RPN", thought.fmea.summary.maxRpn, "danger");
      html += "</div>\n";
    }
    const fmeaRows = thought.fmea.failureModes.map((fm) => {
      const isCritical = fm.rpn >= thought.fmea.rpnThreshold;
      const rpnBadge = renderBadge(fm.rpn.toString(), isCritical ? "danger" : "warning");
      return [
        fm.component,
        fm.failureMode.substring(0, 40) + (fm.failureMode.length > 40 ? "..." : ""),
        fm.severity.toString(),
        fm.occurrence.toString(),
        fm.detection.toString(),
        rpnBadge,
        fm.mitigation ? "\u2713" : "-"
      ];
    });
    html += renderSection("Failure Mode Analysis (FMEA)", `
      <p><strong>System:</strong> ${escapeHTML(thought.fmea.system)} | <strong>RPN Threshold:</strong> ${thought.fmea.rpnThreshold}</p>
    ` + renderTable(
      ["Component", "Failure Mode", "S", "O", "D", "RPN", "Mitigation"],
      fmeaRows.map((row) => row.map((cell) => typeof cell === "string" && cell.startsWith("<") ? cell : escapeHTML(String(cell))))
    ), "\u26A0\uFE0F");
  }
  if (thought.designDecisions && thought.designDecisions.decisions.length > 0) {
    const decisionsContent = thought.designDecisions.decisions.map((dec) => {
      const statusBadge = renderBadge(
        dec.status,
        dec.status === "accepted" ? "success" : dec.status === "rejected" ? "danger" : dec.status === "deprecated" ? "warning" : "secondary"
      );
      return `
        <div class="card">
          <div class="card-header">${escapeHTML(dec.id)}: ${escapeHTML(dec.title)} ${statusBadge}</div>
          <p><strong>Context:</strong> ${escapeHTML(dec.context)}</p>
          <p><strong>Decision:</strong> ${escapeHTML(dec.decision)}</p>
          <p><strong>Rationale:</strong> ${escapeHTML(dec.rationale)}</p>
          ${dec.consequences.length > 0 ? `
            <p><strong>Consequences:</strong></p>
            <ul class="list-styled">
              ${dec.consequences.map((c) => `<li>${escapeHTML(c)}</li>`).join("")}
            </ul>
          ` : ""}
        </div>
      `;
    }).join("\n");
    html += renderSection("Design Decisions", decisionsContent, "\u{1F4DD}");
  }
  if (thought.assessment && includeMetrics) {
    html += renderSection("Assessment", `
      <div class="metrics-grid">
        ${renderMetricCard("Confidence", (thought.assessment.confidence * 100).toFixed(0) + "%", "primary")}
        ${renderMetricCard("Key Risks", thought.assessment.keyRisks.length, "danger")}
        ${renderMetricCard("Open Issues", thought.assessment.openIssues.length, "warning")}
      </div>
      ${renderProgressBar(thought.assessment.confidence * 100, "primary")}
      ${thought.assessment.keyRisks.length > 0 ? `
        <h4>Key Risks</h4>
        <ul class="list-styled">
          ${thought.assessment.keyRisks.map((r) => `<li class="text-danger">${escapeHTML(r)}</li>`).join("")}
        </ul>
      ` : ""}
      ${thought.assessment.nextSteps.length > 0 ? `
        <h4>Next Steps</h4>
        <ul class="list-styled">
          ${thought.assessment.nextSteps.map((s) => `<li>${escapeHTML(s)}</li>`).join("")}
        </ul>
      ` : ""}
    `, "\u{1F4CA}");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function engineeringToUML(thought, options) {
  const { umlTheme, umlDirection, includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  nodes.push({
    id: "challenge",
    label: thought.designChallenge.substring(0, 50),
    shape: "component",
    stereotype: thought.analysisType
  });
  if (thought.requirements && thought.requirements.requirements.length > 0) {
    nodes.push({
      id: "requirements",
      label: includeLabels ? `Requirements (${thought.requirements.requirements.length})` : "Requirements",
      shape: "folder",
      color: "lightyellow"
    });
    edges.push({
      source: "challenge",
      target: "requirements",
      type: "composition"
    });
    for (const req of thought.requirements.requirements.slice(0, 5)) {
      const reqId = sanitizeId(req.id);
      nodes.push({
        id: `req_${reqId}`,
        label: includeLabels ? req.title.substring(0, 30) : req.id,
        shape: "class",
        stereotype: req.priority
      });
      edges.push({
        source: "requirements",
        target: `req_${reqId}`,
        type: "aggregation"
      });
    }
  }
  if (thought.tradeStudy) {
    nodes.push({
      id: "tradeStudy",
      label: includeLabels ? thought.tradeStudy.title.substring(0, 30) : "Trade Study",
      shape: "package",
      color: "lightgreen"
    });
    edges.push({
      source: "challenge",
      target: "tradeStudy",
      type: "dependency"
    });
    for (const alt of thought.tradeStudy.alternatives.slice(0, 4)) {
      const isRec = alt.id === thought.tradeStudy.recommendation;
      nodes.push({
        id: `alt_${sanitizeId(alt.id)}`,
        label: alt.name.substring(0, 25),
        shape: isRec ? "entity" : "rectangle",
        stereotype: isRec ? "recommended" : void 0,
        color: isRec ? "90EE90" : void 0
      });
      edges.push({
        source: "tradeStudy",
        target: `alt_${sanitizeId(alt.id)}`,
        type: "association"
      });
    }
  }
  if (thought.fmea && thought.fmea.failureModes.length > 0) {
    nodes.push({
      id: "fmea",
      label: includeMetrics ? `FMEA (${thought.fmea.summary.criticalModes} critical)` : "FMEA",
      shape: "database",
      color: "mistyrose"
    });
    edges.push({
      source: "challenge",
      target: "fmea",
      type: "dependency"
    });
  }
  if (thought.designDecisions && thought.designDecisions.decisions.length > 0) {
    nodes.push({
      id: "decisions",
      label: includeLabels ? `Decisions (${thought.designDecisions.decisions.length})` : "Decisions",
      shape: "folder",
      color: "lavender"
    });
    edges.push({
      source: "challenge",
      target: "decisions",
      type: "dependency"
    });
  }
  if (thought.assessment && includeMetrics) {
    nodes.push({
      id: "assessment",
      label: `Confidence: ${(thought.assessment.confidence * 100).toFixed(0)}%`,
      shape: "usecase",
      color: thought.assessment.confidence > 0.7 ? "90EE90" : "FFD700"
    });
    edges.push({
      source: "challenge",
      target: "assessment",
      type: "dashed"
    });
  }
  return generateUmlDiagram(nodes, edges, {
    title: `Engineering: ${thought.analysisType}`,
    theme: umlTheme,
    direction: umlDirection
  });
}
function engineeringToJSON(thought, options) {
  const { jsonPrettyPrint = true, jsonIndent = 2, includeMetrics = true } = options;
  const graph = createJsonGraph(`Engineering: ${thought.analysisType}`, "engineering", {
    includeMetrics
  });
  graph.metadata.analysisType = thought.analysisType;
  graph.metadata.designChallenge = thought.designChallenge;
  addNode(graph, {
    id: "challenge",
    label: thought.designChallenge,
    type: "challenge",
    color: "#a8d5ff",
    shape: "stadium",
    metadata: { analysisType: thought.analysisType }
  });
  if (thought.requirements) {
    addNode(graph, {
      id: "requirements",
      label: `Requirements (${thought.requirements.requirements.length})`,
      type: "requirements",
      color: "#fff9c4",
      shape: "rectangle",
      metadata: {
        total: thought.requirements.coverage.total,
        verified: thought.requirements.coverage.verified,
        requirements: thought.requirements.requirements.map((r) => ({
          id: r.id,
          title: r.title,
          priority: r.priority,
          status: r.status
        }))
      }
    });
    addEdge(graph, {
      id: "edge_challenge_requirements",
      source: "challenge",
      target: "requirements",
      type: "has_requirements",
      directed: true
    });
  }
  if (thought.tradeStudy) {
    addNode(graph, {
      id: "tradeStudy",
      label: thought.tradeStudy.title,
      type: "trade_study",
      color: "#c8e6c9",
      shape: "rectangle",
      metadata: {
        objective: thought.tradeStudy.objective,
        recommendation: thought.tradeStudy.recommendation,
        justification: thought.tradeStudy.justification,
        alternatives: thought.tradeStudy.alternatives.map((a) => ({
          id: a.id,
          name: a.name,
          riskLevel: a.riskLevel
        })),
        criteria: thought.tradeStudy.criteria.map((c) => ({
          id: c.id,
          name: c.name,
          weight: c.weight
        }))
      }
    });
    addEdge(graph, {
      id: "edge_challenge_tradeStudy",
      source: "challenge",
      target: "tradeStudy",
      type: "has_trade_study",
      directed: true
    });
  }
  if (thought.fmea && thought.fmea.failureModes.length > 0) {
    addNode(graph, {
      id: "fmea",
      label: `FMEA: ${thought.fmea.system}`,
      type: "fmea",
      color: "#ffcdd2",
      shape: "diamond",
      metadata: {
        system: thought.fmea.system,
        rpnThreshold: thought.fmea.rpnThreshold,
        summary: thought.fmea.summary,
        failureModes: thought.fmea.failureModes.map((fm) => ({
          id: fm.id,
          component: fm.component,
          failureMode: fm.failureMode,
          rpn: fm.rpn,
          severity: fm.severity,
          occurrence: fm.occurrence,
          detection: fm.detection
        }))
      }
    });
    addEdge(graph, {
      id: "edge_challenge_fmea",
      source: "challenge",
      target: "fmea",
      type: "has_fmea",
      directed: true
    });
  }
  if (thought.designDecisions && thought.designDecisions.decisions.length > 0) {
    addNode(graph, {
      id: "decisions",
      label: `Decisions (${thought.designDecisions.decisions.length})`,
      type: "design_decisions",
      color: "#e1bee7",
      shape: "rectangle",
      metadata: {
        projectName: thought.designDecisions.projectName,
        decisions: thought.designDecisions.decisions.map((d) => ({
          id: d.id,
          title: d.title,
          status: d.status,
          decision: d.decision
        }))
      }
    });
    addEdge(graph, {
      id: "edge_challenge_decisions",
      source: "challenge",
      target: "decisions",
      type: "has_decisions",
      directed: true
    });
  }
  if (thought.assessment) {
    addNode(graph, {
      id: "assessment",
      label: `Assessment: ${(thought.assessment.confidence * 100).toFixed(0)}%`,
      type: "assessment",
      color: thought.assessment.confidence > 0.7 ? "#a5d6a7" : "#ffe082",
      shape: "ellipse",
      metadata: {
        confidence: thought.assessment.confidence,
        keyRisks: thought.assessment.keyRisks,
        openIssues: thought.assessment.openIssues,
        nextSteps: thought.assessment.nextSteps
      }
    });
    addEdge(graph, {
      id: "edge_challenge_assessment",
      source: "challenge",
      target: "assessment",
      type: "has_assessment",
      directed: true,
      style: "dashed"
    });
  }
  if (includeMetrics && graph.metrics) {
    addMetric(graph, "analysisType", thought.analysisType);
    if (thought.requirements) {
      addMetric(graph, "requirementCount", thought.requirements.requirements.length);
      addMetric(graph, "verifiedRequirements", thought.requirements.coverage.verified);
    }
    if (thought.tradeStudy) {
      addMetric(graph, "alternativeCount", thought.tradeStudy.alternatives.length);
      addMetric(graph, "recommendation", thought.tradeStudy.recommendation);
    }
    if (thought.fmea) {
      addMetric(graph, "failureModeCount", thought.fmea.failureModes.length);
      addMetric(graph, "criticalModes", thought.fmea.summary.criticalModes);
      addMetric(graph, "maxRpn", thought.fmea.summary.maxRpn);
    }
    if (thought.designDecisions) {
      addMetric(graph, "decisionCount", thought.designDecisions.decisions.length);
    }
    if (thought.assessment) {
      addMetric(graph, "confidence", thought.assessment.confidence);
      addMetric(graph, "riskCount", thought.assessment.keyRisks.length);
    }
  }
  return serializeGraph(graph, { prettyPrint: jsonPrettyPrint, indent: jsonIndent });
}
function engineeringToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  const overviewContent = keyValueSection({
    "Analysis Type": thought.analysisType.toUpperCase(),
    "Design Challenge": thought.designChallenge.substring(0, 100) + (thought.designChallenge.length > 100 ? "..." : "")
  });
  parts.push(section("Overview", overviewContent));
  if (thought.requirements && thought.requirements.requirements.length > 0) {
    const reqRows = thought.requirements.requirements.map((req) => [
      req.id,
      req.title.substring(0, 40) + (req.title.length > 40 ? "..." : ""),
      req.priority,
      req.status,
      req.source
    ]);
    let reqContent = table(["ID", "Title", "Priority", "Status", "Source"], reqRows);
    if (includeMetrics) {
      const cov = thought.requirements.coverage;
      const coveragePercent = cov.verified / Math.max(cov.total, 1) * 100;
      reqContent += "\n\n" + keyValueSection({
        "Total Requirements": cov.total,
        "Verified": cov.verified,
        "Traced to Source": cov.tracedToSource,
        "Allocated to Design": cov.allocatedToDesign,
        "Coverage": `${coveragePercent.toFixed(1)}%`
      });
      reqContent += "\n\n**Verification Progress:**\n\n" + progressBar(coveragePercent);
    }
    parts.push(section("Requirements Traceability", reqContent));
  }
  if (thought.tradeStudy) {
    const criteriaRows = thought.tradeStudy.criteria.map((c) => [
      c.name,
      `${(c.weight * 100).toFixed(0)}%`,
      c.description || "-"
    ]);
    const altRows = thought.tradeStudy.alternatives.map((alt) => [
      alt.id === thought.tradeStudy.recommendation ? `\u2B50 ${alt.name}` : alt.name,
      alt.description.substring(0, 60) + (alt.description.length > 60 ? "..." : ""),
      alt.riskLevel || "-",
      alt.estimatedCost?.toString() || "-"
    ]);
    let tradeContent = `**Objective:** ${thought.tradeStudy.objective}

`;
    tradeContent += "### Criteria\n\n";
    tradeContent += table(["Criterion", "Weight", "Description"], criteriaRows);
    tradeContent += "\n\n### Alternatives\n\n";
    tradeContent += table(["Alternative", "Description", "Risk Level", "Cost"], altRows);
    tradeContent += "\n\n**Recommendation:** " + thought.tradeStudy.recommendation;
    tradeContent += "\n\n**Justification:**\n\n" + thought.tradeStudy.justification;
    parts.push(section("Trade Study: " + thought.tradeStudy.title, tradeContent));
  }
  if (thought.fmea && thought.fmea.failureModes.length > 0) {
    const fmeaRows = thought.fmea.failureModes.map((fm) => {
      const isCritical = fm.rpn >= thought.fmea.rpnThreshold;
      return [
        fm.component,
        fm.failureMode.substring(0, 40) + (fm.failureMode.length > 40 ? "..." : ""),
        fm.severity.toString(),
        fm.occurrence.toString(),
        fm.detection.toString(),
        `${fm.rpn}${isCritical ? " \u26A0\uFE0F" : ""}`,
        fm.mitigation ? "\u2713" : "-"
      ];
    });
    let fmeaContent = `**System:** ${thought.fmea.system}

`;
    fmeaContent += table(
      ["Component", "Failure Mode", "S", "O", "D", "RPN", "Mitigation"],
      fmeaRows
    );
    if (includeMetrics) {
      const sum = thought.fmea.summary;
      fmeaContent += "\n\n" + keyValueSection({
        "Total Modes": sum.totalModes,
        "Critical Modes": sum.criticalModes,
        "Average RPN": sum.averageRpn.toFixed(1),
        "Max RPN": sum.maxRpn,
        "RPN Threshold": thought.fmea.rpnThreshold
      });
    }
    parts.push(section("Failure Mode and Effects Analysis (FMEA)", fmeaContent));
  }
  if (thought.designDecisions && thought.designDecisions.decisions.length > 0) {
    let decisionsContent = "";
    for (const dec of thought.designDecisions.decisions) {
      decisionsContent += `### ${dec.id}: ${dec.title} (${dec.status})

`;
      decisionsContent += keyValueSection({
        "Status": dec.status,
        "Date": dec.date || "-"
      });
      decisionsContent += "\n\n**Context:**\n\n" + dec.context;
      decisionsContent += "\n\n**Decision:**\n\n" + dec.decision;
      decisionsContent += "\n\n**Rationale:**\n\n" + dec.rationale;
      if (dec.consequences.length > 0) {
        decisionsContent += "\n\n**Consequences:**\n\n" + list(dec.consequences);
      }
      if (dec.supersededBy) {
        decisionsContent += `

*Superseded by: ${dec.supersededBy}*`;
      }
      decisionsContent += "\n\n---\n\n";
    }
    parts.push(section("Design Decisions", decisionsContent));
  }
  if (thought.assessment) {
    let assessmentContent = keyValueSection({
      "Confidence": `${(thought.assessment.confidence * 100).toFixed(1)}%`,
      "Key Risks": thought.assessment.keyRisks.length,
      "Open Issues": thought.assessment.openIssues.length
    });
    assessmentContent += "\n\n**Confidence Level:**\n\n" + progressBar(thought.assessment.confidence * 100);
    if (thought.assessment.keyRisks.length > 0) {
      assessmentContent += "\n\n**Key Risks:**\n\n" + list(thought.assessment.keyRisks.map((r) => `\u26A0\uFE0F ${r}`));
    }
    if (thought.assessment.openIssues.length > 0) {
      assessmentContent += "\n\n**Open Issues:**\n\n" + list(thought.assessment.openIssues);
    }
    if (thought.assessment.nextSteps.length > 0) {
      assessmentContent += "\n\n**Next Steps:**\n\n" + list(thought.assessment.nextSteps);
    }
    parts.push(section("Assessment", assessmentContent));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = engineeringToMermaid(thought, options);
    parts.push(section("Visualization", mermaidBlock(mermaidDiagram)));
  }
  return document(`Engineering Analysis: ${thought.analysisType}`, parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "engineering",
      analysisType: thought.analysisType,
      ...thought.assessment?.confidence !== void 0 ? { confidence: thought.assessment.confidence } : {}
    }
  });
}
var init_engineering = __esm({
  "src/export/visual/modes/engineering.ts"() {
    init_esm_shims();
    init_utils();
    init_svg();
    init_graphml();
    init_tikz();
    init_html();
    init_uml();
    init_json();
    init_markdown();
  }
});

// src/export/visual/modes/computability.ts
function exportComputability(thought, options) {
  const { format } = options;
  switch (format) {
    case "mermaid":
      return computabilityToMermaid(thought, options);
    case "dot":
      return computabilityToDOT(thought, options);
    case "ascii":
      return computabilityToASCII(thought);
    case "svg":
      return computabilityToSVG(thought, options);
    case "graphml":
      return computabilityToGraphML(thought, options);
    case "tikz":
      return computabilityToTikZ(thought, options);
    case "html":
      return computabilityToHTML(thought, options);
    case "json":
      return computabilityToJSON(thought, options);
    case "markdown":
      return computabilityToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function computabilityToMermaid(thought, options) {
  const { includeLabels = true } = options;
  if (thought.currentMachine || thought.machines && thought.machines.length > 0) {
    return turingMachineToMermaid(thought.currentMachine || thought.machines[0], includeLabels);
  }
  if (thought.reductions && thought.reductions.length > 0) {
    return reductionChainToMermaid(thought.reductions, thought.reductionChain, includeLabels);
  }
  if (thought.decidabilityProof) {
    return decidabilityProofToMermaid(thought);
  }
  let mermaid = "graph TD\n";
  mermaid += `  type["${thought.thoughtType}"]
`;
  if (thought.keyInsight) {
    mermaid += `  insight["${thought.keyInsight.substring(0, 50)}..."]
`;
    mermaid += "  type --> insight\n";
  }
  return mermaid;
}
function turingMachineToMermaid(machine, includeLabels) {
  let mermaid = "stateDiagram-v2\n";
  mermaid += `  [*] --> ${sanitizeId(machine.initialState)}
`;
  for (const t of machine.transitions) {
    const label = includeLabels ? `${t.readSymbol}/${t.writeSymbol},${t.direction}` : "";
    mermaid += `  ${sanitizeId(t.fromState)} --> ${sanitizeId(t.toState)}`;
    if (label) {
      mermaid += `: ${label}`;
    }
    mermaid += "\n";
  }
  for (const acceptState of machine.acceptStates) {
    mermaid += `  ${sanitizeId(acceptState)} --> [*]
`;
  }
  return mermaid;
}
function reductionChainToMermaid(reductions, chain, includeLabels) {
  let mermaid = "graph LR\n";
  if (chain && chain.length > 0) {
    for (let i = 0; i < chain.length - 1; i++) {
      const from = sanitizeId(chain[i]);
      const to = sanitizeId(chain[i + 1]);
      const reduction = reductions.find((r) => r.fromProblem === chain[i] && r.toProblem === chain[i + 1]);
      const label = includeLabels && reduction ? `\u2264${reduction.type === "polynomial_time" ? "p" : "m"}` : "";
      mermaid += `  ${from}["${chain[i]}"] -->|${label}| ${to}["${chain[i + 1]}"]
`;
    }
  } else {
    for (const r of reductions) {
      const from = sanitizeId(r.fromProblem);
      const to = sanitizeId(r.toProblem);
      const label = includeLabels ? `\u2264${r.type === "polynomial_time" ? "p" : "m"}` : "";
      mermaid += `  ${from}["${r.fromProblem}"] -->|${label}| ${to}["${r.toProblem}"]
`;
    }
  }
  return mermaid;
}
function decidabilityProofToMermaid(thought, _includeLabels) {
  const proof = thought.decidabilityProof;
  let mermaid = "graph TD\n";
  mermaid += `  problem["Problem: ${proof.problem}"]
`;
  mermaid += `  method["Method: ${proof.method}"]
`;
  mermaid += `  conclusion["${proof.conclusion.toUpperCase()}"]
`;
  mermaid += "  problem --> method\n";
  mermaid += "  method --> conclusion\n";
  if (proof.conclusion === "undecidable") {
    mermaid += "  style conclusion fill:#ffcccc,stroke:#ff0000\n";
  } else if (proof.conclusion === "decidable") {
    mermaid += "  style conclusion fill:#ccffcc,stroke:#00ff00\n";
  }
  return mermaid;
}
function computabilityToDOT(thought, options) {
  const { includeLabels = true } = options;
  if (thought.currentMachine || thought.machines && thought.machines.length > 0) {
    return turingMachineToDOT(thought.currentMachine || thought.machines[0], includeLabels);
  }
  if (thought.reductions && thought.reductions.length > 0) {
    return reductionChainToDOT(thought.reductions, thought.reductionChain, includeLabels);
  }
  let dot = "digraph Computability {\n";
  dot += "  rankdir=TD;\n";
  dot += `  type [label="${thought.thoughtType}"];
`;
  dot += "}\n";
  return dot;
}
function turingMachineToDOT(machine, includeLabels) {
  let dot = `digraph TuringMachine {
`;
  dot += "  rankdir=LR;\n";
  dot += "  node [shape=circle];\n\n";
  dot += "  start [shape=point];\n";
  dot += `  start -> ${sanitizeId(machine.initialState)};

`;
  for (const state of machine.states) {
    const isAccept = machine.acceptStates.includes(state);
    const isReject = machine.rejectStates.includes(state);
    const shape = isAccept ? "doublecircle" : isReject ? "circle, style=filled, fillcolor=lightgray" : "circle";
    dot += `  ${sanitizeId(state)} [label="${state}", shape=${shape}];
`;
  }
  dot += "\n";
  for (const t of machine.transitions) {
    const label = includeLabels ? `${t.readSymbol}/${t.writeSymbol},${t.direction}` : "";
    dot += `  ${sanitizeId(t.fromState)} -> ${sanitizeId(t.toState)}`;
    if (label) {
      dot += ` [label="${label}"]`;
    }
    dot += ";\n";
  }
  dot += "}\n";
  return dot;
}
function reductionChainToDOT(reductions, _chain, includeLabels) {
  let dot = "digraph ReductionChain {\n";
  dot += "  rankdir=LR;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  const problems = /* @__PURE__ */ new Set();
  for (const r of reductions) {
    problems.add(r.fromProblem);
    problems.add(r.toProblem);
  }
  for (const p of problems) {
    dot += `  ${sanitizeId(p)} [label="${p}"];
`;
  }
  dot += "\n";
  for (const r of reductions) {
    const label = includeLabels ? `\u2264${r.type === "polynomial_time" ? "p" : "m"}` : "";
    dot += `  ${sanitizeId(r.fromProblem)} -> ${sanitizeId(r.toProblem)}`;
    if (label) {
      dot += ` [label="${label}"]`;
    }
    dot += ";\n";
  }
  dot += "}\n";
  return dot;
}
function computabilityToASCII(thought) {
  let ascii = "COMPUTABILITY ANALYSIS\n";
  ascii += "=".repeat(50) + "\n\n";
  ascii += `Type: ${thought.thoughtType}
`;
  if (thought.keyInsight) {
    ascii += `
Key Insight: ${thought.keyInsight}
`;
  }
  if (thought.currentMachine) {
    const m = thought.currentMachine;
    ascii += `
Turing Machine: ${m.name}
`;
    ascii += "-".repeat(30) + "\n";
    ascii += `States: {${m.states.join(", ")}}
`;
    ascii += `Initial: ${m.initialState}
`;
    ascii += `Accept: {${m.acceptStates.join(", ")}}
`;
    ascii += `Transitions: ${m.transitions.length}
`;
  }
  if (thought.computationTrace) {
    const trace = thought.computationTrace;
    ascii += `
Computation Trace:
`;
    ascii += "-".repeat(30) + "\n";
    ascii += `Input: ${trace.input}
`;
    ascii += `Steps: ${trace.totalSteps}
`;
    ascii += `Result: ${trace.result.toUpperCase()}
`;
    for (const step of trace.steps.slice(0, 5)) {
      const head = " ".repeat(step.headPosition) + "v";
      ascii += `  [${step.stepNumber}] ${step.state}: ${step.tapeContents}
`;
      ascii += `       ${head}
`;
    }
    if (trace.steps.length > 5) {
      ascii += `  ... (${trace.steps.length - 5} more steps)
`;
    }
  }
  if (thought.decidabilityProof) {
    const proof = thought.decidabilityProof;
    ascii += `
Decidability Analysis:
`;
    ascii += "-".repeat(30) + "\n";
    ascii += `Problem: ${proof.problem}
`;
    ascii += `Method: ${proof.method}
`;
    ascii += `Conclusion: ${proof.conclusion.toUpperCase()}
`;
    if (proof.proofSteps.length > 0) {
      ascii += "\nProof Steps:\n";
      for (let i = 0; i < Math.min(proof.proofSteps.length, 5); i++) {
        ascii += `  ${i + 1}. ${proof.proofSteps[i]}
`;
      }
    }
  }
  if (thought.reductions && thought.reductions.length > 0) {
    ascii += `
Reductions:
`;
    ascii += "-".repeat(30) + "\n";
    for (const r of thought.reductions) {
      ascii += `  ${r.fromProblem} \u2264${r.type === "polynomial_time" ? "p" : "m"} ${r.toProblem}
`;
    }
  }
  if (thought.diagonalization) {
    const diag = thought.diagonalization;
    ascii += `
Diagonalization Argument:
`;
    ascii += "-".repeat(30) + "\n";
    ascii += `Pattern: ${diag.pattern}
`;
    ascii += `Enumeration: ${diag.enumeration.description}
`;
    ascii += `Diagonal: ${diag.diagonalConstruction.description}
`;
    ascii += `Contradiction: ${diag.contradiction.impossibility}
`;
  }
  return ascii;
}
function computabilityToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width,
    svgHeight = 400
  } = options;
  const title = thought.currentMachine?.name || "Computability Analysis";
  if (thought.currentMachine) {
    return turingMachineToSVG(thought.currentMachine, { ...options, colorScheme, svgWidth, svgHeight });
  }
  const positions = /* @__PURE__ */ new Map();
  positions.set("type", {
    id: "type",
    x: svgWidth / 2 - 60,
    y: 80,
    width: 120,
    height: 40,
    label: thought.thoughtType,
    type: "type"
  });
  let svg = generateSVGHeader(svgWidth, svgHeight, title);
  svg += '\n  <!-- Nodes -->\n  <g class="nodes">';
  for (const [, pos] of positions) {
    svg += renderRectNode(pos, getNodeColor("primary", colorScheme));
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Type", value: thought.thoughtType },
      { label: "Uncertainty", value: thought.uncertainty.toFixed(2) }
    ];
    svg += renderMetricsPanel(svgWidth - 180, svgHeight - 80, metrics);
  }
  svg += "\n" + generateSVGFooter();
  return svg;
}
function turingMachineToSVG(machine, options) {
  const {
    colorScheme = "default",
    svgWidth = DEFAULT_SVG_OPTIONS.width,
    svgHeight = 400
  } = options;
  const positions = /* @__PURE__ */ new Map();
  const nodeRadius = 30;
  const spacing = 120;
  const cols = Math.ceil(Math.sqrt(machine.states.length));
  machine.states.forEach((state, i) => {
    const row = Math.floor(i / cols);
    const col = i % cols;
    positions.set(state, {
      id: state,
      x: 100 + col * spacing,
      y: 100 + row * spacing,
      width: nodeRadius * 2,
      height: nodeRadius * 2,
      label: state,
      type: machine.acceptStates.includes(state) ? "accept" : machine.rejectStates.includes(state) ? "reject" : "state"
    });
  });
  let svg = generateSVGHeader(svgWidth, svgHeight, machine.name);
  svg += '\n  <!-- Transitions -->\n  <g class="edges">';
  for (const t of machine.transitions) {
    const fromPos = positions.get(t.fromState);
    const toPos = positions.get(t.toState);
    if (fromPos && toPos) {
      svg += renderEdge(fromPos, toPos, { label: `${t.readSymbol}/${t.writeSymbol}` });
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- States -->\n  <g class="nodes">';
  for (const [, pos] of positions) {
    const colors = pos.type === "accept" ? getNodeColor("success", colorScheme) : pos.type === "reject" ? getNodeColor("danger", colorScheme) : getNodeColor("neutral", colorScheme);
    svg += renderEllipseNode(pos, colors);
  }
  svg += "\n  </g>";
  const legendItems = [
    { label: "State", color: getNodeColor("neutral", colorScheme) },
    { label: "Accept", color: getNodeColor("success", colorScheme) },
    { label: "Reject", color: getNodeColor("danger", colorScheme) }
  ];
  svg += renderLegend(20, svgHeight - 80, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function computabilityToGraphML(thought, options) {
  const nodes = [];
  const edges = [];
  let edgeId = 0;
  if (thought.currentMachine) {
    const m = thought.currentMachine;
    for (const state of m.states) {
      nodes.push({
        id: sanitizeId(state),
        label: state,
        type: m.acceptStates.includes(state) ? "accept" : m.rejectStates.includes(state) ? "reject" : "state"
      });
    }
    for (const t of m.transitions) {
      edges.push({
        id: `e${edgeId++}`,
        source: sanitizeId(t.fromState),
        target: sanitizeId(t.toState),
        label: options.includeLabels ? `${t.readSymbol}/${t.writeSymbol},${t.direction}` : void 0,
        directed: true
      });
    }
    return generateGraphML(nodes, edges, { graphName: m.name });
  }
  nodes.push({ id: "root", label: thought.thoughtType, type: "root" });
  return generateGraphML(nodes, edges, { graphName: "Computability Analysis" });
}
function computabilityToTikZ(thought, options) {
  const nodes = [];
  const edges = [];
  if (thought.currentMachine) {
    const m = thought.currentMachine;
    const cols = Math.ceil(Math.sqrt(m.states.length));
    m.states.forEach((state, i) => {
      const row = Math.floor(i / cols);
      const col = i % cols;
      nodes.push({
        id: sanitizeId(state),
        label: state,
        x: col * 3,
        y: -row * 2,
        shape: "ellipse",
        type: m.acceptStates.includes(state) ? "success" : m.rejectStates.includes(state) ? "danger" : "neutral"
      });
    });
    for (const t of m.transitions) {
      edges.push({
        source: sanitizeId(t.fromState),
        target: sanitizeId(t.toState),
        label: options.includeLabels ? `${t.readSymbol}/${t.writeSymbol}` : void 0,
        directed: true
      });
    }
    return generateTikZ(nodes, edges, { title: m.name, colorScheme: options.colorScheme });
  }
  nodes.push({ id: "root", label: thought.thoughtType, x: 0, y: 0, shape: "rectangle", type: "primary" });
  return generateTikZ(nodes, edges, { title: "Computability Analysis" });
}
function computabilityToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Computability Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  const typeBadge = renderBadge(thought.thoughtType, "primary");
  html += `<p>Analysis Type: ${typeBadge}</p>
`;
  if (includeMetrics) {
    html += '<div class="metrics-grid">';
    html += renderMetricCard("Thought Type", thought.thoughtType, "primary");
    html += renderMetricCard("Uncertainty", thought.uncertainty.toFixed(2), "info");
    if (thought.machines) {
      html += renderMetricCard("Machines", thought.machines.length, "info");
    }
    if (thought.reductions) {
      html += renderMetricCard("Reductions", thought.reductions.length, "info");
    }
    html += "</div>\n";
  }
  if (thought.currentMachine) {
    const m = thought.currentMachine;
    html += renderSection("Turing Machine", `
      <p><strong>Name:</strong> ${escapeHTML(m.name)}</p>
      <p><strong>Type:</strong> ${escapeHTML(m.type)}</p>
      <p><strong>States:</strong> {${m.states.map((s) => escapeHTML(s)).join(", ")}}</p>
      <p><strong>Initial State:</strong> ${escapeHTML(m.initialState)}</p>
      <p><strong>Accept States:</strong> {${m.acceptStates.map((s) => escapeHTML(s)).join(", ")}}</p>
      <p><strong>Transitions:</strong> ${m.transitions.length}</p>
    `, "\u{1F916}");
  }
  if (thought.decidabilityProof) {
    const proof = thought.decidabilityProof;
    const conclusionBadge = renderBadge(
      proof.conclusion.toUpperCase(),
      proof.conclusion === "decidable" ? "success" : proof.conclusion === "undecidable" ? "danger" : "warning"
    );
    html += renderSection("Decidability Analysis", `
      <p><strong>Problem:</strong> ${escapeHTML(proof.problem)}</p>
      <p><strong>Method:</strong> ${escapeHTML(proof.method)}</p>
      <p><strong>Conclusion:</strong> ${conclusionBadge}</p>
      ${proof.proofSteps.length > 0 ? renderList(proof.proofSteps) : ""}
    `, "\u{1F4CA}");
  }
  if (thought.reductions && thought.reductions.length > 0) {
    const rows = thought.reductions.map((r) => [
      escapeHTML(r.fromProblem),
      `\u2264${r.type === "polynomial_time" ? "p" : "m"}`,
      escapeHTML(r.toProblem)
    ]);
    html += renderSection("Reductions", renderTable(["From", "Type", "To"], rows), "\u{1F517}");
  }
  if (thought.keyInsight) {
    html += renderSection("Key Insight", `<p>${escapeHTML(thought.keyInsight)}</p>`, "\u{1F4A1}");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function computabilityToJSON(thought, options) {
  const { includeMetrics = true } = options;
  const graph = createJsonGraph("Computability Analysis", "computability");
  addNode(graph, {
    id: "root",
    label: thought.thoughtType,
    type: "thought-type",
    metadata: {
      uncertainty: thought.uncertainty,
      keyInsight: thought.keyInsight
    }
  });
  let edgeId = 0;
  if (thought.machines) {
    for (const m of thought.machines) {
      addNode(graph, {
        id: sanitizeId(m.id),
        label: m.name,
        type: "turing-machine",
        metadata: {
          states: m.states.length,
          transitions: m.transitions.length,
          type: m.type
        }
      });
      addEdge(graph, {
        id: `e${edgeId++}`,
        source: "root",
        target: sanitizeId(m.id),
        type: "contains"
      });
    }
  }
  if (thought.reductions) {
    for (const r of thought.reductions) {
      addNode(graph, {
        id: sanitizeId(r.id),
        label: `${r.fromProblem} \u2192 ${r.toProblem}`,
        type: "reduction",
        metadata: {
          reductionType: r.type,
          fromProblem: r.fromProblem,
          toProblem: r.toProblem
        }
      });
    }
  }
  if (includeMetrics) {
    addMetric(graph, "Thought Type", thought.thoughtType);
    addMetric(graph, "Uncertainty", thought.uncertainty);
    if (thought.machines) {
      addMetric(graph, "Machines", thought.machines.length);
    }
    if (thought.decidabilityProof) {
      addMetric(graph, "Conclusion", thought.decidabilityProof.conclusion);
    }
  }
  addLegendItem(graph, "Turing Machine", "#4A90E2");
  addLegendItem(graph, "Reduction", "#50C878");
  addLegendItem(graph, "Decidable", "#28A745");
  addLegendItem(graph, "Undecidable", "#DC3545");
  return serializeGraph(graph);
}
function computabilityToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  if (includeMetrics) {
    parts.push(section("Analysis", keyValueSection({
      "Type": thought.thoughtType,
      "Uncertainty": thought.uncertainty.toFixed(2),
      ...thought.keyInsight ? { "Key Insight": thought.keyInsight } : {}
    })));
  }
  if (thought.currentMachine) {
    const m = thought.currentMachine;
    parts.push(section("Turing Machine", keyValueSection({
      "Name": m.name,
      "Type": m.type,
      "States": `{${m.states.join(", ")}}`,
      "Initial State": m.initialState,
      "Accept States": `{${m.acceptStates.join(", ")}}`,
      "Transitions": m.transitions.length.toString()
    })));
    if (m.transitions.length > 0) {
      const transitionRows = m.transitions.map((t) => [
        t.fromState,
        t.readSymbol,
        t.toState,
        t.writeSymbol,
        t.direction
      ]);
      parts.push(section("Transition Function", table(
        ["From State", "Read", "To State", "Write", "Move"],
        transitionRows
      )));
    }
  }
  if (thought.decidabilityProof) {
    const proof = thought.decidabilityProof;
    parts.push(section("Decidability Analysis", keyValueSection({
      "Problem": proof.problem,
      "Method": proof.method,
      "Conclusion": `**${proof.conclusion.toUpperCase()}**`
    })));
    if (proof.proofSteps.length > 0) {
      parts.push(section("Proof Steps", list(proof.proofSteps.map((s, i) => `${i + 1}. ${s}`))));
    }
  }
  if (thought.reductions && thought.reductions.length > 0) {
    const reductionRows = thought.reductions.map((r) => [
      r.fromProblem,
      `\u2264${r.type === "polynomial_time" ? "p" : "m"}`,
      r.toProblem
    ]);
    parts.push(section("Reductions", table(["From Problem", "Reduction", "To Problem"], reductionRows)));
  }
  if (thought.diagonalization) {
    const d = thought.diagonalization;
    parts.push(section("Diagonalization Argument", keyValueSection({
      "Pattern": d.pattern,
      "Enumeration": d.enumeration.description,
      "Diagonal Construction": d.diagonalConstruction.description,
      "Contradiction": d.contradiction.impossibility
    })));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = computabilityToMermaid(thought, { ...options});
    parts.push(section("Diagram", mermaidBlock(mermaidDiagram)));
  }
  return document("Computability Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "computability",
      thoughtType: thought.thoughtType,
      uncertainty: thought.uncertainty
    }
  });
}
var init_computability = __esm({
  "src/export/visual/modes/computability.ts"() {
    init_esm_shims();
    init_utils();
    init_svg();
    init_graphml();
    init_tikz();
    init_html();
    init_json();
    init_markdown();
  }
});

// src/export/visual/modes/proof-decomposition.ts
function exportProofDecomposition(decomposition, options) {
  const {
    format,
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = 800,
    svgHeight = 600,
    nodeSpacing = 120
  } = options;
  switch (format) {
    case "mermaid":
      return proofDecompositionToMermaid(decomposition, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return proofDecompositionToDOT(decomposition, includeLabels, includeMetrics);
    case "ascii":
      return proofDecompositionToASCII(decomposition);
    case "svg":
      return proofDecompositionToSVG(decomposition, colorScheme, includeLabels, includeMetrics, svgWidth, svgHeight, nodeSpacing);
    case "html":
      return proofDecompositionToHTML(decomposition, options);
    case "modelica":
      return proofDecompositionToModelica(decomposition, options);
    case "uml":
      return proofDecompositionToUML(decomposition, options);
    case "json":
      return proofDecompositionToJSON(decomposition, options);
    case "markdown":
      return proofDecompositionToMarkdown(decomposition, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function getMermaidShape(type) {
  switch (type) {
    case "axiom":
      return ["([", "])"];
    // Stadium/rounded
    case "definition":
      return ["[[", "]]"];
    // Subroutine
    case "hypothesis":
      return ["[", "]"];
    // Rectangle
    case "lemma":
      return ["{{", "}}"];
    // Hexagon
    case "derived":
      return ["(", ")"];
    // Default rounded
    case "conclusion":
      return ["{", "}"];
    // Diamond shape via styling
    default:
      return ["(", ")"];
  }
}
function getNodeColor2(type, colorScheme) {
  if (colorScheme === "monochrome") return "#ffffff";
  const colors = colorScheme === "pastel" ? {
    axiom: "#c8e6c9",
    // Light green
    definition: "#e1bee7",
    // Light purple
    hypothesis: "#bbdefb",
    // Light blue
    lemma: "#fff9c4",
    // Light yellow
    derived: "#e0e0e0",
    // Light gray
    conclusion: "#d1c4e9"
    // Light purple
  } : {
    axiom: "#81c784",
    // Green
    definition: "#ba68c8",
    // Purple
    hypothesis: "#64b5f6",
    // Blue
    lemma: "#ffd54f",
    // Yellow
    derived: "#bdbdbd",
    // Gray
    conclusion: "#9575cd"
    // Purple
  };
  return colors[type] || colors.derived;
}
function proofDecompositionToMermaid(decomposition, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TD\n";
  if (decomposition.theorem) {
    mermaid += `  title["Proof: ${decomposition.theorem.substring(0, 50)}..."]
`;
    mermaid += "  style title fill:#f5f5f5,stroke:#333\n\n";
  }
  const axioms = decomposition.atoms.filter((a) => a.type === "axiom");
  const hypotheses = decomposition.atoms.filter((a) => a.type === "hypothesis");
  const derived = decomposition.atoms.filter((a) => a.type === "derived" || a.type === "lemma");
  const conclusions = decomposition.atoms.filter((a) => a.type === "conclusion");
  if (axioms.length > 0) {
    mermaid += '  subgraph Axioms["Axioms"]\n';
    for (const atom of axioms) {
      const nodeId = sanitizeId(atom.id);
      const label = includeLabels ? atom.statement.substring(0, 40) + (atom.statement.length > 40 ? "..." : "") : atom.id;
      const [open, close] = getMermaidShape(atom.type);
      mermaid += `    ${nodeId}${open}"${label}"${close}
`;
    }
    mermaid += "  end\n\n";
  }
  if (hypotheses.length > 0) {
    mermaid += '  subgraph Hypotheses["Hypotheses"]\n';
    for (const atom of hypotheses) {
      const nodeId = sanitizeId(atom.id);
      const label = includeLabels ? atom.statement.substring(0, 40) + (atom.statement.length > 40 ? "..." : "") : atom.id;
      const [open, close] = getMermaidShape(atom.type);
      mermaid += `    ${nodeId}${open}"${label}"${close}
`;
    }
    mermaid += "  end\n\n";
  }
  for (const atom of derived) {
    const nodeId = sanitizeId(atom.id);
    const label = includeLabels ? atom.statement.substring(0, 40) + (atom.statement.length > 40 ? "..." : "") : atom.id;
    const [open, close] = getMermaidShape(atom.type);
    mermaid += `  ${nodeId}${open}"${label}"${close}
`;
  }
  if (conclusions.length > 0) {
    mermaid += '\n  subgraph Conclusions["Conclusions"]\n';
    for (const atom of conclusions) {
      const nodeId = sanitizeId(atom.id);
      const label = includeLabels ? atom.statement.substring(0, 40) + (atom.statement.length > 40 ? "..." : "") : atom.id;
      mermaid += `    ${nodeId}{"${label}"}
`;
    }
    mermaid += "  end\n\n";
  }
  if (decomposition.dependencies && decomposition.dependencies.edges) {
    for (const edge of decomposition.dependencies.edges) {
      const fromId = sanitizeId(edge.from);
      const toId = sanitizeId(edge.to);
      const edgeLabel = edge.inferenceRule ? ` -->|${edge.inferenceRule}| ` : " --> ";
      mermaid += `  ${fromId}${edgeLabel}${toId}
`;
    }
  }
  if (decomposition.gaps && decomposition.gaps.length > 0) {
    mermaid += '\n  subgraph Gaps["Identified Gaps"]\n';
    for (const gap of decomposition.gaps) {
      const gapId = sanitizeId(gap.id);
      const label = gap.description.substring(0, 30) + "...";
      mermaid += `    ${gapId}["${label}"]
`;
      mermaid += `    ${sanitizeId(gap.location.from)} -.->|gap| ${gapId}
`;
      mermaid += `    ${gapId} -.-> ${sanitizeId(gap.location.to)}
`;
    }
    mermaid += "  end\n";
  }
  if (includeMetrics) {
    mermaid += '\n  subgraph Metrics["Metrics"]\n';
    mermaid += `    m1["Completeness: ${(decomposition.completeness * 100).toFixed(0)}%"]
`;
    mermaid += `    m2["Rigor: ${decomposition.rigorLevel}"]
`;
    mermaid += `    m3["Atoms: ${decomposition.atomCount}"]
`;
    mermaid += `    m4["Depth: ${decomposition.maxDependencyDepth}"]
`;
    mermaid += "  end\n";
  }
  if (colorScheme !== "monochrome") {
    mermaid += "\n";
    for (const atom of decomposition.atoms) {
      const nodeId = sanitizeId(atom.id);
      const color = getNodeColor2(atom.type, colorScheme);
      mermaid += `  style ${nodeId} fill:${color}
`;
    }
    if (decomposition.gaps) {
      for (const gap of decomposition.gaps) {
        const gapId = sanitizeId(gap.id);
        mermaid += `  style ${gapId} fill:#ffcdd2,stroke:#e53935,stroke-dasharray: 5 5
`;
      }
    }
  }
  return mermaid;
}
function getDOTShape(type) {
  switch (type) {
    case "axiom":
      return "ellipse";
    case "definition":
      return "box3d";
    case "hypothesis":
      return "box";
    case "lemma":
      return "hexagon";
    case "derived":
      return "box";
    case "conclusion":
      return "diamond";
    default:
      return "box";
  }
}
function proofDecompositionToDOT(decomposition, includeLabels, includeMetrics) {
  let dot = "digraph ProofDecomposition {\n";
  dot += "  rankdir=TB;\n";
  dot += "  compound=true;\n";
  dot += '  node [style="rounded,filled", fontname="Arial"];\n';
  dot += '  edge [fontname="Arial", fontsize=10];\n\n';
  if (decomposition.theorem) {
    dot += `  label="Proof: ${decomposition.theorem.substring(0, 60)}...";
`;
    dot += "  labelloc=t;\n";
    dot += "  fontsize=14;\n\n";
  }
  const axioms = decomposition.atoms.filter((a) => a.type === "axiom");
  const hypotheses = decomposition.atoms.filter((a) => a.type === "hypothesis");
  const conclusions = decomposition.atoms.filter((a) => a.type === "conclusion");
  if (axioms.length > 0) {
    dot += "  subgraph cluster_axioms {\n";
    dot += '    label="Axioms";\n';
    dot += "    style=filled;\n";
    dot += '    color="#e8f5e9";\n';
    for (const atom of axioms) {
      const nodeId = sanitizeId(atom.id);
      const label = includeLabels ? atom.statement.substring(0, 40).replace(/"/g, '\\"') : atom.id;
      dot += `    ${nodeId} [label="${label}", shape=${getDOTShape(atom.type)}, fillcolor="#81c784"];
`;
    }
    dot += "  }\n\n";
  }
  if (hypotheses.length > 0) {
    dot += "  subgraph cluster_hypotheses {\n";
    dot += '    label="Hypotheses";\n';
    dot += "    style=filled;\n";
    dot += '    color="#e3f2fd";\n';
    for (const atom of hypotheses) {
      const nodeId = sanitizeId(atom.id);
      const label = includeLabels ? atom.statement.substring(0, 40).replace(/"/g, '\\"') : atom.id;
      dot += `    ${nodeId} [label="${label}", shape=${getDOTShape(atom.type)}, fillcolor="#64b5f6"];
`;
    }
    dot += "  }\n\n";
  }
  const derived = decomposition.atoms.filter((a) => a.type === "derived" || a.type === "lemma");
  for (const atom of derived) {
    const nodeId = sanitizeId(atom.id);
    const label = includeLabels ? atom.statement.substring(0, 40).replace(/"/g, '\\"') : atom.id;
    const color = atom.type === "lemma" ? "#ffd54f" : "#bdbdbd";
    dot += `  ${nodeId} [label="${label}", shape=${getDOTShape(atom.type)}, fillcolor="${color}"];
`;
  }
  dot += "\n";
  if (conclusions.length > 0) {
    dot += "  subgraph cluster_conclusions {\n";
    dot += '    label="Conclusions";\n';
    dot += "    style=filled;\n";
    dot += '    color="#ede7f6";\n';
    for (const atom of conclusions) {
      const nodeId = sanitizeId(atom.id);
      const label = includeLabels ? atom.statement.substring(0, 40).replace(/"/g, '\\"') : atom.id;
      dot += `    ${nodeId} [label="${label}", shape=${getDOTShape(atom.type)}, fillcolor="#9575cd"];
`;
    }
    dot += "  }\n\n";
  }
  if (decomposition.dependencies && decomposition.dependencies.edges) {
    for (const edge of decomposition.dependencies.edges) {
      const fromId = sanitizeId(edge.from);
      const toId = sanitizeId(edge.to);
      const edgeLabel = edge.inferenceRule ? ` [label="${edge.inferenceRule}"]` : "";
      dot += `  ${fromId} -> ${toId}${edgeLabel};
`;
    }
  }
  if (decomposition.gaps && decomposition.gaps.length > 0) {
    dot += "\n  // Gaps (dashed red)\n";
    for (const gap of decomposition.gaps) {
      const gapId = sanitizeId(gap.id);
      const label = gap.description.substring(0, 30).replace(/"/g, '\\"');
      dot += `  ${gapId} [label="${label}", shape=note, fillcolor="#ffcdd2", style="dashed,filled"];
`;
      dot += `  ${sanitizeId(gap.location.from)} -> ${gapId} [style=dashed, color=red];
`;
      dot += `  ${gapId} -> ${sanitizeId(gap.location.to)} [style=dashed, color=red];
`;
    }
  }
  if (includeMetrics) {
    dot += "\n  // Metrics\n";
    dot += "  subgraph cluster_metrics {\n";
    dot += '    label="Metrics";\n';
    dot += "    style=filled;\n";
    dot += '    color="#f5f5f5";\n';
    dot += `    metrics [label="Completeness: ${(decomposition.completeness * 100).toFixed(0)}%\\nRigor: ${decomposition.rigorLevel}\\nAtoms: ${decomposition.atomCount}\\nDepth: ${decomposition.maxDependencyDepth}", shape=note];
`;
    dot += "  }\n";
  }
  dot += "}\n";
  return dot;
}
function proofDecompositionToASCII(decomposition) {
  let ascii = "";
  ascii += "\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n";
  ascii += "\u2551                    PROOF DECOMPOSITION                         \u2551\n";
  ascii += "\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D\n\n";
  if (decomposition.theorem) {
    ascii += `Theorem: ${decomposition.theorem}

`;
  }
  ascii += "\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n";
  ascii += "\u2502 METRICS                                                         \u2502\n";
  ascii += "\u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n";
  ascii += `\u2502 Completeness: ${(decomposition.completeness * 100).toFixed(0)}%`.padEnd(66) + "\u2502\n";
  ascii += `\u2502 Rigor Level:  ${decomposition.rigorLevel}`.padEnd(66) + "\u2502\n";
  ascii += `\u2502 Atom Count:   ${decomposition.atomCount}`.padEnd(66) + "\u2502\n";
  ascii += `\u2502 Max Depth:    ${decomposition.maxDependencyDepth}`.padEnd(66) + "\u2502\n";
  ascii += "\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n";
  const axioms = decomposition.atoms.filter((a) => a.type === "axiom");
  if (axioms.length > 0) {
    ascii += "\u250C\u2500 AXIOMS \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n";
    for (const atom of axioms) {
      const marker = "\u25C9";
      const line = `\u2502 ${marker} [${atom.id}] ${atom.statement}`;
      ascii += line.substring(0, 65).padEnd(66) + "\u2502\n";
    }
    ascii += "\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n";
  }
  const hypotheses = decomposition.atoms.filter((a) => a.type === "hypothesis");
  if (hypotheses.length > 0) {
    ascii += "\u250C\u2500 HYPOTHESES \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n";
    for (const atom of hypotheses) {
      const marker = "\u25C6";
      const line = `\u2502 ${marker} [${atom.id}] ${atom.statement}`;
      ascii += line.substring(0, 65).padEnd(66) + "\u2502\n";
    }
    ascii += "\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n";
  }
  const derived = decomposition.atoms.filter((a) => a.type === "derived" || a.type === "lemma");
  if (derived.length > 0) {
    ascii += "\u250C\u2500 DERIVATION CHAIN \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n";
    for (const atom of derived) {
      const marker = atom.type === "lemma" ? "\u25C7" : "\u25CB";
      const deps = atom.derivedFrom && atom.derivedFrom.length > 0 ? ` \u2190 [${atom.derivedFrom.join(", ")}]` : "";
      const line = `\u2502 ${marker} [${atom.id}] ${atom.statement}${deps}`;
      ascii += line.substring(0, 65).padEnd(66) + "\u2502\n";
      if (atom.usedInferenceRule) {
        ascii += `\u2502   \u2514\u2500 Rule: ${atom.usedInferenceRule}`.padEnd(66) + "\u2502\n";
      }
    }
    ascii += "\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n";
  }
  const conclusions = decomposition.atoms.filter((a) => a.type === "conclusion");
  if (conclusions.length > 0) {
    ascii += "\u250C\u2500 CONCLUSIONS \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n";
    for (const atom of conclusions) {
      const marker = "\u2605";
      const deps = atom.derivedFrom && atom.derivedFrom.length > 0 ? ` \u2190 [${atom.derivedFrom.join(", ")}]` : "";
      const line = `\u2502 ${marker} [${atom.id}] ${atom.statement}${deps}`;
      ascii += line.substring(0, 65).padEnd(66) + "\u2502\n";
    }
    ascii += "\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n";
  }
  if (decomposition.gaps && decomposition.gaps.length > 0) {
    ascii += "\u250C\u2500 GAPS (Missing Steps) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n";
    for (const gap of decomposition.gaps) {
      const severityIcon = gap.severity === "critical" ? "\u26A0" : gap.severity === "significant" ? "!" : "?";
      ascii += `\u2502 ${severityIcon} [${gap.type}] ${gap.description}`.substring(0, 65).padEnd(66) + "\u2502\n";
      ascii += `\u2502   Between: ${gap.location.from} \u2192 ${gap.location.to}`.padEnd(66) + "\u2502\n";
      if (gap.suggestedFix) {
        ascii += `\u2502   Fix: ${gap.suggestedFix}`.substring(0, 65).padEnd(66) + "\u2502\n";
      }
    }
    ascii += "\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n";
  }
  if (decomposition.implicitAssumptions && decomposition.implicitAssumptions.length > 0) {
    ascii += "\u250C\u2500 IMPLICIT ASSUMPTIONS \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n";
    for (const assumption of decomposition.implicitAssumptions) {
      ascii += `\u2502 \u2022 [${assumption.type}]`.padEnd(66) + "\u2502\n";
      ascii += `\u2502   ${assumption.statement}`.substring(0, 65).padEnd(66) + "\u2502\n";
      if (assumption.shouldBeExplicit) {
        ascii += `\u2502   \u26A0 Should be explicit`.padEnd(66) + "\u2502\n";
      }
    }
    ascii += "\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n";
  }
  if (decomposition.dependencies && decomposition.dependencies.edges.length > 0) {
    ascii += "\u250C\u2500 DEPENDENCY TREE \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n";
    ascii += "\u2502                                                                    \u2502\n";
    const roots = decomposition.dependencies.roots || [];
    for (const rootId of roots) {
      ascii += buildASCIITree(rootId, decomposition, 0, /* @__PURE__ */ new Set());
    }
    ascii += "\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n";
  }
  return ascii;
}
function buildASCIITree(nodeId, decomposition, depth, visited) {
  if (visited.has(nodeId) || depth > 10) {
    return "";
  }
  visited.add(nodeId);
  const indent = "\u2502   ".repeat(depth);
  const atom = decomposition.atoms.find((a) => a.id === nodeId);
  if (!atom) return "";
  const typeMarker = {
    axiom: "\u25C9",
    hypothesis: "\u25C6",
    definition: "\u25A3",
    lemma: "\u25C7",
    derived: "\u25CB",
    conclusion: "\u2605"
  }[atom.type] || "?";
  let result = `\u2502 ${indent}${typeMarker} ${atom.id}
`;
  const children = decomposition.dependencies.edges.filter((e) => e.from === nodeId).map((e) => e.to);
  for (const childId of children) {
    result += buildASCIITree(childId, decomposition, depth + 1, visited);
  }
  return result;
}
function getSVGColors(type, colorScheme) {
  if (colorScheme === "monochrome") {
    return { fill: "#ffffff", stroke: "#333333" };
  }
  const colors = colorScheme === "pastel" ? {
    axiom: { fill: "#c8e6c9", stroke: "#4caf50" },
    definition: { fill: "#e1bee7", stroke: "#9c27b0" },
    hypothesis: { fill: "#bbdefb", stroke: "#2196f3" },
    lemma: { fill: "#fff9c4", stroke: "#ffc107" },
    derived: { fill: "#e0e0e0", stroke: "#757575" },
    conclusion: { fill: "#d1c4e9", stroke: "#673ab7" }
  } : {
    axiom: { fill: "#81c784", stroke: "#388e3c" },
    definition: { fill: "#ba68c8", stroke: "#7b1fa2" },
    hypothesis: { fill: "#64b5f6", stroke: "#1976d2" },
    lemma: { fill: "#ffd54f", stroke: "#ffa000" },
    derived: { fill: "#bdbdbd", stroke: "#616161" },
    conclusion: { fill: "#9575cd", stroke: "#512da8" }
  };
  return colors[type] || colors.derived;
}
function escapeSVGText2(text) {
  return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
}
function truncateText2(text, maxChars) {
  if (text.length <= maxChars) return text;
  return text.substring(0, maxChars - 3) + "...";
}
function renderSVGNode(pos, colorScheme) {
  const colors = getSVGColors(pos.type, colorScheme);
  const escapedLabel = escapeSVGText2(truncateText2(pos.label, 30));
  switch (pos.type) {
    case "axiom":
      return `
    <g class="node node-axiom" data-id="${sanitizeId(pos.id)}">
      <rect x="${pos.x}" y="${pos.y}" width="${pos.width}" height="${pos.height}"
            rx="20" ry="20" fill="${colors.fill}" stroke="${colors.stroke}" stroke-width="2"/>
      <text x="${pos.x + pos.width / 2}" y="${pos.y + pos.height / 2 + 5}"
            text-anchor="middle" font-family="Arial, sans-serif" font-size="12">${escapedLabel}</text>
    </g>`;
    case "hypothesis":
      return `
    <g class="node node-hypothesis" data-id="${sanitizeId(pos.id)}">
      <rect x="${pos.x}" y="${pos.y}" width="${pos.width}" height="${pos.height}"
            rx="4" ry="4" fill="${colors.fill}" stroke="${colors.stroke}" stroke-width="2"/>
      <text x="${pos.x + pos.width / 2}" y="${pos.y + pos.height / 2 + 5}"
            text-anchor="middle" font-family="Arial, sans-serif" font-size="12">${escapedLabel}</text>
    </g>`;
    case "conclusion": {
      const cx = pos.x + pos.width / 2;
      const cy = pos.y + pos.height / 2;
      return `
    <g class="node node-conclusion" data-id="${sanitizeId(pos.id)}">
      <polygon points="${cx},${pos.y} ${pos.x + pos.width},${cy} ${cx},${pos.y + pos.height} ${pos.x},${cy}"
               fill="${colors.fill}" stroke="${colors.stroke}" stroke-width="2"/>
      <text x="${cx}" y="${cy + 5}"
            text-anchor="middle" font-family="Arial, sans-serif" font-size="12">${escapedLabel}</text>
    </g>`;
    }
    case "lemma": {
      const hx = pos.x + pos.width / 2;
      const hy = pos.y + pos.height / 2;
      const w = pos.width;
      const h = pos.height;
      return `
    <g class="node node-lemma" data-id="${sanitizeId(pos.id)}">
      <polygon points="${pos.x + w * 0.25},${pos.y} ${pos.x + w * 0.75},${pos.y} ${pos.x + w},${hy} ${pos.x + w * 0.75},${pos.y + h} ${pos.x + w * 0.25},${pos.y + h} ${pos.x},${hy}"
               fill="${colors.fill}" stroke="${colors.stroke}" stroke-width="2"/>
      <text x="${hx}" y="${hy + 5}"
            text-anchor="middle" font-family="Arial, sans-serif" font-size="12">${escapedLabel}</text>
    </g>`;
    }
    case "definition":
      return `
    <g class="node node-definition" data-id="${sanitizeId(pos.id)}">
      <rect x="${pos.x}" y="${pos.y}" width="${pos.width}" height="${pos.height}"
            rx="4" ry="4" fill="${colors.fill}" stroke="${colors.stroke}" stroke-width="2"/>
      <rect x="${pos.x + 4}" y="${pos.y + 4}" width="${pos.width - 8}" height="${pos.height - 8}"
            rx="2" ry="2" fill="none" stroke="${colors.stroke}" stroke-width="1"/>
      <text x="${pos.x + pos.width / 2}" y="${pos.y + pos.height / 2 + 5}"
            text-anchor="middle" font-family="Arial, sans-serif" font-size="12">${escapedLabel}</text>
    </g>`;
    default:
      return `
    <g class="node node-derived" data-id="${sanitizeId(pos.id)}">
      <rect x="${pos.x}" y="${pos.y}" width="${pos.width}" height="${pos.height}"
            rx="8" ry="8" fill="${colors.fill}" stroke="${colors.stroke}" stroke-width="2"/>
      <text x="${pos.x + pos.width / 2}" y="${pos.y + pos.height / 2 + 5}"
            text-anchor="middle" font-family="Arial, sans-serif" font-size="12">${escapedLabel}</text>
    </g>`;
  }
}
function renderSVGEdge(fromPos, toPos, label, isDashed = false, color = "#333333") {
  const fromX = fromPos.x + fromPos.width / 2;
  const fromY = fromPos.y + fromPos.height;
  const toX = toPos.x + toPos.width / 2;
  const toY = toPos.y;
  const midY = (fromY + toY) / 2;
  const path4 = `M ${fromX} ${fromY} C ${fromX} ${midY}, ${toX} ${midY}, ${toX} ${toY - 8}`;
  const dashStyle = isDashed ? 'stroke-dasharray="5,5"' : "";
  const labelElement = label ? `<text x="${(fromX + toX) / 2}" y="${midY - 5}" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" fill="#666">${escapeSVGText2(label)}</text>` : "";
  return `
    <g class="edge">
      <path d="${path4}" fill="none" stroke="${color}" stroke-width="2" ${dashStyle} marker-end="url(#arrowhead)"/>
      ${labelElement}
    </g>`;
}
function proofDecompositionToSVG(decomposition, colorScheme, includeLabels, includeMetrics, width, height, nodeSpacing) {
  const nodeWidth = 150;
  const nodeHeight = 40;
  const padding = 40;
  const layerSpacing = nodeSpacing;
  const axioms = decomposition.atoms.filter((a) => a.type === "axiom");
  const hypotheses = decomposition.atoms.filter((a) => a.type === "hypothesis");
  const derived = decomposition.atoms.filter((a) => a.type === "derived" || a.type === "lemma");
  const conclusions = decomposition.atoms.filter((a) => a.type === "conclusion");
  const nodePositions = /* @__PURE__ */ new Map();
  let currentY = padding;
  const layer1 = [...axioms, ...hypotheses];
  const layer1Width = layer1.length * (nodeWidth + 20) - 20;
  let startX = (width - layer1Width) / 2;
  for (const atom of layer1) {
    const label = includeLabels ? atom.statement : atom.id;
    nodePositions.set(atom.id, {
      id: atom.id,
      x: startX,
      y: currentY,
      width: nodeWidth,
      height: nodeHeight,
      type: atom.type,
      label
    });
    startX += nodeWidth + 20;
  }
  currentY += nodeHeight + layerSpacing;
  const derivedWidth = derived.length * (nodeWidth + 20) - 20;
  startX = (width - derivedWidth) / 2;
  for (const atom of derived) {
    const label = includeLabels ? atom.statement : atom.id;
    nodePositions.set(atom.id, {
      id: atom.id,
      x: startX,
      y: currentY,
      width: nodeWidth,
      height: nodeHeight,
      type: atom.type,
      label
    });
    startX += nodeWidth + 20;
  }
  currentY += nodeHeight + layerSpacing;
  const conclusionsWidth = conclusions.length * (nodeWidth + 20) - 20;
  startX = (width - conclusionsWidth) / 2;
  for (const atom of conclusions) {
    const label = includeLabels ? atom.statement : atom.id;
    nodePositions.set(atom.id, {
      id: atom.id,
      x: startX,
      y: currentY,
      width: nodeWidth,
      height: nodeHeight,
      type: atom.type,
      label
    });
    startX += nodeWidth + 20;
  }
  currentY += nodeHeight + padding;
  const actualHeight = Math.max(height, currentY);
  let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${width} ${actualHeight}" width="${width}" height="${actualHeight}">
  <defs>
    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" fill="#333"/>
    </marker>
    <marker id="arrowhead-red" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" fill="#e53935"/>
    </marker>
  </defs>

  <style>
    .title { font-family: Arial, sans-serif; font-size: 16px; font-weight: bold; }
    .section-label { font-family: Arial, sans-serif; font-size: 12px; fill: #666; font-style: italic; }
    .metrics { font-family: Arial, sans-serif; font-size: 11px; fill: #444; }
  </style>

  <!-- Background -->
  <rect width="100%" height="100%" fill="#fafafa"/>
`;
  if (decomposition.theorem) {
    svg += `
  <!-- Title -->
  <text x="${width / 2}" y="25" text-anchor="middle" class="title">Proof: ${escapeSVGText2(truncateText2(decomposition.theorem, 60))}</text>
`;
  }
  if (decomposition.dependencies && decomposition.dependencies.edges) {
    svg += '\n  <!-- Edges -->\n  <g class="edges">';
    for (const edge of decomposition.dependencies.edges) {
      const fromPos = nodePositions.get(edge.from);
      const toPos = nodePositions.get(edge.to);
      if (fromPos && toPos) {
        svg += renderSVGEdge(fromPos, toPos, edge.inferenceRule);
      }
    }
    svg += "\n  </g>\n";
  }
  if (decomposition.gaps && decomposition.gaps.length > 0) {
    svg += '\n  <!-- Gap Edges -->\n  <g class="gap-edges">';
    for (const gap of decomposition.gaps) {
      const fromPos = nodePositions.get(gap.location.from);
      const toPos = nodePositions.get(gap.location.to);
      if (fromPos && toPos) {
        svg += renderSVGEdge(fromPos, toPos, "GAP: " + truncateText2(gap.description, 20), true, "#e53935");
      }
    }
    svg += "\n  </g>\n";
  }
  svg += '\n  <!-- Nodes -->\n  <g class="nodes">';
  for (const [, pos] of nodePositions) {
    svg += renderSVGNode(pos, colorScheme);
  }
  svg += "\n  </g>\n";
  if (includeMetrics) {
    const metricsX = width - 180;
    const metricsY = actualHeight - 100;
    svg += `
  <!-- Metrics -->
  <g class="metrics-panel">
    <rect x="${metricsX}" y="${metricsY}" width="160" height="90" rx="8" fill="#f5f5f5" stroke="#ddd" stroke-width="1"/>
    <text x="${metricsX + 10}" y="${metricsY + 20}" class="metrics" font-weight="bold">Metrics</text>
    <text x="${metricsX + 10}" y="${metricsY + 38}" class="metrics">Completeness: ${(decomposition.completeness * 100).toFixed(0)}%</text>
    <text x="${metricsX + 10}" y="${metricsY + 54}" class="metrics">Rigor: ${decomposition.rigorLevel}</text>
    <text x="${metricsX + 10}" y="${metricsY + 70}" class="metrics">Atoms: ${decomposition.atomCount}</text>
    <text x="${metricsX + 10}" y="${metricsY + 86}" class="metrics">Depth: ${decomposition.maxDependencyDepth}</text>
  </g>
`;
  }
  svg += `
  <!-- Legend -->
  <g class="legend" transform="translate(20, ${actualHeight - 100})">
    <text x="0" y="0" font-family="Arial, sans-serif" font-size="11" font-weight="bold">Legend</text>
    <rect x="0" y="10" width="20" height="12" rx="6" fill="${getSVGColors("axiom", colorScheme).fill}" stroke="${getSVGColors("axiom", colorScheme).stroke}"/>
    <text x="25" y="20" font-family="Arial, sans-serif" font-size="10">Axiom</text>
    <rect x="0" y="28" width="20" height="12" rx="2" fill="${getSVGColors("hypothesis", colorScheme).fill}" stroke="${getSVGColors("hypothesis", colorScheme).stroke}"/>
    <text x="25" y="38" font-family="Arial, sans-serif" font-size="10">Hypothesis</text>
    <rect x="0" y="46" width="20" height="12" rx="4" fill="${getSVGColors("derived", colorScheme).fill}" stroke="${getSVGColors("derived", colorScheme).stroke}"/>
    <text x="25" y="56" font-family="Arial, sans-serif" font-size="10">Derived</text>
    <polygon points="10,64 20,70 10,76 0,70" fill="${getSVGColors("conclusion", colorScheme).fill}" stroke="${getSVGColors("conclusion", colorScheme).stroke}"/>
    <text x="25" y="74" font-family="Arial, sans-serif" font-size="10">Conclusion</text>
  </g>
`;
  svg += "</svg>";
  return svg;
}
function proofDecompositionToHTML(decomposition, options) {
  const { colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  const theme = colorScheme === "monochrome" ? "light" : "light";
  let html = generateHTMLHeader("Proof Decomposition", { standalone: true, theme });
  if (decomposition.theorem) {
    html += renderSection(
      "Theorem",
      `<p class="theorem-statement">${escapeHTML(decomposition.theorem)}</p>`,
      "info"
    );
  }
  if (includeMetrics) {
    const metricsHTML = `
      <div class="metrics-grid">
        ${renderMetricCard("Completeness", `${(decomposition.completeness * 100).toFixed(0)}%`, renderProgressBar(decomposition.completeness * 100))}
        ${renderMetricCard("Rigor Level", decomposition.rigorLevel)}
        ${renderMetricCard("Atom Count", decomposition.atomCount.toString())}
        ${renderMetricCard("Max Depth", decomposition.maxDependencyDepth.toString())}
      </div>
    `;
    html += renderSection("Metrics", metricsHTML);
  }
  const axioms = decomposition.atoms.filter((a) => a.type === "axiom");
  if (axioms.length > 0) {
    const axiomsRows = axioms.map((atom) => [
      atom.id,
      includeLabels ? atom.statement : atom.id,
      atom.type
    ]);
    html += renderSection("Axioms", renderTable(["ID", "Statement", "Type"], axiomsRows), "success");
  }
  const hypotheses = decomposition.atoms.filter((a) => a.type === "hypothesis");
  if (hypotheses.length > 0) {
    const hypothesesRows = hypotheses.map((atom) => [
      atom.id,
      includeLabels ? atom.statement : atom.id,
      atom.type
    ]);
    html += renderSection("Hypotheses", renderTable(["ID", "Statement", "Type"], hypothesesRows), "info");
  }
  const derived = decomposition.atoms.filter((a) => a.type === "derived" || a.type === "lemma");
  if (derived.length > 0) {
    const derivedRows = derived.map((atom) => {
      const deps = atom.derivedFrom && atom.derivedFrom.length > 0 ? atom.derivedFrom.join(", ") : "None";
      const rule = atom.usedInferenceRule ? atom.usedInferenceRule : "N/A";
      return [
        atom.id,
        includeLabels ? atom.statement : atom.id,
        atom.type,
        deps,
        rule
      ];
    });
    html += renderSection(
      "Derivation Chain",
      renderTable(["ID", "Statement", "Type", "Derived From", "Inference Rule"], derivedRows)
    );
  }
  const conclusions = decomposition.atoms.filter((a) => a.type === "conclusion");
  if (conclusions.length > 0) {
    const conclusionsRows = conclusions.map((atom) => {
      const deps = atom.derivedFrom && atom.derivedFrom.length > 0 ? atom.derivedFrom.join(", ") : "None";
      return [
        atom.id,
        includeLabels ? atom.statement : atom.id,
        atom.type,
        deps
      ];
    });
    html += renderSection("Conclusions", renderTable(["ID", "Statement", "Type", "Derived From"], conclusionsRows), "primary");
  }
  if (decomposition.dependencies && decomposition.dependencies.edges && decomposition.dependencies.edges.length > 0) {
    const depsRows = decomposition.dependencies.edges.map((edge) => [
      edge.from,
      edge.to,
      edge.inferenceRule ? edge.inferenceRule : "Direct"
    ]);
    html += renderSection("Dependencies", renderTable(["From", "To", "Inference Rule"], depsRows));
  }
  if (decomposition.gaps && decomposition.gaps.length > 0) {
    const gapsRows = decomposition.gaps.map((gap) => [
      gap.id,
      gap.type,
      gap.severity,
      gap.description,
      `${gap.location.from} \u2192 ${gap.location.to}`,
      gap.suggestedFix ? gap.suggestedFix : "N/A"
    ]);
    html += renderSection("Gaps (Missing Steps)", renderTable(["ID", "Type", "Severity", "Description", "Location", "Suggested Fix"], gapsRows), "danger");
  }
  if (decomposition.implicitAssumptions && decomposition.implicitAssumptions.length > 0) {
    const assumptionsRows = decomposition.implicitAssumptions.map((assumption) => [
      assumption.type,
      assumption.statement,
      assumption.shouldBeExplicit ? "Yes" : "No",
      assumption.suggestedFormulation
    ]);
    html += renderSection("Implicit Assumptions", renderTable(["Type", "Statement", "Should Be Explicit", "Suggested Formulation"], assumptionsRows), "warning");
  }
  html += generateHTMLFooter(true);
  return html;
}
function proofDecompositionToModelica(decomposition, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const packageName = "ProofDecomposition";
  let modelica = `package ${packageName}
`;
  modelica += `  "Proof decomposition structure for: ${escapeModelicaString(decomposition.theorem || "theorem")}"

`;
  if (decomposition.theorem) {
    modelica += `  record Theorem "Main theorem being proved"
`;
    modelica += `    String statement = "${escapeModelicaString(decomposition.theorem)}";
`;
    modelica += `    Real completeness = ${decomposition.completeness};
`;
    modelica += `    String rigorLevel = "${escapeModelicaString(decomposition.rigorLevel)}";
`;
    modelica += `    Integer atomCount = ${decomposition.atomCount};
`;
    modelica += `    Integer maxDepth = ${decomposition.maxDependencyDepth};
`;
    modelica += `  end Theorem;

`;
  }
  modelica += `  record AtomicStatement "Individual statement in the proof"
`;
  modelica += `    String id "Unique identifier";
`;
  modelica += `    String statementType "Type: axiom, hypothesis, derived, lemma, conclusion, definition";
`;
  modelica += `    String statement "The mathematical statement";
`;
  modelica += `  end AtomicStatement;

`;
  const axioms = decomposition.atoms.filter((a) => a.type === "axiom");
  const hypotheses = decomposition.atoms.filter((a) => a.type === "hypothesis");
  const lemmas = decomposition.atoms.filter((a) => a.type === "lemma");
  const derived = decomposition.atoms.filter((a) => a.type === "derived");
  const conclusions = decomposition.atoms.filter((a) => a.type === "conclusion");
  if (axioms.length > 0) {
    modelica += `  // Axioms (${axioms.length})
`;
    for (const atom of axioms) {
      const atomId = sanitizeModelicaId(atom.id);
      const statement = includeLabels ? escapeModelicaString(atom.statement) : atom.id;
      modelica += `  AtomicStatement ${atomId}(
`;
      modelica += `    id="${escapeModelicaString(atom.id)}",
`;
      modelica += `    statementType="${atom.type}",
`;
      modelica += `    statement="${statement}"
`;
      modelica += `  );
`;
    }
    modelica += "\n";
  }
  if (hypotheses.length > 0) {
    modelica += `  // Hypotheses (${hypotheses.length})
`;
    for (const atom of hypotheses) {
      const atomId = sanitizeModelicaId(atom.id);
      const statement = includeLabels ? escapeModelicaString(atom.statement) : atom.id;
      modelica += `  AtomicStatement ${atomId}(
`;
      modelica += `    id="${escapeModelicaString(atom.id)}",
`;
      modelica += `    statementType="${atom.type}",
`;
      modelica += `    statement="${statement}"
`;
      modelica += `  );
`;
    }
    modelica += "\n";
  }
  if (lemmas.length > 0) {
    modelica += `  // Lemmas (${lemmas.length})
`;
    for (const atom of lemmas) {
      const atomId = sanitizeModelicaId(atom.id);
      const statement = includeLabels ? escapeModelicaString(atom.statement) : atom.id;
      modelica += `  AtomicStatement ${atomId}(
`;
      modelica += `    id="${escapeModelicaString(atom.id)}",
`;
      modelica += `    statementType="${atom.type}",
`;
      modelica += `    statement="${statement}"
`;
      modelica += `  );
`;
    }
    modelica += "\n";
  }
  if (derived.length > 0) {
    modelica += `  // Derived Statements (${derived.length})
`;
    for (const atom of derived) {
      const atomId = sanitizeModelicaId(atom.id);
      const statement = includeLabels ? escapeModelicaString(atom.statement) : atom.id;
      modelica += `  AtomicStatement ${atomId}(
`;
      modelica += `    id="${escapeModelicaString(atom.id)}",
`;
      modelica += `    statementType="${atom.type}",
`;
      modelica += `    statement="${statement}"
`;
      modelica += `  );
`;
    }
    modelica += "\n";
  }
  if (conclusions.length > 0) {
    modelica += `  // Conclusions (${conclusions.length})
`;
    for (const atom of conclusions) {
      const atomId = sanitizeModelicaId(atom.id);
      const statement = includeLabels ? escapeModelicaString(atom.statement) : atom.id;
      modelica += `  AtomicStatement ${atomId}(
`;
      modelica += `    id="${escapeModelicaString(atom.id)}",
`;
      modelica += `    statementType="${atom.type}",
`;
      modelica += `    statement="${statement}"
`;
      modelica += `  );
`;
    }
    modelica += "\n";
  }
  if (decomposition.dependencies && decomposition.dependencies.edges && decomposition.dependencies.edges.length > 0) {
    modelica += `  // Dependencies (${decomposition.dependencies.edges.length} edges)
`;
    modelica += `  /* Proof structure:
`;
    for (const edge of decomposition.dependencies.edges) {
      const rule = edge.inferenceRule ? ` [${edge.inferenceRule}]` : "";
      modelica += `   * ${edge.from} -> ${edge.to}${rule}
`;
    }
    modelica += `   */

`;
  }
  if (decomposition.gaps && decomposition.gaps.length > 0) {
    modelica += `  // Identified Gaps (${decomposition.gaps.length})
`;
    modelica += `  /* Gaps in proof:
`;
    for (const gap of decomposition.gaps) {
      modelica += `   * [${gap.severity}] ${gap.type}: ${gap.description}
`;
      modelica += `   *   Location: ${gap.location.from} -> ${gap.location.to}
`;
      if (gap.suggestedFix) {
        modelica += `   *   Fix: ${gap.suggestedFix}
`;
      }
    }
    modelica += `   */

`;
  }
  if (includeMetrics) {
    modelica += `  annotation(
`;
    modelica += `    Documentation(info="<html>
`;
    modelica += `      <h3>Proof Metrics</h3>
`;
    modelica += `      <ul>
`;
    modelica += `        <li>Completeness: ${(decomposition.completeness * 100).toFixed(0)}%</li>
`;
    modelica += `        <li>Rigor Level: ${decomposition.rigorLevel}</li>
`;
    modelica += `        <li>Atom Count: ${decomposition.atomCount}</li>
`;
    modelica += `        <li>Max Dependency Depth: ${decomposition.maxDependencyDepth}</li>
`;
    modelica += `      </ul>
`;
    modelica += `    </html>")
`;
    modelica += `  );
`;
  }
  modelica += `end ${packageName};
`;
  return modelica;
}
function proofDecompositionToUML(decomposition, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  for (const atom of decomposition.atoms) {
    const label = includeLabels ? atom.statement.substring(0, 40) + (atom.statement.length > 40 ? "..." : "") : atom.id;
    let stereotype = "";
    switch (atom.type) {
      case "axiom":
        stereotype = "\xABaxiom\xBB";
        break;
      case "hypothesis":
        stereotype = "\xABhypothesis\xBB";
        break;
      case "lemma":
        stereotype = "\xABlemma\xBB";
        break;
      case "conclusion":
        stereotype = "\xABconclusion\xBB";
        break;
      case "definition":
        stereotype = "\xABdefinition\xBB";
        break;
      default:
        stereotype = "\xABderived\xBB";
    }
    nodes.push({
      id: atom.id,
      label: `${stereotype}\\n${label}`,
      shape: "class",
      // Use class notation
      stereotype: atom.type
    });
  }
  if (decomposition.dependencies && decomposition.dependencies.edges) {
    for (const edge of decomposition.dependencies.edges) {
      edges.push({
        source: edge.from,
        target: edge.to,
        label: edge.inferenceRule || "derives",
        type: "dependency"
        // UML dependency arrow
      });
    }
  }
  if (decomposition.gaps && decomposition.gaps.length > 0) {
    for (const gap of decomposition.gaps) {
      edges.push({
        source: gap.location.from,
        target: gap.location.to,
        label: `GAP: ${gap.description.substring(0, 20)}`,
        type: "dashed"
      });
    }
  }
  let uml = generateUmlDiagram(nodes, edges, {
    title: `Proof Structure: ${decomposition.theorem?.substring(0, 50) || "Proof Decomposition"}`,
    direction: "top to bottom"
  });
  if (includeMetrics) {
    uml += "\n\nnote right of diagram\n";
    uml += "  **Proof Metrics**\n";
    uml += `  Completeness: ${(decomposition.completeness * 100).toFixed(0)}%
`;
    uml += `  Rigor: ${decomposition.rigorLevel}
`;
    uml += `  Atoms: ${decomposition.atomCount}
`;
    uml += `  Depth: ${decomposition.maxDependencyDepth}
`;
    uml += "end note\n";
  }
  uml += "\nlegend right\n";
  uml += "  |= Type |= Symbol |\n";
  uml += "  | Axiom | \xABaxiom\xBB |\n";
  uml += "  | Hypothesis | \xABhypothesis\xBB |\n";
  uml += "  | Lemma | \xABlemma\xBB |\n";
  uml += "  | Derived | \xABderived\xBB |\n";
  uml += "  | Conclusion | \xABconclusion\xBB |\n";
  uml += "endlegend\n";
  return uml;
}
function proofDecompositionToJSON(decomposition, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const graph = createJsonGraph(
    decomposition.theorem?.substring(0, 50) || "Proof Decomposition",
    "mathematics",
    { includeMetrics, includeLayout: true }
  );
  if (decomposition.theorem) {
    graph.metadata.theorem = decomposition.theorem;
    graph.metadata.completeness = decomposition.completeness;
    graph.metadata.rigorLevel = decomposition.rigorLevel;
    graph.metadata.atomCount = decomposition.atomCount;
    graph.metadata.maxDependencyDepth = decomposition.maxDependencyDepth;
  }
  for (const atom of decomposition.atoms) {
    const label = includeLabels ? atom.statement : atom.id;
    addNode(graph, {
      id: atom.id,
      label,
      type: atom.type,
      shape: atom.type === "conclusion" ? "diamond" : atom.type === "axiom" ? "stadium" : "rectangle",
      metadata: {
        statement: atom.statement,
        derivedFrom: atom.derivedFrom || [],
        usedInferenceRule: atom.usedInferenceRule || null
      }
    });
  }
  if (decomposition.dependencies && decomposition.dependencies.edges) {
    let edgeId = 0;
    for (const edge of decomposition.dependencies.edges) {
      addEdge(graph, {
        id: `edge_${edgeId++}`,
        source: edge.from,
        target: edge.to,
        label: edge.inferenceRule,
        type: "inference",
        directed: true,
        style: "solid"
      });
    }
  }
  if (decomposition.gaps && decomposition.gaps.length > 0) {
    let gapId = 0;
    for (const gap of decomposition.gaps) {
      addEdge(graph, {
        id: `gap_${gapId++}`,
        source: gap.location.from,
        target: gap.location.to,
        label: `GAP: ${gap.description.substring(0, 30)}`,
        type: "gap",
        directed: true,
        style: "dashed",
        metadata: {
          gapType: gap.type,
          severity: gap.severity,
          description: gap.description,
          suggestedFix: gap.suggestedFix || null
        }
      });
    }
  }
  if (includeMetrics) {
    addMetric(graph, "completeness", decomposition.completeness);
    addMetric(graph, "rigorLevel", decomposition.rigorLevel);
    addMetric(graph, "atomCount", decomposition.atomCount);
    addMetric(graph, "maxDependencyDepth", decomposition.maxDependencyDepth);
  }
  if (decomposition.implicitAssumptions && decomposition.implicitAssumptions.length > 0) {
    graph.metadata.implicitAssumptions = decomposition.implicitAssumptions.map((assumption) => ({
      type: assumption.type,
      statement: assumption.statement,
      shouldBeExplicit: assumption.shouldBeExplicit || false,
      suggestedFormulation: assumption.suggestedFormulation || null
    }));
  }
  if (decomposition.gaps && decomposition.gaps.length > 0) {
    graph.metadata.gaps = decomposition.gaps.map((gap) => ({
      id: gap.id,
      type: gap.type,
      severity: gap.severity,
      description: gap.description,
      location: gap.location,
      suggestedFix: gap.suggestedFix || null
    }));
  }
  return serializeGraph(graph, { prettyPrint: true });
}
function proofDecompositionToMarkdown(decomposition, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  if (decomposition.theorem) {
    parts.push(section("Theorem", decomposition.theorem));
  }
  if (includeMetrics) {
    const metricsContent = keyValueSection({
      "Completeness": `${(decomposition.completeness * 100).toFixed(0)}%`,
      "Rigor Level": decomposition.rigorLevel,
      "Atom Count": decomposition.atomCount,
      "Max Dependency Depth": decomposition.maxDependencyDepth
    });
    let metricsFull = metricsContent;
    metricsFull += "\n\n**Completeness:**\n\n" + progressBar(decomposition.completeness * 100);
    parts.push(section("Metrics", metricsFull));
  }
  const axioms = decomposition.atoms.filter((a) => a.type === "axiom");
  if (axioms.length > 0) {
    const axiomRows = axioms.map((atom) => [
      atom.id,
      atom.statement.substring(0, 100) + (atom.statement.length > 100 ? "..." : "")
    ]);
    parts.push(section("Axioms", table(["ID", "Statement"], axiomRows)));
  }
  const hypotheses = decomposition.atoms.filter((a) => a.type === "hypothesis");
  if (hypotheses.length > 0) {
    const hypothesesRows = hypotheses.map((atom) => [
      atom.id,
      atom.statement.substring(0, 100) + (atom.statement.length > 100 ? "..." : "")
    ]);
    parts.push(section("Hypotheses", table(["ID", "Statement"], hypothesesRows)));
  }
  const definitions = decomposition.atoms.filter((a) => a.type === "definition");
  if (definitions.length > 0) {
    const definitionsRows = definitions.map((atom) => [
      atom.id,
      atom.statement.substring(0, 100) + (atom.statement.length > 100 ? "..." : "")
    ]);
    parts.push(section("Definitions", table(["ID", "Statement"], definitionsRows)));
  }
  const lemmas = decomposition.atoms.filter((a) => a.type === "lemma");
  if (lemmas.length > 0) {
    const lemmasRows = lemmas.map((atom) => [
      atom.id,
      atom.statement.substring(0, 80) + (atom.statement.length > 80 ? "..." : ""),
      atom.derivedFrom ? atom.derivedFrom.join(", ") : "-",
      atom.usedInferenceRule || "-"
    ]);
    parts.push(section("Lemmas", table(["ID", "Statement", "Derived From", "Rule"], lemmasRows)));
  }
  const derived = decomposition.atoms.filter((a) => a.type === "derived");
  if (derived.length > 0) {
    const derivedRows = derived.map((atom) => [
      atom.id,
      atom.statement.substring(0, 80) + (atom.statement.length > 80 ? "..." : ""),
      atom.derivedFrom ? atom.derivedFrom.join(", ") : "-",
      atom.usedInferenceRule || "-"
    ]);
    parts.push(section("Derived Statements", table(["ID", "Statement", "Derived From", "Rule"], derivedRows)));
  }
  const conclusions = decomposition.atoms.filter((a) => a.type === "conclusion");
  if (conclusions.length > 0) {
    const conclusionsRows = conclusions.map((atom) => [
      atom.id,
      atom.statement.substring(0, 100) + (atom.statement.length > 100 ? "..." : ""),
      atom.derivedFrom ? atom.derivedFrom.join(", ") : "-"
    ]);
    parts.push(section("Conclusions", table(["ID", "Statement", "Derived From"], conclusionsRows)));
  }
  if (decomposition.dependencies && decomposition.dependencies.edges && decomposition.dependencies.edges.length > 0) {
    const depsRows = decomposition.dependencies.edges.map((edge) => [
      edge.from,
      edge.to,
      edge.inferenceRule || "Direct"
    ]);
    parts.push(section("Dependencies", table(["From", "To", "Inference Rule"], depsRows)));
  }
  if (decomposition.gaps && decomposition.gaps.length > 0) {
    const gapsRows = decomposition.gaps.map((gap) => [
      gap.id,
      gap.type,
      gap.severity,
      gap.description.substring(0, 60) + (gap.description.length > 60 ? "..." : ""),
      `${gap.location.from} \u2192 ${gap.location.to}`,
      gap.suggestedFix ? gap.suggestedFix.substring(0, 40) : "-"
    ]);
    parts.push(section("Identified Gaps", table(
      ["ID", "Type", "Severity", "Description", "Location", "Suggested Fix"],
      gapsRows
    )));
  }
  if (decomposition.implicitAssumptions && decomposition.implicitAssumptions.length > 0) {
    const assumptionsRows = decomposition.implicitAssumptions.map((assumption) => [
      assumption.type,
      assumption.statement.substring(0, 80) + (assumption.statement.length > 80 ? "..." : ""),
      assumption.shouldBeExplicit ? "Yes" : "No",
      assumption.suggestedFormulation ? assumption.suggestedFormulation.substring(0, 50) : "-"
    ]);
    parts.push(section("Implicit Assumptions", table(
      ["Type", "Statement", "Should Be Explicit", "Suggested Formulation"],
      assumptionsRows
    )));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = proofDecompositionToMermaid(decomposition, "default", true, true);
    parts.push(section("Proof Structure Diagram", mermaidBlock(mermaidDiagram)));
  }
  return document("Proof Decomposition Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "proof-decomposition",
      completeness: decomposition.completeness,
      rigorLevel: decomposition.rigorLevel,
      atomCount: decomposition.atomCount
    }
  });
}
var init_proof_decomposition = __esm({
  "src/export/visual/modes/proof-decomposition.ts"() {
    init_esm_shims();
    init_utils();
    init_html();
    init_modelica();
    init_uml();
    init_json();
    init_markdown();
  }
});

// src/export/visual/modes/index.ts
var init_modes2 = __esm({
  "src/export/visual/modes/index.ts"() {
    init_esm_shims();
    init_sequential();
    init_shannon();
    init_mathematics();
    init_physics();
    init_hybrid();
    init_causal();
    init_temporal();
    init_counterfactual();
    init_bayesian();
    init_evidential();
    init_game_theory();
    init_optimization();
    init_abductive();
    init_analogical();
    init_first_principles();
    init_metareasoning();
    init_systems_thinking();
    init_scientific_method();
    init_formal_logic();
    init_engineering();
    init_computability();
    init_proof_decomposition();
  }
});

// src/export/visual/visual-exporter.ts
var VisualExporter;
var init_visual_exporter = __esm({
  "src/export/visual/visual-exporter.ts"() {
    init_esm_shims();
    init_modes2();
    VisualExporter = class {
      exportCausalGraph(thought, options) {
        return exportCausalGraph(thought, options);
      }
      exportTemporalTimeline(thought, options) {
        return exportTemporalTimeline(thought, options);
      }
      exportGameTree(thought, options) {
        return exportGameTree(thought, options);
      }
      exportBayesianNetwork(thought, options) {
        return exportBayesianNetwork(thought, options);
      }
      exportSequentialDependencyGraph(thought, options) {
        return exportSequentialDependencyGraph(thought, options);
      }
      exportShannonStageFlow(thought, options) {
        return exportShannonStageFlow(thought, options);
      }
      exportAbductiveHypotheses(thought, options) {
        return exportAbductiveHypotheses(thought, options);
      }
      exportCounterfactualScenarios(thought, options) {
        return exportCounterfactualScenarios(thought, options);
      }
      exportAnalogicalMapping(thought, options) {
        return exportAnalogicalMapping(thought, options);
      }
      exportEvidentialBeliefs(thought, options) {
        return exportEvidentialBeliefs(thought, options);
      }
      exportFirstPrinciplesDerivation(thought, options) {
        return exportFirstPrinciplesDerivation(thought, options);
      }
      exportSystemsThinkingCausalLoops(thought, options) {
        return exportSystemsThinkingCausalLoops(thought, options);
      }
      exportScientificMethodExperiment(thought, options) {
        return exportScientificMethodExperiment(thought, options);
      }
      exportOptimizationSolution(thought, options) {
        return exportOptimizationSolution(thought, options);
      }
      exportFormalLogicProof(thought, options) {
        return exportFormalLogicProof(thought, options);
      }
      exportMathematicsDerivation(thought, options) {
        return exportMathematicsDerivation(thought, options);
      }
      exportPhysicsVisualization(thought, options) {
        return exportPhysicsVisualization(thought, options);
      }
      exportHybridOrchestration(thought, options) {
        return exportHybridOrchestration(thought, options);
      }
      exportMetaReasoningVisualization(thought, options) {
        return exportMetaReasoningVisualization(thought, options);
      }
      exportProofDecomposition(decomposition, options) {
        return exportProofDecomposition(decomposition, options);
      }
      exportEngineeringAnalysis(thought, options) {
        return exportEngineeringAnalysis(thought, options);
      }
      exportComputability(thought, options) {
        return exportComputability(thought, options);
      }
    };
  }
});

// src/export/visual/utils/latex.ts
var init_latex = __esm({
  "src/export/visual/utils/latex.ts"() {
    init_esm_shims();
  }
});

// src/export/visual/utils/latex-mermaid-integration.ts
var init_latex_mermaid_integration = __esm({
  "src/export/visual/utils/latex-mermaid-integration.ts"() {
    init_esm_shims();
  }
});

// src/export/visual/utils/index.ts
var init_utils2 = __esm({
  "src/export/visual/utils/index.ts"() {
    init_esm_shims();
    init_mermaid();
    init_dot();
    init_ascii();
    init_svg();
    init_graphml();
    init_tikz();
    init_html();
    init_modelica();
    init_uml();
    init_json();
    init_markdown();
    init_latex();
    init_latex_mermaid_integration();
  }
});

// src/export/visual/index.ts
var init_visual = __esm({
  "src/export/visual/index.ts"() {
    init_esm_shims();
    init_visual_exporter();
    init_modes2();
    init_utils2();
  }
});

// src/services/ExportService.ts
var ExportService;
var init_ExportService = __esm({
  "src/services/ExportService.ts"() {
    init_esm_shims();
    init_types();
    init_visual();
    init_sanitization();
    init_logger();
    ExportService = class {
      visualExporter;
      logger;
      constructor(logger2) {
        this.visualExporter = new VisualExporter();
        this.logger = logger2 || createLogger({ minLevel: 1 /* INFO */, enableConsole: true });
      }
      /**
       * Export a session to the specified format
       *
       * Main export method that routes to format-specific exporters.
       * Handles both standard formats (JSON, Markdown, etc.) and visual
       * formats (Mermaid, DOT, ASCII).
       *
       * @param session - The session to export
       * @param format - The desired export format
       * @returns Formatted string in the requested format
       * @throws {Error} If session has no thoughts for visual exports
       *
       * @example
       * ```typescript
       * const service = new ExportService();
       * const exported = service.exportSession(session, 'markdown');
       * ```
       */
      exportSession(session, format) {
        const startTime = Date.now();
        this.logger.debug("Export started", { sessionId: session.id, format, thoughtCount: session.thoughts.length });
        if (format === "mermaid" || format === "dot" || format === "ascii" || format === "svg" || format === "graphml" || format === "tikz" || format === "modelica" || format === "html" || format === "uml" || format === "visual-json" || format === "visual-markdown") {
          const visualFormat = format === "visual-json" ? "json" : format === "visual-markdown" ? "markdown" : format;
          const result2 = this.exportVisual(session, visualFormat);
          this.logger.debug("Export completed", {
            sessionId: session.id,
            format,
            duration: Date.now() - startTime,
            outputSize: result2.length
          });
          return result2;
        }
        let result;
        switch (format) {
          case "json":
            result = this.exportToJSON(session);
            break;
          case "markdown":
            result = this.exportToMarkdown(session);
            break;
          case "latex":
            result = this.exportToLatex(session);
            break;
          case "jupyter":
            result = this.exportToJupyter(session);
            break;
          default:
            result = this.exportToJSON(session);
        }
        this.logger.debug("Export completed", {
          sessionId: session.id,
          format,
          duration: Date.now() - startTime,
          outputSize: result.length
        });
        return result;
      }
      /**
       * Export session to visual format (Mermaid, DOT, ASCII)
       *
       * Uses VisualExporter to generate visual representations
       * based on the session's thinking mode and thought structure.
       *
       * @param session - The session to export
       * @param format - Visual format (mermaid, dot, ascii)
       * @returns Visual representation as string
       * @throws {Error} If session has no thoughts
       */
      exportVisual(session, format) {
        const lastThought = session.thoughts[session.thoughts.length - 1];
        if (!lastThought) {
          throw new Error("No thoughts in session to export");
        }
        if (lastThought.mode === "causal" && "causalGraph" in lastThought) {
          return this.visualExporter.exportCausalGraph(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "temporal" && "timeline" in lastThought) {
          return this.visualExporter.exportTemporalTimeline(lastThought, {
            format,
            includeLabels: true
          });
        }
        if (lastThought.mode === "gametheory" && "game" in lastThought) {
          return this.visualExporter.exportGameTree(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "bayesian" && "hypothesis" in lastThought) {
          return this.visualExporter.exportBayesianNetwork(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "firstprinciples" /* FIRSTPRINCIPLES */ && "question" in lastThought) {
          return this.visualExporter.exportFirstPrinciplesDerivation(lastThought, {
            format,
            colorScheme: "default"
          });
        }
        if (lastThought.mode === "sequential" /* SEQUENTIAL */ && "buildUpon" in lastThought) {
          return this.visualExporter.exportSequentialDependencyGraph(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "shannon" /* SHANNON */ && "stage" in lastThought) {
          return this.visualExporter.exportShannonStageFlow(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "abductive" /* ABDUCTIVE */ && "hypotheses" in lastThought) {
          return this.visualExporter.exportAbductiveHypotheses(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "counterfactual" /* COUNTERFACTUAL */ && "scenarios" in lastThought) {
          return this.visualExporter.exportCounterfactualScenarios(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "analogical" /* ANALOGICAL */ && "sourceAnalogy" in lastThought) {
          return this.visualExporter.exportAnalogicalMapping(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "evidential" /* EVIDENTIAL */ && "frameOfDiscernment" in lastThought) {
          return this.visualExporter.exportEvidentialBeliefs(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "systemsthinking" /* SYSTEMSTHINKING */ && "systemComponents" in lastThought) {
          return this.visualExporter.exportSystemsThinkingCausalLoops(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "scientificmethod" /* SCIENTIFICMETHOD */ && "hypothesis" in lastThought) {
          return this.visualExporter.exportScientificMethodExperiment(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "optimization" /* OPTIMIZATION */ && "objectiveFunction" in lastThought) {
          return this.visualExporter.exportOptimizationSolution(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "formallogic" /* FORMALLOGIC */ && "premises" in lastThought) {
          return this.visualExporter.exportFormalLogicProof(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "mathematics" /* MATHEMATICS */ && "proofStrategy" in lastThought) {
          return this.visualExporter.exportMathematicsDerivation(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "physics" /* PHYSICS */ && "tensorProperties" in lastThought) {
          return this.visualExporter.exportPhysicsVisualization(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "hybrid" /* HYBRID */ && "primaryMode" in lastThought) {
          return this.visualExporter.exportHybridOrchestration(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "metareasoning" /* METAREASONING */ && "currentStrategy" in lastThought) {
          return this.visualExporter.exportMetaReasoningVisualization(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "engineering" /* ENGINEERING */ && "analysisType" in lastThought) {
          return this.visualExporter.exportEngineeringAnalysis(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        return this.exportGenericThoughtSequence(session, format);
      }
      /**
       * Export a generic thought sequence diagram for any mode
       * Creates a flowchart showing the thought progression
       */
      exportGenericThoughtSequence(session, format) {
        const thoughts = session.thoughts;
        const title = (session.title || "Thinking Session").replace(/"/g, "'");
        const mode = session.mode;
        if (format === "mermaid") {
          let diagram = "flowchart TD\n";
          diagram += `    subgraph "${title}"
`;
          diagram += "    direction TB\n";
          diagram += `    SESSION["Session: ${mode}<br/>${thoughts.length} thoughts"]
`;
          for (let i = 0; i < thoughts.length; i++) {
            const t = thoughts[i];
            const truncated = t.content.length > 50 ? t.content.substring(0, 47).replace(/"/g, "'").replace(/\n/g, " ") + "..." : t.content.replace(/"/g, "'").replace(/\n/g, " ");
            const status = t.nextThoughtNeeded ? "..." : "Done";
            diagram += `    T${i + 1}["Thought ${i + 1} [${status}]<br/>${truncated}"]
`;
          }
          diagram += "    SESSION --> T1\n";
          for (let i = 1; i < thoughts.length; i++) {
            diagram += `    T${i} --> T${i + 1}
`;
          }
          const lastT = thoughts[thoughts.length - 1];
          if (lastT && !lastT.nextThoughtNeeded) {
            diagram += `    T${thoughts.length} --> COMPLETE["Complete"]
`;
          }
          diagram += "    end\n";
          return diagram;
        }
        if (format === "dot") {
          let dot = "digraph ThinkingSession {\n";
          dot += "    rankdir=TB;\n";
          dot += "    node [shape=box, style=rounded];\n";
          dot += `    label="${title} (${mode})";

`;
          for (let i = 0; i < thoughts.length; i++) {
            const t = thoughts[i];
            const truncated = t.content.length > 40 ? t.content.substring(0, 37).replace(/"/g, '\\"').replace(/\n/g, " ") + "..." : t.content.replace(/"/g, '\\"').replace(/\n/g, " ");
            dot += `    T${i + 1} [label="Thought ${i + 1}\\n${truncated}"];
`;
          }
          for (let i = 1; i < thoughts.length; i++) {
            dot += `    T${i} -> T${i + 1};
`;
          }
          dot += "}\n";
          return dot;
        }
        if (format === "ascii") {
          const bar = "\u2550".repeat(50);
          let ascii = `\u2554${bar}\u2557
`;
          ascii += `\u2551 ${title.substring(0, 48).padEnd(48)} \u2551
`;
          ascii += `\u2551 Mode: ${mode.padEnd(42)} \u2551
`;
          ascii += `\u2560${bar}\u2563
`;
          for (let i = 0; i < thoughts.length; i++) {
            const t = thoughts[i];
            const status = t.nextThoughtNeeded ? "[\u2192]" : "[\u2713]";
            const truncated = t.content.substring(0, 35).replace(/\n/g, " ");
            ascii += `\u2551 ${status} Thought ${i + 1}: ${truncated.padEnd(35)} \u2551
`;
            if (i < thoughts.length - 1) {
              ascii += "\u2551     \u2502                                              \u2551\n";
              ascii += "\u2551     \u25BC                                              \u2551\n";
            }
          }
          ascii += `\u255A${bar}\u255D
`;
          return ascii;
        }
        const thoughtsText = thoughts.map(
          (t, i) => `Thought ${i + 1} (${t.mode}):
${t.content}
`
        ).join("\n");
        return `Session: ${title}
Mode: ${mode}

${thoughtsText}`;
      }
      /**
       * Export session to JSON format
       *
       * Converts the session to JSON, handling Map serialization.
       *
       * @param session - The session to export
       * @returns JSON string with pretty printing
       */
      exportToJSON(session) {
        const sessionWithCustomMetrics = {
          ...session,
          metrics: {
            ...session.metrics,
            customMetrics: Object.fromEntries(session.metrics.customMetrics)
          }
        };
        return JSON.stringify(sessionWithCustomMetrics, null, 2);
      }
      /**
       * Export session to Markdown format
       *
       * Creates a human-readable Markdown document with session details
       * and all thoughts formatted as sections.
       *
       * @param session - The session to export
       * @returns Markdown-formatted string
       */
      exportToMarkdown(session) {
        const status = session.isComplete ? "Complete" : "In Progress";
        let md = `# Thinking Session: ${session.title}

`;
        md += `**Mode**: ${session.mode}
`;
        md += `**Created**: ${session.createdAt.toISOString()}
`;
        md += `**Status**: ${status}

`;
        md += `## Thoughts

`;
        for (const thought of session.thoughts) {
          md += `### Thought ${thought.thoughtNumber}/${session.thoughts.length}

`;
          md += `${thought.content}

`;
          if (isMetaReasoningThought(thought)) {
            md += `#### \u{1F4CA} Meta-Reasoning Analysis

`;
            md += `**Current Strategy:**
`;
            md += `- Mode: ${thought.currentStrategy.mode}
`;
            md += `- Approach: ${thought.currentStrategy.approach}
`;
            md += `- Thoughts Spent: ${thought.currentStrategy.thoughtsSpent}
`;
            if (thought.currentStrategy.progressIndicators.length > 0) {
              md += `- Progress: ${thought.currentStrategy.progressIndicators.join(", ")}
`;
            }
            md += `
`;
            md += `**Strategy Evaluation:**
`;
            md += `- Effectiveness: ${(thought.strategyEvaluation.effectiveness * 100).toFixed(1)}%
`;
            md += `- Efficiency: ${(thought.strategyEvaluation.efficiency * 100).toFixed(1)}%
`;
            md += `- Confidence: ${(thought.strategyEvaluation.confidence * 100).toFixed(1)}%
`;
            md += `- Quality Score: ${(thought.strategyEvaluation.qualityScore * 100).toFixed(1)}%
`;
            if (thought.strategyEvaluation.issues.length > 0) {
              md += `- Issues: ${thought.strategyEvaluation.issues.join("; ")}
`;
            }
            if (thought.strategyEvaluation.strengths.length > 0) {
              md += `- Strengths: ${thought.strategyEvaluation.strengths.join("; ")}
`;
            }
            md += `
`;
            md += `**Recommendation:** ${thought.recommendation.action}
`;
            md += `- ${thought.recommendation.justification}
`;
            md += `- Confidence: ${(thought.recommendation.confidence * 100).toFixed(1)}%
`;
            md += `- Expected Improvement: ${thought.recommendation.expectedImprovement}
`;
            if (thought.alternativeStrategies.length > 0) {
              md += `
**Alternative Strategies:**
`;
              for (const alt of thought.alternativeStrategies) {
                md += `- **${alt.mode}** (score: ${(alt.recommendationScore * 100).toFixed(0)}%): ${alt.reasoning}
`;
              }
            }
            md += `
**Quality Metrics:**
`;
            md += `- Logical Consistency: ${(thought.qualityMetrics.logicalConsistency * 100).toFixed(1)}%
`;
            md += `- Evidence Quality: ${(thought.qualityMetrics.evidenceQuality * 100).toFixed(1)}%
`;
            md += `- Completeness: ${(thought.qualityMetrics.completeness * 100).toFixed(1)}%
`;
            md += `- Originality: ${(thought.qualityMetrics.originality * 100).toFixed(1)}%
`;
            md += `- Clarity: ${(thought.qualityMetrics.clarity * 100).toFixed(1)}%
`;
            md += `- Overall Quality: ${(thought.qualityMetrics.overallQuality * 100).toFixed(1)}%
`;
            md += `
`;
          }
        }
        return md;
      }
      /**
       * Export session to LaTeX format
       *
       * Generates a LaTeX document with proper escaping for special characters.
       * Ready for compilation with pdflatex.
       *
       * @param session - The session to export
       * @returns LaTeX document as string
       */
      exportToLatex(session) {
        const status = session.isComplete ? "Complete" : "In Progress";
        const safeTitle = escapeLatex(session.title);
        const safeMode = escapeLatex(session.mode);
        const safeStatus = escapeLatex(status);
        let latex = `\\documentclass{article}
`;
        latex += `\\usepackage[utf8]{inputenc}
`;
        latex += `\\title{${safeTitle}}
`;
        latex += `\\begin{document}
`;
        latex += `\\maketitle

`;
        latex += `\\section{Session Details}
`;
        latex += `Mode: ${safeMode}\\\\
`;
        latex += `Status: ${safeStatus}\\\\

`;
        latex += `\\section{Thoughts}
`;
        for (const thought of session.thoughts) {
          latex += `\\subsection{Thought ${thought.thoughtNumber}}
`;
          latex += `${escapeLatex(thought.content)}

`;
        }
        latex += `\\end{document}
`;
        return latex;
      }
      /**
       * Export session to HTML format
       *
       * Generates a standalone HTML page with XSS protection via escaping.
       * Includes basic styling for readability.
       *
       * Note: Currently unused as HTML export is handled by visual exporters.
       * Kept for potential future use as a session-level HTML export.
       *
       * @param session - The session to export
       * @returns HTML document as string
       */
      // @ts-expect-error - Unused method kept for future use
      exportToHTML(session) {
        const status = session.isComplete ? "Complete" : "In Progress";
        const safeTitle = escapeHtml(session.title);
        const safeMode = escapeHtml(session.mode);
        const safeStatus = escapeHtml(status);
        let html = `<!DOCTYPE html>
<html>
<head>
`;
        html += `  <meta charset="UTF-8">
`;
        html += `  <meta name="viewport" content="width=device-width, initial-scale=1.0">
`;
        html += `  <title>${safeTitle}</title>
`;
        html += `  <style>body { font-family: Arial, sans-serif; max-width: 800px; margin: 50px auto; padding: 0 20px; }</style>
`;
        html += `</head>
<body>
`;
        html += `  <h1>${safeTitle}</h1>
`;
        html += `  <p><strong>Mode:</strong> ${safeMode}</p>
`;
        html += `  <p><strong>Status:</strong> ${safeStatus}</p>
`;
        html += `  <h2>Thoughts</h2>
`;
        for (const thought of session.thoughts) {
          html += `  <div>
`;
          html += `    <h3>Thought ${thought.thoughtNumber}/${session.thoughts.length}</h3>
`;
          html += `    <p>${escapeHtml(thought.content)}</p>
`;
          html += `  </div>
`;
        }
        html += `</body>
</html>
`;
        return html;
      }
      /**
       * Export session to Jupyter Notebook format
       *
       * Creates a .ipynb file structure with Markdown cells for each thought.
       * Compatible with Jupyter Notebook and JupyterLab.
       *
       * @param session - The session to export
       * @returns JSON string representing Jupyter notebook
       */
      exportToJupyter(session) {
        const status = session.isComplete ? "Complete" : "In Progress";
        const notebook = {
          cells: [],
          metadata: {},
          nbformat: 4,
          nbformat_minor: 2
        };
        notebook.cells.push({
          cell_type: "markdown",
          metadata: {},
          source: [
            `# Thinking Session: ${session.title}
`,
            `
`,
            `**Mode**: ${session.mode}
`,
            `**Status**: ${status}
`
          ]
        });
        for (const thought of session.thoughts) {
          notebook.cells.push({
            cell_type: "markdown",
            metadata: {},
            source: [
              `## Thought ${thought.thoughtNumber}/${session.thoughts.length}
`,
              `
`,
              `${thought.content}
`
            ]
          });
        }
        return JSON.stringify(notebook, null, 2);
      }
    };
  }
});

// src/services/ModeRouter.ts
var ModeRouter;
var init_ModeRouter = __esm({
  "src/services/ModeRouter.ts"() {
    init_esm_shims();
    init_types();
    init_logger();
    init_MetaMonitor();
    ModeRouter = class {
      sessionManager;
      recommender;
      logger;
      monitor;
      /**
       * Create a new ModeRouter
       *
       * @param sessionManager - Session manager instance for mode switching
       * @param logger - Optional logger for dependency injection
       * @param monitor - Optional MetaMonitor instance for dependency injection
       *
       * @example
       * ```typescript
       * const router = new ModeRouter(sessionManager);
       * // Or with DI:
       * const router = new ModeRouter(sessionManager, customLogger, customMonitor);
       * ```
       */
      constructor(sessionManager, logger2, monitor) {
        this.sessionManager = sessionManager;
        this.recommender = new ModeRecommender();
        this.logger = logger2 || createLogger({ minLevel: 1 /* INFO */, enableConsole: true });
        this.monitor = monitor || metaMonitor;
      }
      /**
       * Switch a session to a new thinking mode
       *
       * Changes the thinking mode of an active session while preserving
       * existing thoughts. Useful when the problem characteristics change
       * or initial mode selection was suboptimal.
       *
       * @param sessionId - ID of the session to switch
       * @param newMode - The new thinking mode to use
       * @param reason - Reason for the mode switch (for logging)
       * @returns The updated session
       * @throws {Error} If session not found
       *
       * @example
       * ```typescript
       * const session = await router.switchMode(
       *   'session-123',
       *   ThinkingMode.MATHEMATICS,
       *   'Problem requires mathematical proof'
       * );
       * ```
       */
      async switchMode(sessionId, newMode, reason) {
        this.logger.info("Switching mode", {
          sessionId,
          newMode,
          reason
        });
        const session = await this.sessionManager.switchMode(sessionId, newMode, reason);
        this.logger.debug("Mode switch completed", {
          sessionId,
          newMode,
          thoughtCount: session.thoughts.length
        });
        return session;
      }
      /**
       * Get quick mode recommendation based on problem type
       *
       * Provides a fast, single-mode recommendation based on a simple
       * problem type string. Useful for quick suggestions without detailed
       * problem analysis.
       *
       * @param problemType - Simple problem type description
       * @returns Recommended thinking mode
       *
       * @example
       * ```typescript
       * const mode = router.quickRecommend('mathematical proof');
       * // Returns: ThinkingMode.MATHEMATICS
       * ```
       */
      quickRecommend(problemType) {
        this.logger.debug("Quick recommend requested", { problemType });
        const mode = this.recommender.quickRecommend(problemType);
        this.logger.debug("Quick recommend result", { problemType, recommendedMode: mode });
        return mode;
      }
      /**
       * Get comprehensive mode recommendations
       *
       * Analyzes problem characteristics and returns ranked recommendations
       * for individual modes and optionally mode combinations.
       *
       * @param characteristics - Detailed problem characteristics
       * @param includeCombinations - Whether to include mode combinations
       * @returns Formatted recommendation response
       *
       * @example
       * ```typescript
       * const response = router.getRecommendations({
       *   requiresProof: true,
       *   hasQuantities: true,
       *   hasUncertainty: false
       * }, true);
       * ```
       */
      getRecommendations(characteristics, includeCombinations = false) {
        this.logger.debug("Getting mode recommendations", {
          characteristics,
          includeCombinations
        });
        const modeRecs = this.recommender.recommendModes(characteristics);
        const combinationRecs = includeCombinations ? this.recommender.recommendCombinations(characteristics) : [];
        this.logger.debug("Recommendations generated", {
          modeCount: modeRecs.length,
          combinationCount: combinationRecs.length,
          topMode: modeRecs[0]?.mode,
          topScore: modeRecs[0]?.score
        });
        let response = "# Mode Recommendations\n\n";
        response += "## Individual Modes\n\n";
        for (const rec of modeRecs) {
          response += `### ${rec.mode} (Score: ${rec.score})
`;
          response += `**Reasoning**: ${rec.reasoning}

`;
          response += `**Strengths**:
`;
          for (const strength of rec.strengths) {
            response += `- ${strength}
`;
          }
          response += `
**Limitations**:
`;
          for (const limitation of rec.limitations) {
            response += `- ${limitation}
`;
          }
          response += `
**Examples**: ${rec.examples.join(", ")}

`;
          response += "---\n\n";
        }
        if (combinationRecs.length > 0) {
          response += "## Recommended Mode Combinations\n\n";
          for (const combo of combinationRecs) {
            response += `### ${combo.modes.join(" + ")} (${combo.sequence})
`;
            response += `**Rationale**: ${combo.rationale}

`;
            response += `**Benefits**:
`;
            for (const benefit of combo.benefits) {
              response += `- ${benefit}
`;
            }
            response += `
**Synergies**:
`;
            for (const synergy of combo.synergies) {
              response += `- ${synergy}
`;
            }
            response += "\n---\n\n";
          }
        }
        return response;
      }
      /**
       * Format a quick recommendation response
       *
       * Creates a formatted response for quick recommendations.
       *
       * @param problemType - The problem type that was analyzed
       * @param recommendedMode - The recommended mode
       * @returns Formatted response string
       */
      formatQuickRecommendation(problemType, recommendedMode) {
        return `Quick recommendation for "${problemType}":

**Recommended Mode**: ${recommendedMode}

For more detailed recommendations, provide problemCharacteristics.`;
      }
      /**
       * Evaluate current session and suggest mode switch if beneficial
       *
       * Uses meta-reasoning to evaluate the current strategy effectiveness
       * and suggest alternative modes if the current approach is suboptimal.
       *
       * @param sessionId - Session to evaluate
       * @param problemType - Optional problem type for context
       * @returns Evaluation result with switch recommendation
       *
       * @example
       * ```typescript
       * const evaluation = await router.evaluateAndSuggestSwitch('session-123', 'debugging');
       * if (evaluation.shouldSwitch) {
       *   await router.switchMode(sessionId, evaluation.suggestedMode!, evaluation.reasoning);
       * }
       * ```
       */
      async evaluateAndSuggestSwitch(sessionId, problemType = "general") {
        this.logger.debug("Evaluating session for potential mode switch", { sessionId, problemType });
        const evaluation = this.monitor.evaluateStrategy(sessionId);
        const session = await this.sessionManager.getSession(sessionId);
        const currentMode = session?.mode || "sequential" /* SEQUENTIAL */;
        const alternatives = this.monitor.suggestAlternatives(sessionId, currentMode);
        const shouldSwitch = evaluation.effectiveness < 0.4 || evaluation.effectiveness < 0.6 && alternatives.length > 0 && alternatives[0].recommendationScore > 0.75;
        const suggestedMode = shouldSwitch && alternatives.length > 0 ? alternatives[0].mode : void 0;
        const reasoning = shouldSwitch ? `Current strategy effectiveness: ${(evaluation.effectiveness * 100).toFixed(1)}%. ${alternatives[0]?.reasoning || "Consider switching modes."}` : `Current strategy performing adequately (effectiveness: ${(evaluation.effectiveness * 100).toFixed(1)}%). Continue with current mode.`;
        this.logger.debug("Mode switch evaluation completed", {
          sessionId,
          shouldSwitch,
          suggestedMode,
          currentEffectiveness: evaluation.effectiveness
        });
        return {
          currentEvaluation: evaluation,
          shouldSwitch,
          suggestedMode,
          reasoning,
          alternatives
        };
      }
      /**
       * Auto-switch mode if current strategy is failing
       *
       * Automatically evaluates and switches modes if the current approach
       * is demonstrably ineffective (effectiveness < 0.3).
       *
       * @param sessionId - Session to evaluate
       * @param problemType - Optional problem type for context
       * @returns Switch result with details
       *
       * @example
       * ```typescript
       * const result = await router.autoSwitchIfNeeded('session-123', 'complex-problem');
       * console.log(result.switched ? 'Switched to' + result.newMode : 'No switch needed');
       * ```
       */
      async autoSwitchIfNeeded(sessionId, problemType = "general") {
        this.logger.debug("Auto-switch evaluation", { sessionId, problemType });
        const evaluation = await this.evaluateAndSuggestSwitch(sessionId, problemType);
        const autoSwitchThreshold = 0.3;
        if (evaluation.currentEvaluation.effectiveness < autoSwitchThreshold && evaluation.suggestedMode) {
          const session = await this.sessionManager.getSession(sessionId);
          const oldMode = session?.mode || "sequential" /* SEQUENTIAL */;
          await this.switchMode(sessionId, evaluation.suggestedMode, evaluation.reasoning);
          this.logger.info("Auto-switched mode due to low effectiveness", {
            sessionId,
            oldMode,
            newMode: evaluation.suggestedMode,
            effectiveness: evaluation.currentEvaluation.effectiveness
          });
          return {
            switched: true,
            oldMode,
            newMode: evaluation.suggestedMode,
            reasoning: evaluation.reasoning,
            evaluation: evaluation.currentEvaluation
          };
        }
        this.logger.debug("Auto-switch not needed", {
          sessionId,
          effectiveness: evaluation.currentEvaluation.effectiveness,
          threshold: autoSwitchThreshold
        });
        return {
          switched: false,
          reasoning: evaluation.reasoning,
          evaluation: evaluation.currentEvaluation
        };
      }
    };
  }
});

// src/services/index.ts
var services_exports = {};
__export(services_exports, {
  ExportService: () => ExportService,
  ModeRouter: () => ModeRouter,
  ThoughtFactory: () => ThoughtFactory
});
var init_services = __esm({
  "src/services/index.ts"() {
    init_esm_shims();
    init_ThoughtFactory();
    init_ExportService();
    init_ModeRouter();
  }
});

// src/index.ts
init_esm_shims();

// src/tools/definitions.ts
init_esm_shims();

// src/tools/json-schemas.ts
init_esm_shims();
var baseThoughtProperties = {
  sessionId: {
    type: "string",
    description: "Optional session ID. If not provided, a new session will be created."
  },
  thought: {
    type: "string",
    description: "The current thought or reasoning step",
    minLength: 1
  },
  thoughtNumber: {
    type: "integer",
    description: "Current thought number in sequence",
    minimum: 1
  },
  totalThoughts: {
    type: "integer",
    description: "Estimated total number of thoughts needed",
    minimum: 1
  },
  nextThoughtNeeded: {
    type: "boolean",
    description: "Whether another thought step is needed"
  },
  isRevision: {
    type: "boolean",
    description: "Whether this thought revises previous thinking"
  },
  revisesThought: {
    type: "string",
    description: "ID of the thought being revised"
  },
  revisionReason: {
    type: "string",
    description: "Explanation for why revision is needed"
  },
  branchFrom: {
    type: "string",
    description: "ID of thought to branch from for alternative reasoning path"
  },
  branchId: {
    type: "string",
    description: "Identifier for this reasoning branch"
  },
  uncertainty: {
    type: "number",
    description: "Confidence level (0-1, where 1 is highest confidence)",
    minimum: 0,
    maximum: 1
  },
  dependencies: {
    type: "array",
    items: { type: "string" },
    description: "IDs of thoughts this one depends on"
  },
  assumptions: {
    type: "array",
    items: { type: "string" },
    description: "Key assumptions made in this thought"
  }
};
var baseThoughtRequired = ["thought", "thoughtNumber", "totalThoughts", "nextThoughtNeeded"];
var deepthinking_core_schema = {
  name: "deepthinking_core",
  description: "Core reasoning: inductive, deductive, abductive",
  inputSchema: {
    type: "object",
    properties: {
      ...baseThoughtProperties,
      mode: {
        type: "string",
        enum: ["inductive", "deductive", "abductive"],
        description: "Core reasoning mode"
      },
      // Inductive properties
      observations: {
        type: "array",
        items: { type: "string" },
        description: "Specific cases observed (inductive/abductive)"
      },
      pattern: {
        type: "string",
        description: "Identified pattern (inductive)"
      },
      generalization: {
        type: "string",
        description: "General principle formed (inductive)"
      },
      confidence: {
        type: "number",
        minimum: 0,
        maximum: 1,
        description: "Strength of inference (inductive)"
      },
      counterexamples: {
        type: "array",
        items: { type: "string" },
        description: "Known exceptions (inductive)"
      },
      sampleSize: {
        type: "integer",
        minimum: 1,
        description: "Number of observations (inductive)"
      },
      // Deductive properties
      premises: {
        type: "array",
        items: { type: "string" },
        description: "General principles (deductive)"
      },
      conclusion: {
        type: "string",
        description: "Specific conclusion (deductive)"
      },
      logicForm: {
        type: "string",
        description: "Logic form: modus ponens, modus tollens, etc. (deductive)"
      },
      validityCheck: {
        type: "boolean",
        description: "Is the deduction logically valid? (deductive)"
      },
      soundnessCheck: {
        type: "boolean",
        description: "Are the premises true? (deductive)"
      },
      // Abductive properties
      hypotheses: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            explanation: { type: "string" },
            score: { type: "number" }
          },
          required: ["id", "explanation"],
          additionalProperties: false
        },
        description: "Candidate explanations (abductive)"
      },
      bestExplanation: {
        type: "object",
        properties: {
          id: { type: "string" },
          explanation: { type: "string" },
          score: { type: "number" }
        },
        required: ["id", "explanation"],
        additionalProperties: false,
        description: "Best explanation chosen (abductive)"
      }
    },
    required: [...baseThoughtRequired],
    additionalProperties: false
  }
};
var deepthinking_standard_schema = {
  name: "deepthinking_standard",
  description: "Standard workflows: sequential, shannon (5-stage), hybrid",
  inputSchema: {
    type: "object",
    properties: {
      ...baseThoughtProperties,
      mode: {
        type: "string",
        enum: ["sequential", "shannon", "hybrid"],
        description: "Thinking mode to use"
      },
      stage: {
        type: "string",
        enum: ["problem_definition", "constraints", "model", "proof", "implementation"],
        description: "Shannon methodology stage (only for shannon mode)"
      },
      activeModes: {
        type: "array",
        items: { type: "string" },
        description: "Active sub-modes for hybrid mode"
      }
    },
    required: [...baseThoughtRequired],
    additionalProperties: false
  }
};
var deepthinking_mathematics_schema = {
  name: "deepthinking_mathematics",
  description: "Math/physics/computability: proofs, Turing machines, decidability, tensors, LaTeX, conservation laws",
  inputSchema: {
    type: "object",
    properties: {
      ...baseThoughtProperties,
      mode: {
        type: "string",
        enum: ["mathematics", "physics", "computability"],
        description: "Mathematical reasoning mode"
      },
      thoughtType: {
        type: "string",
        description: "Specific thought type for mathematics mode. Use 'proof_decomposition', 'dependency_analysis', 'consistency_check', 'gap_identification', or 'assumption_trace' for proof analysis."
      },
      mathematicalModel: {
        type: "object",
        properties: {
          latex: { type: "string", description: "LaTeX representation" },
          symbolic: { type: "string", description: "Symbolic notation" },
          ascii: { type: "string", description: "ASCII math representation" }
        },
        required: ["latex", "symbolic"],
        additionalProperties: false,
        description: "Mathematical model representation"
      },
      proofStrategy: {
        type: "object",
        properties: {
          type: {
            type: "string",
            enum: ["direct", "contradiction", "induction", "construction", "contrapositive"],
            description: "Type of mathematical proof"
          },
          steps: {
            type: "array",
            items: { type: "string" },
            description: "Proof steps"
          }
        },
        required: ["type", "steps"],
        additionalProperties: false,
        description: "Proof strategy being used"
      },
      tensorProperties: {
        type: "object",
        properties: {
          rank: {
            type: "array",
            items: { type: "integer" },
            minItems: 2,
            maxItems: 2,
            description: "Tensor rank as [contravariant, covariant]"
          },
          components: { type: "string", description: "Tensor components" },
          latex: { type: "string", description: "LaTeX representation" },
          symmetries: {
            type: "array",
            items: { type: "string" },
            description: "Symmetry properties"
          },
          invariants: {
            type: "array",
            items: { type: "string" },
            description: "Invariant quantities"
          },
          transformation: {
            type: "string",
            enum: ["covariant", "contravariant", "mixed"],
            description: "Transformation type"
          }
        },
        required: ["rank", "components", "latex", "transformation"],
        additionalProperties: false,
        description: "Tensor properties for physics calculations"
      },
      physicalInterpretation: {
        type: "object",
        properties: {
          quantity: { type: "string", description: "Physical quantity being described" },
          units: { type: "string", description: "Units of the quantity" },
          conservationLaws: {
            type: "array",
            items: { type: "string" },
            description: "Conservation laws applicable"
          }
        },
        required: ["quantity", "units", "conservationLaws"],
        additionalProperties: false,
        description: "Physical interpretation of the model"
      },
      // Phase 8: Proof decomposition fields
      proofSteps: {
        type: "array",
        description: "Structured proof steps for decomposition analysis",
        items: {
          type: "object",
          properties: {
            stepNumber: { type: "integer", minimum: 1, description: "Step number in the proof" },
            statement: { type: "string", description: "The statement being made" },
            justification: { type: "string", description: "Justification for this step" },
            latex: { type: "string", description: "LaTeX representation of the statement" },
            referencesSteps: {
              type: "array",
              items: { type: "integer" },
              description: "Step numbers this step references"
            }
          },
          required: ["stepNumber", "statement"],
          additionalProperties: false
        }
      },
      theorem: {
        type: "string",
        description: "The theorem being proved (for proof decomposition)"
      },
      hypotheses: {
        type: "array",
        items: { type: "string" },
        description: "Starting hypotheses for the proof"
      },
      analysisDepth: {
        type: "string",
        enum: ["shallow", "standard", "deep"],
        description: "Depth of proof analysis"
      },
      includeConsistencyCheck: {
        type: "boolean",
        description: "Whether to run inconsistency detection"
      },
      traceAssumptions: {
        type: "boolean",
        description: "Whether to include assumption chain analysis"
      }
    },
    required: [...baseThoughtRequired],
    additionalProperties: false
  }
};
var deepthinking_temporal_schema = {
  name: "deepthinking_temporal",
  description: "Temporal: timelines, Allen intervals, event sequencing",
  inputSchema: {
    type: "object",
    properties: {
      ...baseThoughtProperties,
      mode: {
        type: "string",
        enum: ["temporal"],
        description: "Temporal reasoning mode"
      },
      timeline: {
        type: "object",
        properties: {
          id: { type: "string", description: "Timeline ID" },
          name: { type: "string", description: "Timeline name" },
          timeUnit: {
            type: "string",
            enum: ["milliseconds", "seconds", "minutes", "hours", "days", "months", "years"],
            description: "Time unit"
          },
          events: {
            type: "array",
            items: { type: "string" },
            description: "Event IDs in this timeline"
          },
          startTime: { type: "number", description: "Timeline start time (optional)" },
          endTime: { type: "number", description: "Timeline end time (optional)" }
        },
        required: ["id", "name", "timeUnit", "events"],
        additionalProperties: false,
        description: "Timeline definition"
      },
      events: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            description: { type: "string" },
            timestamp: { type: "number", description: "Event timestamp as number" },
            type: {
              type: "string",
              enum: ["instant", "interval"],
              description: "Event type"
            },
            duration: { type: "number", description: "Event duration (optional)" },
            properties: {
              type: "object",
              additionalProperties: true,
              description: "Additional event properties"
            }
          },
          required: ["id", "name", "description", "timestamp", "type"],
          additionalProperties: false
        },
        description: "Temporal events"
      },
      constraints: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            type: {
              type: "string",
              enum: ["before", "after", "during", "simultaneous"],
              description: "Constraint type"
            },
            subject: { type: "string", description: "Subject event ID" },
            object: { type: "string", description: "Object event ID" },
            confidence: { type: "number", minimum: 0, maximum: 1, description: "Confidence in constraint" }
          },
          required: ["id", "type", "subject", "object", "confidence"],
          additionalProperties: false
        },
        description: "Temporal constraints"
      },
      intervals: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            start: { type: "number", description: "Interval start" },
            end: { type: "number", description: "Interval end" },
            contains: {
              type: "array",
              items: { type: "string" },
              description: "Event IDs contained in this interval"
            },
            overlaps: {
              type: "array",
              items: { type: "string" },
              description: "Interval IDs that overlap"
            }
          },
          required: ["id", "name", "start", "end"],
          additionalProperties: false
        },
        description: "Temporal intervals"
      },
      relations: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            from: { type: "string", description: "Source event ID" },
            to: { type: "string", description: "Target event ID" },
            relationType: {
              type: "string",
              enum: ["before", "after", "during", "overlaps", "meets", "starts", "finishes", "equals", "causes"],
              description: "Relation type (Allen's interval algebra)"
            },
            strength: { type: "number", minimum: 0, maximum: 1, description: "Relation strength" },
            delay: { type: "number", description: "Temporal delay (optional)" }
          },
          required: ["id", "from", "to", "relationType", "strength"],
          additionalProperties: false
        },
        description: "Temporal relations between events"
      }
    },
    required: [...baseThoughtRequired],
    additionalProperties: false
  }
};
var deepthinking_probabilistic_schema = {
  name: "deepthinking_probabilistic",
  description: "Probabilistic: Bayesian updates, Dempster-Shafer belief",
  inputSchema: {
    type: "object",
    properties: {
      ...baseThoughtProperties,
      mode: {
        type: "string",
        enum: ["bayesian", "evidential"],
        description: "Probabilistic reasoning mode"
      },
      priorProbability: {
        type: "number",
        minimum: 0,
        maximum: 1,
        description: "Prior probability before evidence"
      },
      likelihood: {
        type: "number",
        minimum: 0,
        maximum: 1,
        description: "Likelihood of evidence given hypothesis"
      },
      posteriorProbability: {
        type: "number",
        minimum: 0,
        maximum: 1,
        description: "Posterior probability after evidence"
      },
      evidence: {
        type: "array",
        items: { type: "string" },
        description: "Evidence considered"
      },
      hypotheses: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            description: { type: "string" },
            probability: { type: "number", minimum: 0, maximum: 1 }
          },
          required: ["id", "description"],
          additionalProperties: false
        },
        description: "Hypotheses under consideration"
      },
      frameOfDiscernment: {
        type: "array",
        items: { type: "string" },
        description: "Frame of discernment for Dempster-Shafer theory"
      },
      massFunction: {
        type: "object",
        additionalProperties: { type: "number", minimum: 0, maximum: 1 },
        description: "Mass function assignments"
      },
      beliefFunction: {
        type: "object",
        additionalProperties: { type: "number", minimum: 0, maximum: 1 },
        description: "Belief function values"
      },
      plausibilityFunction: {
        type: "object",
        additionalProperties: { type: "number", minimum: 0, maximum: 1 },
        description: "Plausibility function values"
      }
    },
    required: [...baseThoughtRequired],
    additionalProperties: false
  }
};
var deepthinking_causal_schema = {
  name: "deepthinking_causal",
  description: "Causal: graphs, counterfactuals (abductive moved to core)",
  inputSchema: {
    type: "object",
    properties: {
      ...baseThoughtProperties,
      mode: {
        type: "string",
        enum: ["causal", "counterfactual"],
        description: "Causal reasoning mode"
      },
      nodes: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            description: { type: "string" }
          },
          required: ["id", "name"],
          additionalProperties: false
        },
        description: "Nodes in the causal graph"
      },
      edges: {
        type: "array",
        items: {
          type: "object",
          properties: {
            from: { type: "string" },
            to: { type: "string" },
            strength: { type: "number", minimum: 0, maximum: 1 },
            type: { type: "string" }
          },
          required: ["from", "to"],
          additionalProperties: false
        },
        description: "Causal edges in the graph"
      },
      interventions: {
        type: "array",
        items: {
          type: "object",
          properties: {
            node: { type: "string" },
            value: { type: "string" },
            effect: { type: "string" }
          },
          required: ["node"],
          additionalProperties: false
        },
        description: "Interventions applied to the causal graph"
      },
      counterfactual: {
        type: "object",
        properties: {
          actual: { type: "string" },
          hypothetical: { type: "string" },
          consequence: { type: "string" }
        },
        additionalProperties: false,
        description: "Counterfactual scenario"
      },
      observations: {
        type: "array",
        items: { type: "string" },
        description: "Observed phenomena for abductive reasoning"
      },
      explanations: {
        type: "array",
        items: {
          type: "object",
          properties: {
            hypothesis: { type: "string" },
            plausibility: { type: "number", minimum: 0, maximum: 1 }
          },
          required: ["hypothesis"],
          additionalProperties: false
        },
        description: "Candidate explanations"
      }
    },
    required: [...baseThoughtRequired],
    additionalProperties: false
  }
};
var deepthinking_strategic_schema = {
  name: "deepthinking_strategic",
  description: "Strategic: game theory, Nash equilibria, optimization",
  inputSchema: {
    type: "object",
    properties: {
      ...baseThoughtProperties,
      mode: {
        type: "string",
        enum: ["gametheory", "optimization"],
        description: "Strategic reasoning mode"
      },
      players: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            isRational: { type: "boolean", description: "Whether player is rational" },
            availableStrategies: {
              type: "array",
              items: { type: "string" },
              description: "Strategy IDs available to this player"
            },
            role: { type: "string", description: "Player's role in the game" }
          },
          required: ["id", "name", "isRational", "availableStrategies"],
          additionalProperties: false
        },
        description: "Players in the game"
      },
      strategies: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            playerId: { type: "string", description: "ID of the player using this strategy" },
            name: { type: "string", description: "Strategy name" },
            description: { type: "string", description: "Strategy description" },
            isPure: { type: "boolean", description: "Whether this is a pure strategy" },
            probability: { type: "number", minimum: 0, maximum: 1, description: "Probability for mixed strategies" }
          },
          required: ["id", "playerId", "name", "description", "isPure"],
          additionalProperties: false
        },
        description: "Available strategies"
      },
      payoffMatrix: {
        type: "object",
        properties: {
          players: {
            type: "array",
            items: { type: "string" },
            description: "Player IDs in the matrix"
          },
          dimensions: {
            type: "array",
            items: { type: "number" },
            description: "Dimensions of the payoff matrix"
          },
          payoffs: {
            type: "array",
            items: {
              type: "object",
              properties: {
                strategyProfile: {
                  type: "array",
                  items: { type: "string" },
                  description: "Strategy IDs for this profile"
                },
                payoffs: {
                  type: "array",
                  items: { type: "number" },
                  description: "Payoff values for each player"
                }
              },
              required: ["strategyProfile", "payoffs"],
              additionalProperties: false
            },
            description: "Payoff entries"
          }
        },
        required: ["players", "dimensions", "payoffs"],
        additionalProperties: false,
        description: "Payoff matrix for the game"
      },
      objectiveFunction: {
        type: "string",
        description: "Function to optimize"
      },
      constraints: {
        type: "array",
        items: { type: "string" },
        description: "Optimization constraints"
      },
      optimizationMethod: {
        type: "string",
        description: "Method used for optimization"
      },
      solution: {
        type: "object",
        properties: {
          value: { type: "string" },
          variables: {
            type: "object",
            additionalProperties: { type: "number" }
          }
        },
        additionalProperties: false,
        description: "Optimization solution"
      }
    },
    required: [...baseThoughtRequired],
    additionalProperties: false
  }
};
var deepthinking_analytical_schema = {
  name: "deepthinking_analytical",
  description: "Analytical: analogical mapping, first principles, meta-reasoning, cryptanalytic (decibans)",
  inputSchema: {
    type: "object",
    properties: {
      ...baseThoughtProperties,
      mode: {
        type: "string",
        enum: ["analogical", "firstprinciples", "metareasoning", "cryptanalytic"],
        description: "Analytical reasoning mode"
      },
      sourceAnalogy: {
        type: "object",
        properties: {
          domain: { type: "string" },
          elements: {
            type: "array",
            items: { type: "string" }
          },
          relations: {
            type: "array",
            items: { type: "string" }
          }
        },
        additionalProperties: false,
        description: "Source domain for analogy"
      },
      targetAnalogy: {
        type: "object",
        properties: {
          domain: { type: "string" },
          elements: {
            type: "array",
            items: { type: "string" }
          },
          relations: {
            type: "array",
            items: { type: "string" }
          }
        },
        additionalProperties: false,
        description: "Target domain for analogy"
      },
      mappings: {
        type: "array",
        items: {
          type: "object",
          properties: {
            source: { type: "string" },
            target: { type: "string" },
            confidence: { type: "number", minimum: 0, maximum: 1 }
          },
          required: ["source", "target"],
          additionalProperties: false
        },
        description: "Mappings between domains"
      },
      fundamentals: {
        type: "array",
        items: { type: "string" },
        description: "Fundamental truths or axioms"
      },
      derivedInsights: {
        type: "array",
        items: { type: "string" },
        description: "Insights derived from first principles"
      }
    },
    required: [...baseThoughtRequired],
    additionalProperties: false
  }
};
var deepthinking_scientific_schema = {
  name: "deepthinking_scientific",
  description: "Scientific: hypothesis testing, systems thinking, formal logic",
  inputSchema: {
    type: "object",
    properties: {
      ...baseThoughtProperties,
      mode: {
        type: "string",
        enum: ["scientificmethod", "systemsthinking", "formallogic"],
        description: "Scientific reasoning mode"
      },
      hypothesis: {
        type: "string",
        description: "Scientific hypothesis"
      },
      predictions: {
        type: "array",
        items: { type: "string" },
        description: "Testable predictions"
      },
      experiments: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            description: { type: "string" },
            result: { type: "string" }
          },
          required: ["id", "description"],
          additionalProperties: false
        },
        description: "Experiments conducted"
      },
      systemComponents: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            role: { type: "string" }
          },
          required: ["id", "name"],
          additionalProperties: false
        },
        description: "Components of the system"
      },
      interactions: {
        type: "array",
        items: {
          type: "object",
          properties: {
            from: { type: "string" },
            to: { type: "string" },
            type: { type: "string" }
          },
          required: ["from", "to", "type"],
          additionalProperties: false
        },
        description: "Interactions between components"
      },
      feedbackLoops: {
        type: "array",
        items: {
          type: "object",
          properties: {
            type: {
              type: "string",
              enum: ["positive", "negative", "neutral"]
            },
            components: {
              type: "array",
              items: { type: "string" }
            }
          },
          additionalProperties: false
        },
        description: "Feedback loops in the system"
      },
      premises: {
        type: "array",
        items: { type: "string" },
        description: "Logical premises"
      },
      conclusion: {
        type: "string",
        description: "Logical conclusion"
      },
      inference: {
        type: "string",
        description: "Type of logical inference used"
      }
    },
    required: [...baseThoughtRequired],
    additionalProperties: false
  }
};
var deepthinking_engineering_schema = {
  name: "deepthinking_engineering",
  description: "Engineering: requirements, trade studies, FMEA, ADRs, algorithm design (CLRS)",
  inputSchema: {
    type: "object",
    properties: {
      ...baseThoughtProperties,
      mode: {
        type: "string",
        enum: ["engineering", "algorithmic"],
        description: "Engineering reasoning mode"
      },
      // Engineering-specific properties
      requirementId: {
        type: "string",
        description: "Requirement ID being analyzed"
      },
      tradeStudy: {
        type: "object",
        properties: {
          options: {
            type: "array",
            items: { type: "string" },
            description: "Options being compared"
          },
          criteria: {
            type: "array",
            items: { type: "string" },
            description: "Evaluation criteria"
          },
          weights: {
            type: "object",
            additionalProperties: { type: "number" },
            description: "Criteria weights"
          }
        },
        additionalProperties: false,
        description: "Trade study configuration"
      },
      fmeaEntry: {
        type: "object",
        properties: {
          failureMode: { type: "string" },
          severity: { type: "integer", minimum: 1, maximum: 10 },
          occurrence: { type: "integer", minimum: 1, maximum: 10 },
          detection: { type: "integer", minimum: 1, maximum: 10 },
          rpn: { type: "integer", description: "Risk Priority Number = S * O * D" }
        },
        additionalProperties: false,
        description: "FMEA analysis entry"
      },
      // Algorithmic-specific properties
      algorithmName: {
        type: "string",
        description: "Name of the algorithm being analyzed"
      },
      designPattern: {
        type: "string",
        enum: ["divide-and-conquer", "dynamic-programming", "greedy", "backtracking", "branch-and-bound", "randomized", "approximation"],
        description: "Algorithm design pattern"
      },
      complexityAnalysis: {
        type: "object",
        properties: {
          timeComplexity: { type: "string", description: "Time complexity (e.g., O(n log n))" },
          spaceComplexity: { type: "string", description: "Space complexity (e.g., O(n))" },
          bestCase: { type: "string" },
          averageCase: { type: "string" },
          worstCase: { type: "string" }
        },
        additionalProperties: false,
        description: "Complexity analysis"
      },
      correctnessProof: {
        type: "object",
        properties: {
          invariant: { type: "string", description: "Loop invariant" },
          termination: { type: "string", description: "Termination argument" },
          correctness: { type: "string", description: "Correctness proof" }
        },
        additionalProperties: false,
        description: "Algorithm correctness proof"
      }
    },
    required: [...baseThoughtRequired],
    additionalProperties: false
  }
};
var deepthinking_academic_schema = {
  name: "deepthinking_academic",
  description: "Academic: synthesis (literature review), argumentation (Toulmin), critique (peer review), analysis (qualitative)",
  inputSchema: {
    type: "object",
    properties: {
      ...baseThoughtProperties,
      mode: {
        type: "string",
        enum: ["synthesis", "argumentation", "critique", "analysis"],
        description: "Academic research reasoning mode"
      },
      // Synthesis-specific properties
      sources: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            citation: { type: "string" },
            keyFindings: { type: "array", items: { type: "string" } },
            methodology: { type: "string" },
            relevance: { type: "number", minimum: 0, maximum: 1 }
          },
          additionalProperties: false
        },
        description: "Literature sources being synthesized"
      },
      themes: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            description: { type: "string" },
            sourceIds: { type: "array", items: { type: "string" } },
            strength: { type: "number", minimum: 0, maximum: 1 },
            consensus: { type: "string", enum: ["strong", "moderate", "weak", "contested"] }
          },
          required: ["id", "name"]
        },
        description: "Identified themes across sources"
      },
      researchGaps: {
        type: "array",
        items: { type: "string" },
        description: "Identified gaps in the literature"
      },
      gaps: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            description: { type: "string" },
            type: { type: "string", enum: ["empirical", "theoretical", "methodological", "population", "contextual"] },
            importance: { type: "string", enum: ["critical", "significant", "moderate", "minor"] }
          },
          required: ["id", "description"]
        },
        description: "Identified gaps in the literature (structured)"
      },
      // Argumentation-specific properties (Toulmin model)
      claim: {
        type: "string",
        description: "Main claim or thesis"
      },
      data: {
        type: "array",
        items: { type: "string" },
        description: "Evidence supporting the claim"
      },
      warrant: {
        type: "string",
        description: "Reasoning connecting data to claim"
      },
      backing: {
        type: "string",
        description: "Support for the warrant"
      },
      qualifier: {
        type: "string",
        description: "Degree of certainty (e.g., 'probably', 'likely')"
      },
      rebuttal: {
        type: "string",
        description: "Potential counter-arguments"
      },
      // Critique-specific properties
      strengths: {
        type: "array",
        items: { type: "string" },
        description: "Identified strengths"
      },
      weaknesses: {
        type: "array",
        items: { type: "string" },
        description: "Identified weaknesses"
      },
      methodologyAssessment: {
        type: "object",
        properties: {
          validity: { type: "string" },
          reliability: { type: "string" },
          limitations: { type: "array", items: { type: "string" } }
        },
        additionalProperties: false,
        description: "Assessment of methodology"
      },
      // Analysis-specific properties
      analysisMethod: {
        type: "string",
        enum: ["thematic", "grounded-theory", "discourse", "content", "narrative", "phenomenological"],
        description: "Qualitative analysis method"
      },
      codes: {
        type: "array",
        items: {
          type: "object",
          properties: {
            code: { type: "string" },
            description: { type: "string" },
            examples: { type: "array", items: { type: "string" } }
          },
          additionalProperties: false
        },
        description: "Coding scheme for analysis"
      },
      categories: {
        type: "array",
        items: { type: "string" },
        description: "Categories derived from codes"
      }
    },
    required: [...baseThoughtRequired],
    additionalProperties: false
  }
};
var deepthinking_session_schema = {
  name: "deepthinking_session",
  description: "Session: summarize, export, get, switch_mode, recommend, delete",
  inputSchema: {
    type: "object",
    properties: {
      sessionId: {
        type: "string",
        description: "Session ID (required for most actions except recommend_mode)"
      },
      action: {
        type: "string",
        enum: ["summarize", "export", "get_session", "switch_mode", "recommend_mode", "delete_session"],
        description: "Session action to perform"
      },
      exportFormat: {
        type: "string",
        enum: ["markdown", "latex", "json", "html", "jupyter", "mermaid", "dot", "ascii"],
        description: "Export format (for export action)"
      },
      newMode: {
        type: "string",
        description: "New thinking mode (for switch_mode action)"
      },
      problemType: {
        type: "string",
        description: "Quick problem type for mode recommendation"
      },
      problemCharacteristics: {
        type: "object",
        properties: {
          domain: { type: "string", description: "Problem domain" },
          complexity: {
            type: "string",
            enum: ["low", "medium", "high"],
            description: "Problem complexity level"
          },
          uncertainty: {
            type: "string",
            enum: ["low", "medium", "high"],
            description: "Uncertainty level"
          },
          timeDependent: { type: "boolean", description: "Whether problem involves time" },
          multiAgent: { type: "boolean", description: "Whether problem involves multiple agents" },
          requiresProof: { type: "boolean", description: "Whether formal proof is needed" },
          requiresQuantification: { type: "boolean", description: "Whether quantitative analysis is needed" },
          hasIncompleteInfo: { type: "boolean", description: "Whether information is incomplete" },
          requiresExplanation: { type: "boolean", description: "Whether explanation is needed" },
          hasAlternatives: { type: "boolean", description: "Whether alternative scenarios exist" }
        },
        required: ["domain", "complexity", "uncertainty", "timeDependent", "multiAgent", "requiresProof", "requiresQuantification", "hasIncompleteInfo", "requiresExplanation", "hasAlternatives"],
        additionalProperties: false,
        description: "Detailed problem characteristics for comprehensive recommendation"
      },
      includeCombinations: {
        type: "boolean",
        description: "Include mode combinations in recommendations"
      }
    },
    required: ["action"],
    additionalProperties: false
  }
};
var jsonSchemas = [
  deepthinking_core_schema,
  deepthinking_standard_schema,
  deepthinking_mathematics_schema,
  deepthinking_temporal_schema,
  deepthinking_probabilistic_schema,
  deepthinking_causal_schema,
  deepthinking_strategic_schema,
  deepthinking_analytical_schema,
  deepthinking_scientific_schema,
  deepthinking_engineering_schema,
  deepthinking_academic_schema,
  deepthinking_session_schema
];

// src/tools/schemas/base.ts
init_esm_shims();

// src/tools/schemas/shared.ts
init_esm_shims();
var ConfidenceSchema = z.number().min(0).max(1);
var PositiveIntSchema = z.number().int().min(1);
var LevelEnum = z.enum(["low", "medium", "high"]);
z.enum(["positive", "negative", "neutral"]);
var ExportFormatEnum = z.enum([
  "markdown",
  "latex",
  "json",
  "html",
  "jupyter",
  "mermaid",
  "dot",
  "ascii"
]);
var SessionActionEnum = z.enum([
  "summarize",
  "export",
  "get_session",
  "switch_mode",
  "recommend_mode",
  "delete_session"
]);
var ProofTypeEnum = z.enum([
  "direct",
  "contradiction",
  "induction",
  "construction",
  "contrapositive"
]);
var TimeUnitEnum = z.enum([
  "milliseconds",
  "seconds",
  "minutes",
  "hours",
  "days",
  "months",
  "years"
]);
var TemporalConstraintEnum = z.enum([
  "before",
  "after",
  "during",
  "overlaps",
  "meets",
  "starts",
  "finishes",
  "equals"
]);
var TemporalRelationEnum = z.enum([
  "before",
  "after",
  "during",
  "overlaps",
  "meets",
  "starts",
  "finishes",
  "equals",
  "causes"
]);
var EventTypeEnum = z.enum(["instant", "interval"]);
var TransformationEnum = z.enum(["covariant", "contravariant", "mixed"]);
var ShannonStageEnum = z.enum([
  "problem_definition",
  "constraints",
  "model",
  "proof",
  "implementation"
]);
var EntitySchema = z.object({
  id: z.string(),
  name: z.string()
});
EntitySchema.extend({
  description: z.string()
});

// src/tools/schemas/base.ts
var BaseThoughtSchema = z.object({
  sessionId: z.string().optional(),
  thought: z.string().min(1),
  thoughtNumber: PositiveIntSchema,
  totalThoughts: PositiveIntSchema,
  nextThoughtNeeded: z.boolean(),
  isRevision: z.boolean().optional(),
  revisesThought: z.string().optional(),
  revisionReason: z.string().optional(),
  branchFrom: z.string().optional(),
  branchId: z.string().optional(),
  uncertainty: ConfidenceSchema.optional(),
  dependencies: z.array(z.string()).optional(),
  assumptions: z.array(z.string()).optional()
});
var SessionActionSchema = z.object({
  sessionId: z.string().optional(),
  action: SessionActionEnum,
  exportFormat: ExportFormatEnum.optional(),
  newMode: z.string().optional(),
  problemType: z.string().optional(),
  problemCharacteristics: z.object({
    domain: z.string(),
    complexity: LevelEnum,
    uncertainty: LevelEnum,
    timeDependent: z.boolean(),
    multiAgent: z.boolean(),
    requiresProof: z.boolean(),
    requiresQuantification: z.boolean(),
    hasIncompleteInfo: z.boolean(),
    requiresExplanation: z.boolean(),
    hasAlternatives: z.boolean()
  }).optional(),
  includeCombinations: z.boolean().optional()
});

// src/tools/schemas/modes/core.ts
init_esm_shims();
var StandardSchema = BaseThoughtSchema.extend({
  mode: z.enum(["sequential", "shannon", "hybrid"]),
  stage: ShannonStageEnum.optional(),
  activeModes: z.array(z.string()).optional()
});
var CoreModeSchema = BaseThoughtSchema.extend({
  mode: z.enum(["inductive", "deductive", "abductive"]),
  // Inductive properties
  observations: z.array(z.string()).optional(),
  pattern: z.string().optional(),
  generalization: z.string().optional(),
  confidence: z.number().min(0).max(1).optional(),
  counterexamples: z.array(z.string()).optional(),
  sampleSize: z.number().int().min(1).optional(),
  // Deductive properties
  premises: z.array(z.string()).optional(),
  conclusion: z.string().optional(),
  logicForm: z.string().optional(),
  validityCheck: z.boolean().optional(),
  soundnessCheck: z.boolean().optional(),
  // Abductive properties
  hypotheses: z.array(z.object({
    id: z.string(),
    explanation: z.string(),
    score: z.number().optional()
  })).optional(),
  bestExplanation: z.object({
    id: z.string(),
    explanation: z.string(),
    score: z.number().optional()
  }).optional()
});

// src/tools/schemas/modes/mathematics.ts
init_esm_shims();
var ProofStrategySchema = z.object({
  type: ProofTypeEnum,
  steps: z.array(z.string())
});
var MathematicalModelSchema = z.object({
  latex: z.string(),
  symbolic: z.string(),
  ascii: z.string().optional()
});
var TensorPropertiesSchema = z.object({
  rank: z.tuple([z.number(), z.number()]),
  components: z.string(),
  latex: z.string(),
  symmetries: z.array(z.string()),
  invariants: z.array(z.string()),
  transformation: TransformationEnum
});
var PhysicalInterpretationSchema = z.object({
  quantity: z.string(),
  units: z.string(),
  conservationLaws: z.array(z.string())
});
var ProofStepInputSchema = z.object({
  stepNumber: z.number().int().positive(),
  statement: z.string(),
  justification: z.string().optional(),
  latex: z.string().optional(),
  referencesSteps: z.array(z.number()).optional()
});
var MathSchema = BaseThoughtSchema.extend({
  mode: z.enum(["mathematics", "physics", "computability"]),
  thoughtType: z.string().optional(),
  proofStrategy: ProofStrategySchema.optional(),
  mathematicalModel: MathematicalModelSchema.optional(),
  tensorProperties: TensorPropertiesSchema.optional(),
  physicalInterpretation: PhysicalInterpretationSchema.optional(),
  // Phase 8: Proof decomposition fields
  proofSteps: z.array(ProofStepInputSchema).optional(),
  theorem: z.string().optional(),
  hypotheses: z.array(z.string()).optional(),
  analysisDepth: z.enum(["shallow", "standard", "deep"]).optional(),
  includeConsistencyCheck: z.boolean().optional(),
  traceAssumptions: z.boolean().optional()
});

// src/tools/schemas/modes/temporal.ts
init_esm_shims();
var TimelineSchema = z.object({
  id: z.string(),
  name: z.string(),
  timeUnit: TimeUnitEnum,
  events: z.array(z.string()),
  startTime: z.number().optional(),
  endTime: z.number().optional()
});
var TemporalEventSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string(),
  timestamp: z.number(),
  type: EventTypeEnum,
  duration: z.number().optional(),
  properties: z.record(z.string(), z.unknown()).optional()
});
var TemporalConstraintSchema = z.object({
  id: z.string(),
  type: TemporalConstraintEnum,
  subject: z.string(),
  object: z.string(),
  confidence: ConfidenceSchema
});
var TemporalIntervalSchema = z.object({
  id: z.string(),
  name: z.string(),
  start: z.number(),
  end: z.number(),
  contains: z.array(z.string()).optional(),
  overlaps: z.array(z.string()).optional()
});
var TemporalRelationSchema = z.object({
  id: z.string(),
  from: z.string(),
  to: z.string(),
  relationType: TemporalRelationEnum,
  strength: ConfidenceSchema,
  delay: z.number().optional()
});
var TemporalSchema = BaseThoughtSchema.extend({
  mode: z.literal("temporal"),
  timeline: TimelineSchema.optional(),
  events: z.array(TemporalEventSchema).optional(),
  constraints: z.array(TemporalConstraintSchema).optional(),
  intervals: z.array(TemporalIntervalSchema).optional(),
  relations: z.array(TemporalRelationSchema).optional()
});

// src/tools/schemas/modes/probabilistic.ts
init_esm_shims();
var BeliefMassSchema = z.object({
  hypothesisSet: z.array(z.string()),
  mass: ConfidenceSchema,
  justification: z.string()
});
var ProbabilisticSchema = BaseThoughtSchema.extend({
  mode: z.enum(["bayesian", "evidential"]),
  // Evidential (Dempster-Shafer) specific
  frameOfDiscernment: z.array(z.string()).optional(),
  beliefMasses: z.array(BeliefMassSchema).optional()
});

// src/tools/schemas/modes/causal.ts
init_esm_shims();
var CausalNodeSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string().optional(),
  type: z.enum(["cause", "effect", "mediator", "confounder"]).optional()
});
var CausalEdgeSchema = z.object({
  from: z.string(),
  to: z.string(),
  type: z.string().optional(),
  strength: z.number().min(0).max(1).optional()
});
var CounterfactualSchema = z.object({
  actual: z.string().optional(),
  hypothetical: z.string().optional(),
  consequence: z.string().optional()
});
var InterventionSchema = z.object({
  node: z.string(),
  value: z.string().optional(),
  effect: z.string().optional()
});
var CausalSchema = BaseThoughtSchema.extend({
  mode: z.enum(["causal", "counterfactual", "abductive"]),
  // Causal graph properties (top-level for JSON schema compatibility)
  nodes: z.array(CausalNodeSchema).optional(),
  edges: z.array(CausalEdgeSchema).optional(),
  // Nested causalGraph for backwards compatibility
  causalGraph: z.object({
    nodes: z.array(CausalNodeSchema),
    edges: z.array(CausalEdgeSchema)
  }).optional(),
  // Counterfactual properties
  counterfactual: CounterfactualSchema.optional(),
  // Intervention properties
  interventions: z.array(InterventionSchema).optional(),
  // Observations for abductive reasoning
  observations: z.array(z.string()).optional(),
  explanations: z.array(z.object({
    hypothesis: z.string(),
    plausibility: z.number().min(0).max(1).optional()
  })).optional()
});

// src/tools/schemas/modes/strategic.ts
init_esm_shims();
var PlayerSchema = z.object({
  id: z.string(),
  name: z.string(),
  isRational: z.boolean(),
  availableStrategies: z.array(z.string()),
  role: z.string().optional()
});
var StrategySchema = z.object({
  id: z.string(),
  playerId: z.string(),
  name: z.string(),
  description: z.string(),
  isPure: z.boolean(),
  probability: ConfidenceSchema.optional()
});
var PayoffEntrySchema = z.object({
  strategyProfile: z.array(z.string()),
  payoffs: z.array(z.number())
});
var PayoffMatrixSchema = z.object({
  players: z.array(z.string()),
  dimensions: z.array(z.number()),
  payoffs: z.array(PayoffEntrySchema)
});
var StrategicSchema = BaseThoughtSchema.extend({
  mode: z.enum(["gametheory", "optimization"]),
  // Game theory specific
  players: z.array(PlayerSchema).optional(),
  strategies: z.array(StrategySchema).optional(),
  payoffMatrix: PayoffMatrixSchema.optional()
});

// src/tools/schemas/modes/analytical.ts
init_esm_shims();
var AnalyticalSchema = BaseThoughtSchema.extend({
  mode: z.enum(["analogical", "firstprinciples", "metareasoning", "cryptanalytic"])
});

// src/tools/schemas/modes/scientific.ts
init_esm_shims();
var ScientificSchema = BaseThoughtSchema.extend({
  mode: z.enum(["scientificmethod", "systemsthinking", "formallogic"])
});

// src/tools/schemas/modes/engineering.ts
init_esm_shims();
var EngineeringSchema = BaseThoughtSchema.extend({
  mode: z.enum(["engineering", "algorithmic"])
});

// src/tools/schemas/modes/academic.ts
init_esm_shims();
var AcademicModeEnum = z.enum(["synthesis", "argumentation", "critique", "analysis"]);
var SourceSchema = z.object({
  id: z.string(),
  type: z.string().optional(),
  title: z.string(),
  authors: z.array(z.string()).optional(),
  year: z.number().int().optional(),
  venue: z.string().optional(),
  doi: z.string().optional(),
  relevance: ConfidenceSchema.optional()
});
var ThemeSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string().optional(),
  sourceIds: z.array(z.string()).optional(),
  strength: ConfidenceSchema.optional(),
  consensus: z.enum(["strong", "moderate", "weak", "contested"]).optional()
});
var GapSchema = z.object({
  id: z.string(),
  description: z.string(),
  type: z.enum(["empirical", "theoretical", "methodological", "population", "contextual"]).optional(),
  importance: z.enum(["critical", "significant", "moderate", "minor"]).optional()
});
var ClaimSchema = z.object({
  id: z.string(),
  statement: z.string(),
  type: z.enum(["fact", "value", "policy", "definition", "cause"]).optional(),
  strength: z.enum(["strong", "moderate", "tentative"]).optional()
});
var GroundsSchema = z.object({
  id: z.string(),
  type: z.enum(["empirical", "statistical", "testimonial", "analogical", "logical", "textual"]).optional(),
  content: z.string(),
  source: z.string().optional(),
  reliability: ConfidenceSchema.optional()
});
var WarrantSchema = z.object({
  id: z.string(),
  statement: z.string(),
  type: z.enum(["generalization", "analogy", "causal", "authority", "principle", "definition"]).optional(),
  groundsIds: z.array(z.string()).optional(),
  claimId: z.string().optional()
});
var RebuttalSchema = z.object({
  id: z.string(),
  objection: z.string(),
  type: z.enum(["factual", "logical", "ethical", "practical", "definitional"]).optional(),
  strength: z.enum(["strong", "moderate", "weak"]).optional(),
  response: z.string().optional()
});
var CritiquedWorkSchema = z.object({
  id: z.string().optional(),
  title: z.string(),
  authors: z.array(z.string()).optional(),
  year: z.number().int().optional(),
  type: z.string().optional(),
  field: z.string().optional()
});
var CodeSchema = z.object({
  id: z.string(),
  label: z.string(),
  definition: z.string().optional(),
  type: z.enum(["descriptive", "in_vivo", "process", "initial", "focused", "axial", "theoretical", "emotion", "value"]).optional(),
  frequency: z.number().int().optional(),
  examples: z.array(z.string()).optional()
});
var MemoSchema = z.object({
  id: z.string(),
  type: z.enum(["analytical", "theoretical", "methodological", "reflexive", "code", "operational"]).optional(),
  content: z.string(),
  relatedCodes: z.array(z.string()).optional()
});
var AcademicSchema = BaseThoughtSchema.extend({
  mode: AcademicModeEnum,
  thoughtType: z.string().optional(),
  // Synthesis properties
  sources: z.array(SourceSchema).optional(),
  themes: z.array(ThemeSchema).optional(),
  gaps: z.array(GapSchema).optional(),
  // Argumentation properties (Toulmin model)
  claims: z.array(ClaimSchema).optional(),
  grounds: z.array(GroundsSchema).optional(),
  warrants: z.array(WarrantSchema).optional(),
  rebuttals: z.array(RebuttalSchema).optional(),
  argumentStrength: ConfidenceSchema.optional(),
  // Critique properties
  critiquedWork: CritiquedWorkSchema.optional(),
  strengths: z.array(z.string()).optional(),
  weaknesses: z.array(z.string()).optional(),
  suggestions: z.array(z.string()).optional(),
  // Analysis properties (qualitative)
  methodology: z.enum([
    "thematic_analysis",
    "grounded_theory",
    "discourse_analysis",
    "content_analysis",
    "phenomenological",
    "narrative_analysis",
    "framework_analysis",
    "template_analysis",
    "mixed_qualitative"
  ]).optional(),
  dataSources: z.array(z.object({
    id: z.string(),
    type: z.string(),
    description: z.string().optional(),
    participantId: z.string().optional()
  })).optional(),
  codes: z.array(CodeSchema).optional(),
  memos: z.array(MemoSchema).optional(),
  saturationReached: z.boolean().optional(),
  // Shared
  keyInsight: z.string().optional()
});
var toolList = jsonSchemas;
var toolSchemas = {
  deepthinking_core: CoreModeSchema,
  deepthinking_standard: StandardSchema,
  deepthinking_mathematics: MathSchema,
  deepthinking_temporal: TemporalSchema,
  deepthinking_probabilistic: ProbabilisticSchema,
  deepthinking_causal: CausalSchema,
  deepthinking_strategic: StrategicSchema,
  deepthinking_analytical: AnalyticalSchema,
  deepthinking_scientific: ScientificSchema,
  deepthinking_engineering: EngineeringSchema,
  deepthinking_academic: AcademicSchema,
  deepthinking_session: SessionActionSchema
};
var modeToToolMap = {
  // Core reasoning modes (fundamental)
  inductive: "deepthinking_core",
  deductive: "deepthinking_core",
  abductive: "deepthinking_core",
  // Standard workflow modes
  sequential: "deepthinking_standard",
  shannon: "deepthinking_standard",
  hybrid: "deepthinking_standard",
  // Math/Physics/Computability modes
  mathematics: "deepthinking_mathematics",
  physics: "deepthinking_mathematics",
  computability: "deepthinking_mathematics",
  // Temporal mode
  temporal: "deepthinking_temporal",
  // Probabilistic modes
  bayesian: "deepthinking_probabilistic",
  evidential: "deepthinking_probabilistic",
  // Causal modes
  causal: "deepthinking_causal",
  counterfactual: "deepthinking_causal",
  // Strategic modes
  gametheory: "deepthinking_strategic",
  optimization: "deepthinking_strategic",
  // Analytical modes (includes cryptanalytic)
  analogical: "deepthinking_analytical",
  firstprinciples: "deepthinking_analytical",
  metareasoning: "deepthinking_analytical",
  cryptanalytic: "deepthinking_analytical",
  // Scientific modes
  scientificmethod: "deepthinking_scientific",
  systemsthinking: "deepthinking_scientific",
  formallogic: "deepthinking_scientific",
  // Engineering modes (Phase 14)
  engineering: "deepthinking_engineering",
  algorithmic: "deepthinking_engineering",
  // Academic research modes (Phase 14)
  synthesis: "deepthinking_academic",
  argumentation: "deepthinking_academic",
  critique: "deepthinking_academic",
  analysis: "deepthinking_academic"
};
function isValidTool(toolName) {
  return toolName in toolSchemas;
}

// src/index.ts
init_thinking();
init_types();
init_modes();
var __filename2 = fileURLToPath(import.meta.url);
var __dirname2 = dirname(__filename2);
var packageJson = JSON.parse(
  readFileSync(join(__dirname2, "../package.json"), "utf-8")
);
var server = new Server(
  {
    name: packageJson.name,
    version: packageJson.version
  },
  {
    capabilities: {
      tools: {}
    }
  }
);
var _sessionManager = null;
var _thoughtFactory = null;
var _exportService = null;
var _modeRouter = null;
async function getSessionManager() {
  if (!_sessionManager) {
    const { SessionManager: SessionManager2 } = await Promise.resolve().then(() => (init_session2(), session_exports));
    const sessionDir = process.env.SESSION_DIR;
    if (sessionDir) {
      const { FileSessionStore: FileSessionStore2 } = await Promise.resolve().then(() => (init_file_store(), file_store_exports));
      const storage = new FileSessionStore2(sessionDir);
      await storage.initialize();
      _sessionManager = new SessionManager2({}, void 0, storage);
      console.error(`[deepthinking-mcp] Using file-based session storage: ${sessionDir}`);
    } else {
      _sessionManager = new SessionManager2();
    }
  }
  return _sessionManager;
}
async function getThoughtFactory() {
  if (!_thoughtFactory) {
    const { ThoughtFactory: ThoughtFactory2 } = await Promise.resolve().then(() => (init_services(), services_exports));
    _thoughtFactory = new ThoughtFactory2();
  }
  return _thoughtFactory;
}
async function getExportService() {
  if (!_exportService) {
    const { ExportService: ExportService2 } = await Promise.resolve().then(() => (init_services(), services_exports));
    _exportService = new ExportService2();
  }
  return _exportService;
}
async function getModeRouter() {
  if (!_modeRouter) {
    const { ModeRouter: ModeRouter2 } = await Promise.resolve().then(() => (init_services(), services_exports));
    const sessionManager = await getSessionManager();
    _modeRouter = new ModeRouter2(sessionManager);
  }
  return _modeRouter;
}
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      ...toolList,
      // 9 new focused tools
      thinkingTool
      // Legacy tool for backward compatibility
    ]
  };
});
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;
  try {
    if (isValidTool(name)) {
      const schema = toolSchemas[name];
      const input = schema.parse(args);
      if (name === "deepthinking_session") {
        return await handleSessionAction(input);
      }
      return await handleAddThought(input, name);
    }
    if (name === "deepthinking") {
      const { ThinkingToolSchema: ThinkingToolSchema2 } = await Promise.resolve().then(() => (init_thinking(), thinking_exports));
      const input = ThinkingToolSchema2.parse(args);
      const deprecationWarning = '\u26A0\uFE0F DEPRECATED: The "deepthinking" tool is deprecated. Use the focused tools instead: deepthinking_core, deepthinking_mathematics, deepthinking_temporal, deepthinking_probabilistic, deepthinking_causal, deepthinking_strategic, deepthinking_analytical, deepthinking_scientific, deepthinking_session. See docs/migration/v4.0-tool-splitting.md for details.\n\n';
      switch (input.action) {
        case "add_thought": {
          const result = await handleAddThought(input, modeToToolMap[input.mode || "hybrid"] || "deepthinking_core");
          return prependWarning(result, deprecationWarning);
        }
        case "summarize":
        case "export":
        case "switch_mode":
        case "get_session":
        case "recommend_mode": {
          const result = await handleSessionAction(input);
          return prependWarning(result, deprecationWarning);
        }
        default:
          throw new Error(`Unknown action: ${input.action}`);
      }
    }
    throw new Error(`Unknown tool: ${name}`);
  } catch (error) {
    return {
      content: [
        {
          type: "text",
          text: `Error: ${error instanceof Error ? error.message : String(error)}`
        }
      ],
      isError: true
    };
  }
});
function prependWarning(result, warning) {
  if (result.content && result.content[0] && result.content[0].type === "text") {
    result.content[0].text = warning + result.content[0].text;
  }
  return result;
}
async function handleAddThought(input, _toolName) {
  const sessionManager = await getSessionManager();
  const thoughtFactory = await getThoughtFactory();
  let sessionId = input.sessionId;
  const mode = input.mode || "hybrid" /* HYBRID */;
  if (!sessionId) {
    const session2 = await sessionManager.createSession({
      mode,
      title: `Thinking Session ${(/* @__PURE__ */ new Date()).toISOString()}`
    });
    sessionId = session2.id;
  }
  const thought = thoughtFactory.createThought({ ...input, mode }, sessionId);
  const session = await sessionManager.addThought(sessionId, thought);
  const registry = ModeHandlerRegistry.getInstance();
  const modeStatus = {
    mode: thought.mode,
    isFullyImplemented: isFullyImplemented(thought.mode),
    hasSpecializedHandler: registry.hasSpecializedHandler(thought.mode),
    note: !isFullyImplemented(thought.mode) ? "This mode is experimental with limited runtime implementation" : registry.hasSpecializedHandler(thought.mode) ? void 0 : "Using generic handler - specialized validation not available"
  };
  const response = {
    sessionId: session.id,
    thoughtId: thought.id,
    thoughtNumber: thought.thoughtNumber,
    mode: thought.mode,
    nextThoughtNeeded: thought.nextThoughtNeeded,
    sessionComplete: session.isComplete,
    totalThoughts: session.thoughts.length,
    modeStatus
    // Phase 10 Sprint 1: API transparency
  };
  if (thought.decomposition) {
    response.decomposition = thought.decomposition;
  }
  if (thought.consistencyReport) {
    response.consistencyReport = thought.consistencyReport;
  }
  if (thought.gapAnalysis) {
    response.gapAnalysis = thought.gapAnalysis;
  }
  return {
    content: [
      {
        type: "text",
        text: JSON.stringify(response, null, 2)
      }
    ]
  };
}
async function handleSessionAction(input) {
  const action = input.action;
  switch (action) {
    case "summarize":
      return await handleSummarize(input);
    case "export":
      return await handleExport(input);
    case "switch_mode":
      return await handleSwitchMode(input);
    case "get_session":
      return await handleGetSession(input);
    case "recommend_mode":
      return await handleRecommendMode(input);
    case "delete_session":
      return await handleDeleteSession(input);
    default:
      throw new Error(`Unknown session action: ${action}`);
  }
}
async function handleSummarize(input) {
  if (!input.sessionId) {
    throw new Error("sessionId required for summarize action");
  }
  const sessionManager = await getSessionManager();
  const summary = await sessionManager.generateSummary(input.sessionId);
  return {
    content: [
      {
        type: "text",
        text: summary
      }
    ]
  };
}
async function handleExport(input) {
  if (!input.sessionId) {
    throw new Error("sessionId required for export action");
  }
  const sessionManager = await getSessionManager();
  const exportService = await getExportService();
  const session = await sessionManager.getSession(input.sessionId);
  if (!session) {
    throw new Error(`Session ${input.sessionId} not found`);
  }
  const format = input.exportFormat || "json";
  const exported = exportService.exportSession(session, format);
  return {
    content: [{
      type: "text",
      text: exported
    }]
  };
}
async function handleSwitchMode(input) {
  if (!input.sessionId || !input.newMode) {
    throw new Error("sessionId and newMode required for switch_mode action");
  }
  const modeRouter = await getModeRouter();
  const session = await modeRouter.switchMode(
    input.sessionId,
    input.newMode,
    "User requested mode switch"
  );
  return {
    content: [
      {
        type: "text",
        text: `Switched session ${session.id} to ${session.mode} mode`
      }
    ]
  };
}
async function handleGetSession(input) {
  if (!input.sessionId) {
    throw new Error("sessionId required for get_session action");
  }
  const sessionManager = await getSessionManager();
  const session = await sessionManager.getSession(input.sessionId);
  if (!session) {
    throw new Error(`Session ${input.sessionId} not found`);
  }
  const metricsWithCustom = {
    ...session.metrics,
    customMetrics: Object.fromEntries(session.metrics.customMetrics)
  };
  return {
    content: [
      {
        type: "text",
        text: JSON.stringify({
          id: session.id,
          title: session.title,
          mode: session.mode,
          thoughtCount: session.thoughts.length,
          isComplete: session.isComplete,
          metrics: metricsWithCustom
        }, null, 2)
      }
    ]
  };
}
async function handleRecommendMode(input) {
  const modeRouter = await getModeRouter();
  if (input.problemType && !input.problemCharacteristics) {
    const recommendedMode = modeRouter.quickRecommend(input.problemType);
    const response = modeRouter.formatQuickRecommendation(input.problemType, recommendedMode);
    return {
      content: [{
        type: "text",
        text: response
      }],
      isError: false
    };
  }
  if (input.problemCharacteristics) {
    const response = modeRouter.getRecommendations(
      input.problemCharacteristics,
      input.includeCombinations || false
    );
    return {
      content: [{
        type: "text",
        text: response
      }],
      isError: false
    };
  }
  return {
    content: [{
      type: "text",
      text: "Error: Please provide either problemType or problemCharacteristics for mode recommendations."
    }],
    isError: true
  };
}
async function handleDeleteSession(input) {
  if (!input.sessionId) {
    throw new Error("sessionId required for delete_session action");
  }
  const sessionManager = await getSessionManager();
  const session = await sessionManager.getSession(input.sessionId);
  if (!session) {
    throw new Error(`Session ${input.sessionId} not found`);
  }
  await sessionManager.deleteSession(input.sessionId);
  return {
    content: [
      {
        type: "text",
        text: `Session ${input.sessionId} deleted successfully`
      }
    ]
  };
}
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("DeepThinking MCP server running on stdio");
}
main().catch((error) => {
  console.error("Fatal error:", error);
  process.exit(1);
});
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map