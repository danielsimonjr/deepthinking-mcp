#!/usr/bin/env node
import * as path3 from 'path';
import { dirname, join } from 'path';
import { fileURLToPath } from 'url';
import { z } from 'zod';
import { randomUUID, createHash } from 'crypto';
import { readFileSync, promises } from 'fs';
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { ListToolsRequestSchema, CallToolRequestSchema } from '@modelcontextprotocol/sdk/types.js';

var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var init_esm_shims = __esm({
  "node_modules/tsup/assets/esm_shims.js"() {
  }
});

// src/tools/thinking.ts
var thinking_exports = {};
__export(thinking_exports, {
  ThinkingToolSchema: () => ThinkingToolSchema,
  thinkingTool: () => thinkingTool
});
var ThinkingToolSchema, thinkingTool;
var init_thinking = __esm({
  "src/tools/thinking.ts"() {
    init_esm_shims();
    ThinkingToolSchema = z.object({
      sessionId: z.string().optional(),
      mode: z.enum(["sequential", "shannon", "mathematics", "physics", "hybrid", "inductive", "deductive", "abductive", "causal", "bayesian", "counterfactual", "analogical", "temporal", "gametheory", "evidential", "firstprinciples", "systemsthinking", "scientificmethod", "optimization", "formallogic"]).default("hybrid"),
      thought: z.string(),
      thoughtNumber: z.number().int().positive(),
      totalThoughts: z.number().int().positive(),
      nextThoughtNeeded: z.boolean(),
      isRevision: z.boolean().optional(),
      revisesThought: z.string().optional(),
      revisionReason: z.string().optional(),
      branchFrom: z.string().optional(),
      branchId: z.string().optional(),
      stage: z.enum(["problem_definition", "constraints", "model", "proof", "implementation"]).optional(),
      uncertainty: z.number().min(0).max(1).optional(),
      dependencies: z.array(z.string()).optional(),
      assumptions: z.array(z.string()).optional(),
      thoughtType: z.string().optional(),
      mathematicalModel: z.object({
        latex: z.string(),
        symbolic: z.string(),
        ascii: z.string().optional()
      }).optional(),
      proofStrategy: z.object({
        type: z.enum(["direct", "contradiction", "induction", "construction", "contrapositive"]),
        steps: z.array(z.string())
      }).optional(),
      tensorProperties: z.object({
        rank: z.tuple([z.number(), z.number()]),
        components: z.string(),
        latex: z.string(),
        symmetries: z.array(z.string()),
        invariants: z.array(z.string()),
        transformation: z.enum(["covariant", "contravariant", "mixed"])
      }).optional(),
      physicalInterpretation: z.object({
        quantity: z.string(),
        units: z.string(),
        conservationLaws: z.array(z.string())
      }).optional(),
      // Inductive reasoning properties (Phase 5, v5.0.0)
      pattern: z.string().optional(),
      generalization: z.string().optional(),
      confidence: z.number().min(0).max(1).optional(),
      counterexamples: z.array(z.string()).optional(),
      sampleSize: z.number().int().min(1).optional(),
      // Deductive reasoning properties (Phase 5, v5.0.0)
      premises: z.array(z.string()).optional(),
      logicForm: z.string().optional(),
      validityCheck: z.boolean().optional(),
      soundnessCheck: z.boolean().optional(),
      // Abductive reasoning properties (v2.0)
      observations: z.union([
        z.array(z.string()),
        // For inductive reasoning - simple strings
        z.array(z.object({
          // For abductive reasoning - structured objects
          id: z.string(),
          description: z.string(),
          confidence: z.number().min(0).max(1)
        }))
      ]).optional(),
      hypotheses: z.array(z.object({
        id: z.string(),
        // Abductive fields
        explanation: z.string().optional(),
        assumptions: z.array(z.string()).optional(),
        predictions: z.array(z.string()).optional(),
        score: z.number().optional(),
        // Evidential fields
        name: z.string().optional(),
        description: z.string().optional(),
        mutuallyExclusive: z.boolean().optional(),
        subsets: z.array(z.string()).optional()
      })).optional(),
      evaluationCriteria: z.object({
        parsimony: z.number(),
        explanatoryPower: z.number(),
        plausibility: z.number(),
        testability: z.boolean()
      }).optional(),
      evidence: z.array(z.object({
        id: z.string(),
        description: z.string(),
        // Abductive fields
        hypothesisId: z.string().optional(),
        type: z.enum(["supporting", "contradicting", "neutral"]).optional(),
        strength: z.number().min(0).max(1).optional(),
        // Evidential fields
        source: z.string().optional(),
        reliability: z.number().min(0).max(1).optional(),
        timestamp: z.number().optional(),
        supports: z.array(z.string()).optional(),
        contradicts: z.array(z.string()).optional()
      })).optional(),
      bestExplanation: z.object({
        id: z.string(),
        explanation: z.string(),
        assumptions: z.array(z.string()),
        predictions: z.array(z.string()),
        score: z.number()
      }).optional(),
      // Causal reasoning properties (v2.0)
      causalGraph: z.object({
        nodes: z.array(z.object({
          id: z.string(),
          name: z.string(),
          type: z.enum(["cause", "effect", "mediator", "confounder"]),
          description: z.string()
        })),
        edges: z.array(z.object({
          from: z.string(),
          to: z.string(),
          strength: z.number(),
          confidence: z.number().min(0).max(1)
        }))
      }).optional(),
      interventions: z.array(z.object({
        nodeId: z.string(),
        action: z.string(),
        expectedEffects: z.array(z.object({
          nodeId: z.string(),
          expectedChange: z.string(),
          confidence: z.number()
        }))
      })).optional(),
      mechanisms: z.array(z.object({
        from: z.string(),
        to: z.string(),
        description: z.string(),
        type: z.enum(["direct", "indirect", "feedback"])
      })).optional(),
      confounders: z.array(z.object({
        nodeId: z.string(),
        affects: z.array(z.string()),
        description: z.string()
      })).optional(),
      // Bayesian reasoning properties (v2.0)
      hypothesis: z.object({
        id: z.string(),
        statement: z.string()
      }).optional(),
      prior: z.object({
        probability: z.number().min(0).max(1),
        justification: z.string()
      }).optional(),
      likelihood: z.object({
        probability: z.number().min(0).max(1),
        description: z.string()
      }).optional(),
      posterior: z.object({
        probability: z.number().min(0).max(1),
        calculation: z.string()
      }).optional(),
      bayesFactor: z.number().optional(),
      // Counterfactual reasoning properties (v2.0)
      actual: z.object({
        id: z.string(),
        name: z.string(),
        description: z.string(),
        conditions: z.array(z.object({
          factor: z.string(),
          value: z.string()
        })),
        outcomes: z.array(z.object({
          description: z.string(),
          impact: z.enum(["positive", "negative", "neutral"]),
          magnitude: z.number().optional()
        }))
      }).optional(),
      counterfactuals: z.array(z.object({
        id: z.string(),
        name: z.string(),
        description: z.string(),
        conditions: z.array(z.object({
          factor: z.string(),
          value: z.string()
        })),
        outcomes: z.array(z.object({
          description: z.string(),
          impact: z.enum(["positive", "negative", "neutral"]),
          magnitude: z.number().optional()
        }))
      })).optional(),
      comparison: z.object({
        differences: z.array(z.object({
          aspect: z.string(),
          actual: z.string(),
          counterfactual: z.string(),
          significance: z.enum(["high", "medium", "low"])
        })),
        insights: z.array(z.string()),
        lessons: z.array(z.string())
      }).optional(),
      interventionPoint: z.object({
        description: z.string(),
        alternatives: z.array(z.string())
      }).optional(),
      causalChains: z.array(z.object({
        intervention: z.string(),
        steps: z.array(z.string()),
        finalOutcome: z.string()
      })).optional(),
      // Analogical reasoning properties (v2.0)
      sourceDomain: z.object({
        id: z.string(),
        name: z.string(),
        description: z.string(),
        entities: z.array(z.object({
          id: z.string(),
          name: z.string(),
          type: z.string()
        })),
        relations: z.array(z.object({
          id: z.string(),
          type: z.string(),
          from: z.string(),
          to: z.string()
        }))
      }).optional(),
      targetDomain: z.object({
        id: z.string(),
        name: z.string(),
        description: z.string(),
        entities: z.array(z.object({
          id: z.string(),
          name: z.string(),
          type: z.string()
        })),
        relations: z.array(z.object({
          id: z.string(),
          type: z.string(),
          from: z.string(),
          to: z.string()
        }))
      }).optional(),
      mapping: z.array(z.object({
        sourceEntityId: z.string(),
        targetEntityId: z.string(),
        justification: z.string(),
        confidence: z.number().min(0).max(1)
      })).optional(),
      insights: z.array(z.object({
        description: z.string(),
        sourceEvidence: z.string(),
        targetApplication: z.string()
      })).optional(),
      inferences: z.array(z.object({
        sourcePattern: z.string(),
        targetPrediction: z.string(),
        confidence: z.number().min(0).max(1),
        needsVerification: z.boolean()
      })).optional(),
      limitations: z.array(z.string()).optional(),
      analogyStrength: z.number().min(0).max(1).optional(),
      // Temporal reasoning properties (Phase 3, v2.1)
      timeline: z.object({
        id: z.string(),
        name: z.string(),
        timeUnit: z.enum(["milliseconds", "seconds", "minutes", "hours", "days", "months", "years"]),
        startTime: z.number().optional(),
        endTime: z.number().optional(),
        events: z.array(z.string())
      }).optional(),
      events: z.array(z.object({
        id: z.string(),
        name: z.string(),
        description: z.string(),
        timestamp: z.number(),
        duration: z.number().optional(),
        type: z.enum(["instant", "interval"]),
        properties: z.record(z.string(), z.any())
      })).optional(),
      intervals: z.array(z.object({
        id: z.string(),
        name: z.string(),
        start: z.number(),
        end: z.number(),
        overlaps: z.array(z.string()).optional(),
        contains: z.array(z.string()).optional()
      })).optional(),
      constraints: z.array(z.object({
        id: z.string(),
        type: z.enum(["before", "after", "during", "overlaps", "meets", "starts", "finishes", "equals"]),
        subject: z.string(),
        object: z.string(),
        confidence: z.number().min(0).max(1)
      })).optional(),
      relations: z.array(z.object({
        id: z.string(),
        from: z.string(),
        to: z.string(),
        relationType: z.enum(["causes", "enables", "prevents", "precedes", "follows"]),
        strength: z.number().min(0).max(1),
        delay: z.number().optional()
      })).optional(),
      // Game theory properties (Phase 3, v2.2)
      game: z.object({
        id: z.string(),
        name: z.string(),
        description: z.string(),
        type: z.enum(["normal_form", "extensive_form", "cooperative", "non_cooperative"]),
        numPlayers: z.number().int().min(2),
        isZeroSum: z.boolean(),
        isPerfectInformation: z.boolean()
      }).optional(),
      players: z.array(z.object({
        id: z.string(),
        name: z.string(),
        role: z.string().optional(),
        isRational: z.boolean(),
        availableStrategies: z.array(z.string())
      })).optional(),
      strategies: z.array(z.object({
        id: z.string(),
        playerId: z.string(),
        name: z.string(),
        description: z.string(),
        isPure: z.boolean(),
        probability: z.number().min(0).max(1).optional()
      })).optional(),
      payoffMatrix: z.object({
        players: z.array(z.string()),
        dimensions: z.array(z.number()),
        payoffs: z.array(z.object({
          strategyProfile: z.array(z.string()),
          payoffs: z.array(z.number())
        }))
      }).optional(),
      nashEquilibria: z.array(z.object({
        id: z.string(),
        strategyProfile: z.array(z.string()),
        payoffs: z.array(z.number()),
        type: z.enum(["pure", "mixed"]),
        isStrict: z.boolean(),
        stability: z.number().min(0).max(1)
      })).optional(),
      dominantStrategies: z.array(z.object({
        playerId: z.string(),
        strategyId: z.string(),
        type: z.enum(["strictly_dominant", "weakly_dominant"]),
        dominatesStrategies: z.array(z.string()),
        justification: z.string()
      })).optional(),
      gameTree: z.object({
        rootNode: z.string(),
        nodes: z.array(z.object({
          id: z.string(),
          type: z.enum(["decision", "chance", "terminal"]),
          playerId: z.string().optional(),
          parentNode: z.string().optional(),
          childNodes: z.array(z.string()),
          action: z.string().optional(),
          probability: z.number().min(0).max(1).optional(),
          payoffs: z.array(z.number()).optional()
        })),
        informationSets: z.array(z.object({
          id: z.string(),
          playerId: z.string(),
          nodes: z.array(z.string()),
          availableActions: z.array(z.string())
        })).optional()
      }).optional(),
      // Evidential properties (Phase 3, v2.3)
      frameOfDiscernment: z.array(z.string()).optional(),
      beliefFunctions: z.array(z.object({
        id: z.string(),
        source: z.string(),
        massAssignments: z.array(z.object({
          hypothesisSet: z.array(z.string()),
          mass: z.number().min(0).max(1),
          justification: z.string()
        })),
        conflictMass: z.number().optional()
      })).optional(),
      combinedBelief: z.object({
        id: z.string(),
        source: z.string(),
        massAssignments: z.array(z.object({
          hypothesisSet: z.array(z.string()),
          mass: z.number().min(0).max(1),
          justification: z.string()
        })),
        conflictMass: z.number().optional()
      }).optional(),
      plausibility: z.object({
        id: z.string(),
        assignments: z.array(z.object({
          hypothesisSet: z.array(z.string()),
          plausibility: z.number().min(0).max(1),
          belief: z.number().min(0).max(1),
          uncertaintyInterval: z.tuple([z.number(), z.number()])
        }))
      }).optional(),
      decisions: z.array(z.object({
        id: z.string(),
        name: z.string(),
        selectedHypothesis: z.array(z.string()),
        confidence: z.number().min(0).max(1),
        reasoning: z.string(),
        alternatives: z.array(z.object({
          hypothesis: z.array(z.string()),
          expectedUtility: z.number(),
          risk: z.number()
        }))
      })).optional(),
      // First-Principles properties (Phase 3, v3.1.0)
      question: z.string().optional(),
      principles: z.array(z.object({
        id: z.string(),
        type: z.enum(["axiom", "definition", "observation", "logical_inference", "assumption"]),
        statement: z.string(),
        justification: z.string(),
        dependsOn: z.array(z.string()).optional(),
        confidence: z.number().min(0).max(1).optional()
      })).optional(),
      derivationSteps: z.array(z.object({
        stepNumber: z.number().int().positive(),
        principle: z.string(),
        inference: z.string(),
        logicalForm: z.string().optional(),
        confidence: z.number().min(0).max(1)
      })).optional(),
      conclusion: z.union([
        z.string(),
        // For deductive reasoning - simple conclusion
        z.object({
          // For first-principles reasoning - structured conclusion
          statement: z.string(),
          derivationChain: z.array(z.number()),
          certainty: z.number().min(0).max(1),
          limitations: z.array(z.string()).optional()
        })
      ]).optional(),
      alternativeInterpretations: z.array(z.string()).optional(),
      // Systems Thinking properties (Phase 4, v3.2.0)
      system: z.object({
        id: z.string(),
        name: z.string(),
        description: z.string(),
        boundary: z.string(),
        purpose: z.string(),
        timeHorizon: z.string().optional()
      }).optional(),
      components: z.array(z.object({
        id: z.string(),
        name: z.string(),
        type: z.enum(["stock", "flow", "variable", "parameter", "delay"]),
        description: z.string(),
        unit: z.string().optional(),
        initialValue: z.number().optional(),
        formula: z.string().optional(),
        influencedBy: z.array(z.string()).optional()
      })).optional(),
      feedbackLoops: z.array(z.object({
        id: z.string(),
        name: z.string(),
        type: z.enum(["reinforcing", "balancing"]),
        description: z.string(),
        components: z.array(z.string()),
        polarity: z.enum(["+", "-"]),
        strength: z.number().min(0).max(1),
        delay: z.number().optional(),
        dominance: z.enum(["early", "middle", "late"]).optional()
      })).optional(),
      leveragePoints: z.array(z.object({
        id: z.string(),
        name: z.string(),
        location: z.string(),
        description: z.string(),
        effectiveness: z.number().min(0).max(1),
        difficulty: z.number().min(0).max(1),
        type: z.enum(["parameter", "feedback", "structure", "goal", "paradigm"]),
        interventionExamples: z.array(z.string())
      })).optional(),
      behaviors: z.array(z.object({
        id: z.string(),
        name: z.string(),
        description: z.string(),
        pattern: z.enum(["growth", "decline", "oscillation", "equilibrium", "chaos", "overshoot_collapse"]),
        causes: z.array(z.string()),
        timeframe: z.string(),
        unintendedConsequences: z.array(z.string()).optional()
      })).optional(),
      // Scientific Method properties (Phase 4, v3.2.0)
      researchQuestion: z.object({
        id: z.string(),
        question: z.string(),
        background: z.string(),
        rationale: z.string(),
        significance: z.string(),
        variables: z.object({
          independent: z.array(z.string()),
          dependent: z.array(z.string()),
          control: z.array(z.string())
        })
      }).optional(),
      scientificHypotheses: z.array(z.object({
        id: z.string(),
        type: z.enum(["null", "alternative", "directional", "non_directional"]),
        statement: z.string(),
        prediction: z.string(),
        rationale: z.string(),
        testable: z.boolean(),
        falsifiable: z.boolean()
      })).optional(),
      experiment: z.object({
        id: z.string(),
        type: z.enum(["experimental", "quasi_experimental", "observational", "correlational"]),
        design: z.string(),
        sampleSize: z.number().int().positive(),
        sampleSizeJustification: z.string().optional(),
        randomization: z.boolean(),
        blinding: z.enum(["none", "single", "double", "triple"]).optional(),
        controls: z.array(z.string()),
        procedure: z.array(z.string()),
        materials: z.array(z.string()).optional(),
        duration: z.string().optional(),
        ethicalConsiderations: z.array(z.string()).optional()
      }).optional(),
      dataCollection: z.object({
        id: z.string(),
        method: z.array(z.string()),
        instruments: z.array(z.string()),
        dataQuality: z.object({
          completeness: z.number().min(0).max(1),
          reliability: z.number().min(0).max(1),
          validity: z.number().min(0).max(1)
        }),
        limitations: z.array(z.string()).optional()
      }).optional(),
      statisticalAnalysis: z.object({
        id: z.string(),
        tests: z.array(z.object({
          id: z.string(),
          name: z.string(),
          hypothesisTested: z.string(),
          testStatistic: z.number(),
          pValue: z.number().min(0).max(1),
          confidenceInterval: z.tuple([z.number(), z.number()]).optional(),
          alpha: z.number().min(0).max(1),
          result: z.enum(["reject_null", "fail_to_reject_null"]),
          interpretation: z.string()
        })),
        summary: z.string(),
        effectSize: z.object({
          type: z.string(),
          value: z.number(),
          interpretation: z.string()
        }).optional(),
        powerAnalysis: z.object({
          power: z.number().min(0).max(1),
          alpha: z.number().min(0).max(1),
          interpretation: z.string()
        }).optional()
      }).optional(),
      scientificConclusion: z.object({
        id: z.string(),
        statement: z.string(),
        supportedHypotheses: z.array(z.string()),
        rejectedHypotheses: z.array(z.string()),
        confidence: z.number().min(0).max(1),
        limitations: z.array(z.string()),
        alternativeExplanations: z.array(z.string()).optional(),
        futureDirections: z.array(z.string()),
        replicationConsiderations: z.array(z.string()),
        practicalImplications: z.array(z.string()).optional(),
        theoreticalImplications: z.array(z.string()).optional()
      }).optional(),
      // Optimization properties (Phase 4, v3.2.0)
      optimizationProblem: z.object({
        id: z.string(),
        name: z.string(),
        description: z.string(),
        type: z.enum(["linear", "nonlinear", "integer", "mixed_integer", "constraint_satisfaction", "multi_objective"]),
        approach: z.enum(["exact", "heuristic", "metaheuristic", "approximation"]).optional(),
        complexity: z.string().optional()
      }).optional(),
      decisionVariables: z.array(z.object({
        id: z.string(),
        name: z.string(),
        description: z.string(),
        type: z.enum(["continuous", "integer", "binary", "categorical"]),
        unit: z.string().optional(),
        semantics: z.string()
      })).optional(),
      optimizationConstraints: z.array(z.object({
        id: z.string(),
        name: z.string(),
        description: z.string(),
        type: z.enum(["hard", "soft"]),
        formula: z.string(),
        variables: z.array(z.string()),
        penalty: z.number().optional(),
        rationale: z.string(),
        priority: z.number().optional()
      })).optional(),
      objectives: z.array(z.object({
        id: z.string(),
        name: z.string(),
        description: z.string(),
        type: z.enum(["minimize", "maximize"]),
        formula: z.string(),
        variables: z.array(z.string()),
        weight: z.number().min(0).max(1).optional(),
        units: z.string().optional(),
        idealValue: z.number().optional(),
        acceptableRange: z.tuple([z.number(), z.number()]).optional()
      })).optional(),
      solution: z.object({
        id: z.string(),
        type: z.enum(["optimal", "feasible", "infeasible", "unbounded", "approximate"]),
        variableValues: z.record(z.string(), z.union([z.number(), z.string()])),
        objectiveValues: z.record(z.string(), z.number()),
        quality: z.number().min(0).max(1),
        computationTime: z.number().optional(),
        iterations: z.number().optional(),
        method: z.string().optional(),
        guarantees: z.array(z.string()).optional()
      }).optional(),
      sensitivityAnalysis: z.object({
        id: z.string(),
        robustness: z.number().min(0).max(1),
        criticalConstraints: z.array(z.string()),
        shadowPrices: z.record(z.string(), z.number()).optional(),
        recommendations: z.array(z.string())
      }).optional(),
      // Formal Logic properties (Phase 4, v3.2.0)
      propositions: z.array(z.object({
        id: z.string(),
        symbol: z.string(),
        statement: z.string(),
        truthValue: z.boolean().optional(),
        type: z.enum(["atomic", "compound"]),
        formula: z.string().optional()
      })).optional(),
      logicalInferences: z.array(z.object({
        id: z.string(),
        rule: z.enum(["modus_ponens", "modus_tollens", "hypothetical_syllogism", "disjunctive_syllogism", "conjunction", "simplification", "addition", "resolution", "contradiction", "excluded_middle"]),
        premises: z.array(z.string()),
        conclusion: z.string(),
        justification: z.string(),
        valid: z.boolean()
      })).optional(),
      logicalProof: z.object({
        id: z.string(),
        theorem: z.string(),
        technique: z.enum(["direct", "contradiction", "contrapositive", "cases", "induction", "natural_deduction", "resolution", "semantic_tableaux"]),
        steps: z.array(z.object({
          stepNumber: z.number().int().positive(),
          statement: z.string(),
          formula: z.string().optional(),
          justification: z.string(),
          rule: z.enum(["modus_ponens", "modus_tollens", "hypothetical_syllogism", "disjunctive_syllogism", "conjunction", "simplification", "addition", "resolution", "contradiction", "excluded_middle"]).optional(),
          referencesSteps: z.array(z.number()).optional(),
          isAssumption: z.boolean().optional(),
          dischargesAssumption: z.number().optional()
        })),
        conclusion: z.string(),
        valid: z.boolean(),
        completeness: z.number().min(0).max(1),
        assumptions: z.array(z.string()).optional()
      }).optional(),
      truthTable: z.object({
        id: z.string(),
        propositions: z.array(z.string()),
        formula: z.string().optional(),
        rows: z.array(z.object({
          rowNumber: z.number().int().positive(),
          assignments: z.record(z.string(), z.boolean()),
          result: z.boolean()
        })),
        isTautology: z.boolean(),
        isContradiction: z.boolean(),
        isContingent: z.boolean()
      }).optional(),
      satisfiability: z.object({
        id: z.string(),
        formula: z.string(),
        satisfiable: z.boolean(),
        model: z.record(z.string(), z.boolean()).optional(),
        method: z.enum(["dpll", "cdcl", "resolution", "truth_table", "other"]),
        complexity: z.string().optional(),
        explanation: z.string()
      }).optional(),
      action: z.enum(["add_thought", "summarize", "export", "switch_mode", "get_session", "recommend_mode"]).default("add_thought"),
      exportFormat: z.enum(["markdown", "latex", "json", "html", "jupyter", "mermaid", "dot", "ascii"]).optional(),
      newMode: z.enum(["sequential", "shannon", "mathematics", "physics", "hybrid", "inductive", "deductive", "abductive", "causal", "bayesian", "counterfactual", "analogical", "temporal", "gametheory", "evidential", "firstprinciples", "systemsthinking", "scientificmethod", "optimization", "formallogic"]).optional(),
      // Mode recommendation parameters (v2.4)
      problemType: z.string().optional(),
      problemCharacteristics: z.object({
        domain: z.string(),
        complexity: z.enum(["low", "medium", "high"]),
        uncertainty: z.enum(["low", "medium", "high"]),
        timeDependent: z.boolean(),
        multiAgent: z.boolean(),
        requiresProof: z.boolean(),
        requiresQuantification: z.boolean(),
        hasIncompleteInfo: z.boolean(),
        requiresExplanation: z.boolean(),
        hasAlternatives: z.boolean()
      }).optional(),
      includeCombinations: z.boolean().optional()
    });
    thinkingTool = {
      name: "deepthinking",
      description: "[DEPRECATED] Use deepthinking_* tools instead. Legacy tool supporting 18 reasoning modes with auto-routing to focused tools.",
      inputSchema: {
        type: "object",
        properties: {
          sessionId: { type: "string" },
          mode: {
            type: "string",
            enum: ["sequential", "shannon", "mathematics", "physics", "hybrid", "inductive", "deductive", "abductive", "causal", "bayesian", "counterfactual", "analogical", "temporal", "gametheory", "evidential", "firstprinciples", "systemsthinking", "scientificmethod", "optimization", "formallogic"],
            default: "hybrid"
          },
          thought: { type: "string", minLength: 1 },
          thoughtNumber: { type: "integer", minimum: 1 },
          totalThoughts: { type: "integer", minimum: 1 },
          nextThoughtNeeded: { type: "boolean" },
          isRevision: { type: "boolean" },
          revisesThought: { type: "string" },
          revisionReason: { type: "string" },
          branchFrom: { type: "string" },
          branchId: { type: "string" },
          stage: {
            type: "string",
            enum: ["problem_definition", "constraints", "model", "proof", "implementation"]
          },
          uncertainty: { type: "number", minimum: 0, maximum: 1 },
          dependencies: { type: "array", items: { type: "string" } },
          assumptions: { type: "array", items: { type: "string" } },
          thoughtType: { type: "string" },
          // Math/Physics properties
          mathematicalModel: {
            type: "object",
            properties: {
              latex: { type: "string" },
              symbolic: { type: "string" },
              ascii: { type: "string" }
            },
            additionalProperties: false
          },
          proofStrategy: {
            type: "object",
            properties: {
              type: { type: "string", enum: ["direct", "contradiction", "induction", "construction", "contrapositive"] },
              steps: { type: "array", items: { type: "string" } }
            },
            additionalProperties: false
          },
          tensorProperties: {
            type: "object",
            properties: {
              rank: { type: "array", items: { type: "number" }, minItems: 2, maxItems: 2 },
              components: { type: "string" },
              latex: { type: "string" },
              symmetries: { type: "array", items: { type: "string" } },
              invariants: { type: "array", items: { type: "string" } },
              transformation: { type: "string", enum: ["covariant", "contravariant", "mixed"] }
            },
            additionalProperties: false
          }
          // All other optional properties from various modes (simplified for legacy compatibility)
          // Most users should migrate to focused tools for full schema validation
        },
        required: ["thought", "thoughtNumber", "totalThoughts", "nextThoughtNeeded"],
        additionalProperties: true
        // Allow extra properties for backward compatibility
      }
    };
  }
});

// src/types/core.ts
function isFullyImplemented(mode) {
  return FULLY_IMPLEMENTED_MODES.includes(mode);
}
function isTemporalThought(thought) {
  return thought.mode === "temporal" /* TEMPORAL */;
}
function isGameTheoryThought(thought) {
  return thought.mode === "gametheory" /* GAMETHEORY */;
}
function isEvidentialThought(thought) {
  return thought.mode === "evidential" /* EVIDENTIAL */;
}
function isMetaReasoningThought(thought) {
  return thought.mode === "metareasoning" /* METAREASONING */;
}
var ThinkingMode, FULLY_IMPLEMENTED_MODES;
var init_core = __esm({
  "src/types/core.ts"() {
    init_esm_shims();
    ThinkingMode = /* @__PURE__ */ ((ThinkingMode2) => {
      ThinkingMode2["SEQUENTIAL"] = "sequential";
      ThinkingMode2["SHANNON"] = "shannon";
      ThinkingMode2["MATHEMATICS"] = "mathematics";
      ThinkingMode2["PHYSICS"] = "physics";
      ThinkingMode2["HYBRID"] = "hybrid";
      ThinkingMode2["ENGINEERING"] = "engineering";
      ThinkingMode2["COMPUTABILITY"] = "computability";
      ThinkingMode2["CRYPTANALYTIC"] = "cryptanalytic";
      ThinkingMode2["ALGORITHMIC"] = "algorithmic";
      ThinkingMode2["METAREASONING"] = "metareasoning";
      ThinkingMode2["RECURSIVE"] = "recursive";
      ThinkingMode2["MODAL"] = "modal";
      ThinkingMode2["STOCHASTIC"] = "stochastic";
      ThinkingMode2["CONSTRAINT"] = "constraint";
      ThinkingMode2["OPTIMIZATION"] = "optimization";
      ThinkingMode2["INDUCTIVE"] = "inductive";
      ThinkingMode2["DEDUCTIVE"] = "deductive";
      ThinkingMode2["ABDUCTIVE"] = "abductive";
      ThinkingMode2["CAUSAL"] = "causal";
      ThinkingMode2["BAYESIAN"] = "bayesian";
      ThinkingMode2["COUNTERFACTUAL"] = "counterfactual";
      ThinkingMode2["ANALOGICAL"] = "analogical";
      ThinkingMode2["TEMPORAL"] = "temporal";
      ThinkingMode2["GAMETHEORY"] = "gametheory";
      ThinkingMode2["EVIDENTIAL"] = "evidential";
      ThinkingMode2["FIRSTPRINCIPLES"] = "firstprinciples";
      ThinkingMode2["SYSTEMSTHINKING"] = "systemsthinking";
      ThinkingMode2["SCIENTIFICMETHOD"] = "scientificmethod";
      ThinkingMode2["FORMALLOGIC"] = "formallogic";
      ThinkingMode2["SYNTHESIS"] = "synthesis";
      ThinkingMode2["ARGUMENTATION"] = "argumentation";
      ThinkingMode2["CRITIQUE"] = "critique";
      ThinkingMode2["ANALYSIS"] = "analysis";
      ThinkingMode2["CUSTOM"] = "custom";
      return ThinkingMode2;
    })(ThinkingMode || {});
    FULLY_IMPLEMENTED_MODES = [
      "sequential" /* SEQUENTIAL */,
      "shannon" /* SHANNON */,
      "mathematics" /* MATHEMATICS */,
      "physics" /* PHYSICS */,
      "hybrid" /* HYBRID */,
      "engineering" /* ENGINEERING */,
      // Phase 10 v7.1.0
      "computability" /* COMPUTABILITY */,
      // Phase 11 v7.2.0 - Turing's legacy
      "cryptanalytic" /* CRYPTANALYTIC */,
      // Phase 11 v7.2.0 - Turing's Bletchley Park work
      "algorithmic" /* ALGORITHMIC */,
      // Phase 12 v7.3.0 - CLRS algorithms
      "metareasoning" /* METAREASONING */,
      "recursive" /* RECURSIVE */,
      "modal" /* MODAL */,
      "stochastic" /* STOCHASTIC */,
      "constraint" /* CONSTRAINT */,
      "optimization" /* OPTIMIZATION */,
      "inductive" /* INDUCTIVE */,
      // Phase 5 v5.0.0
      "deductive" /* DEDUCTIVE */
      // Phase 5 v5.0.0
    ];
  }
});

// src/types/session.ts
var init_session = __esm({
  "src/types/session.ts"() {
    init_esm_shims();
  }
});

// src/modes/handlers/ModeHandler.ts
function validationSuccess(warnings = []) {
  return {
    valid: true,
    errors: [],
    warnings
  };
}
function validationFailure(errors, warnings = []) {
  return {
    valid: false,
    errors,
    warnings
  };
}
function createValidationError(field, message, code) {
  return { field, message, code };
}
function createValidationWarning(field, message, suggestion) {
  return { field, message, suggestion };
}
var init_ModeHandler = __esm({
  "src/modes/handlers/ModeHandler.ts"() {
    init_esm_shims();
  }
});

// src/types/modes/recommendations.ts
var ModeRecommender;
var init_recommendations = __esm({
  "src/types/modes/recommendations.ts"() {
    init_esm_shims();
    ModeRecommender = class {
      /**
       * Recommends reasoning modes based on problem characteristics
       * Returns modes ranked by suitability score
       */
      recommendModes(characteristics) {
        const recommendations = [];
        const isPhilosophical = characteristics.domain.toLowerCase().includes("metaphysics") || characteristics.domain.toLowerCase().includes("theology") || characteristics.domain.toLowerCase().includes("philosophy") || characteristics.domain.toLowerCase().includes("epistemology") || characteristics.domain.toLowerCase().includes("ethics");
        if (characteristics.complexity === "high" && (characteristics.requiresExplanation || characteristics.hasAlternatives || isPhilosophical)) {
          recommendations.push({
            mode: "hybrid" /* HYBRID */,
            score: 0.92,
            reasoning: "Complex problem benefits from multi-modal synthesis combining inductive, deductive, and abductive reasoning",
            strengths: ["Comprehensive analysis", "Combines empirical and logical approaches", "Maximum evidential strength", "Convergent validation"],
            limitations: ["Time-intensive", "Requires understanding of multiple reasoning types"],
            examples: ["Philosophical arguments", "Scientific theories", "Complex decision-making", "Metaphysical questions"]
          });
        }
        if (!characteristics.requiresProof && (characteristics.requiresQuantification || characteristics.hasIncompleteInfo || isPhilosophical)) {
          recommendations.push({
            mode: "inductive" /* INDUCTIVE */,
            score: isPhilosophical ? 0.85 : 0.8,
            reasoning: "Problem requires pattern recognition and generalization from observations",
            strengths: ["Empirical grounding", "Pattern detection", "Probabilistic reasoning", "Scientific discovery"],
            limitations: ["Cannot prove with certainty", "Vulnerable to black swans", "Sample size dependent"],
            examples: ["Scientific hypotheses", "Trend analysis", "Empirical arguments", "Data-driven insights"]
          });
        }
        if (characteristics.requiresProof || isPhilosophical) {
          recommendations.push({
            mode: "deductive" /* DEDUCTIVE */,
            score: characteristics.requiresProof ? 0.9 : 0.75,
            reasoning: "Problem requires logical derivation from general principles to specific conclusions",
            strengths: ["Logical validity", "Rigorous inference", "Exposes contradictions", "Formal reasoning"],
            limitations: ["Soundness depends on premise truth", "Vulnerable to definitional disputes", "May not handle uncertainty well"],
            examples: ["Logical proofs", "Mathematical theorems", "Philosophical arguments", "Formal verification"]
          });
        }
        if (characteristics.requiresExplanation || isPhilosophical) {
          recommendations.push({
            mode: "abductive" /* ABDUCTIVE */,
            score: isPhilosophical ? 0.9 : 0.87,
            reasoning: "Problem requires finding best explanations through comparative hypothesis evaluation",
            strengths: ["Hypothesis generation", "Comparative evaluation", "Explanatory power assessment", "Handles competing theories"],
            limitations: ["May miss non-obvious explanations", "Explanatory power is subjective"],
            examples: ["Scientific explanation", "Debugging", "Diagnosis", "Theory selection", "Metaphysical arguments"]
          });
        }
        if (characteristics.complexity === "high" || characteristics.hasAlternatives && characteristics.uncertainty === "high") {
          recommendations.push({
            mode: "metareasoning" /* METAREASONING */,
            score: characteristics.complexity === "high" ? 0.88 : 0.82,
            reasoning: "Complex or uncertain problems benefit from strategic monitoring and adaptive reasoning",
            strengths: ["Strategy evaluation", "Mode switching recommendations", "Quality monitoring", "Resource allocation", "Self-reflection"],
            limitations: ["Meta-level overhead", "Requires understanding of other modes", "May not directly solve the problem"],
            examples: ["Strategy selection", "Debugging stuck reasoning", "Quality assessment", "Adaptive problem-solving"]
          });
        }
        if (characteristics.timeDependent) {
          recommendations.push({
            mode: "temporal" /* TEMPORAL */,
            score: 0.9,
            reasoning: "Problem involves time-dependent events and sequences",
            strengths: ["Event sequencing", "Temporal causality", "Timeline construction"],
            limitations: ["Limited strategic reasoning"],
            examples: ["Process modeling", "Event correlation", "Timeline debugging"]
          });
        }
        if (characteristics.multiAgent) {
          recommendations.push({
            mode: "gametheory" /* GAMETHEORY */,
            score: 0.85,
            reasoning: "Problem involves strategic interactions between agents",
            strengths: ["Equilibrium analysis", "Strategic reasoning", "Multi-agent dynamics"],
            limitations: ["Assumes rationality", "Complex computations"],
            examples: ["Competitive analysis", "Auction design", "Negotiation"]
          });
        }
        if (characteristics.hasIncompleteInfo && characteristics.uncertainty === "high" && !isPhilosophical) {
          recommendations.push({
            mode: "evidential" /* EVIDENTIAL */,
            score: 0.82,
            reasoning: "Problem has incomplete information and high uncertainty requiring Dempster-Shafer belief functions",
            strengths: ["Handles ignorance", "Evidence combination", "Uncertainty intervals"],
            limitations: ["Computational complexity", "Requires careful mass assignment", "Better for sensor fusion than philosophical reasoning"],
            examples: ["Sensor fusion", "Diagnostic reasoning", "Intelligence analysis"]
          });
        }
        if (characteristics.timeDependent && characteristics.requiresExplanation) {
          recommendations.push({
            mode: "causal" /* CAUSAL */,
            score: 0.86,
            reasoning: "Problem requires understanding cause-effect relationships",
            strengths: ["Intervention analysis", "Causal graphs", "Impact assessment"],
            limitations: ["Requires domain knowledge", "Difficult to identify confounders"],
            examples: ["Impact analysis", "System design", "Policy evaluation"]
          });
        }
        if (characteristics.requiresQuantification && characteristics.uncertainty !== "low") {
          recommendations.push({
            mode: "bayesian" /* BAYESIAN */,
            score: 0.84,
            reasoning: "Problem requires probabilistic reasoning with evidence updates",
            strengths: ["Principled uncertainty", "Evidence integration", "Prior knowledge"],
            limitations: ["Requires probability estimates", "Computationally intensive"],
            examples: ["A/B testing", "Risk assessment", "Predictive modeling"]
          });
        }
        if (characteristics.hasAlternatives) {
          recommendations.push({
            mode: "counterfactual" /* COUNTERFACTUAL */,
            score: 0.82,
            reasoning: "Problem benefits from analyzing alternative scenarios",
            strengths: ["What-if analysis", "Post-mortem insights", "Decision comparison"],
            limitations: ["Speculative", "Difficult to validate"],
            examples: ["Post-mortems", "Strategic planning", "Architecture decisions"]
          });
        }
        if (characteristics.complexity === "high" && characteristics.requiresExplanation) {
          recommendations.push({
            mode: "analogical" /* ANALOGICAL */,
            score: 0.8,
            reasoning: "Problem can benefit from cross-domain analogies",
            strengths: ["Creative insights", "Knowledge transfer", "Pattern recognition"],
            limitations: ["Analogies may be superficial", "Requires diverse knowledge"],
            examples: ["Novel problem solving", "Design thinking", "Innovation"]
          });
        }
        if (characteristics.requiresProof) {
          recommendations.push({
            mode: "mathematics" /* MATHEMATICS */,
            score: 0.95,
            reasoning: "Problem requires formal proofs and symbolic reasoning",
            strengths: ["Rigorous proofs", "Symbolic computation", "Theorem proving"],
            limitations: ["Limited to mathematical domains"],
            examples: ["Algorithm correctness", "Complexity analysis", "Formal verification"]
          });
        }
        if (characteristics.domain === "physics" || characteristics.domain === "engineering") {
          recommendations.push({
            mode: "physics" /* PHYSICS */,
            score: 0.9,
            reasoning: "Problem involves physical systems or tensor mathematics",
            strengths: ["Field theory", "Conservation laws", "Tensor analysis"],
            limitations: ["Specialized to physics domains"],
            examples: ["Physical modeling", "System dynamics", "Engineering analysis"]
          });
        }
        if (characteristics.complexity === "high" && characteristics.requiresProof) {
          recommendations.push({
            mode: "shannon" /* SHANNON */,
            score: 0.88,
            reasoning: "Complex problem requiring systematic decomposition",
            strengths: ["Systematic approach", "Problem decomposition", "Rigorous analysis"],
            limitations: ["Time-intensive", "Requires discipline"],
            examples: ["Complex system design", "Research problems", "Novel algorithms"]
          });
        }
        if (characteristics.domain === "engineering" || characteristics.domain === "software" || characteristics.domain === "systems" || characteristics.requiresQuantification && !characteristics.requiresProof) {
          recommendations.push({
            mode: "engineering" /* ENGINEERING */,
            score: characteristics.domain === "engineering" ? 0.92 : 0.85,
            reasoning: "Problem requires systematic engineering analysis with trade-offs and constraints",
            strengths: ["Requirements analysis", "Trade-off evaluation", "System design", "Failure mode analysis", "Implementation planning"],
            limitations: ["May over-engineer simple problems", "Requires domain expertise"],
            examples: ["System architecture", "Design decisions", "Performance optimization", "Reliability analysis", "Technical debt assessment"]
          });
        }
        if (characteristics.domain === "computer science" || characteristics.domain === "computation" || characteristics.requiresProof && characteristics.domain.includes("algorithm")) {
          recommendations.push({
            mode: "computability" /* COMPUTABILITY */,
            score: 0.88,
            reasoning: "Problem involves computational complexity, decidability, or algorithmic analysis",
            strengths: ["Turing machine analysis", "Decidability proofs", "Complexity classification", "Halting problem variants"],
            limitations: ["Highly theoretical", "Requires formal CS background"],
            examples: ["Algorithm decidability", "Complexity bounds", "Reduction proofs", "Computational limits"]
          });
        }
        if (characteristics.domain === "security" || characteristics.domain === "cryptography" || characteristics.domain.includes("crypto")) {
          recommendations.push({
            mode: "cryptanalytic" /* CRYPTANALYTIC */,
            score: 0.9,
            reasoning: "Problem involves cryptographic analysis, security assessment, or information-theoretic reasoning",
            strengths: ["Statistical analysis", "Pattern detection", "Deciban calculations", "Key space analysis", "Attack surface evaluation"],
            limitations: ["Specialized domain", "Requires mathematical background"],
            examples: ["Cipher analysis", "Protocol security", "Key management", "Attack vectors", "Information leakage"]
          });
        }
        if (characteristics.complexity === "high" && (characteristics.hasAlternatives || characteristics.requiresExplanation)) {
          recommendations.push({
            mode: "recursive" /* RECURSIVE */,
            score: 0.82,
            reasoning: "Problem has recursive structure or can be decomposed into smaller similar subproblems",
            strengths: ["Problem decomposition", "Self-similar analysis", "Base case identification", "Recursive patterns"],
            limitations: ["Stack overflow risk in deep recursion", "May miss non-recursive solutions"],
            examples: ["Divide and conquer", "Tree traversal", "Fractal analysis", "Self-referential problems"]
          });
        }
        if (characteristics.hasAlternatives && characteristics.uncertainty === "high") {
          recommendations.push({
            mode: "modal" /* MODAL */,
            score: 0.8,
            reasoning: "Problem involves possibility, necessity, or reasoning about alternative scenarios",
            strengths: ["Possible worlds analysis", "Necessity vs possibility", "Epistemic reasoning", "Deontic analysis"],
            limitations: ["Abstract and theoretical", "May overcomplicate simple choices"],
            examples: ["Modal logic proofs", "Necessity analysis", "Epistemic uncertainty", "Deontic obligations"]
          });
        }
        if (characteristics.uncertainty === "high" && characteristics.requiresQuantification) {
          recommendations.push({
            mode: "stochastic" /* STOCHASTIC */,
            score: 0.84,
            reasoning: "Problem involves random processes, probabilistic transitions, or stochastic modeling",
            strengths: ["Markov chains", "Random process modeling", "Probabilistic state transitions", "Monte Carlo methods"],
            limitations: ["Requires probability theory", "Computationally intensive"],
            examples: ["Queueing systems", "Random walks", "Stochastic optimization", "Process simulation"]
          });
        }
        if (characteristics.hasAlternatives && characteristics.requiresQuantification) {
          recommendations.push({
            mode: "constraint" /* CONSTRAINT */,
            score: 0.83,
            reasoning: "Problem involves multiple constraints that must be satisfied simultaneously",
            strengths: ["Constraint propagation", "Feasibility analysis", "SAT solving", "CSP formulation"],
            limitations: ["NP-hard in general", "May have no solution"],
            examples: ["Scheduling", "Resource allocation", "Configuration", "Puzzle solving"]
          });
        }
        if (characteristics.requiresQuantification && characteristics.hasAlternatives) {
          recommendations.push({
            mode: "optimization" /* OPTIMIZATION */,
            score: 0.86,
            reasoning: "Problem requires finding optimal or near-optimal solutions from alternatives",
            strengths: ["Objective function formulation", "Gradient methods", "Convex optimization", "Meta-heuristics"],
            limitations: ["Local optima", "Computational complexity", "May require relaxation"],
            examples: ["Resource optimization", "Parameter tuning", "Portfolio optimization", "Route planning"]
          });
        }
        if (isPhilosophical || characteristics.complexity === "high" && characteristics.requiresExplanation) {
          recommendations.push({
            mode: "firstprinciples" /* FIRSTPRINCIPLES */,
            score: isPhilosophical ? 0.88 : 0.82,
            reasoning: "Problem benefits from breaking down to fundamental truths and building up from there",
            strengths: ["Assumption identification", "Foundational analysis", "Novel solutions", "Deep understanding"],
            limitations: ["Time-intensive", "May rediscover known solutions", "Requires broad knowledge"],
            examples: ["Innovation challenges", "Paradigm shifts", "Root cause analysis", "Foundational questions"]
          });
        }
        if (characteristics.complexity === "high" && (characteristics.timeDependent || characteristics.multiAgent)) {
          recommendations.push({
            mode: "systemsthinking" /* SYSTEMSTHINKING */,
            score: 0.85,
            reasoning: "Problem involves complex systems with interconnected components and feedback loops",
            strengths: ["Holistic view", "Feedback loop analysis", "Emergence detection", "Leverage point identification"],
            limitations: ["Can be overwhelming", "Requires system boundaries definition"],
            examples: ["Organizational change", "Ecosystem analysis", "Market dynamics", "Social systems"]
          });
        }
        if (characteristics.hasIncompleteInfo && (characteristics.requiresExplanation || characteristics.requiresQuantification)) {
          recommendations.push({
            mode: "scientificmethod" /* SCIENTIFICMETHOD */,
            score: 0.84,
            reasoning: "Problem requires systematic empirical investigation and hypothesis testing",
            strengths: ["Hypothesis formulation", "Experimental design", "Falsification", "Reproducibility"],
            limitations: ["Requires data collection", "Time for experiments", "May not apply to all domains"],
            examples: ["Research questions", "A/B testing", "Empirical studies", "Data-driven decisions"]
          });
        }
        if (characteristics.requiresProof && !characteristics.requiresQuantification) {
          recommendations.push({
            mode: "formallogic" /* FORMALLOGIC */,
            score: 0.87,
            reasoning: "Problem requires rigorous formal logical analysis and proof construction",
            strengths: ["Propositional logic", "Predicate logic", "Proof systems", "Logical completeness"],
            limitations: ["May be overly formal", "Limited expressiveness for some domains"],
            examples: ["Formal verification", "Logical puzzles", "Argument validity", "Theorem proving"]
          });
        }
        if (characteristics.domain === "computer science" || characteristics.domain === "algorithms" || characteristics.domain === "data structures" || characteristics.domain === "software" || characteristics.requiresProof && characteristics.requiresQuantification) {
          recommendations.push({
            mode: "algorithmic" /* ALGORITHMIC */,
            score: characteristics.domain === "algorithms" ? 0.95 : 0.88,
            reasoning: "Problem involves algorithm design, complexity analysis, or data structure optimization",
            strengths: [
              "Algorithm design patterns (divide-and-conquer, DP, greedy)",
              "Complexity analysis (time, space, amortized)",
              "Correctness proofs (loop invariants, induction)",
              "Data structure selection and analysis",
              "Graph algorithms and optimization"
            ],
            limitations: ["Focused on computational problems", "Requires algorithmic thinking"],
            examples: [
              "Sorting and searching",
              "Graph traversal (BFS, DFS)",
              "Dynamic programming formulation",
              "Shortest path algorithms",
              "NP-completeness proofs"
            ]
          });
        }
        if (characteristics.domain === "research" || characteristics.domain === "academic" || characteristics.domain === "literature" || characteristics.hasIncompleteInfo && characteristics.requiresExplanation && !characteristics.requiresProof) {
          recommendations.push({
            mode: "synthesis" /* SYNTHESIS */,
            score: characteristics.domain === "research" || characteristics.domain === "academic" ? 0.92 : 0.85,
            reasoning: "Problem requires integrating knowledge from multiple sources and identifying themes",
            strengths: [
              "Literature integration",
              "Theme extraction",
              "Gap identification",
              "Cross-source analysis",
              "Knowledge synthesis"
            ],
            limitations: ["Requires access to multiple sources", "Time-intensive", "May miss emerging research"],
            examples: [
              "Literature reviews",
              "Systematic reviews",
              "Meta-analyses",
              "Research synthesis",
              "State-of-the-art surveys"
            ]
          });
        }
        if (characteristics.requiresExplanation && (characteristics.hasAlternatives || characteristics.domain === "academic" || characteristics.domain === "philosophy")) {
          recommendations.push({
            mode: "argumentation" /* ARGUMENTATION */,
            score: characteristics.domain === "academic" ? 0.9 : 0.84,
            reasoning: "Problem requires structured argumentation with claims, evidence, and warrants",
            strengths: [
              "Toulmin model support",
              "Claim-evidence structure",
              "Warrant articulation",
              "Rebuttal handling",
              "Qualifier specification"
            ],
            limitations: ["Formal structure may feel rigid", "Requires clear claim formulation"],
            examples: [
              "Academic papers",
              "Thesis arguments",
              "Policy proposals",
              "Debate preparation",
              "Position papers"
            ]
          });
        }
        if (characteristics.requiresExplanation && (characteristics.domain === "academic" || characteristics.domain === "research" || characteristics.domain === "review")) {
          recommendations.push({
            mode: "critique" /* CRITIQUE */,
            score: characteristics.domain === "review" ? 0.92 : 0.86,
            reasoning: "Problem requires critical evaluation of methodology, validity, and limitations",
            strengths: [
              "Methodology assessment",
              "Validity evaluation",
              "Limitation identification",
              "Strength recognition",
              "Constructive feedback"
            ],
            limitations: ["Requires domain expertise", "May seem overly critical"],
            examples: [
              "Peer review",
              "Paper critiques",
              "Methodology evaluation",
              "Research assessment",
              "Quality analysis"
            ]
          });
        }
        if (characteristics.hasIncompleteInfo && characteristics.requiresExplanation && (characteristics.domain === "research" || characteristics.domain === "qualitative" || characteristics.domain === "social science")) {
          recommendations.push({
            mode: "analysis" /* ANALYSIS */,
            score: characteristics.domain === "qualitative" ? 0.93 : 0.85,
            reasoning: "Problem requires systematic qualitative analysis using established methods",
            strengths: [
              "Thematic analysis",
              "Grounded theory",
              "Discourse analysis",
              "Content analysis",
              "Code development"
            ],
            limitations: ["Subjective interpretation", "Time-intensive coding", "Requires methodological rigor"],
            examples: [
              "Interview analysis",
              "Document analysis",
              "Ethnographic research",
              "Case study analysis",
              "Narrative analysis"
            ]
          });
        }
        if (recommendations.length === 0) {
          recommendations.push({
            mode: "sequential" /* SEQUENTIAL */,
            score: 0.7,
            reasoning: "General-purpose iterative reasoning",
            strengths: ["Flexible", "Adaptable", "Iterative refinement"],
            limitations: ["May lack structure for complex problems"],
            examples: ["General problem solving", "Exploration", "Brainstorming"]
          });
        }
        return recommendations.sort((a, b) => b.score - a.score);
      }
      /**
       * Recommends combinations of reasoning modes that work well together
       */
      recommendCombinations(characteristics) {
        const combinations = [];
        const isPhilosophical = characteristics.domain.toLowerCase().includes("metaphysics") || characteristics.domain.toLowerCase().includes("theology") || characteristics.domain.toLowerCase().includes("philosophy") || characteristics.domain.toLowerCase().includes("epistemology") || characteristics.domain.toLowerCase().includes("ethics");
        if (isPhilosophical || characteristics.complexity === "high" && characteristics.requiresExplanation && characteristics.hasAlternatives) {
          combinations.push({
            modes: ["inductive" /* INDUCTIVE */, "deductive" /* DEDUCTIVE */, "abductive" /* ABDUCTIVE */],
            sequence: "hybrid",
            rationale: "Synthesize empirical patterns, logical derivations, and explanatory hypotheses for maximum evidential strength",
            benefits: ["Convergent validation from three independent methods", "Empirical grounding + logical rigor + explanatory power", "Highest achievable confidence through multi-modal synthesis", "Exposes both empirical patterns and logical contradictions"],
            synergies: ["Inductive patterns inform abductive hypotheses", "Deductive logic tests hypothesis validity", "Abductive explanations guide inductive search", "All three methods converge on same conclusion"]
          });
        }
        if (characteristics.timeDependent && characteristics.requiresExplanation) {
          combinations.push({
            modes: ["temporal" /* TEMPORAL */, "causal" /* CAUSAL */],
            sequence: "sequential",
            rationale: "Build timeline first, then analyze causal relationships",
            benefits: ["Complete temporal-causal model", "Root cause with timeline context"],
            synergies: ["Temporal events inform causal nodes", "Causal edges explain temporal sequences"]
          });
        }
        if (characteristics.requiresExplanation && characteristics.requiresQuantification) {
          combinations.push({
            modes: ["abductive" /* ABDUCTIVE */, "bayesian" /* BAYESIAN */],
            sequence: "sequential",
            rationale: "Generate hypotheses, then quantify with probabilities",
            benefits: ["Systematic hypothesis generation", "Quantified belief updates"],
            synergies: ["Abductive hypotheses become Bayesian hypotheses", "Bayesian updates refine explanations"]
          });
        }
        if (characteristics.multiAgent && characteristics.hasAlternatives) {
          combinations.push({
            modes: ["gametheory" /* GAMETHEORY */, "counterfactual" /* COUNTERFACTUAL */],
            sequence: "hybrid",
            rationale: "Analyze equilibria, then explore alternative strategies",
            benefits: ["Strategic analysis + scenario exploration", "Robustness testing"],
            synergies: ["Equilibria as actual scenarios", "Strategy changes as interventions"]
          });
        }
        if (characteristics.hasIncompleteInfo && characteristics.timeDependent) {
          combinations.push({
            modes: ["evidential" /* EVIDENTIAL */, "causal" /* CAUSAL */],
            sequence: "parallel",
            rationale: "Combine uncertain evidence while modeling causal structure",
            benefits: ["Handles uncertainty and causality", "Evidence fusion with causal reasoning"],
            synergies: ["Belief functions inform causal strengths", "Causal structure guides evidence combination"]
          });
        }
        if (characteristics.timeDependent && characteristics.multiAgent) {
          combinations.push({
            modes: ["temporal" /* TEMPORAL */, "gametheory" /* GAMETHEORY */],
            sequence: "sequential",
            rationale: "Model event sequences, then analyze strategic interactions over time",
            benefits: ["Dynamic game analysis", "Time-dependent strategies"],
            synergies: ["Temporal events as game stages", "Strategies evolve over timeline"]
          });
        }
        if (characteristics.requiresProof && characteristics.complexity === "high") {
          combinations.push({
            modes: ["shannon" /* SHANNON */, "mathematics" /* MATHEMATICS */],
            sequence: "hybrid",
            rationale: "Use Shannon methodology to structure complex mathematical proofs",
            benefits: ["Systematic proof construction", "Clear problem decomposition"],
            synergies: ["Shannon stages guide proof strategy", "Mathematical rigor validates each stage"]
          });
        }
        if ((characteristics.domain === "engineering" || characteristics.domain === "software") && characteristics.hasAlternatives) {
          combinations.push({
            modes: ["engineering" /* ENGINEERING */, "optimization" /* OPTIMIZATION */],
            sequence: "sequential",
            rationale: "Design system architecture, then optimize for performance/cost",
            benefits: ["Structured design", "Optimal trade-offs", "Measurable improvements"],
            synergies: ["Engineering constraints feed optimization", "Optimization validates design choices"]
          });
        }
        if (characteristics.requiresQuantification && characteristics.hasAlternatives && (characteristics.domain === "engineering" || characteristics.domain === "software")) {
          combinations.push({
            modes: ["constraint" /* CONSTRAINT */, "engineering" /* ENGINEERING */],
            sequence: "sequential",
            rationale: "Identify constraints first, then design within those boundaries",
            benefits: ["Feasibility guaranteed", "Requirements satisfaction", "Clear boundaries"],
            synergies: ["Constraints define engineering solution space", "Engineering validates constraint satisfaction"]
          });
        }
        if (characteristics.complexity === "high" && characteristics.requiresExplanation) {
          combinations.push({
            modes: ["firstprinciples" /* FIRSTPRINCIPLES */, "systemsthinking" /* SYSTEMSTHINKING */],
            sequence: "sequential",
            rationale: "Build from fundamental truths, then analyze systemic interactions",
            benefits: ["Deep understanding", "Holistic view", "Novel insights"],
            synergies: ["First principles reveal core elements", "Systems thinking shows interconnections"]
          });
        }
        if (characteristics.hasIncompleteInfo && characteristics.requiresQuantification) {
          combinations.push({
            modes: ["scientificmethod" /* SCIENTIFICMETHOD */, "bayesian" /* BAYESIAN */],
            sequence: "hybrid",
            rationale: "Design experiments and update beliefs with Bayesian inference",
            benefits: ["Rigorous methodology", "Quantified uncertainty", "Evidence integration"],
            synergies: ["Experiments generate evidence", "Bayesian updates refine hypotheses"]
          });
        }
        if (characteristics.requiresProof && !characteristics.hasIncompleteInfo) {
          combinations.push({
            modes: ["formallogic" /* FORMALLOGIC */, "deductive" /* DEDUCTIVE */],
            sequence: "hybrid",
            rationale: "Use formal logic systems with deductive derivation",
            benefits: ["Maximum rigor", "Logically valid conclusions", "Formal verification"],
            synergies: ["Formal logic provides structure", "Deduction ensures valid inference"]
          });
        }
        if (characteristics.complexity === "high" && characteristics.hasAlternatives) {
          combinations.push({
            modes: ["recursive" /* RECURSIVE */, "optimization" /* OPTIMIZATION */],
            sequence: "hybrid",
            rationale: "Decompose problem recursively, optimize at each level",
            benefits: ["Scalable solutions", "Local and global optimization", "Manageable complexity"],
            synergies: ["Recursion breaks down problem", "Optimization solves subproblems optimally"]
          });
        }
        if (characteristics.uncertainty === "high" && characteristics.requiresQuantification) {
          combinations.push({
            modes: ["stochastic" /* STOCHASTIC */, "bayesian" /* BAYESIAN */],
            sequence: "parallel",
            rationale: "Model random processes while updating beliefs probabilistically",
            benefits: ["Complete uncertainty model", "Dynamic belief updates", "Probabilistic predictions"],
            synergies: ["Stochastic models generate distributions", "Bayesian reasoning integrates evidence"]
          });
        }
        if (characteristics.domain === "computer science" && characteristics.requiresProof) {
          combinations.push({
            modes: ["computability" /* COMPUTABILITY */, "formallogic" /* FORMALLOGIC */],
            sequence: "hybrid",
            rationale: "Analyze computational limits with formal logical proofs",
            benefits: ["Decidability analysis", "Rigorous complexity proofs", "Theoretical foundations"],
            synergies: ["Computability defines limits", "Formal logic proves properties"]
          });
        }
        if (characteristics.domain === "security" && characteristics.uncertainty === "high") {
          combinations.push({
            modes: ["cryptanalytic" /* CRYPTANALYTIC */, "stochastic" /* STOCHASTIC */],
            sequence: "parallel",
            rationale: "Analyze cryptographic systems with probabilistic attack modeling",
            benefits: ["Security assessment", "Attack probability estimation", "Key space analysis"],
            synergies: ["Cryptanalysis identifies vulnerabilities", "Stochastic models attack success rates"]
          });
        }
        if (characteristics.complexity === "high" && (characteristics.multiAgent || characteristics.timeDependent)) {
          combinations.push({
            modes: ["systemsthinking" /* SYSTEMSTHINKING */, "engineering" /* ENGINEERING */],
            sequence: "sequential",
            rationale: "Understand system dynamics holistically, then engineer solutions",
            benefits: ["Holistic design", "Feedback-aware engineering", "Emergent behavior consideration"],
            synergies: ["Systems view informs design", "Engineering implements systemic solutions"]
          });
        }
        if (characteristics.hasAlternatives && characteristics.uncertainty === "high") {
          combinations.push({
            modes: ["modal" /* MODAL */, "counterfactual" /* COUNTERFACTUAL */],
            sequence: "parallel",
            rationale: "Analyze possible worlds and counterfactual scenarios together",
            benefits: ["Complete possibility space", "What-if analysis", "Robust decision making"],
            synergies: ["Modal logic structures possibilities", "Counterfactuals explore specific alternatives"]
          });
        }
        if (characteristics.complexity === "high" && characteristics.hasAlternatives) {
          combinations.push({
            modes: ["metareasoning" /* METAREASONING */, "optimization" /* OPTIMIZATION */],
            sequence: "hybrid",
            rationale: "Monitor reasoning strategies and optimize approach selection",
            benefits: ["Adaptive reasoning", "Resource optimization", "Strategy refinement"],
            synergies: ["Metareasoning evaluates strategies", "Optimization selects best approach"]
          });
        }
        if (characteristics.requiresExplanation && characteristics.hasAlternatives) {
          combinations.push({
            modes: ["metareasoning" /* METAREASONING */, "formallogic" /* FORMALLOGIC */, "abductive" /* ABDUCTIVE */],
            sequence: "sequential",
            rationale: "Detect cognitive biases through meta-analysis, identify logical fallacies, and generate alternative explanations as counter-arguments",
            benefits: ["Comprehensive bias detection", "Fallacy identification", "Counter-argument generation", "Critical analysis"],
            synergies: ["Metareasoning identifies reasoning flaws", "Formal logic validates argument structure", "Abductive generates alternative explanations"]
          });
        }
        if (characteristics.hasAlternatives && characteristics.uncertainty !== "low") {
          combinations.push({
            modes: ["metareasoning" /* METAREASONING */, "counterfactual" /* COUNTERFACTUAL */],
            sequence: "parallel",
            rationale: "Self-reflect on reasoning while exploring alternative scenarios to counter biases",
            benefits: ["Bias awareness", "Alternative perspective generation", "Decision robustness"],
            synergies: ["Metareasoning detects bias patterns", "Counterfactual explores what-if scenarios"]
          });
        }
        if (characteristics.domain === "computer science" && characteristics.requiresProof) {
          combinations.push({
            modes: ["algorithmic" /* ALGORITHMIC */, "computability" /* COMPUTABILITY */],
            sequence: "hybrid",
            rationale: "Combine algorithm design with computability analysis for theoretical completeness",
            benefits: ["Algorithm correctness proofs", "Complexity class analysis", "Decidability bounds"],
            synergies: ["Algorithmic design informs complexity", "Computability proves fundamental limits"]
          });
        }
        if (characteristics.hasAlternatives && characteristics.requiresQuantification) {
          combinations.push({
            modes: ["algorithmic" /* ALGORITHMIC */, "optimization" /* OPTIMIZATION */],
            sequence: "sequential",
            rationale: "Design algorithm first, then optimize for performance",
            benefits: ["Correct-by-construction", "Performance optimization", "Trade-off analysis"],
            synergies: ["Algorithm provides baseline", "Optimization improves constants and bounds"]
          });
        }
        if (characteristics.requiresProof && characteristics.domain !== "philosophy") {
          combinations.push({
            modes: ["algorithmic" /* ALGORITHMIC */, "mathematics" /* MATHEMATICS */],
            sequence: "hybrid",
            rationale: "Combine algorithm design with mathematical proof techniques",
            benefits: ["Rigorous correctness proofs", "Loop invariant verification", "Inductive reasoning"],
            synergies: ["Algorithmic structures guide proof strategy", "Mathematical rigor ensures correctness"]
          });
        }
        if (characteristics.complexity === "high" && characteristics.hasAlternatives) {
          combinations.push({
            modes: ["algorithmic" /* ALGORITHMIC */, "recursive" /* RECURSIVE */],
            sequence: "parallel",
            rationale: "Apply divide-and-conquer paradigm with recursive decomposition",
            benefits: ["Natural problem decomposition", "Recurrence solving", "Subproblem identification"],
            synergies: ["Algorithmic patterns guide recursion", "Recursive structure enables Master Theorem"]
          });
        }
        if (characteristics.uncertainty !== "low" && characteristics.requiresQuantification) {
          combinations.push({
            modes: ["algorithmic" /* ALGORITHMIC */, "stochastic" /* STOCHASTIC */],
            sequence: "parallel",
            rationale: "Design randomized algorithms with probabilistic analysis",
            benefits: ["Expected-case analysis", "Monte Carlo methods", "Las Vegas algorithms"],
            synergies: ["Algorithmic framework structures randomization", "Stochastic analysis proves bounds"]
          });
        }
        if (characteristics.domain === "research" || characteristics.domain === "academic") {
          combinations.push({
            modes: ["synthesis" /* SYNTHESIS */, "critique" /* CRITIQUE */],
            sequence: "sequential",
            rationale: "Synthesize literature first, then critically evaluate the synthesized findings",
            benefits: ["Comprehensive review", "Critical evaluation", "Research gap identification"],
            synergies: ["Synthesis identifies patterns", "Critique validates findings"]
          });
        }
        if (characteristics.hasIncompleteInfo && characteristics.requiresExplanation) {
          combinations.push({
            modes: ["synthesis" /* SYNTHESIS */, "analysis" /* ANALYSIS */],
            sequence: "hybrid",
            rationale: "Combine literature synthesis with qualitative analysis methods",
            benefits: ["Multi-source integration", "Thematic consistency", "Methodological rigor"],
            synergies: ["Synthesis provides sources", "Analysis extracts themes"]
          });
        }
        if (characteristics.requiresExplanation && characteristics.hasAlternatives) {
          combinations.push({
            modes: ["argumentation" /* ARGUMENTATION */, "critique" /* CRITIQUE */],
            sequence: "parallel",
            rationale: "Build arguments while critically evaluating opposing views",
            benefits: ["Strong arguments", "Addressed weaknesses", "Robust conclusions"],
            synergies: ["Argumentation structures claims", "Critique strengthens rebuttals"]
          });
        }
        if (characteristics.requiresProof && characteristics.requiresExplanation) {
          combinations.push({
            modes: ["argumentation" /* ARGUMENTATION */, "deductive" /* DEDUCTIVE */],
            sequence: "hybrid",
            rationale: "Combine Toulmin argumentation with deductive logical rigor",
            benefits: ["Structured arguments", "Logical validity", "Academic rigor"],
            synergies: ["Toulmin provides structure", "Deduction ensures validity"]
          });
        }
        if (characteristics.hasIncompleteInfo && !characteristics.requiresProof) {
          combinations.push({
            modes: ["analysis" /* ANALYSIS */, "inductive" /* INDUCTIVE */],
            sequence: "sequential",
            rationale: "Apply qualitative analysis then generalize through inductive reasoning",
            benefits: ["Grounded findings", "Pattern generalization", "Theory building"],
            synergies: ["Analysis identifies codes", "Induction builds theory"]
          });
        }
        if (characteristics.complexity === "high" && characteristics.requiresExplanation) {
          combinations.push({
            modes: ["critique" /* CRITIQUE */, "metareasoning" /* METAREASONING */],
            sequence: "parallel",
            rationale: "Critically analyze while monitoring own biases and reasoning quality",
            benefits: ["Self-aware critique", "Bias mitigation", "Improved objectivity"],
            synergies: ["Critique evaluates content", "Metareasoning evaluates process"]
          });
        }
        if (characteristics.requiresQuantification && characteristics.hasIncompleteInfo) {
          combinations.push({
            modes: ["synthesis" /* SYNTHESIS */, "bayesian" /* BAYESIAN */],
            sequence: "hybrid",
            rationale: "Synthesize literature while quantifying evidence strength",
            benefits: ["Quantified synthesis", "Evidence weighting", "Probabilistic conclusions"],
            synergies: ["Synthesis gathers evidence", "Bayesian weights findings"]
          });
        }
        return combinations;
      }
      /**
       * Get a simple mode recommendation based on a few key characteristics
       * Simplified version for quick recommendations
       * Supports all 28 reasoning modes (v7.2.0)
       */
      quickRecommend(problemType) {
        const typeMap = {
          // Core reasoning modes
          "explanation": "abductive" /* ABDUCTIVE */,
          "hypothesis": "abductive" /* ABDUCTIVE */,
          "inference": "abductive" /* ABDUCTIVE */,
          "pattern": "inductive" /* INDUCTIVE */,
          "generalization": "inductive" /* INDUCTIVE */,
          "empirical": "inductive" /* INDUCTIVE */,
          "logic": "deductive" /* DEDUCTIVE */,
          "proof": "deductive" /* DEDUCTIVE */,
          "derivation": "deductive" /* DEDUCTIVE */,
          "complex": "hybrid" /* HYBRID */,
          "philosophical": "hybrid" /* HYBRID */,
          "metaphysical": "hybrid" /* HYBRID */,
          // Meta-reasoning
          "meta": "metareasoning" /* METAREASONING */,
          "strategy-selection": "metareasoning" /* METAREASONING */,
          "quality-assessment": "metareasoning" /* METAREASONING */,
          "reflection": "metareasoning" /* METAREASONING */,
          "self-evaluation": "metareasoning" /* METAREASONING */,
          // Specialized modes
          "debugging": "abductive" /* ABDUCTIVE */,
          "mathematical": "mathematics" /* MATHEMATICS */,
          "timeline": "temporal" /* TEMPORAL */,
          "strategy": "gametheory" /* GAMETHEORY */,
          "uncertainty": "evidential" /* EVIDENTIAL */,
          "causality": "causal" /* CAUSAL */,
          "probability": "bayesian" /* BAYESIAN */,
          "what-if": "counterfactual" /* COUNTERFACTUAL */,
          "analogy": "analogical" /* ANALOGICAL */,
          "physics": "physics" /* PHYSICS */,
          "systematic": "shannon" /* SHANNON */,
          // ===== NEW MODES (v7.2.0) =====
          // Engineering reasoning
          "engineering": "engineering" /* ENGINEERING */,
          "design": "engineering" /* ENGINEERING */,
          "architecture": "engineering" /* ENGINEERING */,
          "trade-off": "engineering" /* ENGINEERING */,
          "tradeoff": "engineering" /* ENGINEERING */,
          "system-design": "engineering" /* ENGINEERING */,
          "implementation": "engineering" /* ENGINEERING */,
          "reliability": "engineering" /* ENGINEERING */,
          "scalability": "engineering" /* ENGINEERING */,
          "performance": "engineering" /* ENGINEERING */,
          // Computability reasoning
          "computability": "computability" /* COMPUTABILITY */,
          "decidability": "computability" /* COMPUTABILITY */,
          "turing": "computability" /* COMPUTABILITY */,
          "halting": "computability" /* COMPUTABILITY */,
          "complexity-class": "computability" /* COMPUTABILITY */,
          "undecidable": "computability" /* COMPUTABILITY */,
          // Cryptanalytic reasoning
          "cryptanalysis": "cryptanalytic" /* CRYPTANALYTIC */,
          "cryptography": "cryptanalytic" /* CRYPTANALYTIC */,
          "security": "cryptanalytic" /* CRYPTANALYTIC */,
          "cipher": "cryptanalytic" /* CRYPTANALYTIC */,
          "encryption": "cryptanalytic" /* CRYPTANALYTIC */,
          "decryption": "cryptanalytic" /* CRYPTANALYTIC */,
          "attack-vector": "cryptanalytic" /* CRYPTANALYTIC */,
          "key-analysis": "cryptanalytic" /* CRYPTANALYTIC */,
          "protocol-security": "cryptanalytic" /* CRYPTANALYTIC */,
          // Recursive reasoning
          "recursive": "recursive" /* RECURSIVE */,
          "recursion": "recursive" /* RECURSIVE */,
          "divide-conquer": "recursive" /* RECURSIVE */,
          "self-similar": "recursive" /* RECURSIVE */,
          "decomposition": "recursive" /* RECURSIVE */,
          "fractal": "recursive" /* RECURSIVE */,
          "tree-traversal": "recursive" /* RECURSIVE */,
          // Modal reasoning
          "modal": "modal" /* MODAL */,
          "possibility": "modal" /* MODAL */,
          "necessity": "modal" /* MODAL */,
          "possible-worlds": "modal" /* MODAL */,
          "epistemic": "modal" /* MODAL */,
          "deontic": "modal" /* MODAL */,
          "alethic": "modal" /* MODAL */,
          // Stochastic reasoning
          "stochastic": "stochastic" /* STOCHASTIC */,
          "random-process": "stochastic" /* STOCHASTIC */,
          "markov": "stochastic" /* STOCHASTIC */,
          "monte-carlo": "stochastic" /* STOCHASTIC */,
          "probabilistic-process": "stochastic" /* STOCHASTIC */,
          "queueing": "stochastic" /* STOCHASTIC */,
          "random-walk": "stochastic" /* STOCHASTIC */,
          // Constraint reasoning
          "constraint": "constraint" /* CONSTRAINT */,
          "constraints": "constraint" /* CONSTRAINT */,
          "csp": "constraint" /* CONSTRAINT */,
          "sat": "constraint" /* CONSTRAINT */,
          "scheduling": "constraint" /* CONSTRAINT */,
          "allocation": "constraint" /* CONSTRAINT */,
          "feasibility": "constraint" /* CONSTRAINT */,
          "satisfiability": "constraint" /* CONSTRAINT */,
          // Optimization reasoning
          "optimization": "optimization" /* OPTIMIZATION */,
          "optimize": "optimization" /* OPTIMIZATION */,
          "optimal": "optimization" /* OPTIMIZATION */,
          "minimize": "optimization" /* OPTIMIZATION */,
          "maximize": "optimization" /* OPTIMIZATION */,
          "gradient": "optimization" /* OPTIMIZATION */,
          "convex": "optimization" /* OPTIMIZATION */,
          "heuristic": "optimization" /* OPTIMIZATION */,
          "search": "optimization" /* OPTIMIZATION */,
          // First Principles reasoning
          "first-principles": "firstprinciples" /* FIRSTPRINCIPLES */,
          "fundamental": "firstprinciples" /* FIRSTPRINCIPLES */,
          "foundational": "firstprinciples" /* FIRSTPRINCIPLES */,
          "axiom": "firstprinciples" /* FIRSTPRINCIPLES */,
          "ground-truth": "firstprinciples" /* FIRSTPRINCIPLES */,
          "from-scratch": "firstprinciples" /* FIRSTPRINCIPLES */,
          "basic-principles": "firstprinciples" /* FIRSTPRINCIPLES */,
          "root-cause": "firstprinciples" /* FIRSTPRINCIPLES */,
          // Systems Thinking reasoning
          "systems-thinking": "systemsthinking" /* SYSTEMSTHINKING */,
          "systems": "systemsthinking" /* SYSTEMSTHINKING */,
          "holistic": "systemsthinking" /* SYSTEMSTHINKING */,
          "feedback-loop": "systemsthinking" /* SYSTEMSTHINKING */,
          "emergence": "systemsthinking" /* SYSTEMSTHINKING */,
          "interconnected": "systemsthinking" /* SYSTEMSTHINKING */,
          "ecosystem": "systemsthinking" /* SYSTEMSTHINKING */,
          "leverage-point": "systemsthinking" /* SYSTEMSTHINKING */,
          // Scientific Method reasoning
          "scientific": "scientificmethod" /* SCIENTIFICMETHOD */,
          "experiment": "scientificmethod" /* SCIENTIFICMETHOD */,
          "research": "scientificmethod" /* SCIENTIFICMETHOD */,
          "falsification": "scientificmethod" /* SCIENTIFICMETHOD */,
          "hypothesis-testing": "scientificmethod" /* SCIENTIFICMETHOD */,
          "a/b-testing": "scientificmethod" /* SCIENTIFICMETHOD */,
          "reproducibility": "scientificmethod" /* SCIENTIFICMETHOD */,
          "control-group": "scientificmethod" /* SCIENTIFICMETHOD */,
          // Formal Logic reasoning
          "formal-logic": "formallogic" /* FORMALLOGIC */,
          "propositional": "formallogic" /* FORMALLOGIC */,
          "predicate": "formallogic" /* FORMALLOGIC */,
          "theorem-proving": "formallogic" /* FORMALLOGIC */,
          "formal-proof": "formallogic" /* FORMALLOGIC */,
          "validity": "formallogic" /* FORMALLOGIC */,
          "soundness": "formallogic" /* FORMALLOGIC */,
          "completeness": "formallogic" /* FORMALLOGIC */,
          // Bias detection and critical analysis
          "bias": "metareasoning" /* METAREASONING */,
          "bias-detection": "metareasoning" /* METAREASONING */,
          "cognitive-bias": "metareasoning" /* METAREASONING */,
          "fallacy": "formallogic" /* FORMALLOGIC */,
          "fallacies": "formallogic" /* FORMALLOGIC */,
          "logical-fallacy": "formallogic" /* FORMALLOGIC */,
          "counter-argument": "counterfactual" /* COUNTERFACTUAL */,
          "counterargument": "counterfactual" /* COUNTERFACTUAL */,
          "fact-check": "evidential" /* EVIDENTIAL */,
          "misinformation": "evidential" /* EVIDENTIAL */,
          "disinformation": "evidential" /* EVIDENTIAL */,
          "reasoning-flaw": "metareasoning" /* METAREASONING */,
          "argument-analysis": "formallogic" /* FORMALLOGIC */,
          // ===== ALGORITHMIC REASONING (v7.3.0) - CLRS Coverage =====
          // General algorithm terms
          "algorithm": "algorithmic" /* ALGORITHMIC */,
          "algorithms": "algorithmic" /* ALGORITHMIC */,
          "algorithmic": "algorithmic" /* ALGORITHMIC */,
          "data-structure": "algorithmic" /* ALGORITHMIC */,
          "data-structures": "algorithmic" /* ALGORITHMIC */,
          "complexity": "algorithmic" /* ALGORITHMIC */,
          "time-complexity": "algorithmic" /* ALGORITHMIC */,
          "space-complexity": "algorithmic" /* ALGORITHMIC */,
          "big-o": "algorithmic" /* ALGORITHMIC */,
          "asymptotic": "algorithmic" /* ALGORITHMIC */,
          "correctness-proof": "algorithmic" /* ALGORITHMIC */,
          "loop-invariant": "algorithmic" /* ALGORITHMIC */,
          "invariant": "algorithmic" /* ALGORITHMIC */,
          // Design patterns
          "divide-and-conquer": "algorithmic" /* ALGORITHMIC */,
          "dynamic-programming": "algorithmic" /* ALGORITHMIC */,
          "dp": "algorithmic" /* ALGORITHMIC */,
          "memoization": "algorithmic" /* ALGORITHMIC */,
          "greedy-algorithm": "algorithmic" /* ALGORITHMIC */,
          "backtracking": "algorithmic" /* ALGORITHMIC */,
          "branch-and-bound": "algorithmic" /* ALGORITHMIC */,
          "amortized": "algorithmic" /* ALGORITHMIC */,
          "amortized-analysis": "algorithmic" /* ALGORITHMIC */,
          // Sorting algorithms
          "sorting": "algorithmic" /* ALGORITHMIC */,
          "sort": "algorithmic" /* ALGORITHMIC */,
          "insertion-sort": "algorithmic" /* ALGORITHMIC */,
          "merge-sort": "algorithmic" /* ALGORITHMIC */,
          "mergesort": "algorithmic" /* ALGORITHMIC */,
          "quicksort": "algorithmic" /* ALGORITHMIC */,
          "quick-sort": "algorithmic" /* ALGORITHMIC */,
          "heapsort": "algorithmic" /* ALGORITHMIC */,
          "heap-sort": "algorithmic" /* ALGORITHMIC */,
          "counting-sort": "algorithmic" /* ALGORITHMIC */,
          "radix-sort": "algorithmic" /* ALGORITHMIC */,
          "bucket-sort": "algorithmic" /* ALGORITHMIC */,
          "comparison-sort": "algorithmic" /* ALGORITHMIC */,
          // Searching and selection
          "binary-search": "algorithmic" /* ALGORITHMIC */,
          "linear-search": "algorithmic" /* ALGORITHMIC */,
          "selection-algorithm": "algorithmic" /* ALGORITHMIC */,
          "median-of-medians": "algorithmic" /* ALGORITHMIC */,
          "order-statistics": "algorithmic" /* ALGORITHMIC */,
          // Data structures
          "heap": "algorithmic" /* ALGORITHMIC */,
          "binary-heap": "algorithmic" /* ALGORITHMIC */,
          "priority-queue": "algorithmic" /* ALGORITHMIC */,
          "hash-table": "algorithmic" /* ALGORITHMIC */,
          "hashing": "algorithmic" /* ALGORITHMIC */,
          "binary-search-tree": "algorithmic" /* ALGORITHMIC */,
          "bst": "algorithmic" /* ALGORITHMIC */,
          "red-black-tree": "algorithmic" /* ALGORITHMIC */,
          "avl-tree": "algorithmic" /* ALGORITHMIC */,
          "b-tree": "algorithmic" /* ALGORITHMIC */,
          "fibonacci-heap": "algorithmic" /* ALGORITHMIC */,
          "union-find": "algorithmic" /* ALGORITHMIC */,
          "disjoint-set": "algorithmic" /* ALGORITHMIC */,
          "trie": "algorithmic" /* ALGORITHMIC */,
          "segment-tree": "algorithmic" /* ALGORITHMIC */,
          "fenwick-tree": "algorithmic" /* ALGORITHMIC */,
          // Graph algorithms
          "graph-algorithm": "algorithmic" /* ALGORITHMIC */,
          "bfs": "algorithmic" /* ALGORITHMIC */,
          "breadth-first": "algorithmic" /* ALGORITHMIC */,
          "dfs": "algorithmic" /* ALGORITHMIC */,
          "depth-first": "algorithmic" /* ALGORITHMIC */,
          "topological-sort": "algorithmic" /* ALGORITHMIC */,
          "strongly-connected": "algorithmic" /* ALGORITHMIC */,
          "scc": "algorithmic" /* ALGORITHMIC */,
          "minimum-spanning-tree": "algorithmic" /* ALGORITHMIC */,
          "mst": "algorithmic" /* ALGORITHMIC */,
          "kruskal": "algorithmic" /* ALGORITHMIC */,
          "prim": "algorithmic" /* ALGORITHMIC */,
          "dijkstra": "algorithmic" /* ALGORITHMIC */,
          "bellman-ford": "algorithmic" /* ALGORITHMIC */,
          "floyd-warshall": "algorithmic" /* ALGORITHMIC */,
          "shortest-path": "algorithmic" /* ALGORITHMIC */,
          "max-flow": "algorithmic" /* ALGORITHMIC */,
          "ford-fulkerson": "algorithmic" /* ALGORITHMIC */,
          "edmonds-karp": "algorithmic" /* ALGORITHMIC */,
          "bipartite-matching": "algorithmic" /* ALGORITHMIC */,
          // Dynamic programming problems
          "lcs": "algorithmic" /* ALGORITHMIC */,
          "longest-common-subsequence": "algorithmic" /* ALGORITHMIC */,
          "edit-distance": "algorithmic" /* ALGORITHMIC */,
          "levenshtein": "algorithmic" /* ALGORITHMIC */,
          "knapsack": "algorithmic" /* ALGORITHMIC */,
          "matrix-chain": "algorithmic" /* ALGORITHMIC */,
          "optimal-bst": "algorithmic" /* ALGORITHMIC */,
          "rod-cutting": "algorithmic" /* ALGORITHMIC */,
          "coin-change": "algorithmic" /* ALGORITHMIC */,
          // String algorithms
          "string-matching": "algorithmic" /* ALGORITHMIC */,
          "pattern-matching": "algorithmic" /* ALGORITHMIC */,
          "kmp": "algorithmic" /* ALGORITHMIC */,
          "knuth-morris-pratt": "algorithmic" /* ALGORITHMIC */,
          "rabin-karp": "algorithmic" /* ALGORITHMIC */,
          "boyer-moore": "algorithmic" /* ALGORITHMIC */,
          "suffix-array": "algorithmic" /* ALGORITHMIC */,
          "suffix-tree": "algorithmic" /* ALGORITHMIC */,
          // Computational geometry
          "convex-hull": "algorithmic" /* ALGORITHMIC */,
          "graham-scan": "algorithmic" /* ALGORITHMIC */,
          "jarvis-march": "algorithmic" /* ALGORITHMIC */,
          "closest-pair": "algorithmic" /* ALGORITHMIC */,
          "line-intersection": "algorithmic" /* ALGORITHMIC */,
          // Number theory algorithms
          "gcd": "algorithmic" /* ALGORITHMIC */,
          "euclidean": "algorithmic" /* ALGORITHMIC */,
          "modular-arithmetic": "algorithmic" /* ALGORITHMIC */,
          "primality": "algorithmic" /* ALGORITHMIC */,
          "miller-rabin": "algorithmic" /* ALGORITHMIC */,
          "rsa": "algorithmic" /* ALGORITHMIC */,
          // Matrix algorithms
          "strassen": "algorithmic" /* ALGORITHMIC */,
          "matrix-multiplication": "algorithmic" /* ALGORITHMIC */,
          "matrix-exponentiation": "algorithmic" /* ALGORITHMIC */,
          // Advanced topics
          "fft": "algorithmic" /* ALGORITHMIC */,
          "fast-fourier": "algorithmic" /* ALGORITHMIC */,
          "polynomial-multiplication": "algorithmic" /* ALGORITHMIC */,
          "linear-programming": "algorithmic" /* ALGORITHMIC */,
          "simplex": "algorithmic" /* ALGORITHMIC */,
          "approximation-algorithm": "algorithmic" /* ALGORITHMIC */,
          "np-hard": "algorithmic" /* ALGORITHMIC */,
          "np-complete": "algorithmic" /* ALGORITHMIC */,
          // Recurrences and analysis
          "recurrence": "algorithmic" /* ALGORITHMIC */,
          "master-theorem": "algorithmic" /* ALGORITHMIC */,
          "recursion-tree": "algorithmic" /* ALGORITHMIC */,
          "substitution-method": "algorithmic" /* ALGORITHMIC */,
          // ===== ACADEMIC RESEARCH MODES (v7.4.0) =====
          // Synthesis mode - literature review and knowledge integration
          "synthesis": "synthesis" /* SYNTHESIS */,
          "literature-review": "synthesis" /* SYNTHESIS */,
          "literature-synthesis": "synthesis" /* SYNTHESIS */,
          "systematic-review": "synthesis" /* SYNTHESIS */,
          "meta-analysis": "synthesis" /* SYNTHESIS */,
          "knowledge-integration": "synthesis" /* SYNTHESIS */,
          "research-synthesis": "synthesis" /* SYNTHESIS */,
          "state-of-the-art": "synthesis" /* SYNTHESIS */,
          "survey-paper": "synthesis" /* SYNTHESIS */,
          "theme-extraction": "synthesis" /* SYNTHESIS */,
          "gap-analysis": "synthesis" /* SYNTHESIS */,
          "cross-study": "synthesis" /* SYNTHESIS */,
          // Argumentation mode - academic argumentation and Toulmin model
          "argumentation": "argumentation" /* ARGUMENTATION */,
          "argument": "argumentation" /* ARGUMENTATION */,
          "toulmin": "argumentation" /* ARGUMENTATION */,
          "toulmin-model": "argumentation" /* ARGUMENTATION */,
          "claim-evidence": "argumentation" /* ARGUMENTATION */,
          "warrant": "argumentation" /* ARGUMENTATION */,
          "backing": "argumentation" /* ARGUMENTATION */,
          "qualifier": "argumentation" /* ARGUMENTATION */,
          "rebuttal": "argumentation" /* ARGUMENTATION */,
          "thesis-argument": "argumentation" /* ARGUMENTATION */,
          "position-paper": "argumentation" /* ARGUMENTATION */,
          "debate": "argumentation" /* ARGUMENTATION */,
          "persuasion": "argumentation" /* ARGUMENTATION */,
          "dialectic": "argumentation" /* ARGUMENTATION */,
          "rhetorical": "argumentation" /* ARGUMENTATION */,
          // Critique mode - critical analysis and peer review
          "critique": "critique" /* CRITIQUE */,
          "critical-analysis": "critique" /* CRITIQUE */,
          "peer-review": "critique" /* CRITIQUE */,
          "paper-review": "critique" /* CRITIQUE */,
          "methodology-critique": "critique" /* CRITIQUE */,
          "validity-assessment": "critique" /* CRITIQUE */,
          "limitation-analysis": "critique" /* CRITIQUE */,
          "strength-weakness": "critique" /* CRITIQUE */,
          "constructive-feedback": "critique" /* CRITIQUE */,
          "research-critique": "critique" /* CRITIQUE */,
          "evaluation": "critique" /* CRITIQUE */,
          // Analysis mode - qualitative analysis methods
          "qualitative-analysis": "analysis" /* ANALYSIS */,
          "thematic-analysis": "analysis" /* ANALYSIS */,
          "grounded-theory": "analysis" /* ANALYSIS */,
          "discourse-analysis": "analysis" /* ANALYSIS */,
          "content-analysis": "analysis" /* ANALYSIS */,
          "narrative-analysis": "analysis" /* ANALYSIS */,
          "phenomenological": "analysis" /* ANALYSIS */,
          "ethnographic": "analysis" /* ANALYSIS */,
          "coding": "analysis" /* ANALYSIS */,
          "interview-analysis": "analysis" /* ANALYSIS */,
          "document-analysis": "analysis" /* ANALYSIS */,
          "case-study": "analysis" /* ANALYSIS */,
          "qualitative": "analysis" /* ANALYSIS */
        };
        return typeMap[problemType.toLowerCase()] || "sequential" /* SEQUENTIAL */;
      }
    };
  }
});

// src/types/index.ts
var init_types = __esm({
  "src/types/index.ts"() {
    init_esm_shims();
    init_core();
    init_session();
    init_recommendations();
  }
});

// src/utils/type-guards.ts
function isExtendedThoughtType(value) {
  return typeof value === "string" && VALID_THOUGHT_TYPES.includes(value);
}
function toExtendedThoughtType(value, fallback) {
  if (isExtendedThoughtType(value)) {
    return value;
  }
  if (fallback !== void 0) {
    return fallback;
  }
  throw new Error(
    `Invalid ExtendedThoughtType: ${value}. Must be one of: ${VALID_THOUGHT_TYPES.join(", ")}`
  );
}
var VALID_THOUGHT_TYPES;
var init_type_guards = __esm({
  "src/utils/type-guards.ts"() {
    init_esm_shims();
    VALID_THOUGHT_TYPES = [
      "problem_definition",
      "constraints",
      "model",
      "proof",
      "implementation",
      "axiom_definition",
      "theorem_statement",
      "proof_construction",
      "lemma_derivation",
      "corollary",
      "counterexample",
      "algebraic_manipulation",
      "symbolic_computation",
      "numerical_analysis",
      "symmetry_analysis",
      "gauge_theory",
      "field_equations",
      "lagrangian",
      "hamiltonian",
      "conservation_law",
      "dimensional_analysis",
      "tensor_formulation",
      "differential_geometry",
      "decomposition",
      "synthesis",
      "abstraction",
      "analogy",
      "metacognition",
      // Phase 8: Proof Decomposition Types
      "proof_decomposition",
      "dependency_analysis",
      "consistency_check",
      "gap_identification",
      "assumption_trace"
    ];
  }
});
var GenericModeHandler;
var init_GenericModeHandler = __esm({
  "src/modes/handlers/GenericModeHandler.ts"() {
    init_esm_shims();
    init_core();
    init_ModeHandler();
    init_type_guards();
    GenericModeHandler = class {
      mode;
      modeName;
      description;
      constructor(mode, modeName, description) {
        this.mode = mode;
        this.modeName = modeName || this.getDefaultModeName(mode);
        this.description = description || this.getDefaultDescription(mode);
      }
      /**
       * Create a thought object from input
       *
       * This replicates the logic from ThoughtFactory.createThought()
       * for the mode this handler is configured for.
       */
      createThought(input, sessionId) {
        const baseThought = this.createBaseThought(input, sessionId);
        return this.createModeSpecificThought(input, baseThought);
      }
      /**
       * Create the base thought structure common to all modes
       */
      createBaseThought(input, sessionId) {
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          isRevision: input.isRevision,
          revisesThought: input.revisesThought
        };
      }
      /**
       * Create mode-specific thought structure
       *
       * Override this method in specialized handlers to add
       * mode-specific logic and validation.
       */
      createModeSpecificThought(input, baseThought) {
        const mode = input.mode || this.mode;
        switch (mode) {
          case "sequential" /* SEQUENTIAL */:
            return {
              ...baseThought,
              mode: "sequential" /* SEQUENTIAL */,
              revisionReason: input.revisionReason,
              branchFrom: input.branchFrom,
              branchId: input.branchId
            };
          case "shannon" /* SHANNON */:
            return {
              ...baseThought,
              mode: "shannon" /* SHANNON */,
              stage: input.stage || "problem_definition" /* PROBLEM_DEFINITION */,
              uncertainty: input.uncertainty || 0.5,
              dependencies: input.dependencies || [],
              assumptions: input.assumptions || []
            };
          case "mathematics" /* MATHEMATICS */:
            return {
              ...baseThought,
              mode: "mathematics" /* MATHEMATICS */,
              thoughtType: toExtendedThoughtType(input.thoughtType, "model"),
              mathematicalModel: input.mathematicalModel,
              proofStrategy: input.proofStrategy,
              dependencies: input.dependencies || [],
              assumptions: input.assumptions || [],
              uncertainty: input.uncertainty || 0.5
            };
          case "physics" /* PHYSICS */:
            return {
              ...baseThought,
              mode: "physics" /* PHYSICS */,
              thoughtType: toExtendedThoughtType(input.thoughtType, "model"),
              tensorProperties: input.tensorProperties,
              physicalInterpretation: input.physicalInterpretation,
              dependencies: input.dependencies || [],
              assumptions: input.assumptions || [],
              uncertainty: input.uncertainty || 0.5
            };
          case "inductive" /* INDUCTIVE */:
            return {
              ...baseThought,
              mode: "inductive" /* INDUCTIVE */,
              observations: input.observations || [],
              pattern: input.pattern,
              generalization: input.generalization || "",
              confidence: input.confidence ?? 0.5,
              counterexamples: input.counterexamples || [],
              sampleSize: input.sampleSize
            };
          case "deductive" /* DEDUCTIVE */:
            return {
              ...baseThought,
              mode: "deductive" /* DEDUCTIVE */,
              premises: input.premises || [],
              conclusion: input.conclusion || "",
              logicForm: input.logicForm,
              validityCheck: input.validityCheck ?? false,
              soundnessCheck: input.soundnessCheck
            };
          case "abductive" /* ABDUCTIVE */:
            return {
              ...baseThought,
              mode: "abductive" /* ABDUCTIVE */,
              thoughtType: toExtendedThoughtType(input.thoughtType, "problem_definition"),
              observations: input.observations || [],
              hypotheses: input.hypotheses || [],
              evaluationCriteria: input.evaluationCriteria,
              evidence: input.evidence || [],
              bestExplanation: input.bestExplanation
            };
          case "causal" /* CAUSAL */:
            return this.createCausalThought(input, baseThought);
          case "hybrid" /* HYBRID */:
          default:
            return this.createHybridThought(input, baseThought);
        }
      }
      /**
       * Create a causal thought with graph handling
       */
      createCausalThought(input, baseThought) {
        const inputAny = input;
        const causalGraph = input.causalGraph || {
          nodes: inputAny.nodes || [],
          edges: inputAny.edges || []
        };
        return {
          ...baseThought,
          mode: "causal" /* CAUSAL */,
          thoughtType: toExtendedThoughtType(input.thoughtType, "problem_definition"),
          causalGraph,
          interventions: input.interventions || [],
          mechanisms: input.mechanisms || [],
          confounders: input.confounders || []
        };
      }
      /**
       * Create a hybrid thought (default fallback)
       */
      createHybridThought(input, baseThought) {
        return {
          ...baseThought,
          mode: "hybrid" /* HYBRID */,
          thoughtType: toExtendedThoughtType(input.thoughtType, "synthesis"),
          stage: input.stage,
          uncertainty: input.uncertainty,
          dependencies: input.dependencies,
          assumptions: input.assumptions,
          mathematicalModel: input.mathematicalModel,
          tensorProperties: input.tensorProperties,
          physicalInterpretation: input.physicalInterpretation,
          primaryMode: input.mode || "hybrid" /* HYBRID */,
          secondaryFeatures: []
        };
      }
      /**
       * Validate mode-specific input
       *
       * The generic handler performs basic validation.
       * Specialized handlers should override for deeper validation.
       */
      validate(input) {
        const warnings = [];
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        const mode = input.mode || "hybrid" /* HYBRID */;
        if (!isFullyImplemented(mode)) {
          warnings.push(
            createValidationWarning(
              "mode",
              `Mode '${mode}' is experimental with limited runtime implementation`,
              "Consider using a fully implemented mode for production use"
            )
          );
        }
        return validationSuccess(warnings);
      }
      /**
       * Get mode-specific enhancements
       *
       * The generic handler returns minimal enhancements.
       * Specialized handlers can provide richer context.
       */
      getEnhancements(thought) {
        return {
          suggestions: [],
          relatedModes: this.getRelatedModes(thought.mode)
        };
      }
      /**
       * Get mode status information
       */
      getModeStatus() {
        return {
          mode: this.mode,
          isFullyImplemented: isFullyImplemented(this.mode),
          hasSpecializedHandler: false,
          // GenericHandler is not specialized
          note: isFullyImplemented(this.mode) ? void 0 : "This mode is experimental with limited runtime implementation"
        };
      }
      /**
       * Get related modes for suggestions
       */
      getRelatedModes(mode) {
        const relatedModes = {
          ["sequential" /* SEQUENTIAL */]: ["hybrid" /* HYBRID */, "shannon" /* SHANNON */],
          ["shannon" /* SHANNON */]: ["sequential" /* SEQUENTIAL */, "mathematics" /* MATHEMATICS */],
          ["mathematics" /* MATHEMATICS */]: ["physics" /* PHYSICS */, "algorithmic" /* ALGORITHMIC */],
          ["physics" /* PHYSICS */]: ["mathematics" /* MATHEMATICS */, "engineering" /* ENGINEERING */],
          ["hybrid" /* HYBRID */]: ["sequential" /* SEQUENTIAL */, "metareasoning" /* METAREASONING */],
          ["causal" /* CAUSAL */]: ["bayesian" /* BAYESIAN */, "counterfactual" /* COUNTERFACTUAL */],
          ["bayesian" /* BAYESIAN */]: ["causal" /* CAUSAL */, "evidential" /* EVIDENTIAL */],
          ["inductive" /* INDUCTIVE */]: ["deductive" /* DEDUCTIVE */, "abductive" /* ABDUCTIVE */],
          ["deductive" /* DEDUCTIVE */]: ["inductive" /* INDUCTIVE */, "formallogic" /* FORMALLOGIC */],
          ["abductive" /* ABDUCTIVE */]: ["inductive" /* INDUCTIVE */, "causal" /* CAUSAL */],
          ["counterfactual" /* COUNTERFACTUAL */]: ["causal" /* CAUSAL */, "gametheory" /* GAMETHEORY */],
          ["analogical" /* ANALOGICAL */]: ["inductive" /* INDUCTIVE */, "firstprinciples" /* FIRSTPRINCIPLES */],
          ["temporal" /* TEMPORAL */]: ["causal" /* CAUSAL */, "sequential" /* SEQUENTIAL */],
          ["gametheory" /* GAMETHEORY */]: ["optimization" /* OPTIMIZATION */, "counterfactual" /* COUNTERFACTUAL */],
          ["evidential" /* EVIDENTIAL */]: ["bayesian" /* BAYESIAN */, "scientificmethod" /* SCIENTIFICMETHOD */],
          ["firstprinciples" /* FIRSTPRINCIPLES */]: ["deductive" /* DEDUCTIVE */, "analogical" /* ANALOGICAL */],
          ["systemsthinking" /* SYSTEMSTHINKING */]: ["causal" /* CAUSAL */, "optimization" /* OPTIMIZATION */],
          ["scientificmethod" /* SCIENTIFICMETHOD */]: ["evidential" /* EVIDENTIAL */, "synthesis" /* SYNTHESIS */],
          ["formallogic" /* FORMALLOGIC */]: ["deductive" /* DEDUCTIVE */, "mathematics" /* MATHEMATICS */],
          ["metareasoning" /* METAREASONING */]: ["hybrid" /* HYBRID */, "critique" /* CRITIQUE */],
          ["recursive" /* RECURSIVE */]: ["algorithmic" /* ALGORITHMIC */, "mathematics" /* MATHEMATICS */],
          ["modal" /* MODAL */]: ["formallogic" /* FORMALLOGIC */, "counterfactual" /* COUNTERFACTUAL */],
          ["stochastic" /* STOCHASTIC */]: ["bayesian" /* BAYESIAN */, "optimization" /* OPTIMIZATION */],
          ["constraint" /* CONSTRAINT */]: ["optimization" /* OPTIMIZATION */, "formallogic" /* FORMALLOGIC */],
          ["optimization" /* OPTIMIZATION */]: ["constraint" /* CONSTRAINT */, "gametheory" /* GAMETHEORY */],
          ["engineering" /* ENGINEERING */]: ["optimization" /* OPTIMIZATION */, "systemsthinking" /* SYSTEMSTHINKING */],
          ["computability" /* COMPUTABILITY */]: ["algorithmic" /* ALGORITHMIC */, "formallogic" /* FORMALLOGIC */],
          ["cryptanalytic" /* CRYPTANALYTIC */]: ["bayesian" /* BAYESIAN */, "algorithmic" /* ALGORITHMIC */],
          ["algorithmic" /* ALGORITHMIC */]: ["mathematics" /* MATHEMATICS */, "optimization" /* OPTIMIZATION */],
          ["synthesis" /* SYNTHESIS */]: ["critique" /* CRITIQUE */, "analysis" /* ANALYSIS */],
          ["argumentation" /* ARGUMENTATION */]: ["critique" /* CRITIQUE */, "formallogic" /* FORMALLOGIC */],
          ["critique" /* CRITIQUE */]: ["argumentation" /* ARGUMENTATION */, "synthesis" /* SYNTHESIS */],
          ["analysis" /* ANALYSIS */]: ["synthesis" /* SYNTHESIS */, "scientificmethod" /* SCIENTIFICMETHOD */],
          ["custom" /* CUSTOM */]: ["hybrid" /* HYBRID */]
        };
        return relatedModes[mode] || ["hybrid" /* HYBRID */];
      }
      /**
       * Get default mode name
       */
      getDefaultModeName(mode) {
        const names = {
          ["sequential" /* SEQUENTIAL */]: "Sequential Thinking",
          ["shannon" /* SHANNON */]: "Shannon Problem-Solving",
          ["mathematics" /* MATHEMATICS */]: "Mathematical Reasoning",
          ["physics" /* PHYSICS */]: "Physics Modeling",
          ["hybrid" /* HYBRID */]: "Hybrid Mode",
          ["inductive" /* INDUCTIVE */]: "Inductive Reasoning",
          ["deductive" /* DEDUCTIVE */]: "Deductive Reasoning",
          ["abductive" /* ABDUCTIVE */]: "Abductive Reasoning",
          ["causal" /* CAUSAL */]: "Causal Analysis",
          ["bayesian" /* BAYESIAN */]: "Bayesian Inference",
          ["counterfactual" /* COUNTERFACTUAL */]: "Counterfactual Reasoning",
          ["analogical" /* ANALOGICAL */]: "Analogical Reasoning",
          ["temporal" /* TEMPORAL */]: "Temporal Reasoning",
          ["gametheory" /* GAMETHEORY */]: "Game Theory",
          ["evidential" /* EVIDENTIAL */]: "Evidential Reasoning",
          ["firstprinciples" /* FIRSTPRINCIPLES */]: "First Principles",
          ["systemsthinking" /* SYSTEMSTHINKING */]: "Systems Thinking",
          ["scientificmethod" /* SCIENTIFICMETHOD */]: "Scientific Method",
          ["formallogic" /* FORMALLOGIC */]: "Formal Logic",
          ["metareasoning" /* METAREASONING */]: "Meta-Reasoning",
          ["recursive" /* RECURSIVE */]: "Recursive Reasoning",
          ["modal" /* MODAL */]: "Modal Logic",
          ["stochastic" /* STOCHASTIC */]: "Stochastic Reasoning",
          ["constraint" /* CONSTRAINT */]: "Constraint Satisfaction",
          ["optimization" /* OPTIMIZATION */]: "Optimization",
          ["engineering" /* ENGINEERING */]: "Engineering Analysis",
          ["computability" /* COMPUTABILITY */]: "Computability Theory",
          ["cryptanalytic" /* CRYPTANALYTIC */]: "Cryptanalysis",
          ["algorithmic" /* ALGORITHMIC */]: "Algorithm Design",
          ["synthesis" /* SYNTHESIS */]: "Literature Synthesis",
          ["argumentation" /* ARGUMENTATION */]: "Academic Argumentation",
          ["critique" /* CRITIQUE */]: "Critical Analysis",
          ["analysis" /* ANALYSIS */]: "Qualitative Analysis",
          ["custom" /* CUSTOM */]: "Custom Mode"
        };
        return names[mode] || "Unknown Mode";
      }
      /**
       * Get default mode description
       */
      getDefaultDescription(mode) {
        const descriptions = {
          ["sequential" /* SEQUENTIAL */]: "Step-by-step logical reasoning",
          ["shannon" /* SHANNON */]: "Claude Shannon's 5-stage problem-solving methodology",
          ["mathematics" /* MATHEMATICS */]: "Mathematical proofs and formal reasoning",
          ["physics" /* PHYSICS */]: "Physical modeling with tensors and conservation laws",
          ["hybrid" /* HYBRID */]: "Flexible combination of multiple reasoning modes",
          ["inductive" /* INDUCTIVE */]: "Reasoning from specific cases to general principles",
          ["deductive" /* DEDUCTIVE */]: "Reasoning from general principles to specific conclusions",
          ["abductive" /* ABDUCTIVE */]: "Inference to the best explanation",
          ["causal" /* CAUSAL */]: "Causal graph analysis and intervention reasoning",
          ["bayesian" /* BAYESIAN */]: "Probabilistic reasoning with prior updates",
          ["counterfactual" /* COUNTERFACTUAL */]: "What-if scenario analysis",
          ["analogical" /* ANALOGICAL */]: "Reasoning by structural similarity",
          ["temporal" /* TEMPORAL */]: "Temporal logic and event sequencing",
          ["gametheory" /* GAMETHEORY */]: "Strategic interaction and Nash equilibria",
          ["evidential" /* EVIDENTIAL */]: "Dempster-Shafer evidence theory",
          ["firstprinciples" /* FIRSTPRINCIPLES */]: "Reasoning from fundamental truths",
          ["systemsthinking" /* SYSTEMSTHINKING */]: "Feedback loops and system dynamics",
          ["scientificmethod" /* SCIENTIFICMETHOD */]: "Hypothesis testing and experimentation",
          ["formallogic" /* FORMALLOGIC */]: "Propositional and predicate logic",
          ["metareasoning" /* METAREASONING */]: "Reasoning about reasoning strategies",
          ["recursive" /* RECURSIVE */]: "Self-similar problem decomposition",
          ["modal" /* MODAL */]: "Possibility and necessity reasoning",
          ["stochastic" /* STOCHASTIC */]: "Probabilistic state transitions",
          ["constraint" /* CONSTRAINT */]: "Constraint satisfaction problems",
          ["optimization" /* OPTIMIZATION */]: "Objective function optimization",
          ["engineering" /* ENGINEERING */]: "Requirements, trade studies, and FMEA",
          ["computability" /* COMPUTABILITY */]: "Turing machines and decidability",
          ["cryptanalytic" /* CRYPTANALYTIC */]: "Cryptanalysis with deciban evidence",
          ["algorithmic" /* ALGORITHMIC */]: "CLRS algorithm design and analysis",
          ["synthesis" /* SYNTHESIS */]: "Literature review and integration",
          ["argumentation" /* ARGUMENTATION */]: "Toulmin model academic arguments",
          ["critique" /* CRITIQUE */]: "Critical evaluation of scholarly work",
          ["analysis" /* ANALYSIS */]: "Qualitative data analysis methods",
          ["custom" /* CUSTOM */]: "User-defined reasoning mode"
        };
        return descriptions[mode] || "Unknown reasoning mode";
      }
    };
  }
});
var CausalHandler;
var init_CausalHandler = __esm({
  "src/modes/handlers/CausalHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    init_type_guards();
    CausalHandler = class {
      mode = "causal" /* CAUSAL */;
      modeName = "Causal Analysis";
      description = "Causal graph analysis with intervention reasoning and cycle detection";
      /**
       * Supported thought types for causal mode
       */
      supportedThoughtTypes = [
        "problem_definition",
        "causal_graph_construction",
        "intervention_analysis",
        "counterfactual_analysis",
        "confounder_identification",
        "mechanism_discovery"
      ];
      /**
       * Create a causal thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const causalGraph = input.causalGraph || {
          nodes: inputAny.nodes || [],
          edges: inputAny.edges || []
        };
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          isRevision: input.isRevision,
          revisesThought: input.revisesThought,
          mode: "causal" /* CAUSAL */,
          thoughtType: toExtendedThoughtType(input.thoughtType, "problem_definition"),
          causalGraph,
          interventions: input.interventions || [],
          mechanisms: input.mechanisms || [],
          confounders: input.confounders || []
        };
      }
      /**
       * Validate causal-specific input
       *
       * Performs semantic validation:
       * 1. Basic input validation
       * 2. Causal graph structure validation
       * 3. Cycle detection (warns, doesn't fail - cycles may be intentional feedback loops)
       * 4. Intervention target validation
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        const causalGraph = input.causalGraph || {
          nodes: inputAny.nodes || [],
          edges: inputAny.edges || []
        };
        if (causalGraph.nodes.length > 0 || causalGraph.edges.length > 0) {
          const graphValidation = this.validateCausalGraph(causalGraph);
          errors.push(...graphValidation.errors);
          warnings.push(...graphValidation.warnings);
        }
        if (input.interventions && input.interventions.length > 0) {
          const interventionValidation = this.validateInterventions(
            input.interventions,
            causalGraph
          );
          errors.push(...interventionValidation.errors);
          warnings.push(...interventionValidation.warnings);
        }
        if (causalGraph.edges.length > 0) {
          const cycles = this.detectCycles(causalGraph);
          if (cycles.length > 0) {
            warnings.push(
              createValidationWarning(
                "causalGraph",
                `Detected ${cycles.length} cycle(s) in causal graph: ${cycles.map((c) => c.join(" -> ")).join("; ")}`,
                "Cycles may indicate feedback loops. Verify this is intentional."
              )
            );
          }
        }
        if ((!input.confounders || input.confounders.length === 0) && causalGraph.nodes.length >= 3) {
          warnings.push(
            createValidationWarning(
              "confounders",
              "No confounders specified in the causal model",
              "Consider identifying potential confounders that might affect multiple nodes"
            )
          );
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get causal-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["bayesian" /* BAYESIAN */, "counterfactual" /* COUNTERFACTUAL */],
          guidingQuestions: [],
          warnings: [],
          mentalModels: ["Causal Diagrams", "Do-Calculus", "Structural Equation Models"]
        };
        if (thought.causalGraph) {
          const nodeCount = thought.causalGraph.nodes.length;
          const edgeCount = thought.causalGraph.edges.length;
          if (nodeCount > 0 && edgeCount === 0) {
            enhancements.suggestions.push(
              "Add causal edges to connect your nodes and establish causal relationships"
            );
          }
          if (edgeCount > nodeCount * 2) {
            enhancements.suggestions.push(
              "Graph is densely connected. Consider identifying the most significant causal paths"
            );
          }
          enhancements.metrics = {
            nodeCount,
            edgeCount,
            density: nodeCount > 1 ? edgeCount / (nodeCount * (nodeCount - 1)) : 0
          };
          const entryNodes = this.findEntryNodes(thought.causalGraph);
          const exitNodes = this.findExitNodes(thought.causalGraph);
          if (entryNodes.length > 0) {
            enhancements.guidingQuestions.push(
              `What external factors influence the root causes: ${entryNodes.join(", ")}?`
            );
          }
          if (exitNodes.length > 0) {
            enhancements.guidingQuestions.push(
              `What are the downstream consequences of ${exitNodes.join(", ")}?`
            );
          }
        }
        if (!thought.interventions || thought.interventions.length === 0) {
          enhancements.guidingQuestions.push(
            "What interventions could be tested to verify causal relationships?"
          );
        }
        if (!thought.confounders || thought.confounders.length === 0) {
          enhancements.guidingQuestions.push(
            "Are there any hidden common causes (confounders) that might affect multiple variables?"
          );
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Validate causal graph structure
       */
      validateCausalGraph(graph) {
        const errors = [];
        const warnings = [];
        const nodeIds = new Set(graph.nodes.map((n) => n.id));
        if (nodeIds.size !== graph.nodes.length) {
          errors.push(
            createValidationError(
              "causalGraph.nodes",
              "Duplicate node IDs detected in causal graph",
              "DUPLICATE_NODE_IDS"
            )
          );
        }
        for (const edge of graph.edges) {
          if (!nodeIds.has(edge.from)) {
            errors.push(
              createValidationError(
                "causalGraph.edges",
                `Edge references non-existent source node: ${edge.from}`,
                "INVALID_EDGE_SOURCE"
              )
            );
          }
          if (!nodeIds.has(edge.to)) {
            errors.push(
              createValidationError(
                "causalGraph.edges",
                `Edge references non-existent target node: ${edge.to}`,
                "INVALID_EDGE_TARGET"
              )
            );
          }
          if (edge.strength !== void 0 && (edge.strength < -1 || edge.strength > 1)) {
            warnings.push(
              createValidationWarning(
                "causalGraph.edges",
                `Edge strength ${edge.strength} is outside [-1, 1] range`,
                "Normalize edge strength to [-1, 1] where negative indicates inhibitory effects"
              )
            );
          }
          if (edge.confidence !== void 0 && (edge.confidence < 0 || edge.confidence > 1)) {
            warnings.push(
              createValidationWarning(
                "causalGraph.edges",
                `Edge confidence ${edge.confidence} is outside [0, 1] range`,
                "Confidence should be a probability between 0 and 1"
              )
            );
          }
        }
        const selfLoops = graph.edges.filter((e) => e.from === e.to);
        if (selfLoops.length > 0) {
          warnings.push(
            createValidationWarning(
              "causalGraph.edges",
              `${selfLoops.length} self-loop(s) detected: ${selfLoops.map((e) => e.from).join(", ")}`,
              "Self-loops may indicate self-reinforcing effects. Verify this is intentional."
            )
          );
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Validate interventions reference existing nodes
       */
      validateInterventions(interventions, graph) {
        const errors = [];
        const warnings = [];
        const nodeIds = new Set(graph.nodes.map((n) => n.id));
        for (const intervention of interventions) {
          if (!nodeIds.has(intervention.nodeId)) {
            errors.push(
              createValidationError(
                "interventions",
                `Intervention targets non-existent node: ${intervention.nodeId}`,
                "INVALID_INTERVENTION_TARGET"
              )
            );
          }
          if (intervention.expectedEffects) {
            for (const effect of intervention.expectedEffects) {
              if (!nodeIds.has(effect.nodeId)) {
                warnings.push(
                  createValidationWarning(
                    "interventions.expectedEffects",
                    `Expected effect references non-existent node: ${effect.nodeId}`,
                    "Ensure all expected effect nodes are in the causal graph"
                  )
                );
              }
              if (effect.confidence !== void 0 && (effect.confidence < 0 || effect.confidence > 1)) {
                warnings.push(
                  createValidationWarning(
                    "interventions.expectedEffects",
                    `Effect confidence ${effect.confidence} is outside [0, 1] range`,
                    "Confidence should be a probability between 0 and 1"
                  )
                );
              }
            }
          }
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Detect cycles in the causal graph using DFS
       *
       * Returns list of cycles found, where each cycle is a list of node IDs
       */
      detectCycles(graph) {
        const cycles = [];
        const visited = /* @__PURE__ */ new Set();
        const recursionStack = /* @__PURE__ */ new Set();
        const path4 = [];
        const adjacencyList = /* @__PURE__ */ new Map();
        for (const node of graph.nodes) {
          adjacencyList.set(node.id, []);
        }
        for (const edge of graph.edges) {
          const neighbors = adjacencyList.get(edge.from);
          if (neighbors) {
            neighbors.push(edge.to);
          }
        }
        const dfs = (nodeId) => {
          visited.add(nodeId);
          recursionStack.add(nodeId);
          path4.push(nodeId);
          const neighbors = adjacencyList.get(nodeId) || [];
          for (const neighbor of neighbors) {
            if (!visited.has(neighbor)) {
              dfs(neighbor);
            } else if (recursionStack.has(neighbor)) {
              const cycleStart = path4.indexOf(neighbor);
              const cycle = path4.slice(cycleStart);
              cycle.push(neighbor);
              cycles.push(cycle);
            }
          }
          path4.pop();
          recursionStack.delete(nodeId);
        };
        for (const node of graph.nodes) {
          if (!visited.has(node.id)) {
            dfs(node.id);
          }
        }
        return cycles;
      }
      /**
       * Find entry nodes (nodes with no incoming edges)
       */
      findEntryNodes(graph) {
        const hasIncoming = new Set(graph.edges.map((e) => e.to));
        return graph.nodes.filter((n) => !hasIncoming.has(n.id)).map((n) => n.name || n.id);
      }
      /**
       * Find exit nodes (nodes with no outgoing edges)
       */
      findExitNodes(graph) {
        const hasOutgoing = new Set(graph.edges.map((e) => e.from));
        return graph.nodes.filter((n) => !hasOutgoing.has(n.id)).map((n) => n.name || n.id);
      }
    };
  }
});
var BayesianHandler;
var init_BayesianHandler = __esm({
  "src/modes/handlers/BayesianHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    BayesianHandler = class {
      mode = "bayesian" /* BAYESIAN */;
      modeName = "Bayesian Inference";
      description = "Probabilistic reasoning with Bayes theorem and evidence updates";
      /**
       * Supported thought types for Bayesian mode
       */
      supportedThoughtTypes = [
        "prior_elicitation",
        "likelihood_assessment",
        "posterior_update",
        "evidence_evaluation",
        "sensitivity_analysis",
        "hypothesis_comparison"
      ];
      /**
       * Create a Bayesian thought from input
       *
       * Automatically calculates posterior if prior and likelihood are provided
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const hypothesis = inputAny.hypothesis || {
          id: randomUUID(),
          statement: input.thought,
          alternatives: []
        };
        const prior = {
          probability: inputAny.priorProbability ?? 0.5,
          justification: inputAny.priorJustification || "Default prior"
        };
        const likelihood = {
          probability: inputAny.likelihood ?? 0.5,
          description: inputAny.likelihoodDescription || "Default likelihood"
        };
        const evidence = inputAny.evidence || [];
        const posterior = this.calculatePosterior(prior, likelihood, evidence, inputAny);
        const bayesFactor = this.calculateBayesFactor(evidence);
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          isRevision: input.isRevision,
          revisesThought: input.revisesThought,
          mode: "bayesian" /* BAYESIAN */,
          hypothesis,
          prior,
          likelihood,
          evidence,
          posterior,
          bayesFactor,
          sensitivity: inputAny.sensitivity
        };
      }
      /**
       * Validate Bayesian-specific input
       *
       * Performs semantic validation:
       * 1. Basic input validation
       * 2. Probability value range validation
       * 3. Evidence likelihood ratio validation
       * 4. Consistency checks
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        const priorProb = inputAny.priorProbability;
        if (priorProb !== void 0) {
          const priorValidation = this.validateProbability(priorProb, "priorProbability");
          if (!priorValidation.valid) {
            errors.push(...priorValidation.errors);
          }
          warnings.push(...priorValidation.warnings);
        }
        const likelihoodProb = inputAny.likelihood;
        if (likelihoodProb !== void 0) {
          const likelihoodValidation = this.validateProbability(likelihoodProb, "likelihood");
          if (!likelihoodValidation.valid) {
            errors.push(...likelihoodValidation.errors);
          }
          warnings.push(...likelihoodValidation.warnings);
        }
        const posteriorProb = inputAny.posteriorProbability;
        if (posteriorProb !== void 0) {
          const posteriorValidation = this.validateProbability(posteriorProb, "posteriorProbability");
          if (!posteriorValidation.valid) {
            errors.push(...posteriorValidation.errors);
          }
          warnings.push(...posteriorValidation.warnings);
        }
        if (inputAny.evidence && Array.isArray(inputAny.evidence)) {
          for (let i = 0; i < inputAny.evidence.length; i++) {
            const evidenceItem = inputAny.evidence[i];
            const evidenceValidation = this.validateEvidence(evidenceItem, i);
            if (!evidenceValidation.valid) {
              errors.push(...evidenceValidation.errors);
            }
            warnings.push(...evidenceValidation.warnings);
          }
        }
        if (inputAny.hypothesis?.alternatives) {
          const numAlternatives = inputAny.hypothesis.alternatives.length;
          if (numAlternatives > 0 && priorProb !== void 0) {
            if (priorProb > 0.9 && numAlternatives > 2) {
              warnings.push(
                createValidationWarning(
                  "priorProbability",
                  `High prior probability (${priorProb}) with ${numAlternatives} alternatives`,
                  "Consider whether prior properly reflects uncertainty across alternatives"
                )
              );
            }
          }
        }
        if (!inputAny.evidence || inputAny.evidence.length === 0) {
          warnings.push(
            createValidationWarning(
              "evidence",
              "No evidence provided for Bayesian update",
              "Add evidence with likelihood ratios to update the posterior"
            )
          );
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get Bayesian-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["causal" /* CAUSAL */, "evidential" /* EVIDENTIAL */],
          guidingQuestions: [],
          warnings: [],
          metrics: {},
          mentalModels: ["Bayes Theorem", "Prior Updating", "Likelihood Ratio", "Base Rate Fallacy"]
        };
        enhancements.metrics = {
          priorProbability: thought.prior.probability,
          likelihoodProbability: thought.likelihood.probability,
          posteriorProbability: thought.posterior.probability,
          evidenceCount: thought.evidence.length
        };
        if (thought.bayesFactor !== void 0) {
          enhancements.metrics.bayesFactor = thought.bayesFactor;
          const bf = thought.bayesFactor;
          let strength;
          if (bf < 1) {
            strength = bf < 0.1 ? "Strong evidence against" : bf < 0.33 ? "Moderate evidence against" : "Weak evidence against";
          } else {
            strength = bf > 10 ? "Strong evidence for" : bf > 3 ? "Moderate evidence for" : "Weak evidence for";
          }
          enhancements.suggestions.push(`Bayes factor (${bf.toFixed(2)}) indicates: ${strength} the hypothesis`);
        }
        const shift = Math.abs(thought.posterior.probability - thought.prior.probability);
        if (shift < 0.05) {
          enhancements.suggestions.push(
            "Small prior-to-posterior shift. Consider seeking more diagnostic evidence."
          );
        } else if (shift > 0.4) {
          enhancements.warnings.push(
            "Large belief update. Verify evidence quality and likelihood estimates."
          );
        }
        if (thought.posterior.probability > 0.9) {
          enhancements.guidingQuestions.push(
            "What evidence could potentially disconfirm this high-confidence belief?"
          );
        } else if (thought.posterior.probability < 0.1) {
          enhancements.guidingQuestions.push(
            "What new evidence would be needed to revive this hypothesis?"
          );
        } else {
          enhancements.guidingQuestions.push(
            "What additional evidence could help resolve the remaining uncertainty?"
          );
        }
        if (!thought.sensitivity) {
          enhancements.guidingQuestions.push(
            "How sensitive is the posterior to changes in the prior probability?"
          );
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Calculate posterior probability using Bayes' theorem
       *
       * P(H|E) = P(E|H) * P(H) / P(E)
       * where P(E) = P(E|H) * P(H) + P(E|~H) * P(~H)
       */
      calculatePosterior(prior, likelihood, evidence, inputAny) {
        if (inputAny.posteriorProbability !== void 0) {
          return {
            probability: inputAny.posteriorProbability,
            calculation: "Provided directly",
            confidence: inputAny.posteriorConfidence ?? 0.8
          };
        }
        let currentPosterior = prior.probability;
        if (evidence.length > 0) {
          for (const ev of evidence) {
            const pEgivenH = ev.likelihoodGivenHypothesis;
            const pEgivenNotH = ev.likelihoodGivenNotHypothesis;
            const pE = pEgivenH * currentPosterior + pEgivenNotH * (1 - currentPosterior);
            if (pE > 0) {
              currentPosterior = pEgivenH * currentPosterior / pE;
            }
          }
        } else {
          const pEgivenH = likelihood.probability;
          const pEgivenNotH = 1 - likelihood.probability;
          const pE = pEgivenH * prior.probability + pEgivenNotH * (1 - prior.probability);
          if (pE > 0) {
            currentPosterior = pEgivenH * prior.probability / pE;
          }
        }
        const calculation = evidence.length > 0 ? `Updated through ${evidence.length} evidence items using Bayes theorem` : `P(H|E) = P(E|H)P(H) / [P(E|H)P(H) + P(E|~H)P(~H)]`;
        return {
          probability: Math.max(0, Math.min(1, currentPosterior)),
          // Clamp to [0, 1]
          calculation,
          confidence: this.estimatePosteriorConfidence(evidence)
        };
      }
      /**
       * Calculate Bayes factor from evidence
       *
       * BF =  P(E_i|H) / P(E_i|~H)
       */
      calculateBayesFactor(evidence) {
        if (evidence.length === 0) {
          return void 0;
        }
        let bayesFactor = 1;
        for (const ev of evidence) {
          if (ev.likelihoodGivenNotHypothesis > 0) {
            bayesFactor *= ev.likelihoodGivenHypothesis / ev.likelihoodGivenNotHypothesis;
          }
        }
        return bayesFactor;
      }
      /**
       * Estimate confidence in posterior calculation
       */
      estimatePosteriorConfidence(evidence) {
        if (evidence.length === 0) {
          return 0.5;
        }
        const evidenceContribution = Math.min(0.4, evidence.length * 0.1);
        let qualityScore = 0;
        for (const ev of evidence) {
          const ratio = ev.likelihoodGivenHypothesis / (ev.likelihoodGivenNotHypothesis || 0.01);
          if (ratio > 100 || ratio < 0.01) {
            qualityScore += 0.05;
          } else {
            qualityScore += 0.1;
          }
        }
        const avgQuality = qualityScore / evidence.length;
        return Math.min(0.95, 0.5 + evidenceContribution + avgQuality);
      }
      /**
       * Validate a probability value
       */
      validateProbability(value, field) {
        const errors = [];
        const warnings = [];
        if (typeof value !== "number" || isNaN(value)) {
          errors.push(
            createValidationError(
              field,
              `${field} must be a valid number`,
              "INVALID_PROBABILITY_TYPE"
            )
          );
        } else if (value < 0 || value > 1) {
          errors.push(
            createValidationError(
              field,
              `${field} (${value}) must be between 0 and 1`,
              "PROBABILITY_OUT_OF_RANGE"
            )
          );
        } else if (value === 0 || value === 1) {
          warnings.push(
            createValidationWarning(
              field,
              `Extreme probability value (${value}) leaves no room for updating`,
              "Consider using values slightly away from 0 and 1 (e.g., 0.01 or 0.99)"
            )
          );
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Validate an evidence item
       */
      validateEvidence(evidence, index) {
        const errors = [];
        const warnings = [];
        const prefix = `evidence[${index}]`;
        if (!evidence.id || !evidence.description) {
          warnings.push(
            createValidationWarning(
              prefix,
              "Evidence item missing id or description",
              "Add descriptive id and description for better tracking"
            )
          );
        }
        const pEH = evidence.likelihoodGivenHypothesis;
        if (pEH !== void 0) {
          if (typeof pEH !== "number" || isNaN(pEH)) {
            errors.push(
              createValidationError(
                `${prefix}.likelihoodGivenHypothesis`,
                "Likelihood given hypothesis must be a valid number",
                "INVALID_LIKELIHOOD_TYPE"
              )
            );
          } else if (pEH < 0 || pEH > 1) {
            errors.push(
              createValidationError(
                `${prefix}.likelihoodGivenHypothesis`,
                `Likelihood given hypothesis (${pEH}) must be between 0 and 1`,
                "LIKELIHOOD_OUT_OF_RANGE"
              )
            );
          }
        }
        const pEnH = evidence.likelihoodGivenNotHypothesis;
        if (pEnH !== void 0) {
          if (typeof pEnH !== "number" || isNaN(pEnH)) {
            errors.push(
              createValidationError(
                `${prefix}.likelihoodGivenNotHypothesis`,
                "Likelihood given not hypothesis must be a valid number",
                "INVALID_LIKELIHOOD_TYPE"
              )
            );
          } else if (pEnH < 0 || pEnH > 1) {
            errors.push(
              createValidationError(
                `${prefix}.likelihoodGivenNotHypothesis`,
                `Likelihood given not hypothesis (${pEnH}) must be between 0 and 1`,
                "LIKELIHOOD_OUT_OF_RANGE"
              )
            );
          }
        }
        if (pEH !== void 0 && pEnH !== void 0 && Math.abs(pEH - pEnH) < 0.1) {
          warnings.push(
            createValidationWarning(
              prefix,
              `Evidence has low diagnostic value (P(E|H)=${pEH}, P(E|~H)=${pEnH})`,
              "Evidence is more useful when likelihood ratios differ significantly"
            )
          );
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
    };
  }
});
var GameTheoryHandler;
var init_GameTheoryHandler = __esm({
  "src/modes/handlers/GameTheoryHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    GameTheoryHandler = class {
      mode = "gametheory" /* GAMETHEORY */;
      modeName = "Game Theory";
      description = "Strategic interaction analysis with Nash equilibria and payoff matrices";
      /**
       * Supported thought types for game theory mode
       */
      supportedThoughtTypes = [
        "game_definition",
        "strategy_analysis",
        "equilibrium_finding",
        "payoff_computation",
        "dominance_analysis",
        "minimax_analysis",
        "cooperative_analysis",
        "coalition_formation",
        "shapley_value",
        "core_analysis"
      ];
      /**
       * Create a game theory thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const game = inputAny.game;
        const players = inputAny.players || [];
        const strategies = inputAny.strategies || [];
        const payoffMatrix = inputAny.payoffMatrix;
        let nashEquilibria = inputAny.nashEquilibria;
        if (!nashEquilibria && payoffMatrix && players.length > 0) {
          nashEquilibria = this.findPureStrategyNashEquilibria(payoffMatrix, players, strategies);
        }
        let dominantStrategies = inputAny.dominantStrategies;
        if (!dominantStrategies && payoffMatrix && players.length > 0) {
          dominantStrategies = this.findDominantStrategies(payoffMatrix, players, strategies);
        }
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          isRevision: input.isRevision,
          revisesThought: input.revisesThought,
          mode: "gametheory" /* GAMETHEORY */,
          thoughtType: this.resolveThoughtType(input.thoughtType),
          game,
          players,
          strategies,
          payoffMatrix,
          nashEquilibria,
          dominantStrategies,
          gameTree: inputAny.gameTree,
          minimaxAnalysis: inputAny.minimaxAnalysis,
          cooperativeGame: inputAny.cooperativeGame,
          coalitionAnalysis: inputAny.coalitionAnalysis
        };
      }
      /**
       * Validate game theory-specific input
       *
       * Performs semantic validation:
       * 1. Basic input validation
       * 2. Payoff matrix dimension validation
       * 3. Player-strategy consistency
       * 4. Payoff value validation
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        const players = inputAny.players || [];
        const strategies = inputAny.strategies || [];
        const payoffMatrix = inputAny.payoffMatrix;
        if (players.length > 0) {
          const playerValidation = this.validatePlayers(players, strategies);
          if (!playerValidation.valid) {
            errors.push(...playerValidation.errors);
          }
          warnings.push(...playerValidation.warnings);
        }
        if (strategies.length > 0) {
          const strategyValidation = this.validateStrategies(strategies, players);
          if (!strategyValidation.valid) {
            errors.push(...strategyValidation.errors);
          }
          warnings.push(...strategyValidation.warnings);
        }
        if (payoffMatrix) {
          const matrixValidation = this.validatePayoffMatrix(payoffMatrix, players, strategies);
          if (!matrixValidation.valid) {
            errors.push(...matrixValidation.errors);
          }
          warnings.push(...matrixValidation.warnings);
        }
        if (players.length === 0 && !payoffMatrix) {
          warnings.push(
            createValidationWarning(
              "players",
              "No players or payoff matrix defined",
              "Define players and their strategies for game theory analysis"
            )
          );
        }
        const game = inputAny.game;
        if (!game && players.length > 0) {
          warnings.push(
            createValidationWarning(
              "game",
              "No formal game definition provided",
              "Consider adding a Game object with type, name, and properties"
            )
          );
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get game theory-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["optimization" /* OPTIMIZATION */, "counterfactual" /* COUNTERFACTUAL */],
          guidingQuestions: [],
          warnings: [],
          metrics: {},
          mentalModels: [
            "Nash Equilibrium",
            "Dominant Strategy",
            "Pareto Efficiency",
            "Minimax Theorem",
            "Prisoner's Dilemma"
          ]
        };
        if (thought.players) {
          enhancements.metrics.playerCount = thought.players.length;
        }
        if (thought.strategies) {
          enhancements.metrics.strategyCount = thought.strategies.length;
        }
        if (thought.payoffMatrix) {
          enhancements.metrics.payoffEntries = thought.payoffMatrix.payoffs.length;
          const isZeroSum = this.isZeroSumGame(thought.payoffMatrix);
          enhancements.metrics.isZeroSum = isZeroSum ? 1 : 0;
          if (isZeroSum) {
            enhancements.suggestions.push(
              "This is a zero-sum game. Consider minimax strategies."
            );
            enhancements.relatedModes.unshift("optimization" /* OPTIMIZATION */);
          }
        }
        if (thought.nashEquilibria && thought.nashEquilibria.length > 0) {
          enhancements.metrics.nashEquilibriaCount = thought.nashEquilibria.length;
          if (thought.nashEquilibria.length > 1) {
            enhancements.suggestions.push(
              `Multiple Nash equilibria found (${thought.nashEquilibria.length}). Consider coordination mechanisms or focal points.`
            );
            enhancements.guidingQuestions.push(
              "Which equilibrium is most likely to emerge? Are there Schelling focal points?"
            );
          }
          const paretoOptimal = this.checkParetoOptimality(thought.nashEquilibria, thought.payoffMatrix);
          if (!paretoOptimal) {
            enhancements.warnings.push(
              "Nash equilibrium may not be Pareto optimal (like in Prisoner's Dilemma)"
            );
            enhancements.guidingQuestions.push(
              "Is there a mechanism to achieve a Pareto-superior outcome through cooperation?"
            );
          }
        } else if (thought.payoffMatrix) {
          enhancements.suggestions.push(
            "No pure strategy Nash equilibria found. Consider mixed strategies."
          );
          enhancements.guidingQuestions.push(
            "What are the optimal mixed strategy probabilities for each player?"
          );
        }
        if (thought.dominantStrategies && thought.dominantStrategies.length > 0) {
          enhancements.metrics.dominantStrategyCount = thought.dominantStrategies.length;
          enhancements.suggestions.push(
            `${thought.dominantStrategies.length} dominant strategy(ies) identified. These simplify equilibrium analysis.`
          );
        }
        if (thought.game) {
          if (thought.game.type === "cooperative") {
            enhancements.guidingQuestions.push(
              "What coalitions might form? How should payoffs be divided fairly?"
            );
            enhancements.mentalModels.push("Shapley Value", "Core", "Coalition Formation");
          } else if (thought.game.type === "extensive_form") {
            enhancements.guidingQuestions.push(
              "What is the subgame perfect equilibrium? Use backward induction."
            );
            enhancements.mentalModels.push("Backward Induction", "Subgame Perfect Equilibrium");
          }
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Resolve input thought type to valid GameTheory thought type
       */
      resolveThoughtType(inputType) {
        if (inputType && this.supportedThoughtTypes.includes(inputType)) {
          return inputType;
        }
        return "game_definition";
      }
      /**
       * Validate players array
       */
      validatePlayers(players, strategies) {
        const errors = [];
        const warnings = [];
        const playerIds = /* @__PURE__ */ new Set();
        for (const player of players) {
          if (playerIds.has(player.id)) {
            errors.push(
              createValidationError(
                "players",
                `Duplicate player ID: ${player.id}`,
                "DUPLICATE_PLAYER_ID"
              )
            );
          }
          playerIds.add(player.id);
          if (!player.availableStrategies || player.availableStrategies.length === 0) {
            warnings.push(
              createValidationWarning(
                `players.${player.id}`,
                `Player ${player.name || player.id} has no available strategies`,
                "Define available strategies for meaningful game analysis"
              )
            );
          } else {
            for (const stratId of player.availableStrategies) {
              const strategyExists = strategies.some((s) => s.id === stratId);
              if (!strategyExists && strategies.length > 0) {
                errors.push(
                  createValidationError(
                    `players.${player.id}.availableStrategies`,
                    `Player references non-existent strategy: ${stratId}`,
                    "INVALID_STRATEGY_REFERENCE"
                  )
                );
              }
            }
          }
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Validate strategies array
       */
      validateStrategies(strategies, players) {
        const errors = [];
        const warnings = [];
        const strategyIds = /* @__PURE__ */ new Set();
        const playerIds = new Set(players.map((p) => p.id));
        for (const strategy of strategies) {
          if (strategyIds.has(strategy.id)) {
            errors.push(
              createValidationError(
                "strategies",
                `Duplicate strategy ID: ${strategy.id}`,
                "DUPLICATE_STRATEGY_ID"
              )
            );
          }
          strategyIds.add(strategy.id);
          if (strategy.playerId && !playerIds.has(strategy.playerId) && players.length > 0) {
            errors.push(
              createValidationError(
                `strategies.${strategy.id}`,
                `Strategy references non-existent player: ${strategy.playerId}`,
                "INVALID_PLAYER_REFERENCE"
              )
            );
          }
          if (!strategy.isPure && strategy.probability !== void 0) {
            if (strategy.probability < 0 || strategy.probability > 1) {
              errors.push(
                createValidationError(
                  `strategies.${strategy.id}.probability`,
                  `Mixed strategy probability (${strategy.probability}) must be between 0 and 1`,
                  "INVALID_PROBABILITY"
                )
              );
            }
          }
        }
        for (const player of players) {
          const playerStrategies = strategies.filter((s) => s.playerId === player.id && !s.isPure);
          if (playerStrategies.length > 0) {
            const probSum = playerStrategies.reduce((sum, s) => sum + (s.probability || 0), 0);
            if (Math.abs(probSum - 1) > 1e-3) {
              warnings.push(
                createValidationWarning(
                  `strategies`,
                  `Mixed strategy probabilities for player ${player.id} sum to ${probSum.toFixed(3)}, not 1`,
                  "Ensure mixed strategy probabilities sum to exactly 1"
                )
              );
            }
          }
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Validate payoff matrix
       */
      validatePayoffMatrix(matrix, _players, strategies) {
        const errors = [];
        const warnings = [];
        if (matrix.players.length !== matrix.dimensions.length) {
          errors.push(
            createValidationError(
              "payoffMatrix",
              `Player count (${matrix.players.length}) doesn't match dimension count (${matrix.dimensions.length})`,
              "DIMENSION_MISMATCH"
            )
          );
        }
        const expectedEntries = matrix.dimensions.reduce((a, b) => a * b, 1);
        if (matrix.payoffs.length !== expectedEntries) {
          warnings.push(
            createValidationWarning(
              "payoffMatrix.payoffs",
              `Expected ${expectedEntries} payoff entries based on dimensions, got ${matrix.payoffs.length}`,
              "Ensure all strategy combinations have payoff entries"
            )
          );
        }
        for (let i = 0; i < matrix.payoffs.length; i++) {
          const entry = matrix.payoffs[i];
          if (entry.strategyProfile.length !== matrix.players.length) {
            errors.push(
              createValidationError(
                `payoffMatrix.payoffs[${i}]`,
                `Strategy profile has ${entry.strategyProfile.length} strategies, expected ${matrix.players.length}`,
                "INVALID_STRATEGY_PROFILE"
              )
            );
          }
          if (entry.payoffs.length !== matrix.players.length) {
            errors.push(
              createValidationError(
                `payoffMatrix.payoffs[${i}]`,
                `Payoff entry has ${entry.payoffs.length} values, expected ${matrix.players.length}`,
                "INVALID_PAYOFF_COUNT"
              )
            );
          }
          for (const stratId of entry.strategyProfile) {
            const strategyExists = strategies.some((s) => s.id === stratId);
            if (!strategyExists && strategies.length > 0) {
              errors.push(
                createValidationError(
                  `payoffMatrix.payoffs[${i}].strategyProfile`,
                  `Payoff entry references non-existent strategy: ${stratId}`,
                  "INVALID_STRATEGY_REFERENCE"
                )
              );
            }
          }
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Find pure strategy Nash equilibria
       *
       * A strategy profile is a Nash equilibrium if no player can
       * improve their payoff by unilaterally changing their strategy.
       */
      findPureStrategyNashEquilibria(matrix, players, strategies) {
        const equilibria = [];
        if (matrix.players.length !== 2 || matrix.dimensions.length !== 2) {
          return equilibria;
        }
        for (const entry of matrix.payoffs) {
          if (this.isNashEquilibrium(entry, matrix, players, strategies)) {
            equilibria.push({
              id: randomUUID(),
              strategyProfile: entry.strategyProfile,
              payoffs: entry.payoffs,
              type: "pure",
              isStrict: this.isStrictEquilibrium(entry, matrix, players, strategies),
              stability: this.calculateEquilibriumStability(entry, matrix, players, strategies)
            });
          }
        }
        return equilibria;
      }
      /**
       * Check if a strategy profile is a Nash equilibrium
       */
      isNashEquilibrium(entry, matrix, _players, _strategies) {
        for (let playerIdx = 0; playerIdx < matrix.players.length; playerIdx++) {
          const currentPayoff = entry.payoffs[playerIdx];
          for (const altEntry of matrix.payoffs) {
            let onlyThisPlayerDiffers = true;
            for (let i = 0; i < matrix.players.length; i++) {
              if (i === playerIdx) {
                if (altEntry.strategyProfile[i] === entry.strategyProfile[i]) {
                  onlyThisPlayerDiffers = false;
                  break;
                }
              } else {
                if (altEntry.strategyProfile[i] !== entry.strategyProfile[i]) {
                  onlyThisPlayerDiffers = false;
                  break;
                }
              }
            }
            if (onlyThisPlayerDiffers && altEntry.payoffs[playerIdx] > currentPayoff) {
              return false;
            }
          }
        }
        return true;
      }
      /**
       * Check if equilibrium is strict (strictly better than all deviations)
       */
      isStrictEquilibrium(entry, matrix, _players, _strategies) {
        for (let playerIdx = 0; playerIdx < matrix.players.length; playerIdx++) {
          const currentPayoff = entry.payoffs[playerIdx];
          for (const altEntry of matrix.payoffs) {
            let onlyThisPlayerDiffers = true;
            for (let i = 0; i < matrix.players.length; i++) {
              if (i === playerIdx) {
                if (altEntry.strategyProfile[i] === entry.strategyProfile[i]) {
                  onlyThisPlayerDiffers = false;
                  break;
                }
              } else {
                if (altEntry.strategyProfile[i] !== entry.strategyProfile[i]) {
                  onlyThisPlayerDiffers = false;
                  break;
                }
              }
            }
            if (onlyThisPlayerDiffers && altEntry.payoffs[playerIdx] >= currentPayoff) {
              return false;
            }
          }
        }
        return true;
      }
      /**
       * Calculate equilibrium stability score
       */
      calculateEquilibriumStability(entry, matrix, _players, _strategies) {
        let totalPenalty = 0;
        let deviationCount = 0;
        for (let playerIdx = 0; playerIdx < matrix.players.length; playerIdx++) {
          const currentPayoff = entry.payoffs[playerIdx];
          for (const altEntry of matrix.payoffs) {
            let onlyThisPlayerDiffers = true;
            for (let i = 0; i < matrix.players.length; i++) {
              if (i === playerIdx) {
                if (altEntry.strategyProfile[i] === entry.strategyProfile[i]) {
                  onlyThisPlayerDiffers = false;
                  break;
                }
              } else {
                if (altEntry.strategyProfile[i] !== entry.strategyProfile[i]) {
                  onlyThisPlayerDiffers = false;
                  break;
                }
              }
            }
            if (onlyThisPlayerDiffers) {
              totalPenalty += currentPayoff - altEntry.payoffs[playerIdx];
              deviationCount++;
            }
          }
        }
        const avgPenalty = deviationCount > 0 ? totalPenalty / deviationCount : 0;
        return Math.min(1, Math.max(0, 0.5 + avgPenalty / 10));
      }
      /**
       * Find dominant strategies
       */
      findDominantStrategies(matrix, players, strategies) {
        const dominantStrategies = [];
        if (matrix.players.length !== 2) {
          return dominantStrategies;
        }
        for (let playerIdx = 0; playerIdx < players.length; playerIdx++) {
          const player = players[playerIdx];
          const playerStrategies = strategies.filter((s) => s.playerId === player.id);
          for (const strategy of playerStrategies) {
            const dominates = this.checkDominance(strategy, playerIdx, matrix, playerStrategies);
            if (dominates.length > 0) {
              dominantStrategies.push({
                playerId: player.id,
                strategyId: strategy.id,
                type: dominates.length === playerStrategies.length - 1 ? "strictly_dominant" : "weakly_dominant",
                dominatesStrategies: dominates,
                justification: `Strategy ${strategy.name || strategy.id} dominates: ${dominates.join(", ")}`
              });
            }
          }
        }
        return dominantStrategies;
      }
      /**
       * Check which strategies a given strategy dominates
       */
      checkDominance(strategy, playerIdx, matrix, playerStrategies) {
        const dominates = [];
        for (const otherStrategy of playerStrategies) {
          if (otherStrategy.id === strategy.id) continue;
          let dominatesAll = true;
          const strategyPayoffs = /* @__PURE__ */ new Map();
          const otherPayoffs = /* @__PURE__ */ new Map();
          for (const entry of matrix.payoffs) {
            const key = entry.strategyProfile.filter((_, i) => i !== playerIdx).join("-");
            if (entry.strategyProfile[playerIdx] === strategy.id) {
              strategyPayoffs.set(key, entry.payoffs[playerIdx]);
            }
            if (entry.strategyProfile[playerIdx] === otherStrategy.id) {
              otherPayoffs.set(key, entry.payoffs[playerIdx]);
            }
          }
          for (const [key, payoff] of strategyPayoffs) {
            const otherPayoff = otherPayoffs.get(key);
            if (otherPayoff !== void 0 && payoff <= otherPayoff) {
              dominatesAll = false;
              break;
            }
          }
          if (dominatesAll && strategyPayoffs.size > 0) {
            dominates.push(otherStrategy.id);
          }
        }
        return dominates;
      }
      /**
       * Check if game is zero-sum
       */
      isZeroSumGame(matrix) {
        if (matrix.players.length !== 2) {
          return false;
        }
        for (const entry of matrix.payoffs) {
          const sum = entry.payoffs.reduce((a, b) => a + b, 0);
          if (Math.abs(sum) > 1e-3) {
            return false;
          }
        }
        return true;
      }
      /**
       * Check if Nash equilibria are Pareto optimal
       */
      checkParetoOptimality(equilibria, matrix) {
        if (!matrix || equilibria.length === 0) {
          return true;
        }
        for (const eq of equilibria) {
          for (const entry of matrix.payoffs) {
            let paretoDominates = true;
            let strictlyBetter = false;
            for (let i = 0; i < entry.payoffs.length; i++) {
              if (entry.payoffs[i] < eq.payoffs[i]) {
                paretoDominates = false;
                break;
              }
              if (entry.payoffs[i] > eq.payoffs[i]) {
                strictlyBetter = true;
              }
            }
            if (paretoDominates && strictlyBetter) {
              return false;
            }
          }
        }
        return true;
      }
    };
  }
});
var CounterfactualHandler;
var init_CounterfactualHandler = __esm({
  "src/modes/handlers/CounterfactualHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    CounterfactualHandler = class {
      mode = "counterfactual" /* COUNTERFACTUAL */;
      modeName = "Counterfactual Analysis";
      description = "What-if analysis with world state tracking and divergence point identification";
      /**
       * Supported thought types for counterfactual mode
       */
      supportedThoughtTypes = [
        "problem_definition",
        "scenario_construction",
        "divergence_analysis",
        "outcome_comparison",
        "intervention_identification",
        "causal_chain_analysis"
      ];
      /**
       * Create a counterfactual thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const actual = inputAny.actual || {
          id: randomUUID().slice(0, 8),
          name: "Actual Scenario",
          description: "",
          conditions: inputAny.actualConditions || [],
          outcomes: inputAny.actualOutcomes || []
        };
        const counterfactuals = inputAny.counterfactuals || [];
        const comparison = inputAny.comparison || {
          differences: [],
          insights: [],
          lessons: []
        };
        const interventionPoint = inputAny.interventionPoint || {
          description: "",
          timing: "",
          feasibility: 0.5,
          expectedImpact: 0.5
        };
        const thought = {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          isRevision: input.isRevision,
          revisesThought: input.revisesThought,
          mode: "counterfactual" /* COUNTERFACTUAL */,
          actual,
          counterfactuals,
          comparison,
          interventionPoint,
          causalChains: inputAny.causalChains || []
        };
        return thought;
      }
      /**
       * Validate counterfactual-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        if (inputAny.actual) {
          const actualValidation = this.validateScenario(inputAny.actual, "actual");
          errors.push(...actualValidation.errors);
          warnings.push(...actualValidation.warnings);
        }
        if (inputAny.counterfactuals && Array.isArray(inputAny.counterfactuals)) {
          for (let i = 0; i < inputAny.counterfactuals.length; i++) {
            const cf = inputAny.counterfactuals[i];
            const cfValidation = this.validateScenario(cf, `counterfactuals[${i}]`);
            errors.push(...cfValidation.errors);
            warnings.push(...cfValidation.warnings);
            if (cf.conditions && Array.isArray(cf.conditions)) {
              const hasIntervention = cf.conditions.some((c) => c.isIntervention === true);
              if (!hasIntervention) {
                warnings.push(
                  createValidationWarning(
                    `counterfactuals[${i}]`,
                    "Counterfactual scenario has no conditions marked as interventions",
                    "Mark changed conditions with isIntervention: true to track divergence points"
                  )
                );
              }
            }
          }
          if (inputAny.counterfactuals.length === 0 && inputAny.actual) {
            warnings.push(
              createValidationWarning(
                "counterfactuals",
                "No counterfactual scenarios provided",
                "Add alternative scenarios to explore what-if possibilities"
              )
            );
          }
        }
        if (inputAny.interventionPoint) {
          const ipValidation = this.validateInterventionPoint(inputAny.interventionPoint);
          errors.push(...ipValidation.errors);
          warnings.push(...ipValidation.warnings);
        }
        if (inputAny.causalChains && Array.isArray(inputAny.causalChains)) {
          for (let i = 0; i < inputAny.causalChains.length; i++) {
            const chain = inputAny.causalChains[i];
            const chainValidation = this.validateCausalChain(chain, i);
            errors.push(...chainValidation.errors);
            warnings.push(...chainValidation.warnings);
          }
        }
        if (inputAny.comparison) {
          const compValidation = this.validateComparison(inputAny.comparison);
          warnings.push(...compValidation.warnings);
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get counterfactual-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["causal" /* CAUSAL */, "bayesian" /* BAYESIAN */, "temporal" /* TEMPORAL */],
          guidingQuestions: [],
          warnings: [],
          mentalModels: ["Possible Worlds", "Nearest World Semantics", "Intervention Calculus"]
        };
        const actualConditions = thought.actual?.conditions?.length || 0;
        const counterfactualCount = thought.counterfactuals?.length || 0;
        const totalInterventions = this.countInterventions(thought);
        enhancements.metrics = {
          actualConditions,
          counterfactualCount,
          totalInterventions,
          comparisonDepth: this.calculateComparisonDepth(thought.comparison)
        };
        if (counterfactualCount === 0) {
          enhancements.suggestions.push(
            "Define at least one counterfactual scenario to explore alternatives"
          );
        } else if (counterfactualCount === 1) {
          enhancements.suggestions.push(
            "Consider adding more counterfactual scenarios to explore the decision space"
          );
        }
        if (totalInterventions === 0 && counterfactualCount > 0) {
          enhancements.suggestions.push(
            "Mark which conditions were changed from actual using isIntervention: true"
          );
        }
        if (thought.actual && thought.actual.outcomes && thought.actual.outcomes.length > 0) {
          enhancements.guidingQuestions.push(
            "What single change would have most altered the actual outcome?"
          );
        }
        if (thought.interventionPoint && thought.interventionPoint.description) {
          enhancements.guidingQuestions.push(
            `Is the intervention point "${thought.interventionPoint.description}" the earliest possible point of change?`
          );
        }
        if (!thought.causalChains || thought.causalChains.length === 0) {
          enhancements.guidingQuestions.push(
            "What causal chain led from conditions to outcome?"
          );
        }
        if (thought.comparison) {
          if (thought.comparison.insights.length === 0) {
            enhancements.warnings.push(
              "No insights extracted from comparison. What did the counterfactual analysis reveal?"
            );
          }
          if (thought.comparison.lessons.length === 0) {
            enhancements.guidingQuestions.push(
              "What actionable lessons can be drawn from this counterfactual analysis?"
            );
          }
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Validate a scenario
       */
      validateScenario(scenario, path4) {
        const errors = [];
        const warnings = [];
        if (!scenario.name || scenario.name.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              `${path4}.name`,
              "Scenario has no name",
              "Add a descriptive name to identify the scenario"
            )
          );
        }
        if (scenario.conditions && Array.isArray(scenario.conditions)) {
          for (let i = 0; i < scenario.conditions.length; i++) {
            const condition = scenario.conditions[i];
            if (!condition.factor || condition.factor.trim().length === 0) {
              warnings.push(
                createValidationWarning(
                  `${path4}.conditions[${i}].factor`,
                  "Condition has no factor specified",
                  "Each condition should identify what factor is being set"
                )
              );
            }
          }
        }
        if (scenario.outcomes && scenario.outcomes.length > 0) {
          for (let i = 0; i < scenario.outcomes.length; i++) {
            const outcome = scenario.outcomes[i];
            if (outcome.magnitude !== void 0) {
              const magnitude = outcome.magnitude;
              if (magnitude < 0 || magnitude > 1) {
                warnings.push(
                  createValidationWarning(
                    `${path4}.outcomes[${i}].magnitude`,
                    `Outcome magnitude ${magnitude} is outside [0, 1] range`,
                    "Magnitude should be normalized to [0, 1]"
                  )
                );
              }
            }
          }
        }
        if (scenario.likelihood !== void 0) {
          if (scenario.likelihood < 0 || scenario.likelihood > 1) {
            warnings.push(
              createValidationWarning(
                `${path4}.likelihood`,
                `Scenario likelihood ${scenario.likelihood} is outside [0, 1] range`,
                "Likelihood must be between 0 and 1"
              )
            );
          }
        }
        return errors.length > 0 ? validationFailure(errors, warnings) : validationSuccess(warnings);
      }
      /**
       * Validate intervention point
       */
      validateInterventionPoint(ip) {
        const warnings = [];
        if (ip.feasibility !== void 0) {
          if (ip.feasibility < 0 || ip.feasibility > 1) {
            warnings.push(
              createValidationWarning(
                "interventionPoint.feasibility",
                `Feasibility ${ip.feasibility} is outside [0, 1] range`,
                "Feasibility should be a probability between 0 and 1"
              )
            );
          }
        }
        if (ip.expectedImpact !== void 0) {
          if (ip.expectedImpact < 0 || ip.expectedImpact > 1) {
            warnings.push(
              createValidationWarning(
                "interventionPoint.expectedImpact",
                `Expected impact ${ip.expectedImpact} is outside [0, 1] range`,
                "Expected impact should be normalized to [0, 1]"
              )
            );
          }
        }
        if (!ip.description || ip.description.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              "interventionPoint.description",
              "Intervention point has no description",
              "Describe what intervention would be made at this point"
            )
          );
        }
        if (!ip.timing || ip.timing.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              "interventionPoint.timing",
              "Intervention point has no timing specified",
              "Specify when the intervention would occur"
            )
          );
        }
        return validationSuccess(warnings);
      }
      /**
       * Validate causal chain
       */
      validateCausalChain(chain, index) {
        const errors = [];
        const warnings = [];
        if (!chain.id || chain.id.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              `causalChains[${index}].id`,
              "Causal chain has no ID",
              "Add an ID to track the causal chain"
            )
          );
        }
        if (!chain.events || chain.events.length === 0) {
          warnings.push(
            createValidationWarning(
              `causalChains[${index}].events`,
              "Causal chain has no events",
              "Add events to show the causal sequence"
            )
          );
        } else if (chain.events.length < 2) {
          warnings.push(
            createValidationWarning(
              `causalChains[${index}].events`,
              "Causal chain has only one event",
              "A causal chain should have at least two events to show causation"
            )
          );
        }
        if (!chain.branchingPoint || chain.branchingPoint.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              `causalChains[${index}].branchingPoint`,
              "Causal chain has no branching point",
              "Identify where actual and counterfactual paths diverge"
            )
          );
        }
        return errors.length > 0 ? validationFailure(errors, warnings) : validationSuccess(warnings);
      }
      /**
       * Validate comparison
       */
      validateComparison(comparison) {
        const warnings = [];
        if (!comparison.differences || comparison.differences.length === 0) {
          warnings.push(
            createValidationWarning(
              "comparison.differences",
              "No differences identified between scenarios",
              "List key differences between actual and counterfactual scenarios"
            )
          );
        }
        return validationSuccess(warnings);
      }
      /**
       * Count total interventions across all counterfactual scenarios
       */
      countInterventions(thought) {
        let count = 0;
        if (thought.counterfactuals) {
          for (const cf of thought.counterfactuals) {
            if (cf.conditions) {
              count += cf.conditions.filter((c) => c.isIntervention === true).length;
            }
          }
        }
        return count;
      }
      /**
       * Calculate comparison depth based on fields populated
       */
      calculateComparisonDepth(comparison) {
        if (!comparison) return 0;
        let depth = 0;
        if (comparison.differences && comparison.differences.length > 0) depth++;
        if (comparison.insights && comparison.insights.length > 0) depth++;
        if (comparison.lessons && comparison.lessons.length > 0) depth++;
        return depth;
      }
    };
  }
});
var SynthesisHandler;
var init_SynthesisHandler = __esm({
  "src/modes/handlers/SynthesisHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    SynthesisHandler = class {
      mode = "synthesis" /* SYNTHESIS */;
      modeName = "Literature Synthesis";
      description = "Multi-source synthesis with theme extraction, contradiction detection, and gap analysis";
      /**
       * Supported thought types for synthesis mode
       */
      supportedThoughtTypes = [
        "source_identification",
        "source_evaluation",
        "theme_extraction",
        "pattern_integration",
        "gap_identification",
        "synthesis_construction",
        "framework_development"
      ];
      /**
       * Create a synthesis thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const thoughtType = this.resolveThoughtType(inputAny.thoughtType);
        let contradictions = inputAny.contradictions || [];
        if (contradictions.length === 0 && inputAny.sources && inputAny.sources.length > 1) {
          contradictions = this.detectPotentialContradictions(inputAny.sources, inputAny.themes);
        }
        const sourceCoverage = this.calculateSourceCoverage(
          inputAny.sources || [],
          inputAny.themes || []
        );
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          isRevision: input.isRevision,
          revisesThought: input.revisesThought,
          mode: "synthesis" /* SYNTHESIS */,
          thoughtType,
          sources: inputAny.sources || [],
          reviewMetadata: inputAny.reviewMetadata,
          concepts: inputAny.concepts || [],
          themes: inputAny.themes || [],
          findings: inputAny.findings || [],
          patterns: inputAny.patterns || [],
          relations: inputAny.relations || [],
          gaps: inputAny.gaps || [],
          contradictions,
          framework: inputAny.framework,
          conclusions: inputAny.conclusions || [],
          dependencies: inputAny.dependencies || [],
          assumptions: inputAny.assumptions || [],
          uncertainty: inputAny.uncertainty ?? 0.5,
          keyInsight: inputAny.keyInsight,
          // Store calculated metrics in a way accessible to enhancements
          _sourceCoverage: sourceCoverage
        };
      }
      /**
       * Validate synthesis-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        if (inputAny.sources && Array.isArray(inputAny.sources)) {
          const sourceIds = /* @__PURE__ */ new Set();
          for (let i = 0; i < inputAny.sources.length; i++) {
            const source = inputAny.sources[i];
            const sourceValidation = this.validateSource(source, i, sourceIds);
            errors.push(...sourceValidation.errors);
            warnings.push(...sourceValidation.warnings);
            if (source.id) sourceIds.add(source.id);
          }
          if (sourceIds.size !== inputAny.sources.filter((s) => s.id).length) {
            errors.push(
              createValidationError(
                "sources",
                "Duplicate source IDs detected",
                "DUPLICATE_SOURCE_IDS"
              )
            );
          }
          if (inputAny.themes && Array.isArray(inputAny.themes)) {
            for (let i = 0; i < inputAny.themes.length; i++) {
              const theme = inputAny.themes[i];
              const themeValidation = this.validateTheme(theme, i, sourceIds);
              errors.push(...themeValidation.errors);
              warnings.push(...themeValidation.warnings);
            }
          }
          if (inputAny.contradictions && Array.isArray(inputAny.contradictions)) {
            for (let i = 0; i < inputAny.contradictions.length; i++) {
              const contradiction = inputAny.contradictions[i];
              const contValidation = this.validateContradiction(contradiction, i, sourceIds);
              errors.push(...contValidation.errors);
              warnings.push(...contValidation.warnings);
            }
          }
          if (inputAny.sources.length === 1) {
            warnings.push(
              createValidationWarning(
                "sources",
                "Only one source provided",
                "Synthesis typically requires multiple sources for meaningful integration"
              )
            );
          }
        }
        if (inputAny.gaps && Array.isArray(inputAny.gaps) && inputAny.themes) {
          const themeIds = new Set(inputAny.themes.map((t) => t.id).filter(Boolean));
          for (let i = 0; i < inputAny.gaps.length; i++) {
            const gap = inputAny.gaps[i];
            if (gap.relatedThemes) {
              for (const themeId of gap.relatedThemes) {
                if (!themeIds.has(themeId)) {
                  warnings.push(
                    createValidationWarning(
                      `gaps[${i}].relatedThemes`,
                      `Gap references non-existent theme: ${themeId}`,
                      "Ensure all gap theme references exist in themes array"
                    )
                  );
                }
              }
            }
          }
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get synthesis-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["critique" /* CRITIQUE */, "argumentation" /* ARGUMENTATION */, "analysis" /* ANALYSIS */],
          guidingQuestions: [],
          warnings: [],
          mentalModels: [
            "Thematic Analysis",
            "Systematic Review",
            "Conceptual Framework",
            "Evidence Synthesis"
          ]
        };
        const sourceCount = thought.sources?.length || 0;
        const themeCount = thought.themes?.length || 0;
        const contradictionCount = thought.contradictions?.length || 0;
        const gapCount = thought.gaps?.length || 0;
        const coverage = this.calculateSourceCoverage(
          thought.sources || [],
          thought.themes || []
        );
        enhancements.metrics = {
          sourceCount,
          themeCount,
          contradictionCount,
          gapCount,
          sourceCoverage: coverage.coverageRatio,
          uncoveredSources: coverage.uncoveredSources.length
        };
        if (sourceCount === 0) {
          enhancements.suggestions.push(
            "Add sources to synthesize. Include bibliographic details and quality assessments."
          );
        } else if (sourceCount < 5) {
          enhancements.suggestions.push(
            "Consider adding more sources for comprehensive synthesis (typically 10+ for reviews)"
          );
        }
        if (sourceCount >= 2 && themeCount === 0) {
          enhancements.suggestions.push(
            "Extract common themes across your sources to begin synthesis"
          );
        }
        if (coverage.uncoveredSources.length > 0) {
          enhancements.warnings.push(
            `${coverage.uncoveredSources.length} source(s) not referenced in any theme: consider their contribution`
          );
        }
        if (sourceCount >= 3 && contradictionCount === 0) {
          enhancements.guidingQuestions.push(
            "Are there any disagreements or contradictions between sources?"
          );
        }
        if (themeCount >= 2 && gapCount === 0) {
          enhancements.guidingQuestions.push(
            "What gaps exist in the current literature? What questions remain unanswered?"
          );
        }
        const weakConsensus = (thought.themes || []).filter(
          (t) => t.consensus === "weak" || t.consensus === "contested"
        );
        if (weakConsensus.length > 0) {
          enhancements.warnings.push(
            `${weakConsensus.length} theme(s) have weak/contested consensus. Consider exploring why.`
          );
        }
        if (themeCount >= 3 && !thought.framework) {
          enhancements.suggestions.push(
            "Consider developing a conceptual framework to organize themes and relationships"
          );
        }
        if (themeCount >= 2 && (!thought.conclusions || thought.conclusions.length === 0)) {
          enhancements.guidingQuestions.push(
            "What synthesized conclusions can you draw from the themes identified?"
          );
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Resolve thought type to valid SynthesisThoughtType
       */
      resolveThoughtType(inputType) {
        if (inputType && this.supportedThoughtTypes.includes(inputType)) {
          return inputType;
        }
        return "source_identification";
      }
      /**
       * Validate a source
       */
      validateSource(source, index, existingIds) {
        const errors = [];
        const warnings = [];
        if (!source.id || source.id.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              `sources[${index}].id`,
              "Source has no ID",
              "Add an ID to reference this source in themes and contradictions"
            )
          );
        } else if (existingIds.has(source.id)) {
          errors.push(
            createValidationError(
              `sources[${index}].id`,
              `Duplicate source ID: ${source.id}`,
              "DUPLICATE_SOURCE_ID"
            )
          );
        }
        if (!source.title || source.title.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              `sources[${index}].title`,
              "Source has no title",
              "Add a title to identify the source"
            )
          );
        }
        if (source.quality) {
          const qualityFields = [
            "methodologicalRigor",
            "relevance",
            "recency",
            "authorCredibility",
            "overallQuality"
          ];
          for (const field of qualityFields) {
            const value = source.quality[field];
            if (value !== void 0 && (value < 0 || value > 1)) {
              warnings.push(
                createValidationWarning(
                  `sources[${index}].quality.${field}`,
                  `Quality metric ${field} (${value}) is outside [0, 1] range`,
                  "Quality metrics should be normalized to [0, 1]"
                )
              );
            }
          }
        }
        return errors.length > 0 ? validationFailure(errors, warnings) : validationSuccess(warnings);
      }
      /**
       * Validate a theme
       */
      validateTheme(theme, index, sourceIds) {
        const warnings = [];
        if (!theme.id || theme.id.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              `themes[${index}].id`,
              "Theme has no ID",
              "Add an ID to track this theme"
            )
          );
        }
        if (!theme.name || theme.name.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              `themes[${index}].name`,
              "Theme has no name",
              "Add a descriptive name for the theme"
            )
          );
        }
        if (theme.sourceIds && theme.sourceIds.length > 0) {
          for (const sourceId of theme.sourceIds) {
            if (!sourceIds.has(sourceId)) {
              warnings.push(
                createValidationWarning(
                  `themes[${index}].sourceIds`,
                  `Theme references non-existent source: ${sourceId}`,
                  "Ensure all source references exist in sources array"
                )
              );
            }
          }
        } else {
          warnings.push(
            createValidationWarning(
              `themes[${index}].sourceIds`,
              "Theme has no source references",
              "Link the theme to supporting sources"
            )
          );
        }
        if (theme.strength !== void 0 && (theme.strength < 0 || theme.strength > 1)) {
          warnings.push(
            createValidationWarning(
              `themes[${index}].strength`,
              `Theme strength (${theme.strength}) is outside [0, 1] range`,
              "Strength should be normalized to [0, 1]"
            )
          );
        }
        return validationSuccess(warnings);
      }
      /**
       * Validate a contradiction
       */
      validateContradiction(contradiction, index, sourceIds) {
        const warnings = [];
        if (contradiction.position1?.sourceIds) {
          for (const sourceId of contradiction.position1.sourceIds) {
            if (!sourceIds.has(sourceId)) {
              warnings.push(
                createValidationWarning(
                  `contradictions[${index}].position1.sourceIds`,
                  `Position 1 references non-existent source: ${sourceId}`,
                  "Ensure source references exist"
                )
              );
            }
          }
        }
        if (contradiction.position2?.sourceIds) {
          for (const sourceId of contradiction.position2.sourceIds) {
            if (!sourceIds.has(sourceId)) {
              warnings.push(
                createValidationWarning(
                  `contradictions[${index}].position2.sourceIds`,
                  `Position 2 references non-existent source: ${sourceId}`,
                  "Ensure source references exist"
                )
              );
            }
          }
        }
        return validationSuccess(warnings);
      }
      /**
       * Calculate source coverage by themes
       */
      calculateSourceCoverage(sources, themes) {
        const sourceIds = new Set(sources.map((s) => s.id).filter(Boolean));
        const coveredSourceIds = /* @__PURE__ */ new Set();
        for (const theme of themes) {
          if (theme.sourceIds) {
            for (const sourceId of theme.sourceIds) {
              coveredSourceIds.add(sourceId);
            }
          }
        }
        const coveredSources = Array.from(coveredSourceIds).filter((id) => sourceIds.has(id));
        const uncoveredSources = Array.from(sourceIds).filter((id) => !coveredSourceIds.has(id));
        return {
          coverageRatio: sourceIds.size > 0 ? coveredSources.length / sourceIds.size : 0,
          uncoveredSources,
          coveredSources
        };
      }
      /**
       * Detect potential contradictions between sources based on themes
       *
       * Simple heuristic: sources in themes with 'contested' consensus might contradict
       */
      detectPotentialContradictions(_sources, themes) {
        const contradictions = [];
        if (!themes || themes.length === 0) return contradictions;
        const contestedThemes = themes.filter((t) => t.consensus === "contested");
        for (const theme of contestedThemes) {
          if (theme.sourceIds && theme.sourceIds.length >= 2) {
            const sourceA = theme.sourceIds[0];
            const sourceB = theme.sourceIds[1];
            contradictions.push({
              id: `auto-${randomUUID().slice(0, 8)}`,
              description: `Potential contradiction in contested theme: ${theme.name}`,
              position1: {
                statement: `View from source ${sourceA}`,
                sourceIds: [sourceA],
                reasoning: "Auto-detected from contested theme consensus"
              },
              position2: {
                statement: `View from source ${sourceB}`,
                sourceIds: [sourceB],
                reasoning: "Auto-detected from contested theme consensus"
              },
              possibleResolution: "Requires further investigation"
            });
          }
        }
        return contradictions;
      }
    };
  }
});
var SYSTEMS_ARCHETYPES, SystemsThinkingHandler;
var init_SystemsThinkingHandler = __esm({
  "src/modes/handlers/SystemsThinkingHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    SYSTEMS_ARCHETYPES = [
      {
        name: "Fixes that Fail",
        description: "A quick fix creates unintended consequences that make the problem worse",
        pattern: "Solution \u2192 Short-term relief \u2192 Unintended consequences \u2192 Original problem worsened",
        warningSigns: [
          "Quick fixes that keep recurring",
          "Side effects appearing after solution",
          "Escalating interventions required"
        ],
        interventions: [
          "Address root cause instead of symptoms",
          "Consider long-term consequences before acting",
          "Monitor for unintended side effects"
        ],
        loopSignature: { reinforcingCount: 1, balancingCount: 1, hasDelay: true }
      },
      {
        name: "Shifting the Burden",
        description: "A symptomatic solution undermines the fundamental solution",
        pattern: "Symptom \u2192 Quick fix AND Fundamental solution, Quick fix erodes capacity for fundamental solution",
        warningSigns: [
          "Increasing dependence on quick fixes",
          "Atrophying fundamental capabilities",
          "Growing gap between symptoms and root causes"
        ],
        interventions: [
          "Strengthen the fundamental solution",
          "Reduce reliance on symptomatic solutions",
          "Build capacity while managing symptoms"
        ],
        loopSignature: { reinforcingCount: 1, balancingCount: 2, hasDelay: true }
      },
      {
        name: "Limits to Growth",
        description: "Growth approaches a limit which slows or stops further growth",
        pattern: "Growth process \u2192 Success \u2192 Limiting condition activated \u2192 Growth slows/stops",
        warningSigns: [
          "Initial rapid growth",
          "Gradual slowdown despite continued effort",
          "Diminishing returns on investment"
        ],
        interventions: [
          "Identify and address limiting factors early",
          "Prepare for growth constraints",
          "Shift focus from pushing growth to removing limits"
        ],
        loopSignature: { reinforcingCount: 1, balancingCount: 1, hasDelay: false }
      },
      {
        name: "Success to the Successful",
        description: "Success breeds more success, starving other activities",
        pattern: "Initial advantage \u2192 More resources allocated \u2192 Greater success \u2192 Competitors starved",
        warningSigns: [
          "Winner-take-all dynamics",
          "Declining diversity of options",
          "Concentration of resources"
        ],
        interventions: [
          "Ensure fair resource allocation",
          "Support weaker parties",
          "Maintain diverse options"
        ],
        loopSignature: { reinforcingCount: 2, balancingCount: 0, hasDelay: false }
      },
      {
        name: "Tragedy of the Commons",
        description: "Individual overuse depletes a shared resource",
        pattern: "Shared resource \u2192 Individual exploitation \u2192 Resource depletion \u2192 Harm to all",
        warningSigns: [
          "Declining shared resource",
          "Increasing individual consumption",
          "Rational individual behavior leading to collective harm"
        ],
        interventions: [
          "Establish governance mechanisms",
          "Create feedback on individual impact",
          "Align individual incentives with collective good"
        ],
        loopSignature: { reinforcingCount: 1, balancingCount: 1, hasDelay: true }
      },
      {
        name: "Escalation",
        description: "Two parties compete, each responding to the other's actions",
        pattern: "Party A acts \u2192 Party B perceives threat \u2192 Party B responds \u2192 Party A perceives threat \u2192 Cycle",
        warningSigns: [
          "Competitive actions and reactions",
          "Each side feeling justified",
          "Escalating intensity over time"
        ],
        interventions: [
          "Break the cycle unilaterally",
          "Establish communication channels",
          "Find mutual benefit solutions"
        ],
        loopSignature: { reinforcingCount: 2, balancingCount: 0, hasDelay: false }
      },
      {
        name: "Growth and Underinvestment",
        description: "Growth is limited by underinvestment in capacity",
        pattern: "Demand grows \u2192 Capacity stretched \u2192 Performance drops \u2192 Investment deferred \u2192 Limits growth",
        warningSigns: [
          "Quality declining with growth",
          "Deferred investment in capacity",
          "Performance standards lowered"
        ],
        interventions: [
          "Invest in capacity ahead of demand",
          "Maintain performance standards",
          "Plan for growth requirements"
        ],
        loopSignature: { reinforcingCount: 1, balancingCount: 2, hasDelay: true }
      },
      {
        name: "Eroding Goals",
        description: "Under pressure, goals are lowered rather than addressing the gap",
        pattern: "Gap between goals and reality \u2192 Pressure \u2192 Goals lowered \u2192 Gap closed artificially",
        warningSigns: [
          "Gradual lowering of standards",
          "Rationalization of declining performance",
          "Short-term pressure driving decisions"
        ],
        interventions: [
          "Hold firm on essential goals",
          "Address root causes of gaps",
          "Distinguish essential from negotiable goals"
        ],
        loopSignature: { reinforcingCount: 1, balancingCount: 1, hasDelay: false }
      }
    ];
    SystemsThinkingHandler = class {
      mode = "systemsthinking" /* SYSTEMSTHINKING */;
      modeName = "Systems Thinking";
      description = "Systems analysis with archetype detection, feedback loops, and leverage point identification";
      /**
       * Supported thought types for systems thinking mode
       */
      supportedThoughtTypes = [
        "system_definition",
        "component_analysis",
        "feedback_identification",
        "leverage_analysis",
        "behavior_prediction"
      ];
      /**
       * Create a systems thinking thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const thoughtType = this.resolveThoughtType(inputAny.thoughtType);
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          isRevision: input.isRevision,
          revisesThought: input.revisesThought,
          mode: "systemsthinking" /* SYSTEMSTHINKING */,
          thoughtType,
          system: inputAny.system,
          components: inputAny.components || [],
          feedbackLoops: inputAny.feedbackLoops || [],
          leveragePoints: inputAny.leveragePoints || [],
          behaviors: inputAny.behaviors || []
        };
      }
      /**
       * Validate systems thinking-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        const componentIds = /* @__PURE__ */ new Set();
        if (inputAny.components && Array.isArray(inputAny.components)) {
          for (const component of inputAny.components) {
            if (component.id) componentIds.add(component.id);
          }
          for (let i = 0; i < inputAny.components.length; i++) {
            const component = inputAny.components[i];
            const compValidation = this.validateComponent(component, i, componentIds);
            errors.push(...compValidation.errors);
            warnings.push(...compValidation.warnings);
          }
        }
        if (inputAny.feedbackLoops && Array.isArray(inputAny.feedbackLoops)) {
          for (let i = 0; i < inputAny.feedbackLoops.length; i++) {
            const loop = inputAny.feedbackLoops[i];
            const loopValidation = this.validateFeedbackLoop(loop, i, componentIds);
            errors.push(...loopValidation.errors);
            warnings.push(...loopValidation.warnings);
          }
        }
        if (inputAny.leveragePoints && Array.isArray(inputAny.leveragePoints)) {
          for (let i = 0; i < inputAny.leveragePoints.length; i++) {
            const lp = inputAny.leveragePoints[i];
            const lpValidation = this.validateLeveragePoint(lp, i, componentIds);
            errors.push(...lpValidation.errors);
            warnings.push(...lpValidation.warnings);
          }
        }
        if (inputAny.system) {
          const sysValidation = this.validateSystem(inputAny.system);
          warnings.push(...sysValidation.warnings);
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get systems thinking-specific enhancements
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["causal" /* CAUSAL */, "optimization" /* OPTIMIZATION */, "scientificmethod" /* SCIENTIFICMETHOD */],
          guidingQuestions: [],
          warnings: [],
          mentalModels: [
            "Feedback Loops",
            "Stock and Flow",
            "Systems Archetypes",
            "Leverage Points",
            "Emergence"
          ]
        };
        const componentCount = thought.components?.length || 0;
        const feedbackLoopCount = thought.feedbackLoops?.length || 0;
        const leveragePointCount = thought.leveragePoints?.length || 0;
        const behaviorCount = thought.behaviors?.length || 0;
        const reinforcingLoops = (thought.feedbackLoops || []).filter((l) => l.type === "reinforcing").length;
        const balancingLoops = (thought.feedbackLoops || []).filter((l) => l.type === "balancing").length;
        enhancements.metrics = {
          componentCount,
          feedbackLoopCount,
          reinforcingLoops,
          balancingLoops,
          leveragePointCount,
          behaviorCount
        };
        const detectedArchetypesResult = this.detectArchetypes(thought);
        if (detectedArchetypesResult.length > 0) {
          enhancements.detectedArchetypes = detectedArchetypesResult.map((a) => ({
            name: a.name,
            confidence: a.confidence,
            matchedPatterns: a.archetype.warningSigns
          }));
          for (const detected of detectedArchetypesResult) {
            if (detected.confidence > 0.5) {
              enhancements.warnings.push(
                `Potential "${detected.name}" archetype detected. Watch for: ${detected.archetype.warningSigns[0]}`
              );
            }
          }
        }
        if (componentCount === 0) {
          enhancements.suggestions.push(
            "Define system components (stocks, flows, variables) to model the system"
          );
        }
        if (componentCount >= 2 && feedbackLoopCount === 0) {
          enhancements.suggestions.push(
            "Identify feedback loops connecting your components"
          );
        }
        if (reinforcingLoops > 0 && balancingLoops === 0) {
          enhancements.warnings.push(
            "Only reinforcing loops detected. System may be unstable without balancing feedback."
          );
        }
        if (feedbackLoopCount >= 2 && leveragePointCount === 0) {
          enhancements.suggestions.push(
            "Identify leverage points where small changes could have large effects"
          );
        }
        if (thought.system) {
          enhancements.guidingQuestions.push(
            "What is the system optimizing for? Is that the intended goal?"
          );
        }
        if (feedbackLoopCount > 0) {
          enhancements.guidingQuestions.push(
            "Which feedback loop is currently dominant in the system behavior?"
          );
        }
        const delayedLoops = (thought.feedbackLoops || []).filter((l) => l.delay && l.delay > 0);
        if (delayedLoops.length > 0) {
          enhancements.guidingQuestions.push(
            "How do delays in feedback affect system predictability?"
          );
        }
        if (componentCount >= 3 && behaviorCount === 0) {
          enhancements.guidingQuestions.push(
            "What emergent behaviors arise from the interaction of these components?"
          );
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Resolve thought type to valid SystemsThinkingThoughtType
       */
      resolveThoughtType(inputType) {
        if (inputType && this.supportedThoughtTypes.includes(inputType)) {
          return inputType;
        }
        return "system_definition";
      }
      /**
       * Validate a system component
       */
      validateComponent(component, index, existingIds) {
        const errors = [];
        const warnings = [];
        if (!component.id || component.id.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              `components[${index}].id`,
              "Component has no ID",
              "Add an ID to reference this component in loops"
            )
          );
        }
        if (!component.name || component.name.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              `components[${index}].name`,
              "Component has no name",
              "Add a descriptive name"
            )
          );
        }
        if (component.influencedBy) {
          for (const refId of component.influencedBy) {
            if (!existingIds.has(refId)) {
              warnings.push(
                createValidationWarning(
                  `components[${index}].influencedBy`,
                  `References non-existent component: ${refId}`,
                  "Ensure all component references exist"
                )
              );
            }
          }
        }
        return errors.length > 0 ? validationFailure(errors, warnings) : validationSuccess(warnings);
      }
      /**
       * Validate a feedback loop
       */
      validateFeedbackLoop(loop, index, componentIds) {
        const errors = [];
        const warnings = [];
        if (!loop.id || loop.id.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              `feedbackLoops[${index}].id`,
              "Feedback loop has no ID",
              "Add an ID to track this loop"
            )
          );
        }
        if (loop.components && loop.components.length > 0) {
          for (const compId of loop.components) {
            if (!componentIds.has(compId)) {
              warnings.push(
                createValidationWarning(
                  `feedbackLoops[${index}].components`,
                  `Loop references non-existent component: ${compId}`,
                  "Ensure all components in the loop exist"
                )
              );
            }
          }
          if (loop.components.length < 2) {
            warnings.push(
              createValidationWarning(
                `feedbackLoops[${index}].components`,
                "Feedback loop has fewer than 2 components",
                "A feedback loop needs at least 2 components to form a cycle"
              )
            );
          }
        } else {
          warnings.push(
            createValidationWarning(
              `feedbackLoops[${index}].components`,
              "Feedback loop has no components",
              "Add components that form the feedback loop"
            )
          );
        }
        if (loop.strength !== void 0 && (loop.strength < 0 || loop.strength > 1)) {
          warnings.push(
            createValidationWarning(
              `feedbackLoops[${index}].strength`,
              `Loop strength (${loop.strength}) is outside [0, 1] range`,
              "Strength should be normalized to [0, 1]"
            )
          );
        }
        return errors.length > 0 ? validationFailure(errors, warnings) : validationSuccess(warnings);
      }
      /**
       * Validate a leverage point
       */
      validateLeveragePoint(lp, index, componentIds) {
        const warnings = [];
        if (!lp.location || lp.location.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              `leveragePoints[${index}].location`,
              "Leverage point has no location",
              "Specify which component or loop this leverage point targets"
            )
          );
        } else if (!componentIds.has(lp.location)) {
          warnings.push(
            createValidationWarning(
              `leveragePoints[${index}].location`,
              `Leverage point location "${lp.location}" not found in components`,
              "Ensure the location references an existing component or loop"
            )
          );
        }
        if (lp.effectiveness !== void 0 && (lp.effectiveness < 0 || lp.effectiveness > 1)) {
          warnings.push(
            createValidationWarning(
              `leveragePoints[${index}].effectiveness`,
              `Effectiveness (${lp.effectiveness}) is outside [0, 1] range`,
              "Effectiveness should be normalized to [0, 1]"
            )
          );
        }
        if (lp.difficulty !== void 0 && (lp.difficulty < 0 || lp.difficulty > 1)) {
          warnings.push(
            createValidationWarning(
              `leveragePoints[${index}].difficulty`,
              `Difficulty (${lp.difficulty}) is outside [0, 1] range`,
              "Difficulty should be normalized to [0, 1]"
            )
          );
        }
        return validationSuccess(warnings);
      }
      /**
       * Validate system definition
       */
      validateSystem(system) {
        const warnings = [];
        if (!system.boundary || system.boundary.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              "system.boundary",
              "System has no boundary defined",
              "Define what is inside and outside the system"
            )
          );
        }
        if (!system.purpose || system.purpose.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              "system.purpose",
              "System has no purpose defined",
              "Define what the system is designed to achieve"
            )
          );
        }
        return validationSuccess(warnings);
      }
      /**
       * Detect systems archetypes based on structure
       */
      detectArchetypes(thought) {
        const detected = [];
        const loops = thought.feedbackLoops || [];
        const reinforcingCount = loops.filter((l) => l.type === "reinforcing").length;
        const balancingCount = loops.filter((l) => l.type === "balancing").length;
        const hasDelay = loops.some((l) => l.delay && l.delay > 0);
        for (const archetype of SYSTEMS_ARCHETYPES) {
          let confidence = 0;
          const sig = archetype.loopSignature;
          if (sig.reinforcingCount !== void 0) {
            if (reinforcingCount === sig.reinforcingCount) {
              confidence += 0.4;
            } else if (Math.abs(reinforcingCount - sig.reinforcingCount) === 1) {
              confidence += 0.2;
            }
          }
          if (sig.balancingCount !== void 0) {
            if (balancingCount === sig.balancingCount) {
              confidence += 0.4;
            } else if (Math.abs(balancingCount - sig.balancingCount) === 1) {
              confidence += 0.2;
            }
          }
          if (sig.hasDelay !== void 0) {
            if (hasDelay === sig.hasDelay) {
              confidence += 0.2;
            }
          }
          if (confidence >= 0.4) {
            detected.push({
              name: archetype.name,
              confidence: Math.min(confidence, 1),
              archetype
            });
          }
        }
        detected.sort((a, b) => b.confidence - a.confidence);
        return detected.slice(0, 3);
      }
    };
  }
});
var SOCRATIC_CATEGORIES, CritiqueHandler;
var init_CritiqueHandler = __esm({
  "src/modes/handlers/CritiqueHandler.ts"() {
    init_esm_shims();
    init_ModeHandler();
    SOCRATIC_CATEGORIES = [
      {
        name: "Clarification",
        description: "Questions that probe for clarity and understanding",
        purpose: "Ensure clear understanding before critique",
        exampleQuestions: [
          "What do you mean by...?",
          "Could you put that another way?",
          "What is your main point?",
          "Could you give me an example?",
          "Can you explain that term?"
        ]
      },
      {
        name: "Assumptions",
        description: "Questions that probe underlying assumptions",
        purpose: "Uncover hidden assumptions that may be flawed",
        exampleQuestions: [
          "What are you assuming here?",
          "Is that always the case?",
          "Why would you assume that?",
          "What could we assume instead?",
          "What if the opposite were true?"
        ]
      },
      {
        name: "Evidence",
        description: "Questions that probe reasons and evidence",
        purpose: "Evaluate the quality and relevance of evidence",
        exampleQuestions: [
          "What evidence supports this?",
          "How do you know this is true?",
          "What would change your mind?",
          "Is there counter-evidence?",
          "How reliable is this source?"
        ]
      },
      {
        name: "Perspectives",
        description: "Questions that probe viewpoints and perspectives",
        purpose: "Consider alternative viewpoints",
        exampleQuestions: [
          "What would X say about this?",
          "How might others view this?",
          "What is an alternative interpretation?",
          "Who benefits from this view?",
          "What perspective is missing?"
        ]
      },
      {
        name: "Implications",
        description: "Questions that probe implications and consequences",
        purpose: "Explore logical consequences of claims",
        exampleQuestions: [
          "What follows from this?",
          "What are the consequences?",
          "How does this affect...?",
          "If this is true, what else must be true?",
          "What are the risks?"
        ]
      },
      {
        name: "Meta",
        description: "Questions about the question itself",
        purpose: "Examine the reasoning process",
        exampleQuestions: [
          "Why is this question important?",
          "What makes this hard to answer?",
          "What do we need to know to answer this?",
          "How can we find out?",
          "What assumptions underlie this question?"
        ]
      }
    ];
    CritiqueHandler = class {
      mode = "critique" /* CRITIQUE */;
      modeName = "Critical Analysis";
      description = "Scholarly critique with Socratic questioning, balanced evaluation, and methodology assessment";
      /**
       * Supported thought types for critique mode
       */
      supportedThoughtTypes = [
        "work_characterization",
        "methodology_evaluation",
        "argument_analysis",
        "evidence_assessment",
        "contribution_evaluation",
        "limitation_identification",
        "strength_recognition",
        "improvement_suggestion"
      ];
      /**
       * Create a critique thought from input
       */
      createThought(input, sessionId) {
        const inputAny = input;
        const thoughtType = this.resolveThoughtType(inputAny.thoughtType);
        const work = inputAny.work || {
          id: randomUUID().slice(0, 8),
          title: "Untitled Work",
          authors: [],
          year: (/* @__PURE__ */ new Date()).getFullYear(),
          type: "empirical_study",
          field: "Unknown",
          claimedContribution: ""
        };
        const critiquePoints = inputAny.critiquePoints || [];
        const strengthsIdentified = critiquePoints.filter(
          (p) => p.type === "strength"
        ).length;
        const weaknessesIdentified = critiquePoints.filter(
          (p) => p.type === "weakness" || p.type === "concern"
        ).length;
        const balanceRatio = this.calculateBalanceRatio(strengthsIdentified, weaknessesIdentified);
        return {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          isRevision: input.isRevision,
          revisesThought: input.revisesThought,
          mode: "critique" /* CRITIQUE */,
          thoughtType,
          work,
          methodologyEvaluation: inputAny.methodologyEvaluation,
          argumentCritique: inputAny.argumentCritique,
          evidenceCritique: inputAny.evidenceCritique,
          contributionEvaluation: inputAny.contributionEvaluation,
          critiquePoints,
          improvements: inputAny.improvements || [],
          verdict: inputAny.verdict,
          strengthsIdentified,
          weaknessesIdentified,
          balanceRatio,
          dependencies: inputAny.dependencies || [],
          assumptions: inputAny.assumptions || [],
          uncertainty: inputAny.uncertainty ?? 0.5,
          keyInsight: inputAny.keyInsight
        };
      }
      /**
       * Validate critique-specific input
       */
      validate(input) {
        const errors = [];
        const warnings = [];
        const inputAny = input;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        if (input.thoughtNumber > input.totalThoughts) {
          return validationFailure([
            createValidationError(
              "thoughtNumber",
              `Thought number (${input.thoughtNumber}) exceeds total thoughts (${input.totalThoughts})`,
              "INVALID_THOUGHT_NUMBER"
            )
          ]);
        }
        if (inputAny.work) {
          const workValidation = this.validateWork(inputAny.work);
          warnings.push(...workValidation.warnings);
        }
        if (inputAny.methodologyEvaluation) {
          const methValidation = this.validateMethodologyEvaluation(inputAny.methodologyEvaluation);
          errors.push(...methValidation.errors);
          warnings.push(...methValidation.warnings);
        }
        if (inputAny.argumentCritique) {
          const argValidation = this.validateArgumentCritique(inputAny.argumentCritique);
          warnings.push(...argValidation.warnings);
        }
        if (inputAny.critiquePoints && Array.isArray(inputAny.critiquePoints)) {
          for (let i = 0; i < inputAny.critiquePoints.length; i++) {
            const point = inputAny.critiquePoints[i];
            const pointValidation = this.validateCritiquePoint(point, i);
            warnings.push(...pointValidation.warnings);
          }
          const strengths = inputAny.critiquePoints.filter(
            (p) => p.type === "strength"
          ).length;
          const weaknesses = inputAny.critiquePoints.filter(
            (p) => p.type === "weakness" || p.type === "concern"
          ).length;
          if (inputAny.critiquePoints.length >= 3) {
            if (strengths === 0) {
              warnings.push(
                createValidationWarning(
                  "critiquePoints",
                  "No strengths identified in critique",
                  "A balanced critique should acknowledge strengths as well as weaknesses"
                )
              );
            } else if (weaknesses === 0) {
              warnings.push(
                createValidationWarning(
                  "critiquePoints",
                  "No weaknesses or concerns identified",
                  "A thorough critique should identify areas for improvement"
                )
              );
            }
          }
        }
        if (inputAny.verdict) {
          const verdictValidation = this.validateVerdict(inputAny.verdict);
          warnings.push(...verdictValidation.warnings);
        }
        if (errors.length > 0) {
          return validationFailure(errors, warnings);
        }
        return validationSuccess(warnings);
      }
      /**
       * Get critique-specific enhancements with Socratic questions
       */
      getEnhancements(thought) {
        const enhancements = {
          suggestions: [],
          relatedModes: ["argumentation" /* ARGUMENTATION */, "synthesis" /* SYNTHESIS */, "analysis" /* ANALYSIS */],
          guidingQuestions: [],
          warnings: [],
          mentalModels: [
            "Socratic Questioning",
            "Peer Review Framework",
            "Toulmin Model",
            "Critical Thinking"
          ]
        };
        const critiquePointCount = thought.critiquePoints?.length || 0;
        const improvementCount = thought.improvements?.length || 0;
        enhancements.metrics = {
          strengthsIdentified: thought.strengthsIdentified,
          weaknessesIdentified: thought.weaknessesIdentified,
          balanceRatio: thought.balanceRatio,
          critiquePointCount,
          improvementCount,
          hasVerdict: thought.verdict ? 1 : 0
        };
        const socraticCategories = this.getSocraticQuestions(thought.thoughtType);
        const socraticQuestionsRecord = {};
        for (const category of socraticCategories) {
          socraticQuestionsRecord[category.name] = category.exampleQuestions;
        }
        enhancements.socraticQuestions = socraticQuestionsRecord;
        for (const category of socraticCategories.slice(0, 2)) {
          enhancements.guidingQuestions.push(category.exampleQuestions[0]);
        }
        if (thought.balanceRatio < 0.2) {
          enhancements.warnings.push(
            "Critique appears heavily weighted toward weaknesses. Consider identifying strengths."
          );
        } else if (thought.balanceRatio > 0.8) {
          enhancements.warnings.push(
            "Critique appears heavily weighted toward strengths. Consider identifying limitations."
          );
        }
        if (!thought.methodologyEvaluation && thought.work?.type === "empirical_study") {
          enhancements.suggestions.push(
            "Consider adding methodology evaluation for empirical work"
          );
        }
        if (!thought.argumentCritique && thought.work?.type === "theoretical_paper") {
          enhancements.suggestions.push(
            "Consider adding argument structure analysis for theoretical work"
          );
        }
        if (critiquePointCount >= 5 && !thought.verdict) {
          enhancements.suggestions.push(
            "Consider providing an overall verdict summarizing the critique"
          );
        }
        if (thought.weaknessesIdentified > 0 && improvementCount === 0) {
          enhancements.suggestions.push(
            "Consider adding constructive improvement suggestions for identified weaknesses"
          );
        }
        if (thought.work) {
          if (!thought.work.researchQuestion && thought.work.type === "empirical_study") {
            enhancements.guidingQuestions.push(
              "What is the research question being addressed?"
            );
          }
        }
        if (thought.critiquePoints && thought.critiquePoints.length > 0) {
          const criticalCount = thought.critiquePoints.filter(
            (p) => p.severity === "critical"
          ).length;
          const majorCount = thought.critiquePoints.filter(
            (p) => p.severity === "major"
          ).length;
          if (criticalCount > 0 && thought.verdict?.recommendation === "accept") {
            enhancements.warnings.push(
              "Accept recommendation despite critical issues. Verify this is intentional."
            );
          }
          if (criticalCount === 0 && majorCount === 0 && thought.verdict?.recommendation === "reject") {
            enhancements.warnings.push(
              "Reject recommendation with no critical/major issues. Consider revising verdict."
            );
          }
        }
        return enhancements;
      }
      /**
       * Check if this handler supports a specific thought type
       */
      supportsThoughtType(thoughtType) {
        return this.supportedThoughtTypes.includes(thoughtType);
      }
      /**
       * Resolve thought type to valid CritiqueThoughtType
       */
      resolveThoughtType(inputType) {
        if (inputType && this.supportedThoughtTypes.includes(inputType)) {
          return inputType;
        }
        return "work_characterization";
      }
      /**
       * Calculate balance ratio (0 = all weaknesses, 1 = all strengths, 0.5 = balanced)
       */
      calculateBalanceRatio(strengths, weaknesses) {
        const total = strengths + weaknesses;
        if (total === 0) return 0.5;
        return strengths / total;
      }
      /**
       * Validate work being critiqued
       */
      validateWork(work) {
        const warnings = [];
        if (!work.title || work.title.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              "work.title",
              "Work has no title",
              "Add a title to identify the work being critiqued"
            )
          );
        }
        if (!work.authors || work.authors.length === 0) {
          warnings.push(
            createValidationWarning(
              "work.authors",
              "No authors specified",
              "Add author information for proper attribution"
            )
          );
        }
        if (!work.claimedContribution || work.claimedContribution.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              "work.claimedContribution",
              "No claimed contribution specified",
              "Identify what contribution the work claims to make"
            )
          );
        }
        return validationSuccess(warnings);
      }
      /**
       * Validate methodology evaluation
       */
      validateMethodologyEvaluation(meth) {
        const errors = [];
        const warnings = [];
        if (meth.overallRating !== void 0 && (meth.overallRating < 0 || meth.overallRating > 1)) {
          warnings.push(
            createValidationWarning(
              "methodologyEvaluation.overallRating",
              `overallRating (${meth.overallRating}) is outside [0, 1] range`,
              "Ratings should be normalized to [0, 1]"
            )
          );
        }
        const subRatings = ["design.rating", "sample.rating", "analysis.rating"];
        for (const path4 of subRatings) {
          const [parent, child] = path4.split(".");
          const parentObj = meth[parent];
          if (parentObj && parentObj[child] !== void 0) {
            const value = parentObj[child];
            if (value < 0 || value > 1) {
              warnings.push(
                createValidationWarning(
                  `methodologyEvaluation.${path4}`,
                  `${path4} (${value}) is outside [0, 1] range`,
                  "Ratings should be normalized to [0, 1]"
                )
              );
            }
          }
        }
        return errors.length > 0 ? validationFailure(errors, warnings) : validationSuccess(warnings);
      }
      /**
       * Validate argument critique
       */
      validateArgumentCritique(arg) {
        const warnings = [];
        if (arg.rating !== void 0 && (arg.rating < 0 || arg.rating > 1)) {
          warnings.push(
            createValidationWarning(
              "argumentCritique.rating",
              `Argument rating (${arg.rating}) is outside [0, 1] range`,
              "Rating should be normalized to [0, 1]"
            )
          );
        }
        if (arg.logicalStructure) {
          if (arg.logicalStructure.overallCoherence !== void 0) {
            if (arg.logicalStructure.overallCoherence < 0 || arg.logicalStructure.overallCoherence > 1) {
              warnings.push(
                createValidationWarning(
                  "argumentCritique.logicalStructure.overallCoherence",
                  `Coherence (${arg.logicalStructure.overallCoherence}) is outside [0, 1] range`,
                  "Coherence should be normalized to [0, 1]"
                )
              );
            }
          }
          if (arg.logicalStructure.circularReasoning) {
            warnings.push(
              createValidationWarning(
                "argumentCritique.logicalStructure",
                "Circular reasoning detected in the argument",
                "This is a significant logical flaw that should be addressed"
              )
            );
          }
        }
        return validationSuccess(warnings);
      }
      /**
       * Validate a critique point
       */
      validateCritiquePoint(point, index) {
        const warnings = [];
        if (!point.description || point.description.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              `critiquePoints[${index}].description`,
              "Critique point has no description",
              "Add a detailed description of the critique"
            )
          );
        }
        if (point.type === "weakness" || point.type === "concern") {
          if (!point.recommendation) {
            warnings.push(
              createValidationWarning(
                `critiquePoints[${index}].recommendation`,
                "Weakness has no recommendation for improvement",
                "Consider adding a constructive suggestion"
              )
            );
          }
        }
        return validationSuccess(warnings);
      }
      /**
       * Validate verdict
       */
      validateVerdict(verdict) {
        const warnings = [];
        if (verdict.confidence !== void 0 && (verdict.confidence < 0 || verdict.confidence > 1)) {
          warnings.push(
            createValidationWarning(
              "verdict.confidence",
              `Verdict confidence (${verdict.confidence}) is outside [0, 1] range`,
              "Confidence should be between 0 and 1"
            )
          );
        }
        if (!verdict.summary || verdict.summary.trim().length === 0) {
          warnings.push(
            createValidationWarning(
              "verdict.summary",
              "Verdict has no summary",
              "Add a summary explaining the recommendation"
            )
          );
        }
        return validationSuccess(warnings);
      }
      /**
       * Get Socratic questions based on thought type
       */
      getSocraticQuestions(thoughtType) {
        const typeToCategories = {
          work_characterization: ["Clarification", "Meta"],
          methodology_evaluation: ["Evidence", "Assumptions"],
          argument_analysis: ["Assumptions", "Implications"],
          evidence_assessment: ["Evidence", "Perspectives"],
          contribution_evaluation: ["Implications", "Perspectives"],
          limitation_identification: ["Assumptions", "Evidence"],
          strength_recognition: ["Clarification", "Implications"],
          improvement_suggestion: ["Perspectives", "Meta"]
        };
        const categoryNames = typeToCategories[thoughtType] || ["Clarification", "Evidence"];
        return SOCRATIC_CATEGORIES.filter((c) => categoryNames.includes(c.name));
      }
    };
  }
});

// src/modes/handlers/registry.ts
var ModeHandlerRegistry;
var init_registry = __esm({
  "src/modes/handlers/registry.ts"() {
    init_esm_shims();
    init_core();
    init_ModeHandler();
    init_GenericModeHandler();
    ModeHandlerRegistry = class _ModeHandlerRegistry {
      static instance = null;
      handlers = /* @__PURE__ */ new Map();
      constructor() {
      }
      /**
       * Get the singleton instance
       */
      static getInstance() {
        if (!_ModeHandlerRegistry.instance) {
          _ModeHandlerRegistry.instance = new _ModeHandlerRegistry();
        }
        return _ModeHandlerRegistry.instance;
      }
      /**
       * Reset the singleton (for testing)
       */
      static resetInstance() {
        _ModeHandlerRegistry.instance = null;
      }
      /**
       * Register a mode handler
       *
       * @param handler - The handler to register
       * @throws Error if handler for mode is already registered
       */
      register(handler) {
        if (this.handlers.has(handler.mode)) {
          throw new Error(
            `Handler for mode '${handler.mode}' is already registered. Use replace() to override an existing handler.`
          );
        }
        this.handlers.set(handler.mode, handler);
      }
      /**
       * Replace an existing handler or register a new one
       *
       * @param handler - The handler to register/replace
       */
      replace(handler) {
        this.handlers.set(handler.mode, handler);
      }
      /**
       * Unregister a handler
       *
       * @param mode - The mode to unregister
       * @returns true if handler was removed, false if not found
       */
      unregister(mode) {
        return this.handlers.delete(mode);
      }
      /**
       * Get handler for a mode
       *
       * Returns the specialized handler if registered,
       * otherwise returns the generic handler.
       *
       * @param mode - The thinking mode
       * @returns The handler for the mode
       */
      getHandler(mode) {
        return this.handlers.get(mode) || this.createGenericHandlerForMode(mode);
      }
      /**
       * Check if a specialized handler is registered for a mode
       *
       * @param mode - The thinking mode
       * @returns true if a specialized handler exists
       */
      hasSpecializedHandler(mode) {
        return this.handlers.has(mode);
      }
      /**
       * Get all registered modes
       *
       * @returns Array of modes with specialized handlers
       */
      getRegisteredModes() {
        return Array.from(this.handlers.keys());
      }
      /**
       * Create a thought using the appropriate handler
       *
       * This is the main entry point for thought creation.
       * Delegates to specialized handler if registered,
       * otherwise uses generic handler.
       *
       * @param input - The tool input
       * @param sessionId - The session ID
       * @returns Created thought
       */
      createThought(input, sessionId) {
        const mode = input.mode || "hybrid" /* HYBRID */;
        const handler = this.getHandler(mode);
        return handler.createThought(input, sessionId);
      }
      /**
       * Validate input using the appropriate handler
       *
       * @param input - The tool input
       * @returns Validation result
       */
      validate(input) {
        const mode = input.mode || "hybrid" /* HYBRID */;
        if (!input.thought || input.thought.trim().length === 0) {
          return validationFailure([
            createValidationError("thought", "Thought content is required", "EMPTY_THOUGHT")
          ]);
        }
        const handler = this.getHandler(mode);
        return handler.validate(input);
      }
      /**
       * Get mode status information
       *
       * @param mode - The thinking mode
       * @returns Mode status for API response
       */
      getModeStatus(mode) {
        const hasSpecialized = this.hasSpecializedHandler(mode);
        const handler = this.getHandler(mode);
        return {
          mode,
          isFullyImplemented: isFullyImplemented(mode),
          hasSpecializedHandler: hasSpecialized,
          note: this.getModeNote(mode, hasSpecialized),
          supportedThoughtTypes: this.getSupportedThoughtTypes(handler, mode)
        };
      }
      /**
       * Get registry statistics
       *
       * @returns Statistics about registered handlers
       */
      getStats() {
        const allModes = Object.values(ThinkingMode).filter(
          (v) => typeof v === "string"
        );
        const modesWithHandlers = this.getRegisteredModes();
        const modesWithGenericHandler = allModes.filter(
          (mode) => !this.handlers.has(mode)
        );
        return {
          totalHandlers: this.handlers.size,
          specializedHandlers: this.handlers.size,
          modesWithHandlers,
          modesWithGenericHandler
        };
      }
      /**
       * Create a generic handler configured for a specific mode
       */
      createGenericHandlerForMode(mode) {
        return new GenericModeHandler(mode);
      }
      /**
       * Get appropriate note for mode status
       */
      getModeNote(mode, hasSpecialized) {
        if (!isFullyImplemented(mode)) {
          return "This mode is experimental with limited runtime implementation";
        }
        if (!hasSpecialized) {
          return "Using generic handler - specialized validation not available";
        }
        return void 0;
      }
      /**
       * Get supported thought types for a mode
       */
      getSupportedThoughtTypes(_handler, mode) {
        const thoughtTypes = {
          mathematics: [
            "problem_definition",
            "constraints",
            "model",
            "proof",
            "implementation",
            "proof_decomposition",
            "dependency_analysis",
            "consistency_check",
            "gap_identification",
            "assumption_trace"
          ],
          physics: [
            "problem_definition",
            "model",
            "tensor_formulation",
            "conservation_law",
            "dimensional_analysis"
          ],
          causal: ["problem_definition", "graph_construction", "intervention_analysis", "mechanism_identification"],
          bayesian: ["prior_definition", "likelihood_assessment", "posterior_calculation", "sensitivity_analysis"],
          temporal: ["event_definition", "interval_analysis", "constraint_checking", "timeline_construction"],
          gametheory: ["game_definition", "strategy_analysis", "equilibrium_finding", "payoff_calculation"],
          synthesis: ["source_identification", "theme_extraction", "gap_analysis", "framework_construction"],
          argumentation: ["claim_formulation", "grounds_development", "warrant_construction", "rebuttal_analysis"],
          critique: ["work_characterization", "methodology_evaluation", "argument_critique", "contribution_assessment"],
          analysis: ["data_familiarization", "coding", "theme_development", "pattern_analysis"]
        };
        const modeKey = mode.toLowerCase();
        return thoughtTypes[modeKey] || ["general"];
      }
      /**
       * Clear all registered handlers (for testing)
       */
      clear() {
        this.handlers.clear();
      }
    };
  }
});

// src/modes/handlers/index.ts
var init_handlers = __esm({
  "src/modes/handlers/index.ts"() {
    init_esm_shims();
    init_CausalHandler();
    init_BayesianHandler();
    init_GameTheoryHandler();
    init_CounterfactualHandler();
    init_SynthesisHandler();
    init_SystemsThinkingHandler();
    init_CritiqueHandler();
    init_registry();
  }
});

// src/utils/errors.ts
var DeepThinkingError, SessionNotFoundError;
var init_errors = __esm({
  "src/utils/errors.ts"() {
    init_esm_shims();
    DeepThinkingError = class extends Error {
      code;
      context;
      timestamp;
      constructor(message, code, context) {
        super(message);
        this.name = this.constructor.name;
        this.code = code;
        this.context = context;
        this.timestamp = /* @__PURE__ */ new Date();
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
      }
      /**
       * Convert error to JSON for logging/serialization
       */
      toJSON() {
        return {
          name: this.name,
          message: this.message,
          code: this.code,
          context: this.context,
          timestamp: this.timestamp.toISOString(),
          stack: this.stack
        };
      }
    };
    SessionNotFoundError = class extends DeepThinkingError {
      constructor(sessionId) {
        super(`Session not found: ${sessionId}`, "SESSION_NOT_FOUND", { sessionId });
      }
    };
  }
});

// src/utils/sanitization.ts
function sanitizeString(input, maxLength = MAX_LENGTHS.STRING_FIELD, fieldName = "input") {
  if (typeof input !== "string") {
    throw new Error(`${fieldName} must be a string`);
  }
  const trimmed = input.trim();
  if (trimmed.length === 0) {
    throw new Error(`${fieldName} cannot be empty`);
  }
  if (trimmed.length > maxLength) {
    throw new Error(`${fieldName} exceeds maximum length of ${maxLength} characters`);
  }
  if (trimmed.includes("\0")) {
    throw new Error(`${fieldName} contains invalid null bytes`);
  }
  return trimmed;
}
function validateSessionId(sessionId) {
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  if (!uuidRegex.test(sessionId)) {
    throw new Error(`Invalid session ID format: ${sessionId}`);
  }
  return sessionId;
}
function sanitizeThoughtContent(content) {
  return sanitizeString(content, MAX_LENGTHS.THOUGHT_CONTENT, "thought content");
}
function escapeHtml(text) {
  const htmlEscapeMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;",
    "/": "&#x2F;"
  };
  return text.replace(/[&<>"'\/]/g, (char) => htmlEscapeMap[char] || char);
}
function escapeLatex(text) {
  const latexEscapeMap = {
    "\\": "\\textbackslash{}",
    "{": "\\{",
    "}": "\\}",
    "$": "\\$",
    "&": "\\&",
    "%": "\\%",
    "#": "\\#",
    "_": "\\_",
    "~": "\\textasciitilde{}",
    "^": "\\textasciicircum{}"
  };
  return text.replace(/[\\{}$&%#_~^]/g, (char) => latexEscapeMap[char] || char);
}
var MAX_LENGTHS;
var init_sanitization = __esm({
  "src/utils/sanitization.ts"() {
    init_esm_shims();
    MAX_LENGTHS = {
      THOUGHT_CONTENT: 1e5,
      // 100KB for thought content
      TITLE: 500,
      DOMAIN: 200,
      AUTHOR: 300,
      SESSION_ID: 100,
      HYPOTHESIS: 5e3,
      DESCRIPTION: 1e4,
      STRING_FIELD: 1e3
    };
  }
});

// src/utils/logger-types.ts
var LogLevel;
var init_logger_types = __esm({
  "src/utils/logger-types.ts"() {
    init_esm_shims();
    LogLevel = /* @__PURE__ */ ((LogLevel2) => {
      LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
      LogLevel2[LogLevel2["INFO"] = 1] = "INFO";
      LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
      LogLevel2[LogLevel2["ERROR"] = 3] = "ERROR";
      LogLevel2[LogLevel2["SILENT"] = 4] = "SILENT";
      return LogLevel2;
    })(LogLevel || {});
  }
});

// src/utils/logger.ts
function createLogger(config) {
  return new Logger(config);
}
var DEFAULT_CONFIG, Logger, logger;
var init_logger = __esm({
  "src/utils/logger.ts"() {
    init_esm_shims();
    init_logger_types();
    DEFAULT_CONFIG = {
      minLevel: 1 /* INFO */,
      enableConsole: true,
      enableTimestamps: true,
      prettyPrint: true
    };
    Logger = class {
      config;
      logs = [];
      constructor(config) {
        this.config = { ...DEFAULT_CONFIG, ...config };
      }
      /**
       * Log a debug message
       */
      debug(message, context) {
        this.log(0 /* DEBUG */, message, context);
      }
      /**
       * Log an info message
       */
      info(message, context) {
        this.log(1 /* INFO */, message, context);
      }
      /**
       * Log a warning message
       */
      warn(message, context) {
        this.log(2 /* WARN */, message, context);
      }
      /**
       * Log an error message
       */
      error(message, error, context) {
        this.log(3 /* ERROR */, message, context, error);
      }
      /**
       * Internal log method
       */
      log(level, message, context, error) {
        if (level < this.config.minLevel) {
          return;
        }
        const entry = {
          level,
          message,
          timestamp: /* @__PURE__ */ new Date(),
          context,
          error
        };
        this.logs.push(entry);
        if (this.config.enableConsole) {
          this.writeToConsole(entry);
        }
      }
      /**
       * Write log entry to console
       */
      writeToConsole(entry) {
        const levelName = LogLevel[entry.level];
        const timestamp = this.config.enableTimestamps ? `[${entry.timestamp.toISOString()}] ` : "";
        let message = `${timestamp}${levelName}: ${entry.message}`;
        if (entry.context && this.config.prettyPrint) {
          message += `
  Context: ${JSON.stringify(entry.context, null, 2)}`;
        }
        if (entry.error) {
          message += `
  Error: ${entry.error.message}`;
          if (entry.error.stack && this.config.prettyPrint) {
            message += `
  Stack: ${entry.error.stack}`;
          }
        }
        switch (entry.level) {
          case 0 /* DEBUG */:
          case 1 /* INFO */:
            console.log(message);
            break;
          case 2 /* WARN */:
            console.warn(message);
            break;
          case 3 /* ERROR */:
            console.error(message);
            break;
        }
      }
      /**
       * Get all log entries
       */
      getLogs(minLevel) {
        if (minLevel !== void 0) {
          return this.logs.filter((log) => log.level >= minLevel);
        }
        return [...this.logs];
      }
      /**
       * Clear all logs
       */
      clearLogs() {
        this.logs = [];
      }
      /**
       * Set minimum log level
       */
      setLevel(level) {
        this.config.minLevel = level;
      }
      /**
       * Export logs as JSON
       */
      exportLogs() {
        return JSON.stringify(this.logs.map((log) => ({
          ...log,
          level: LogLevel[log.level],
          timestamp: log.timestamp.toISOString()
        })), null, 2);
      }
    };
    logger = new Logger();
  }
});

// src/cache/lru.ts
var LRUCache;
var init_lru = __esm({
  "src/cache/lru.ts"() {
    init_esm_shims();
    LRUCache = class {
      cache;
      config;
      stats;
      constructor(config = {}) {
        this.cache = /* @__PURE__ */ new Map();
        this.config = {
          /**
           * Default max cache size: 100 entries
           * Reasoning:
           * - Validation cache typically stores session/thought validation results
           * - Average entry size: ~1-2KB (validation result + metadata)
           * - 100 entries = ~100-200KB memory usage
           * - Sufficient for most use cases (covers recent validations)
           * - Prevents unbounded memory growth in long-running processes
           * - Can be overridden via config parameter for high-traffic scenarios
           */
          maxSize: config.maxSize || 100,
          strategy: "lru",
          ttl: config.ttl || 0,
          enableStats: config.enableStats !== false,
          onEvict: config.onEvict || (() => {
          })
        };
        this.stats = {
          size: 0,
          maxSize: this.config.maxSize,
          hits: 0,
          misses: 0,
          hitRate: 0,
          evictions: 0,
          sets: 0,
          deletes: 0,
          memoryUsage: 0,
          avgAccessTime: 0
        };
      }
      /**
       * Get value by key
       */
      get(key) {
        const entry = this.cache.get(key);
        if (!entry) {
          if (this.config.enableStats) {
            this.stats.misses++;
            this.updateHitRate();
          }
          return void 0;
        }
        if (entry.expiresAt && entry.expiresAt < /* @__PURE__ */ new Date()) {
          this.delete(key);
          if (this.config.enableStats) {
            this.stats.misses++;
            this.updateHitRate();
          }
          return void 0;
        }
        entry.lastAccessedAt = /* @__PURE__ */ new Date();
        entry.accessCount++;
        this.cache.delete(key);
        this.cache.set(key, entry);
        if (this.config.enableStats) {
          this.stats.hits++;
          this.updateHitRate();
        }
        return entry.value;
      }
      /**
       * Set value for key
       */
      set(key, value, ttl) {
        const existing = this.cache.get(key);
        if (existing) {
          this.cache.delete(key);
        } else if (this.cache.size >= this.config.maxSize) {
          this.evictLRU();
        }
        const now = /* @__PURE__ */ new Date();
        const effectiveTtl = ttl ?? this.config.ttl;
        const entry = {
          key,
          value,
          createdAt: now,
          lastAccessedAt: now,
          accessCount: 0,
          expiresAt: effectiveTtl ? new Date(now.getTime() + effectiveTtl) : void 0,
          size: this.estimateSize(value)
        };
        this.cache.set(key, entry);
        if (this.config.enableStats) {
          this.stats.sets++;
          this.stats.size = this.cache.size;
          this.stats.memoryUsage += entry.size || 0;
        }
      }
      /**
       * Check if key exists
       */
      has(key) {
        const entry = this.cache.get(key);
        if (!entry) return false;
        if (entry.expiresAt && entry.expiresAt < /* @__PURE__ */ new Date()) {
          this.delete(key);
          return false;
        }
        return true;
      }
      /**
       * Delete entry by key
       */
      delete(key) {
        const entry = this.cache.get(key);
        if (!entry) return false;
        this.cache.delete(key);
        if (this.config.enableStats) {
          this.stats.deletes++;
          this.stats.size = this.cache.size;
          this.stats.memoryUsage -= entry.size || 0;
        }
        return true;
      }
      /**
       * Clear all entries
       */
      clear() {
        this.cache.clear();
        if (this.config.enableStats) {
          this.stats.size = 0;
          this.stats.memoryUsage = 0;
        }
      }
      /**
       * Get cache size
       */
      size() {
        return this.cache.size;
      }
      /**
       * Get cache statistics
       */
      getStats() {
        return { ...this.stats };
      }
      /**
       * Get all keys
       */
      keys() {
        return Array.from(this.cache.keys());
      }
      /**
       * Get all values
       */
      values() {
        return Array.from(this.cache.values()).map((e) => e.value);
      }
      /**
       * Get all entries
       */
      entries() {
        return Array.from(this.cache.entries()).map(([k, v]) => [k, v.value]);
      }
      /**
       * Evict least recently used entry
       */
      evictLRU() {
        const firstKey = this.cache.keys().next().value;
        if (firstKey) {
          const entry = this.cache.get(firstKey);
          this.cache.delete(firstKey);
          if (this.config.onEvict && entry) {
            this.config.onEvict(firstKey, entry.value);
          }
          if (this.config.enableStats) {
            this.stats.evictions++;
            this.stats.size = this.cache.size;
            if (entry) {
              this.stats.memoryUsage -= entry.size || 0;
            }
          }
        }
      }
      /**
       * Update hit rate
       */
      updateHitRate() {
        const total = this.stats.hits + this.stats.misses;
        this.stats.hitRate = total > 0 ? this.stats.hits / total : 0;
      }
      /**
       * Estimate entry size
       */
      estimateSize(value) {
        try {
          return JSON.stringify(value).length * 2;
        } catch {
          return 0;
        }
      }
      /**
       * Clean expired entries
       */
      cleanExpired() {
        let cleaned = 0;
        const now = /* @__PURE__ */ new Date();
        for (const [key, entry] of this.cache) {
          if (entry.expiresAt && entry.expiresAt < now) {
            this.delete(key);
            cleaned++;
          }
        }
        return cleaned;
      }
    };
  }
});

// src/config/index.ts
function getConfig() {
  return Object.freeze({ ...activeConfig });
}
function validateConfig(config) {
  if (config.maxThoughtsInMemory < 1) {
    throw new Error("maxThoughtsInMemory must be at least 1");
  }
  if (config.compressionThreshold < 0) {
    throw new Error("compressionThreshold must be non-negative");
  }
  if (config.maxContentLength < 1) {
    throw new Error("maxContentLength must be at least 1");
  }
  if (config.validationTolerance < 0 || config.validationTolerance > 1) {
    throw new Error("validationTolerance must be between 0 and 1");
  }
  if (config.maxActiveSessions < 1) {
    throw new Error("maxActiveSessions must be at least 1");
  }
  if (config.sessionTimeoutMs < 0) {
    throw new Error("sessionTimeoutMs must be non-negative");
  }
  if (config.validationCacheMaxSize < 0) {
    throw new Error("validationCacheMaxSize must be non-negative");
  }
  if (!["debug", "info", "warn", "error"].includes(config.logLevel)) {
    throw new Error("logLevel must be one of: debug, info, warn, error");
  }
}
var defaultConfig, activeConfig;
var init_config = __esm({
  "src/config/index.ts"() {
    init_esm_shims();
    defaultConfig = {
      maxThoughtsInMemory: parseInt(process.env.MCP_MAX_THOUGHTS || "1000", 10),
      compressionThreshold: parseInt(process.env.MCP_COMPRESSION_THRESHOLD || "500", 10),
      maxContentLength: parseInt(process.env.MCP_MAX_CONTENT_LENGTH || "10000", 10),
      validationTolerance: parseFloat(process.env.MCP_VALIDATION_TOLERANCE || "0.01"),
      maxActiveSessions: parseInt(process.env.MCP_MAX_SESSIONS || "100", 10),
      sessionTimeoutMs: parseInt(process.env.MCP_SESSION_TIMEOUT_MS || "0", 10),
      enableValidationCache: process.env.MCP_ENABLE_VALIDATION_CACHE !== "false",
      validationCacheMaxSize: parseInt(process.env.MCP_VALIDATION_CACHE_SIZE || "1000", 10),
      enablePersistence: process.env.MCP_ENABLE_PERSISTENCE === "true",
      persistenceDir: process.env.MCP_PERSISTENCE_DIR || "./.deepthinking-sessions",
      logLevel: process.env.MCP_LOG_LEVEL || "info",
      enablePerformanceMetrics: process.env.MCP_ENABLE_PERF_METRICS === "true"
    };
    activeConfig = { ...defaultConfig };
    validateConfig(activeConfig);
    getConfig();
  }
});
var ValidationCache, validationCache;
var init_cache = __esm({
  "src/validation/cache.ts"() {
    init_esm_shims();
    init_config();
    ValidationCache = class {
      cache;
      maxSize;
      hits = 0;
      misses = 0;
      constructor(maxSize) {
        const config = getConfig();
        this.maxSize = maxSize || config.validationCacheMaxSize;
        this.cache = /* @__PURE__ */ new Map();
      }
      /**
       * Generate a cache key from thought content
       *
       * Uses SHA-256 hash of JSON-serialized content for reliable cache keys
       *
       * @param content - Content to hash
       * @returns Cache key
       */
      generateKey(content) {
        const json = JSON.stringify(content);
        return createHash("sha256").update(json).digest("hex");
      }
      /**
       * Get validation result from cache
       *
       * @param content - Content to look up
       * @returns Cached result or undefined if not found
       */
      get(content) {
        const key = this.generateKey(content);
        const entry = this.cache.get(key);
        if (entry) {
          this.hits++;
          entry.hitCount++;
          this.cache.delete(key);
          this.cache.set(key, entry);
          return entry;
        }
        this.misses++;
        return void 0;
      }
      /**
       * Store validation result in cache
       *
       * @param content - Content that was validated
       * @param result - Validation result to cache
       */
      set(content, result) {
        const key = this.generateKey(content);
        if (this.cache.size >= this.maxSize) {
          const firstKey = this.cache.keys().next().value;
          if (firstKey !== void 0) {
            this.cache.delete(firstKey);
          }
        }
        const entry = {
          result,
          timestamp: Date.now(),
          hitCount: 0
        };
        this.cache.set(key, entry);
      }
      /**
       * Check if content is in cache
       *
       * @param content - Content to check
       * @returns true if cached
       */
      has(content) {
        const key = this.generateKey(content);
        return this.cache.has(key);
      }
      /**
       * Clear all cached validation results
       */
      clear() {
        this.cache.clear();
        this.hits = 0;
        this.misses = 0;
      }
      /**
       * Get cache statistics
       */
      getStats() {
        const total = this.hits + this.misses;
        return {
          size: this.cache.size,
          maxSize: this.maxSize,
          hits: this.hits,
          misses: this.misses,
          hitRate: total > 0 ? this.hits / total : 0
        };
      }
      /**
       * Resize the cache
       *
       * @param newSize - New maximum cache size
       */
      resize(newSize) {
        this.maxSize = newSize;
        if (this.cache.size > newSize) {
          const keysToDelete = this.cache.size - newSize;
          const keys = Array.from(this.cache.keys());
          for (let i = 0; i < keysToDelete; i++) {
            this.cache.delete(keys[i]);
          }
        }
      }
      /**
       * Get entries sorted by hit count (most used first)
       */
      getTopEntries(limit = 10) {
        const entries = Array.from(this.cache.entries()).map(([key, entry]) => ({ key, entry })).sort((a, b) => b.entry.hitCount - a.entry.hitCount);
        return entries.slice(0, limit);
      }
      /**
       * Remove entries older than a certain age
       *
       * @param maxAgeMs - Maximum age in milliseconds
       * @returns Number of entries removed
       */
      evictOld(maxAgeMs) {
        const now = Date.now();
        let removed = 0;
        for (const [key, entry] of this.cache.entries()) {
          if (now - entry.timestamp > maxAgeMs) {
            this.cache.delete(key);
            removed++;
          }
        }
        return removed;
      }
    };
    validationCache = new ValidationCache();
  }
});

// src/session/SessionMetricsCalculator.ts
var SessionMetricsCalculator;
var init_SessionMetricsCalculator = __esm({
  "src/session/SessionMetricsCalculator.ts"() {
    init_esm_shims();
    init_core();
    init_cache();
    SessionMetricsCalculator = class {
      /**
       * Initialize metrics for a new session
       *
       * Creates a fresh metrics object with all counters set to zero
       * and cache statistics initialized.
       *
       * @returns Initialized session metrics
       *
       * @example
       * ```typescript
       * const metrics = calculator.initializeMetrics();
       * session.metrics = metrics;
       * ```
       */
      initializeMetrics() {
        return {
          totalThoughts: 0,
          thoughtsByType: {},
          averageUncertainty: 0,
          revisionCount: 0,
          timeSpent: 0,
          dependencyDepth: 0,
          customMetrics: /* @__PURE__ */ new Map(),
          cacheStats: {
            hits: 0,
            misses: 0,
            hitRate: 0,
            size: 0,
            maxSize: 0
          }
        };
      }
      /**
       * Update session metrics after adding a thought
       *
       * Performs incremental updates using O(1) algorithms for performance.
       * Handles mode-specific metrics for temporal, game theory, and evidential modes.
       *
       * **Performance Optimizations**:
       * - Incremental thoughtsByType counter (O(1) vs O(n) recalculation)
       * - Running average for uncertainty (O(1) vs O(n) recalculation)
       * - Max dependency depth tracking (O(1) comparison)
       *
       * @param session - Session to update (modified in-place)
       * @param thought - Newly added thought
       *
       * @example
       * ```typescript
       * calculator.updateMetrics(session, newThought);
       * console.log(session.metrics.totalThoughts); // Incremented
       * ```
       */
      updateMetrics(session, thought) {
        const metrics = session.metrics;
        metrics.totalThoughts = session.thoughts.length;
        const thoughtType = thought.mode || "unknown";
        metrics.thoughtsByType[thoughtType] = (metrics.thoughtsByType[thoughtType] || 0) + 1;
        if (thought.isRevision) {
          metrics.revisionCount++;
        }
        metrics.timeSpent = session.updatedAt.getTime() - session.createdAt.getTime();
        if ("uncertainty" in thought && typeof thought.uncertainty === "number") {
          const uncertaintyValue = thought.uncertainty;
          const currentSum = metrics._uncertaintySum || 0;
          const currentCount = metrics._uncertaintyCount || 0;
          const newSum = currentSum + uncertaintyValue;
          const newCount = currentCount + 1;
          metrics._uncertaintySum = newSum;
          metrics._uncertaintyCount = newCount;
          metrics.averageUncertainty = newSum / newCount;
        }
        if ("dependencies" in thought && thought.dependencies) {
          const deps = thought.dependencies;
          if (deps && deps.length > metrics.dependencyDepth) {
            metrics.dependencyDepth = deps.length;
          }
        }
        this.updateModeSpecificMetrics(metrics, thought);
        this.updateCacheStats(session);
      }
      /**
       * Update mode-specific custom metrics
       *
       * Calculates and stores metrics unique to specific thinking modes:
       * - Temporal: events, timeline, relations, constraints, intervals
       * - Game Theory: players, strategies, equilibria, game type
       * - Evidential: hypotheses, evidence, belief functions, decisions
       *
       * @param metrics - Session metrics to update
       * @param thought - Thought to analyze
       */
      updateModeSpecificMetrics(metrics, thought) {
        if (isTemporalThought(thought)) {
          if (thought.events) {
            metrics.customMetrics.set("totalEvents", thought.events.length);
          }
          if (thought.timeline) {
            metrics.customMetrics.set("timelineUnit", thought.timeline.timeUnit);
          }
          if (thought.relations) {
            const causalRelations = thought.relations.filter((r) => r.relationType === "causes");
            metrics.customMetrics.set("causalRelations", causalRelations.length);
          }
          if (thought.constraints) {
            metrics.customMetrics.set("temporalConstraints", thought.constraints.length);
          }
          if (thought.intervals) {
            metrics.customMetrics.set("timeIntervals", thought.intervals.length);
          }
        }
        if (isGameTheoryThought(thought)) {
          if (thought.players) {
            metrics.customMetrics.set("numPlayers", thought.players.length);
          }
          if (thought.strategies) {
            metrics.customMetrics.set("totalStrategies", thought.strategies.length);
            const mixedStrategies = thought.strategies.filter((s) => !s.isPure);
            metrics.customMetrics.set("mixedStrategies", mixedStrategies.length);
          }
          if (thought.nashEquilibria) {
            metrics.customMetrics.set("nashEquilibria", thought.nashEquilibria.length);
            const pureEquilibria = thought.nashEquilibria.filter((e) => e.type === "pure");
            metrics.customMetrics.set("pureNashEquilibria", pureEquilibria.length);
          }
          if (thought.dominantStrategies) {
            metrics.customMetrics.set("dominantStrategies", thought.dominantStrategies.length);
          }
          if (thought.game) {
            metrics.customMetrics.set("gameType", thought.game.type);
            metrics.customMetrics.set("isZeroSum", thought.game.isZeroSum);
          }
        }
        if (isEvidentialThought(thought)) {
          if (thought.hypotheses) {
            metrics.customMetrics.set("totalHypotheses", thought.hypotheses.length);
          }
          if (thought.evidence) {
            metrics.customMetrics.set("totalEvidence", thought.evidence.length);
            const avgReliability = thought.evidence.reduce((sum, e) => sum + e.reliability, 0) / thought.evidence.length;
            metrics.customMetrics.set("avgEvidenceReliability", avgReliability);
          }
          if (thought.beliefFunctions) {
            metrics.customMetrics.set("beliefFunctions", thought.beliefFunctions.length);
          }
          if (thought.combinedBelief) {
            metrics.customMetrics.set("hasCombinedBelief", true);
            if (thought.combinedBelief.conflictMass !== void 0) {
              metrics.customMetrics.set("conflictMass", thought.combinedBelief.conflictMass);
            }
          }
          if (thought.decisions) {
            metrics.customMetrics.set("decisions", thought.decisions.length);
          }
        }
      }
      /**
       * Update validation cache statistics in session metrics
       *
       * Retrieves current validation cache statistics and updates the
       * session metrics with the latest values.
       *
       * @param session - Session to update
       *
       * @example
       * ```typescript
       * calculator.updateCacheStats(session);
       * console.log(session.metrics.cacheStats.hitRate); // Updated
       * ```
       */
      updateCacheStats(session) {
        const cacheStats = validationCache.getStats();
        session.metrics.cacheStats = {
          hits: cacheStats.hits,
          misses: cacheStats.misses,
          hitRate: cacheStats.hitRate,
          size: cacheStats.size,
          maxSize: cacheStats.maxSize
        };
      }
    };
  }
});

// src/services/MetaMonitor.ts
var MetaMonitor, metaMonitor;
var init_MetaMonitor = __esm({
  "src/services/MetaMonitor.ts"() {
    init_esm_shims();
    MetaMonitor = class {
      sessionHistory = /* @__PURE__ */ new Map();
      currentStrategies = /* @__PURE__ */ new Map();
      modeTransitions = /* @__PURE__ */ new Map();
      /**
       * Record a thought in session history
       */
      recordThought(sessionId, thought) {
        if (!this.sessionHistory.has(sessionId)) {
          this.sessionHistory.set(sessionId, []);
        }
        const history = this.sessionHistory.get(sessionId);
        history.push({
          thoughtId: thought.id,
          mode: thought.mode,
          timestamp: thought.timestamp,
          content: thought.content,
          uncertainty: "uncertainty" in thought ? thought.uncertainty : void 0
        });
        if (!this.modeTransitions.has(sessionId)) {
          this.modeTransitions.set(sessionId, []);
        }
        const transitions = this.modeTransitions.get(sessionId);
        if (transitions.length === 0 || transitions[transitions.length - 1] !== thought.mode) {
          transitions.push(thought.mode);
        }
      }
      /**
       * Start tracking a new strategy
       */
      startStrategy(sessionId, mode) {
        this.currentStrategies.set(sessionId, {
          mode,
          thoughtsSpent: 0,
          startTime: /* @__PURE__ */ new Date(),
          progressIndicators: [],
          issuesEncountered: []
        });
      }
      /**
       * Update current strategy progress
       */
      updateStrategyProgress(sessionId, indicator) {
        const strategy = this.currentStrategies.get(sessionId);
        if (strategy) {
          strategy.progressIndicators.push(indicator);
          strategy.thoughtsSpent++;
        }
      }
      /**
       * Record an issue with current strategy
       */
      recordStrategyIssue(sessionId, issue) {
        const strategy = this.currentStrategies.get(sessionId);
        if (strategy) {
          strategy.issuesEncountered.push(issue);
        }
      }
      /**
       * Evaluate current strategy effectiveness
       */
      evaluateStrategy(sessionId) {
        const strategy = this.currentStrategies.get(sessionId);
        if (!strategy) {
          return {
            effectiveness: 0.5,
            efficiency: 0.5,
            confidence: 0.5,
            progressRate: 0,
            qualityScore: 0.5,
            issues: ["No active strategy being tracked"],
            strengths: []
          };
        }
        const thoughtsSpent = strategy.thoughtsSpent;
        const progressMade = strategy.progressIndicators.length;
        const issuesCount = strategy.issuesEncountered.length;
        const timeElapsed = (/* @__PURE__ */ new Date()).getTime() - strategy.startTime.getTime();
        const effectiveness = Math.min(1, progressMade / Math.max(1, thoughtsSpent));
        const efficiency = timeElapsed > 0 ? Math.min(1, progressMade / (timeElapsed / 6e4)) : 0.5;
        const confidence = Math.max(0.1, 1 - issuesCount * 0.15);
        const progressRate = thoughtsSpent > 0 ? progressMade / thoughtsSpent : 0;
        const qualityScore = effectiveness * 0.4 + efficiency * 0.2 + confidence * 0.4;
        return {
          effectiveness,
          efficiency,
          confidence,
          progressRate,
          qualityScore,
          issues: [...strategy.issuesEncountered],
          strengths: strategy.progressIndicators.slice(-3)
          // Recent progress
        };
      }
      /**
       * Suggest alternative strategies based on current performance
       */
      suggestAlternatives(sessionId, currentMode) {
        const evaluation = this.evaluateStrategy(sessionId);
        const alternatives = [];
        if (evaluation.effectiveness < 0.4) {
          if (currentMode !== "hybrid" /* HYBRID */) {
            alternatives.push({
              mode: "hybrid" /* HYBRID */,
              reasoning: "Low effectiveness detected - hybrid multi-modal approach may provide better results",
              expectedBenefit: "Combines multiple reasoning types for comprehensive analysis",
              switchingCost: 0.3,
              recommendationScore: 0.85
            });
          }
          if (currentMode !== "inductive" /* INDUCTIVE */) {
            alternatives.push({
              mode: "inductive" /* INDUCTIVE */,
              reasoning: "Consider gathering more empirical observations",
              expectedBenefit: "Build stronger generalizations from specific cases",
              switchingCost: 0.2,
              recommendationScore: 0.7
            });
          }
        }
        if (evaluation.effectiveness >= 0.4 && evaluation.efficiency < 0.5) {
          alternatives.push({
            mode: currentMode,
            // Same mode, but recommend refinement
            reasoning: "Progress detected but efficiency is low - consider refining current approach",
            expectedBenefit: "Improved efficiency while maintaining progress",
            switchingCost: 0.1,
            recommendationScore: 0.65
          });
        }
        return alternatives;
      }
      /**
       * Calculate quality metrics for current session
       */
      calculateQualityMetrics(sessionId) {
        const history = this.sessionHistory.get(sessionId) || [];
        const strategy = this.currentStrategies.get(sessionId);
        if (history.length === 0) {
          return {
            logicalConsistency: 0.5,
            evidenceQuality: 0.5,
            completeness: 0.5,
            originality: 0.5,
            clarity: 0.5,
            overallQuality: 0.5
          };
        }
        const issuesCount = strategy?.issuesEncountered.length || 0;
        const logicalConsistency = Math.max(0.1, 1 - issuesCount * 0.1);
        const avgUncertainty = history.reduce((sum, entry) => sum + (entry.uncertainty || 0.5), 0) / history.length;
        const evidenceQuality = 1 - avgUncertainty;
        const completeness = Math.min(1, history.length / 5);
        const uniqueModes = new Set(history.map((h) => h.mode)).size;
        const originality = Math.min(1, uniqueModes / 3);
        const progressCount = strategy?.progressIndicators.length || 0;
        const clarity = Math.min(1, progressCount / Math.max(1, history.length));
        const overallQuality = logicalConsistency * 0.25 + evidenceQuality * 0.2 + completeness * 0.15 + originality * 0.15 + clarity * 0.25;
        return {
          logicalConsistency,
          evidenceQuality,
          completeness,
          originality,
          clarity,
          overallQuality
        };
      }
      /**
       * Get session context for meta-reasoning
       */
      getSessionContext(sessionId, problemType) {
        const history = this.sessionHistory.get(sessionId) || [];
        const transitions = this.modeTransitions.get(sessionId) || [];
        return {
          sessionId,
          totalThoughts: history.length,
          modesUsed: transitions,
          modeSwitches: Math.max(0, transitions.length - 1),
          problemType,
          historicalEffectiveness: this.getHistoricalEffectiveness(problemType)
        };
      }
      /**
       * Get historical effectiveness for similar problems (simplified)
       */
      getHistoricalEffectiveness(_problemType) {
        return void 0;
      }
      /**
       * Clear session data (for cleanup)
       */
      clearSession(sessionId) {
        this.sessionHistory.delete(sessionId);
        this.currentStrategies.delete(sessionId);
        this.modeTransitions.delete(sessionId);
      }
      /**
       * Get all tracked sessions
       */
      getActiveSessions() {
        return Array.from(this.sessionHistory.keys());
      }
    };
    metaMonitor = new MetaMonitor();
  }
});
var DEFAULT_CONFIG2, SessionManager;
var init_manager = __esm({
  "src/session/manager.ts"() {
    init_esm_shims();
    init_errors();
    init_sanitization();
    init_logger();
    init_lru();
    init_SessionMetricsCalculator();
    init_MetaMonitor();
    DEFAULT_CONFIG2 = {
      modeConfig: {
        mode: "hybrid" /* HYBRID */,
        strictValidation: false,
        allowModeSwitch: true
      },
      enableAutoSave: true,
      enableValidation: true,
      enableVisualization: true,
      integrations: {},
      exportFormats: ["markdown", "latex", "json"],
      autoExportOnComplete: false,
      maxThoughtsInMemory: 1e3,
      compressionThreshold: 500
    };
    SessionManager = class {
      activeSessions;
      config;
      logger;
      storage;
      metricsCalculator;
      monitor;
      /**
       * Creates a new SessionManager instance
       *
       * @param config - Optional default configuration applied to all new sessions
       * @param logger - Optional logger instance or log level (default: INFO level logger)
       * @param storage - Optional persistent storage backend for sessions
       * @param monitor - Optional MetaMonitor instance for dependency injection
       *
       * @example
       * ```typescript
       * // Memory-only mode with default logger
       * const manager = new SessionManager({
       *   enableAutoSave: true,
       *   maxThoughtsInMemory: 500
       * });
       *
       * // With custom logger (DI)
       * import { createLogger, LogLevel } from './utils/logger.js';
       * const logger = createLogger({ minLevel: LogLevel.DEBUG });
       * const manager = new SessionManager({}, logger);
       *
       * // With file-based persistence (backward compatible)
       * import { FileSessionStore } from './storage/file-store.js';
       * const storage = new FileSessionStore('./sessions');
       * await storage.initialize();
       * const manager = new SessionManager({}, LogLevel.INFO, storage);
       * ```
       */
      constructor(config, logger2, storage, monitor) {
        this.activeSessions = new LRUCache({
          maxSize: 1e3,
          enableStats: true,
          onEvict: async (key, session) => {
            if (this.storage && session.config.enableAutoSave) {
              try {
                await this.storage.saveSession(session);
                this.logger.debug("Evicted session saved to storage", { sessionId: key });
              } catch (error) {
                this.logger.error("Failed to save evicted session", error, { sessionId: key });
              }
            }
            if (this.monitor) {
              this.monitor.clearSession(key);
            }
          }
        });
        this.config = config || {};
        this.storage = storage;
        this.monitor = monitor || metaMonitor;
        if (logger2 && typeof logger2 === "object" && "info" in logger2) {
          this.logger = logger2;
        } else {
          this.logger = createLogger({
            minLevel: logger2 || 1 /* INFO */,
            enableConsole: true
          });
        }
        this.metricsCalculator = new SessionMetricsCalculator();
      }
      /**
       * Create a new thinking session
       *
       * Creates and initializes a new thinking session with the specified configuration.
       * Sessions are stored in memory and tracked until explicitly deleted.
       *
       * @param options - Session creation options
       * @param options.title - Session title (default: 'Untitled Session')
       * @param options.mode - Thinking mode to use (default: HYBRID)
       * @param options.domain - Problem domain (e.g., 'mathematics', 'physics')
       * @param options.author - Session creator/author
       * @param options.config - Session-specific configuration overrides
       * @returns Promise resolving to the created session
       *
       * @example
       * ```typescript
       * const session = await manager.createSession({
       *   title: 'Mathematical Proof',
       *   mode: ThinkingMode.MATHEMATICS,
       *   domain: 'number-theory',
       *   author: 'user@example.com'
       * });
       * ```
       */
      async createSession(options = {}) {
        const title = options.title ? sanitizeString(options.title, MAX_LENGTHS.TITLE, "title") : "Untitled Session";
        const domain = options.domain ? sanitizeString(options.domain, MAX_LENGTHS.DOMAIN, "domain") : void 0;
        const author = options.author ? sanitizeString(options.author, MAX_LENGTHS.AUTHOR, "author") : void 0;
        const sessionId = randomUUID();
        const now = /* @__PURE__ */ new Date();
        const session = {
          id: sessionId,
          title,
          mode: options.mode || "hybrid" /* HYBRID */,
          domain,
          config: this.mergeConfig(options.config),
          thoughts: [],
          createdAt: now,
          updatedAt: now,
          author,
          currentThoughtNumber: 0,
          isComplete: false,
          metrics: this.metricsCalculator.initializeMetrics(),
          tags: [],
          collaborators: author ? [author] : []
        };
        this.activeSessions.set(sessionId, session);
        if (this.storage && session.config.enableAutoSave) {
          try {
            await this.storage.saveSession(session);
            this.logger.debug("Session persisted to storage", { sessionId });
          } catch (error) {
            this.logger.error("Failed to persist session", error, { sessionId });
          }
        }
        this.monitor.startStrategy(sessionId, session.mode);
        this.logger.info("Session created", {
          sessionId,
          title,
          mode: session.mode,
          domain,
          author
        });
        return session;
      }
      /**
       * Get a session by ID
       *
       * Retrieves a session by its unique identifier. If the session is not in memory
       * but storage is available, it will attempt to load from storage.
       *
       * @param sessionId - Unique UUID v4 identifier of the session
       * @returns Promise resolving to the session, or null if not found
       *
       * @example
       * ```typescript
       * const session = await manager.getSession('550e8400-e29b-41d4-a716-446655440000');
       * if (session) {
       *   console.log(`Session: ${session.title}`);
       *   console.log(`Thoughts: ${session.thoughts.length}`);
       * }
       * ```
       */
      async getSession(sessionId) {
        let session = this.activeSessions.get(sessionId);
        if (!session && this.storage) {
          try {
            session = await this.storage.loadSession(sessionId) ?? void 0;
            if (session) {
              this.activeSessions.set(sessionId, session);
              this.logger.debug("Session loaded from storage", { sessionId });
            }
          } catch (error) {
            this.logger.error("Failed to load session from storage", error, { sessionId });
          }
        }
        return session || null;
      }
      /**
       * Add a thought to a session
       *
       * Adds a new thought to an existing session and automatically updates:
       * - Session metrics (uses O(1) incremental calculation)
       * - Thought timestamps
       * - Session completion status
       * - Mode-specific analytics
       *
       * @param sessionId - ID of the session to add thought to
       * @param thought - The thought object to add
       * @returns Promise resolving to the updated session
       * @throws Error if session is not found
       *
       * @example
       * ```typescript
       * await manager.addThought(session.id, {
       *   thought: 'Initial hypothesis: the problem can be solved using...',
       *   thoughtNumber: 1,
       *   totalThoughts: 5,
       *   nextThoughtNeeded: true,
       *   uncertainty: 0.3
       * });
       * ```
       */
      async addThought(sessionId, thought) {
        validateSessionId(sessionId);
        const session = this.activeSessions.get(sessionId);
        if (!session) {
          this.logger.error("Session not found", void 0, { sessionId });
          throw new SessionNotFoundError(sessionId);
        }
        if (thought.content) {
          thought.content = sanitizeThoughtContent(thought.content);
        }
        thought.sessionId = sessionId;
        thought.timestamp = /* @__PURE__ */ new Date();
        session.thoughts.push(thought);
        session.currentThoughtNumber = thought.thoughtNumber;
        session.updatedAt = /* @__PURE__ */ new Date();
        this.metricsCalculator.updateMetrics(session, thought);
        this.monitor.recordThought(sessionId, thought);
        if (!thought.nextThoughtNeeded) {
          session.isComplete = true;
          this.logger.info("Session completed", {
            sessionId,
            title: session.title,
            totalThoughts: session.thoughts.length
          });
        }
        if (this.storage && session.config.enableAutoSave) {
          try {
            await this.storage.saveSession(session);
            this.logger.debug("Session persisted after thought added", { sessionId });
          } catch (error) {
            this.logger.error("Failed to persist session", error, { sessionId });
          }
        }
        this.logger.debug("Thought added", {
          sessionId,
          thoughtNumber: thought.thoughtNumber,
          totalThoughts: session.thoughts.length
        });
        return session;
      }
      /**
       * Update session mode (switch reasoning approach mid-session)
       *
       * Changes the thinking mode of an active session. This is useful when
       * the problem requires a different reasoning approach.
       *
       * @param sessionId - ID of the session to update
       * @param newMode - New thinking mode to switch to
       * @param reason - Optional reason for the mode switch
       * @returns Promise resolving to the updated session
       * @throws Error if session is not found
       *
       * @example
       * ```typescript
       * await manager.switchMode(
       *   session.id,
       *   ThinkingMode.CAUSAL,
       *   'Need to analyze cause-effect relationships'
       * );
       * ```
       */
      async switchMode(sessionId, newMode, reason) {
        validateSessionId(sessionId);
        const session = this.activeSessions.get(sessionId);
        if (!session) {
          this.logger.error("Session not found", void 0, { sessionId });
          throw new SessionNotFoundError(sessionId);
        }
        const oldMode = session.mode;
        session.mode = newMode;
        session.config.modeConfig.mode = newMode;
        session.updatedAt = /* @__PURE__ */ new Date();
        if (this.storage && session.config.enableAutoSave) {
          try {
            await this.storage.saveSession(session);
            this.logger.debug("Session persisted after mode switch", { sessionId });
          } catch (error) {
            this.logger.error("Failed to persist session", error, { sessionId });
          }
        }
        this.logger.info("Session mode switched", {
          sessionId,
          oldMode,
          newMode,
          reason
        });
        return session;
      }
      /**
       * List all active sessions with metadata
       *
       * Returns summary information for all sessions. If storage is available,
       * includes both in-memory sessions and persisted sessions.
       *
       * @param includeStoredSessions - Whether to include sessions from storage (default: true)
       * @returns Promise resolving to array of session metadata
       *
       * @example
       * ```typescript
       * const sessions = await manager.listSessions();
       * sessions.forEach(s => {
       *   console.log(`${s.title}: ${s.thoughtCount} thoughts (${s.mode})`);
       * });
       * ```
       */
      async listSessions(includeStoredSessions = true) {
        const memoryMetadata = Array.from(this.activeSessions.values()).map((session) => ({
          id: session.id,
          title: session.title,
          createdAt: session.createdAt,
          updatedAt: session.updatedAt,
          thoughtCount: session.thoughts.length,
          mode: session.mode,
          isComplete: session.isComplete
        }));
        if (!this.storage || !includeStoredSessions) {
          return memoryMetadata;
        }
        try {
          const storedMetadata = await this.storage.listSessions();
          const memoryIds = new Set(memoryMetadata.map((s) => s.id));
          const combined = [
            ...memoryMetadata,
            ...storedMetadata.filter((s) => !memoryIds.has(s.id))
          ];
          return combined;
        } catch (error) {
          this.logger.error("Failed to list stored sessions", error);
          return memoryMetadata;
        }
      }
      /**
       * Delete a session
       *
       * Removes a session from memory and storage (if available).
       * This operation cannot be undone.
       *
       * @param sessionId - ID of the session to delete
       * @returns Promise that resolves when deletion is complete
       *
       * @example
       * ```typescript
       * await manager.deleteSession('old-session-id');
       * ```
       */
      async deleteSession(sessionId) {
        const session = this.activeSessions.get(sessionId);
        const deletedFromMemory = this.activeSessions.delete(sessionId);
        if (this.storage) {
          try {
            await this.storage.deleteSession(sessionId);
            this.logger.debug("Session deleted from storage", { sessionId });
          } catch (error) {
            this.logger.error("Failed to delete session from storage", error, { sessionId });
          }
        }
        if (deletedFromMemory && session) {
          this.logger.info("Session deleted", {
            sessionId,
            title: session.title,
            thoughtCount: session.thoughts.length
          });
        } else {
          this.logger.warn("Attempted to delete non-existent session from memory", { sessionId });
        }
      }
      /**
       * Generate a text summary of a session
       *
       * Creates a markdown-formatted summary including:
       * - Session metadata (title, mode, status)
       * - Total thought count
       * - Key thoughts (first 100 characters of each)
       *
       * @param sessionId - ID of the session to summarize
       * @returns Promise resolving to markdown-formatted summary
       * @throws Error if session is not found
       *
       * @example
       * ```typescript
       * const summary = await manager.generateSummary(session.id);
       * console.log(summary);
       * // Output:
       * // # Mathematical Proof
       * // Mode: mathematics
       * // Total Thoughts: 15
       * // Status: Complete
       * // ...
       * ```
       */
      async generateSummary(sessionId) {
        validateSessionId(sessionId);
        const session = this.activeSessions.get(sessionId);
        if (!session) {
          throw new SessionNotFoundError(sessionId);
        }
        let summary = `# ${session.title}

`;
        summary += `Mode: ${session.mode}
`;
        summary += `Total Thoughts: ${session.thoughts.length}
`;
        summary += `Status: ${session.isComplete ? "Complete" : "In Progress"}

`;
        summary += `## Key Thoughts:

`;
        for (const thought of session.thoughts) {
          summary += `${thought.thoughtNumber}. ${thought.content.substring(0, 100)}...
`;
        }
        return summary;
      }
      /**
       * Merge configurations (private helper)
       *
       * Combines default config, instance config, and user config
       * with proper precedence: user > instance > default
       */
      mergeConfig(userConfig) {
        return {
          ...DEFAULT_CONFIG2,
          ...this.config,
          ...userConfig
        };
      }
    };
  }
});

// src/session/index.ts
var session_exports = {};
__export(session_exports, {
  SessionManager: () => SessionManager
});
var init_session2 = __esm({
  "src/session/index.ts"() {
    init_esm_shims();
    init_manager();
  }
});

// src/session/storage/interface.ts
var DEFAULT_STORAGE_CONFIG;
var init_interface = __esm({
  "src/session/storage/interface.ts"() {
    init_esm_shims();
    DEFAULT_STORAGE_CONFIG = {
      autoSave: true,
      autoSaveDelay: 1e3,
      // 1 second
      enableCompression: false,
      maxSessions: 1e3,
      maxSessionAge: 30 * 24 * 60 * 60 * 1e3,
      // 30 days
      enableEncryption: false,
      serialization: {
        prettyPrint: false,
        includeMetadata: true
      }
    };
  }
});
function getLockPath(filePath) {
  return `${filePath}.lock`;
}
function getSharedLockDir(filePath) {
  return `${filePath}.locks`;
}
function createLockInfo(type) {
  return {
    pid: process.pid,
    hostname: __require("os").hostname(),
    timestamp: Date.now(),
    type,
    instanceId: INSTANCE_ID
  };
}
function isLockStale(lockInfo, staleThreshold) {
  const age = Date.now() - lockInfo.timestamp;
  return age > staleThreshold;
}
async function readLockInfo(lockPath) {
  try {
    const content = await promises.readFile(lockPath, "utf-8");
    return JSON.parse(content);
  } catch {
    return null;
  }
}
async function writeLockInfo(lockPath, lockInfo) {
  const tempPath = `${lockPath}.${INSTANCE_ID}.tmp`;
  try {
    await promises.writeFile(tempPath, JSON.stringify(lockInfo), { flag: "wx" });
    await promises.rename(tempPath, lockPath);
    return true;
  } catch (error) {
    try {
      await promises.unlink(tempPath);
    } catch {
    }
    if (error.code === "EEXIST" || error.code === "EPERM" || error.code === "ENOENT") {
      return false;
    }
    throw error;
  }
}
async function acquireExclusiveLock(filePath, options) {
  const lockPath = getLockPath(filePath);
  const sharedLockDir = getSharedLockDir(filePath);
  const startTime = Date.now();
  while (Date.now() - startTime < options.timeout) {
    const existingLock = await readLockInfo(lockPath);
    if (existingLock) {
      if (existingLock.instanceId === INSTANCE_ID) {
        return async () => {
          await promises.unlink(lockPath).catch(() => {
          });
        };
      }
      if (isLockStale(existingLock, options.staleThreshold)) {
        await promises.unlink(lockPath).catch(() => {
        });
      } else {
        await sleep(options.retryInterval);
        continue;
      }
    }
    try {
      const sharedLocks = await promises.readdir(sharedLockDir);
      const validSharedLocks = [];
      for (const lockFile of sharedLocks) {
        const sharedLockPath = path3.join(sharedLockDir, lockFile);
        const sharedLockInfo = await readLockInfo(sharedLockPath);
        if (sharedLockInfo && !isLockStale(sharedLockInfo, options.staleThreshold)) {
          validSharedLocks.push(sharedLockInfo);
        } else {
          await promises.unlink(sharedLockPath).catch(() => {
          });
        }
      }
      if (validSharedLocks.length > 0) {
        await sleep(options.retryInterval);
        continue;
      }
    } catch (error) {
      if (error.code !== "ENOENT") {
        throw error;
      }
    }
    const lockInfo = createLockInfo("exclusive");
    if (await writeLockInfo(lockPath, lockInfo)) {
      return async () => {
        await promises.unlink(lockPath).catch(() => {
        });
      };
    }
    await sleep(options.retryInterval);
  }
  throw new Error(`Timeout acquiring exclusive lock on ${filePath} after ${options.timeout}ms`);
}
async function acquireSharedLock(filePath, options) {
  const exclusiveLockPath = getLockPath(filePath);
  const sharedLockDir = getSharedLockDir(filePath);
  const sharedLockPath = path3.join(sharedLockDir, `${INSTANCE_ID}.lock`);
  const startTime = Date.now();
  while (Date.now() - startTime < options.timeout) {
    const exclusiveLock = await readLockInfo(exclusiveLockPath);
    if (exclusiveLock) {
      if (isLockStale(exclusiveLock, options.staleThreshold)) {
        await promises.unlink(exclusiveLockPath).catch(() => {
        });
      } else {
        await sleep(options.retryInterval);
        continue;
      }
    }
    await promises.mkdir(sharedLockDir, { recursive: true });
    const lockInfo = createLockInfo("shared");
    try {
      await promises.writeFile(sharedLockPath, JSON.stringify(lockInfo), { flag: "wx" });
      const recheck = await readLockInfo(exclusiveLockPath);
      if (recheck && !isLockStale(recheck, options.staleThreshold)) {
        await promises.unlink(sharedLockPath).catch(() => {
        });
        await sleep(options.retryInterval);
        continue;
      }
      return async () => {
        await promises.unlink(sharedLockPath).catch(() => {
        });
        try {
          const remaining = await promises.readdir(sharedLockDir);
          if (remaining.length === 0) {
            await promises.rmdir(sharedLockDir);
          }
        } catch {
        }
      };
    } catch (error) {
      if (error.code === "EEXIST") {
        return async () => {
          await promises.unlink(sharedLockPath).catch(() => {
          });
        };
      }
      throw error;
    }
  }
  throw new Error(`Timeout acquiring shared lock on ${filePath} after ${options.timeout}ms`);
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
async function acquireLock(filePath, options) {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  if (opts.type === "shared") {
    return acquireSharedLock(filePath, opts);
  }
  return acquireExclusiveLock(filePath, opts);
}
async function withLock(filePath, fn, options) {
  const release = await acquireLock(filePath, { ...options, type: "exclusive" });
  try {
    return await fn();
  } finally {
    await release();
  }
}
async function withSharedLock(filePath, fn, options) {
  const release = await acquireLock(filePath, { ...options, type: "shared" });
  try {
    return await fn();
  } finally {
    await release();
  }
}
var DEFAULT_OPTIONS, INSTANCE_ID;
var init_file_lock = __esm({
  "src/utils/file-lock.ts"() {
    init_esm_shims();
    DEFAULT_OPTIONS = {
      timeout: 1e4,
      retryInterval: 50,
      staleThreshold: 3e4,
      type: "exclusive"
    };
    INSTANCE_ID = `${process.pid}-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
  }
});

// src/session/storage/file-store.ts
var file_store_exports = {};
__export(file_store_exports, {
  FileSessionStore: () => FileSessionStore
});
var DEFAULT_LOCK_OPTIONS, FileSessionStore;
var init_file_store = __esm({
  "src/session/storage/file-store.ts"() {
    init_esm_shims();
    init_interface();
    init_logger();
    init_file_lock();
    DEFAULT_LOCK_OPTIONS = {
      timeout: 1e4,
      // 10 seconds
      retryInterval: 50,
      // 50ms between retries
      staleThreshold: 3e4
      // 30 seconds before lock is considered stale
    };
    FileSessionStore = class {
      baseDir;
      sessionsDir;
      metadataFile;
      config;
      metadataCache;
      initialized = false;
      lockOptions;
      /**
       * Create a new FileSessionStore
       *
       * @param baseDir - Base directory for session storage
       * @param config - Storage configuration options
       */
      constructor(baseDir, config) {
        this.baseDir = baseDir;
        this.sessionsDir = path3.join(baseDir, "sessions");
        this.metadataFile = path3.join(baseDir, "metadata", "index.json");
        this.config = { ...DEFAULT_STORAGE_CONFIG, ...config };
        this.metadataCache = /* @__PURE__ */ new Map();
        this.lockOptions = { ...DEFAULT_LOCK_OPTIONS };
      }
      /**
       * Initialize storage directories
       */
      async initialize() {
        if (this.initialized) {
          return;
        }
        try {
          await promises.mkdir(this.sessionsDir, { recursive: true });
          await promises.mkdir(path3.dirname(this.metadataFile), { recursive: true });
          await this.loadMetadataIndex();
          this.initialized = true;
          logger.info("FileSessionStore initialized", {
            baseDir: this.baseDir,
            config: this.config
          });
        } catch (error) {
          logger.error("Failed to initialize FileSessionStore", error instanceof Error ? error : new Error(String(error)), {
            baseDir: this.baseDir
          });
          throw error;
        }
      }
      /**
       * Save a session to disk (with exclusive lock)
       */
      async saveSession(session) {
        await this.ensureInitialized();
        const sessionPath = this.getSessionPath(session.id);
        try {
          await withLock(sessionPath, async () => {
            const serializable = this.prepareForSerialization(session);
            const json = this.config.serialization?.prettyPrint ? JSON.stringify(serializable, null, 2) : JSON.stringify(serializable);
            await promises.writeFile(sessionPath, json, "utf-8");
          }, this.lockOptions);
          await this.updateMetadata(session);
          logger.debug("Session saved", { sessionId: session.id, path: sessionPath });
        } catch (error) {
          logger.error("Failed to save session", error instanceof Error ? error : new Error(String(error)), {
            sessionId: session.id
          });
          throw error;
        }
      }
      /**
       * Load a session from disk (with shared lock)
       */
      async loadSession(sessionId) {
        await this.ensureInitialized();
        const sessionPath = this.getSessionPath(sessionId);
        try {
          try {
            await promises.access(sessionPath);
          } catch {
            return null;
          }
          const session = await withSharedLock(sessionPath, async () => {
            const json = await promises.readFile(sessionPath, "utf-8");
            const parsed = JSON.parse(json);
            return this.restoreFromSerialization(parsed);
          }, this.lockOptions);
          logger.debug("Session loaded", { sessionId });
          return session;
        } catch (error) {
          logger.error("Failed to load session", error instanceof Error ? error : new Error(String(error)), { sessionId });
          return null;
        }
      }
      /**
       * Delete a session from disk (with exclusive lock)
       */
      async deleteSession(sessionId) {
        await this.ensureInitialized();
        const sessionPath = this.getSessionPath(sessionId);
        try {
          try {
            await promises.access(sessionPath);
          } catch {
            return false;
          }
          await withLock(sessionPath, async () => {
            await promises.unlink(sessionPath);
          }, this.lockOptions);
          this.metadataCache.delete(sessionId);
          await this.saveMetadataIndex();
          logger.info("Session deleted", { sessionId });
          return true;
        } catch (error) {
          logger.error("Failed to delete session", error instanceof Error ? error : new Error(String(error)), { sessionId });
          return false;
        }
      }
      /**
       * List all sessions (metadata only)
       * Refreshes from disk to get updates from other instances
       */
      async listSessions() {
        await this.ensureInitialized();
        await this.loadMetadataIndex();
        return Array.from(this.metadataCache.values());
      }
      /**
       * Check if a session exists
       */
      async exists(sessionId) {
        await this.ensureInitialized();
        await this.loadMetadataIndex();
        return this.metadataCache.has(sessionId);
      }
      /**
       * Get storage statistics
       */
      async getStats() {
        await this.ensureInitialized();
        await this.loadMetadataIndex();
        const sessions = Array.from(this.metadataCache.values());
        const totalSessions = sessions.length;
        const totalThoughts = sessions.reduce((sum, s) => sum + s.thoughtCount, 0);
        let storageSize = 0;
        try {
          const files = await promises.readdir(this.sessionsDir);
          for (const file of files) {
            if (file.endsWith(".json")) {
              const filePath = path3.join(this.sessionsDir, file);
              const stats = await promises.stat(filePath);
              storageSize += stats.size;
            }
          }
        } catch (error) {
          logger.warn("Failed to calculate storage size", { error });
        }
        const dates = sessions.map((s) => new Date(s.createdAt)).sort((a, b) => a.getTime() - b.getTime());
        const averageSessionSize = totalSessions > 0 ? storageSize / totalSessions : 0;
        let storageHealth = "healthy";
        if (totalSessions > this.config.maxSessions * 0.9) {
          storageHealth = "critical";
        } else if (totalSessions > this.config.maxSessions * 0.7) {
          storageHealth = "warning";
        }
        return {
          totalSessions,
          totalThoughts,
          storageSize,
          oldestSession: dates[0],
          newestSession: dates[dates.length - 1],
          averageSessionSize,
          storageHealth
        };
      }
      /**
       * Clean up old sessions
       */
      async cleanup(maxAgeMs) {
        await this.ensureInitialized();
        await this.loadMetadataIndex();
        const now = Date.now();
        const sessions = Array.from(this.metadataCache.values());
        let cleanedCount = 0;
        for (const session of sessions) {
          const age = now - new Date(session.createdAt).getTime();
          if (age > maxAgeMs) {
            await this.deleteSession(session.id);
            cleanedCount++;
          }
        }
        if (cleanedCount > 0) {
          logger.info("Cleanup completed", {
            cleanedCount,
            maxAgeMs,
            remaining: sessions.length - cleanedCount
          });
        }
        return cleanedCount;
      }
      /**
       * Close storage (no-op for file storage)
       */
      async close() {
        logger.info("FileSessionStore closed");
        this.initialized = false;
      }
      /**
       * Get file path for a session
       */
      getSessionPath(sessionId) {
        return path3.join(this.sessionsDir, `${sessionId}.json`);
      }
      /**
       * Update metadata cache and index (with exclusive lock)
       */
      async updateMetadata(session) {
        const metadata = {
          id: session.id,
          title: session.title,
          createdAt: session.createdAt,
          updatedAt: session.updatedAt,
          thoughtCount: session.thoughts.length,
          mode: session.mode,
          isComplete: session.isComplete
        };
        this.metadataCache.set(session.id, metadata);
        await this.saveMetadataIndex();
      }
      /**
       * Load metadata index from disk (with shared lock)
       */
      async loadMetadataIndex() {
        try {
          await promises.access(this.metadataFile);
          const metadata = await withSharedLock(this.metadataFile, async () => {
            const json = await promises.readFile(this.metadataFile, "utf-8");
            const parsed = JSON.parse(json);
            return parsed.map(
              (item) => this.restoreFromSerialization(item)
            );
          }, this.lockOptions);
          this.metadataCache.clear();
          for (const meta of metadata) {
            this.metadataCache.set(meta.id, meta);
          }
          logger.debug("Metadata index loaded", {
            sessionCount: metadata.length
          });
        } catch {
          this.metadataCache.clear();
        }
      }
      /**
       * Save metadata index to disk (with exclusive lock)
       */
      async saveMetadataIndex() {
        try {
          await promises.access(this.metadataFile);
          const existingJson = await promises.readFile(this.metadataFile, "utf-8");
          const existingParsed = JSON.parse(existingJson);
          const existingMetadata = existingParsed.map(
            (item) => this.restoreFromSerialization(item)
          );
          for (const meta of existingMetadata) {
            if (!this.metadataCache.has(meta.id)) {
              const sessionPath = this.getSessionPath(meta.id);
              try {
                await promises.access(sessionPath);
                this.metadataCache.set(meta.id, meta);
              } catch {
              }
            }
          }
        } catch {
        }
        await withLock(this.metadataFile, async () => {
          const metadata = Array.from(this.metadataCache.values());
          const serializable = metadata.map((item) => this.prepareForSerialization(item));
          const json = JSON.stringify(serializable, null, 2);
          await promises.writeFile(this.metadataFile, json, "utf-8");
        }, this.lockOptions);
      }
      /**
       * Ensure storage is initialized
       */
      async ensureInitialized() {
        if (!this.initialized) {
          await this.initialize();
        }
      }
      /**
       * Prepare an object for serialization by converting special types
       * Recursively processes the object tree to handle Date and Map objects
       */
      prepareForSerialization(obj) {
        if (obj === null || obj === void 0) {
          return obj;
        }
        if (obj instanceof Date) {
          return {
            _type: "Date",
            value: obj.toISOString()
          };
        }
        if (obj instanceof Map) {
          return {
            _type: "Map",
            value: Array.from(obj.entries())
          };
        }
        if (Array.isArray(obj)) {
          return obj.map((item) => this.prepareForSerialization(item));
        }
        if (typeof obj === "object") {
          const result = {};
          for (const [key, value] of Object.entries(obj)) {
            result[key] = this.prepareForSerialization(value);
          }
          return result;
        }
        return obj;
      }
      /**
       * Restore an object from serialization by reconstructing special types
       * Recursively processes the object tree to restore Date and Map objects
       */
      restoreFromSerialization(obj) {
        if (obj === null || obj === void 0) {
          return obj;
        }
        if (typeof obj === "object" && obj._type) {
          if (obj._type === "Date") {
            return new Date(obj.value);
          }
          if (obj._type === "Map") {
            return new Map(obj.value);
          }
        }
        if (Array.isArray(obj)) {
          return obj.map((item) => this.restoreFromSerialization(item));
        }
        if (typeof obj === "object") {
          const result = {};
          for (const [key, value] of Object.entries(obj)) {
            result[key] = this.restoreFromSerialization(value);
          }
          return result;
        }
        return obj;
      }
    };
  }
});
var ThoughtFactory;
var init_ThoughtFactory = __esm({
  "src/services/ThoughtFactory.ts"() {
    init_esm_shims();
    init_type_guards();
    init_logger();
    init_handlers();
    ThoughtFactory = class {
      logger;
      registry;
      constructor(logger2) {
        this.logger = logger2 || createLogger({ minLevel: 1 /* INFO */, enableConsole: true });
        this.registry = ModeHandlerRegistry.getInstance();
        this.registerSpecializedHandlers();
      }
      /**
       * Register all specialized handlers (Phase 10 Sprint 2 + 2B)
       */
      registerSpecializedHandlers() {
        this.registry.replace(new CausalHandler());
        this.registry.replace(new BayesianHandler());
        this.registry.replace(new GameTheoryHandler());
        this.registry.replace(new CounterfactualHandler());
        this.registry.replace(new SynthesisHandler());
        this.registry.replace(new SystemsThinkingHandler());
        this.registry.replace(new CritiqueHandler());
        this.logger.debug("Specialized handlers registered", {
          count: 7,
          handlers: ["Causal", "Bayesian", "GameTheory", "Counterfactual", "Synthesis", "SystemsThinking", "Critique"]
        });
      }
      /**
       * Check if a mode has a specialized handler
       */
      hasSpecializedHandler(mode) {
        return this.registry.hasSpecializedHandler(mode);
      }
      /**
       * Get stats about registered handlers
       */
      getStats() {
        const stats = this.registry.getStats();
        return {
          specializedHandlers: stats.specializedHandlers,
          modesWithHandlers: stats.modesWithHandlers
        };
      }
      /**
       * Create a thought object based on input and mode
       *
       * Generates a properly typed thought object with mode-specific fields
       * and default values. Each mode has unique required and optional fields.
       *
       * @param input - Thought input from MCP tool
       * @param sessionId - Session ID this thought belongs to
       * @returns Typed thought object ready for session storage
       *
       * @example
       * ```typescript
       * const thought = factory.createThought({
       *   mode: 'mathematics',
       *   thought: 'Analyzing the problem...',
       *   thoughtNumber: 1,
       *   totalThoughts: 5,
       *   nextThoughtNeeded: true,
       *   mathematicalModel: { equations: ['E = mc^2'] }
       * }, 'session-123');
       * ```
       */
      createThought(input, sessionId) {
        const mode = input.mode || "hybrid" /* HYBRID */;
        this.logger.debug("Creating thought", {
          sessionId,
          mode,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          isRevision: input.isRevision,
          hasSpecializedHandler: this.registry.hasSpecializedHandler(mode)
        });
        if (this.registry.hasSpecializedHandler(mode)) {
          this.logger.debug("Using specialized handler", { mode });
          return this.registry.createThought(input, sessionId);
        }
        const baseThought = {
          id: randomUUID(),
          sessionId,
          thoughtNumber: input.thoughtNumber,
          totalThoughts: input.totalThoughts,
          content: input.thought,
          timestamp: /* @__PURE__ */ new Date(),
          nextThoughtNeeded: input.nextThoughtNeeded,
          isRevision: input.isRevision,
          revisesThought: input.revisesThought
        };
        switch (input.mode) {
          case "sequential":
            return {
              ...baseThought,
              mode: "sequential" /* SEQUENTIAL */,
              revisionReason: input.revisionReason,
              branchFrom: input.branchFrom,
              branchId: input.branchId
            };
          case "shannon":
            return {
              ...baseThought,
              mode: "shannon" /* SHANNON */,
              stage: input.stage || "problem_definition" /* PROBLEM_DEFINITION */,
              uncertainty: input.uncertainty || 0.5,
              dependencies: input.dependencies || [],
              assumptions: input.assumptions || []
            };
          case "mathematics":
            return {
              ...baseThought,
              mode: "mathematics" /* MATHEMATICS */,
              thoughtType: toExtendedThoughtType(input.thoughtType, "model"),
              mathematicalModel: input.mathematicalModel,
              proofStrategy: input.proofStrategy,
              dependencies: input.dependencies || [],
              assumptions: input.assumptions || [],
              uncertainty: input.uncertainty || 0.5
            };
          case "physics":
            return {
              ...baseThought,
              mode: "physics" /* PHYSICS */,
              thoughtType: toExtendedThoughtType(input.thoughtType, "model"),
              tensorProperties: input.tensorProperties,
              physicalInterpretation: input.physicalInterpretation,
              dependencies: input.dependencies || [],
              assumptions: input.assumptions || [],
              uncertainty: input.uncertainty || 0.5
            };
          case "inductive":
            return {
              ...baseThought,
              mode: "inductive" /* INDUCTIVE */,
              observations: input.observations || [],
              pattern: input.pattern,
              generalization: input.generalization || "",
              confidence: input.confidence ?? 0.5,
              counterexamples: input.counterexamples || [],
              sampleSize: input.sampleSize
            };
          case "deductive":
            return {
              ...baseThought,
              mode: "deductive" /* DEDUCTIVE */,
              premises: input.premises || [],
              conclusion: input.conclusion || "",
              logicForm: input.logicForm,
              validityCheck: input.validityCheck ?? false,
              soundnessCheck: input.soundnessCheck
            };
          case "abductive":
            return {
              ...baseThought,
              mode: "abductive" /* ABDUCTIVE */,
              thoughtType: toExtendedThoughtType(input.thoughtType, "problem_definition"),
              observations: input.observations || [],
              hypotheses: input.hypotheses || [],
              evaluationCriteria: input.evaluationCriteria,
              evidence: input.evidence || [],
              bestExplanation: input.bestExplanation
            };
          case "causal":
            const inputAny = input;
            const causalGraph = input.causalGraph || {
              nodes: inputAny.nodes || [],
              edges: inputAny.edges || []
            };
            return {
              ...baseThought,
              mode: "causal" /* CAUSAL */,
              thoughtType: toExtendedThoughtType(input.thoughtType, "problem_definition"),
              causalGraph,
              interventions: input.interventions || [],
              mechanisms: input.mechanisms || [],
              confounders: input.confounders || []
            };
          case "bayesian":
            return {
              ...baseThought,
              mode: "bayesian" /* BAYESIAN */,
              thoughtType: toExtendedThoughtType(input.thoughtType, "problem_definition"),
              hypothesis: input.hypothesis,
              prior: input.prior,
              likelihood: input.likelihood,
              evidence: input.evidence || [],
              posterior: input.posterior,
              bayesFactor: input.bayesFactor
            };
          case "counterfactual":
            return {
              ...baseThought,
              mode: "counterfactual" /* COUNTERFACTUAL */,
              thoughtType: toExtendedThoughtType(input.thoughtType, "problem_definition"),
              actual: input.actual,
              counterfactuals: input.counterfactuals || [],
              comparison: input.comparison,
              interventionPoint: input.interventionPoint,
              causalChains: input.causalChains || []
            };
          case "analogical":
            return {
              ...baseThought,
              mode: "analogical" /* ANALOGICAL */,
              thoughtType: toExtendedThoughtType(input.thoughtType, "analogy"),
              sourceDomain: input.sourceDomain,
              targetDomain: input.targetDomain,
              mapping: input.mapping || [],
              insights: input.insights || [],
              inferences: input.inferences || [],
              limitations: input.limitations || [],
              analogyStrength: input.analogyStrength
            };
          case "temporal":
            return {
              ...baseThought,
              mode: "temporal" /* TEMPORAL */,
              thoughtType: input.thoughtType || "event_definition",
              timeline: input.timeline,
              events: input.events || [],
              intervals: input.intervals || [],
              constraints: input.constraints || [],
              relations: input.relations || []
            };
          case "gametheory":
            return {
              ...baseThought,
              mode: "gametheory" /* GAMETHEORY */,
              thoughtType: input.thoughtType || "game_definition",
              game: input.game,
              players: input.players || [],
              strategies: input.strategies || [],
              payoffMatrix: input.payoffMatrix,
              nashEquilibria: input.nashEquilibria || [],
              dominantStrategies: input.dominantStrategies || [],
              gameTree: input.gameTree
            };
          case "evidential":
            return {
              ...baseThought,
              mode: "evidential" /* EVIDENTIAL */,
              thoughtType: input.thoughtType || "hypothesis_definition",
              frameOfDiscernment: input.frameOfDiscernment,
              hypotheses: input.hypotheses || [],
              evidence: input.evidence || [],
              beliefFunctions: input.beliefFunctions || [],
              combinedBelief: input.combinedBelief,
              plausibility: input.plausibility,
              decisions: input.decisions || []
            };
          case "firstprinciples" /* FIRSTPRINCIPLES */:
            return {
              ...baseThought,
              mode: "firstprinciples" /* FIRSTPRINCIPLES */,
              question: input.question || "",
              principles: input.principles || [],
              derivationSteps: input.derivationSteps || [],
              conclusion: input.conclusion || { statement: "", derivationChain: [], certainty: 0 },
              alternativeInterpretations: input.alternativeInterpretations || []
            };
          case "metareasoning": {
            const metaInput = input;
            return {
              ...baseThought,
              mode: "metareasoning" /* METAREASONING */,
              currentStrategy: metaInput.currentStrategy || {
                mode: "sequential" /* SEQUENTIAL */,
                approach: "Default sequential approach",
                startedAt: /* @__PURE__ */ new Date(),
                thoughtsSpent: 0,
                progressIndicators: []
              },
              strategyEvaluation: metaInput.strategyEvaluation || {
                effectiveness: 0.5,
                efficiency: 0.5,
                confidence: 0.5,
                progressRate: 0,
                qualityScore: 0.5,
                issues: [],
                strengths: []
              },
              alternativeStrategies: metaInput.alternativeStrategies || [],
              recommendation: metaInput.recommendation || {
                action: "CONTINUE",
                justification: "No specific recommendation yet",
                confidence: 0.5,
                expectedImprovement: "Monitor progress"
              },
              resourceAllocation: metaInput.resourceAllocation || {
                timeSpent: 0,
                thoughtsRemaining: input.totalThoughts - input.thoughtNumber,
                complexityLevel: "medium",
                urgency: "medium",
                recommendation: "Continue with current approach"
              },
              qualityMetrics: metaInput.qualityMetrics || {
                logicalConsistency: 0.5,
                evidenceQuality: 0.5,
                completeness: 0.5,
                originality: 0.5,
                clarity: 0.5,
                overallQuality: 0.5
              },
              sessionContext: metaInput.sessionContext || {
                sessionId,
                totalThoughts: input.thoughtNumber,
                modesUsed: [input.mode],
                modeSwitches: 0,
                problemType: "general"
              }
            };
          }
          case "engineering": {
            const engInput = input;
            return {
              ...baseThought,
              mode: "engineering" /* ENGINEERING */,
              analysisType: engInput.analysisType || "comprehensive",
              designChallenge: engInput.designChallenge || input.thought,
              requirements: engInput.requirements,
              tradeStudy: engInput.tradeStudy,
              fmea: engInput.fmea,
              designDecisions: engInput.designDecisions,
              assessment: engInput.assessment
            };
          }
          // ===== Phase 11 v7.2.0 - Turing's legacy =====
          case "computability": {
            const compInput = input;
            return {
              ...baseThought,
              mode: "computability" /* COMPUTABILITY */,
              thoughtType: compInput.thoughtType || "machine_definition",
              machines: compInput.machines || [],
              currentMachine: compInput.currentMachine,
              computationTrace: compInput.computationTrace,
              problems: compInput.problems || [],
              currentProblem: compInput.currentProblem,
              reductions: compInput.reductions || [],
              reductionChain: compInput.reductionChain || [],
              decidabilityProof: compInput.decidabilityProof,
              diagonalization: compInput.diagonalization,
              complexityAnalysis: compInput.complexityAnalysis,
              oracleAnalysis: compInput.oracleAnalysis,
              dependencies: compInput.dependencies || [],
              assumptions: compInput.assumptions || [],
              uncertainty: compInput.uncertainty ?? 0.5,
              classicProblems: compInput.classicProblems || [],
              keyInsight: compInput.keyInsight
            };
          }
          case "cryptanalytic": {
            const cryptInput = input;
            return {
              ...baseThought,
              mode: "cryptanalytic" /* CRYPTANALYTIC */,
              thoughtType: cryptInput.thoughtType || "hypothesis_formation",
              ciphertext: cryptInput.ciphertext,
              plaintext: cryptInput.plaintext,
              hypotheses: cryptInput.hypotheses || [],
              currentHypothesis: cryptInput.currentHypothesis,
              evidenceChains: cryptInput.evidenceChains || [],
              keySpaceAnalysis: cryptInput.keySpaceAnalysis,
              frequencyAnalysis: cryptInput.frequencyAnalysis,
              banburismusAnalysis: cryptInput.banburismusAnalysis || [],
              cribAnalysis: cryptInput.cribAnalysis || [],
              patterns: cryptInput.patterns || [],
              cipherType: cryptInput.cipherType,
              dependencies: cryptInput.dependencies || [],
              assumptions: cryptInput.assumptions || [],
              uncertainty: cryptInput.uncertainty ?? 0.5,
              keyInsight: cryptInput.keyInsight
            };
          }
          // ===== Phase 12 v7.3.0 - CLRS algorithms =====
          case "algorithmic": {
            const algoInput = input;
            return {
              ...baseThought,
              mode: "algorithmic" /* ALGORITHMIC */,
              thoughtType: algoInput.thoughtType || "algorithm_definition",
              algorithm: algoInput.algorithm,
              clrsCategory: algoInput.clrsCategory,
              clrsAlgorithm: algoInput.clrsAlgorithm,
              designPattern: algoInput.designPattern,
              timeComplexity: algoInput.timeComplexity,
              spaceComplexity: algoInput.spaceComplexity,
              recurrence: algoInput.recurrence,
              correctnessProof: algoInput.correctnessProof,
              loopInvariants: algoInput.loopInvariants || [],
              dpFormulation: algoInput.dpFormulation,
              greedyProof: algoInput.greedyProof,
              graphContext: algoInput.graphContext,
              dataStructure: algoInput.dataStructure,
              amortizedAnalysis: algoInput.amortizedAnalysis,
              comparison: algoInput.comparison,
              dependencies: algoInput.dependencies || [],
              assumptions: algoInput.assumptions || [],
              uncertainty: algoInput.uncertainty ?? 0.5,
              keyInsight: algoInput.keyInsight,
              pseudocode: algoInput.pseudocode,
              executionTrace: algoInput.executionTrace
            };
          }
          // ===== Phase 4 v3.2.0 - Scientific modes =====
          case "systemsthinking": {
            const sysInput = input;
            return {
              ...baseThought,
              mode: "systemsthinking" /* SYSTEMSTHINKING */,
              thoughtType: sysInput.thoughtType || "system_definition",
              system: sysInput.system,
              components: sysInput.components || [],
              feedbackLoops: sysInput.feedbackLoops || [],
              leveragePoints: sysInput.leveragePoints || [],
              behaviors: sysInput.behaviors || []
            };
          }
          case "scientificmethod": {
            const sciInput = input;
            return {
              ...baseThought,
              mode: "scientificmethod" /* SCIENTIFICMETHOD */,
              thoughtType: sciInput.thoughtType || "question_formulation",
              researchQuestion: sciInput.researchQuestion,
              scientificHypotheses: sciInput.scientificHypotheses || [],
              experiment: sciInput.experiment,
              data: sciInput.data,
              analysis: sciInput.analysis,
              conclusion: sciInput.conclusion
            };
          }
          case "formallogic": {
            const logicInput = input;
            return {
              ...baseThought,
              mode: "formallogic" /* FORMALLOGIC */,
              thoughtType: logicInput.thoughtType || "proposition_definition",
              propositions: logicInput.propositions || [],
              logicalInferences: logicInput.logicalInferences || [],
              proof: logicInput.proof,
              truthTable: logicInput.truthTable,
              satisfiability: logicInput.satisfiability
            };
          }
          case "optimization": {
            const optInput = input;
            return {
              ...baseThought,
              mode: "optimization" /* OPTIMIZATION */,
              thoughtType: optInput.thoughtType || "problem_formulation",
              objectiveFunction: optInput.objectiveFunction,
              constraints: optInput.constraints || [],
              variables: optInput.variables || [],
              solution: optInput.solution,
              method: optInput.method,
              convergence: optInput.convergence,
              sensitivity: optInput.sensitivity
            };
          }
          // ===== Phase 13 v7.4.0 - Academic Research modes =====
          case "synthesis": {
            const synthInput = input;
            return {
              ...baseThought,
              mode: "synthesis" /* SYNTHESIS */,
              thoughtType: synthInput.thoughtType || "source_identification",
              sources: synthInput.sources || [],
              reviewMetadata: synthInput.reviewMetadata,
              concepts: synthInput.concepts || [],
              themes: synthInput.themes || [],
              findings: synthInput.findings || [],
              patterns: synthInput.patterns || [],
              relations: synthInput.relations || [],
              gaps: synthInput.gaps || [],
              contradictions: synthInput.contradictions || [],
              framework: synthInput.framework,
              conclusions: synthInput.conclusions || [],
              dependencies: synthInput.dependencies || [],
              assumptions: synthInput.assumptions || [],
              uncertainty: synthInput.uncertainty ?? 0.5,
              keyInsight: synthInput.keyInsight
            };
          }
          case "argumentation": {
            const argInput = input;
            return {
              ...baseThought,
              mode: "argumentation" /* ARGUMENTATION */,
              thoughtType: argInput.thoughtType || "claim_formulation",
              claims: argInput.claims || [],
              currentClaim: argInput.currentClaim,
              grounds: argInput.grounds || [],
              warrants: argInput.warrants || [],
              backings: argInput.backings || [],
              qualifiers: argInput.qualifiers || [],
              rebuttals: argInput.rebuttals || [],
              arguments: argInput.arguments || [],
              currentArgument: argInput.currentArgument,
              argumentChain: argInput.argumentChain,
              dialectic: argInput.dialectic,
              rhetoricalStrategies: argInput.rhetoricalStrategies || [],
              audienceConsideration: argInput.audienceConsideration,
              fallacies: argInput.fallacies || [],
              argumentStrength: argInput.argumentStrength ?? 0.5,
              dependencies: argInput.dependencies || [],
              assumptions: argInput.assumptions || [],
              uncertainty: argInput.uncertainty ?? 0.5,
              keyInsight: argInput.keyInsight
            };
          }
          case "critique": {
            const critInput = input;
            return {
              ...baseThought,
              mode: "critique" /* CRITIQUE */,
              thoughtType: critInput.thoughtType || "work_characterization",
              work: critInput.work || {
                id: randomUUID(),
                title: "Untitled Work",
                authors: [],
                year: (/* @__PURE__ */ new Date()).getFullYear(),
                type: "empirical_study",
                field: "Unknown",
                claimedContribution: ""
              },
              methodologyEvaluation: critInput.methodologyEvaluation,
              argumentCritique: critInput.argumentCritique,
              evidenceCritique: critInput.evidenceCritique,
              contributionEvaluation: critInput.contributionEvaluation,
              critiquePoints: critInput.critiquePoints || [],
              improvements: critInput.improvements || [],
              verdict: critInput.verdict,
              strengthsIdentified: critInput.strengthsIdentified ?? 0,
              weaknessesIdentified: critInput.weaknessesIdentified ?? 0,
              balanceRatio: critInput.balanceRatio ?? 1,
              dependencies: critInput.dependencies || [],
              assumptions: critInput.assumptions || [],
              uncertainty: critInput.uncertainty ?? 0.5,
              keyInsight: critInput.keyInsight
            };
          }
          case "analysis": {
            const analInput = input;
            return {
              ...baseThought,
              mode: "analysis" /* ANALYSIS */,
              thoughtType: analInput.thoughtType || "data_familiarization",
              methodology: analInput.methodology || "thematic_analysis",
              dataSources: analInput.dataSources || [],
              dataSegments: analInput.dataSegments || [],
              totalSegments: analInput.totalSegments,
              codebook: analInput.codebook,
              currentCodes: analInput.currentCodes || [],
              codingProgress: analInput.codingProgress,
              themes: analInput.themes || [],
              thematicMap: analInput.thematicMap,
              memos: analInput.memos || [],
              gtCategories: analInput.gtCategories || [],
              theoreticalSampling: analInput.theoreticalSampling || [],
              discoursePatterns: analInput.discoursePatterns || [],
              rigorAssessment: analInput.rigorAssessment,
              dependencies: analInput.dependencies || [],
              assumptions: analInput.assumptions || [],
              uncertainty: analInput.uncertainty ?? 0.5,
              keyInsight: analInput.keyInsight
            };
          }
          case "hybrid":
          default:
            return {
              ...baseThought,
              mode: "hybrid" /* HYBRID */,
              thoughtType: toExtendedThoughtType(input.thoughtType, "synthesis"),
              stage: input.stage,
              uncertainty: input.uncertainty,
              dependencies: input.dependencies,
              assumptions: input.assumptions,
              mathematicalModel: input.mathematicalModel,
              tensorProperties: input.tensorProperties,
              physicalInterpretation: input.physicalInterpretation,
              primaryMode: input.mode || "hybrid" /* HYBRID */,
              secondaryFeatures: []
            };
        }
      }
    };
  }
});

// src/services/RefactoredThoughtFactory.ts
var RefactoredThoughtFactory;
var init_RefactoredThoughtFactory = __esm({
  "src/services/RefactoredThoughtFactory.ts"() {
    init_esm_shims();
    init_ThoughtFactory();
    init_handlers();
    init_logger();
    RefactoredThoughtFactory = class {
      registry;
      legacyFactory;
      useRegistryForAll;
      logger;
      constructor(config = {}) {
        this.registry = ModeHandlerRegistry.getInstance();
        this.legacyFactory = new ThoughtFactory();
        this.useRegistryForAll = config.useRegistryForAll ?? false;
        this.logger = config.logger || createLogger({ minLevel: 1 /* INFO */, enableConsole: true });
        if (config.autoRegisterHandlers !== false) {
          this.registerSpecializedHandlers();
        }
      }
      /**
       * Register all specialized handlers
       *
       * Called automatically during construction unless disabled.
       * Uses replace() to allow re-registration without errors.
       */
      registerSpecializedHandlers() {
        this.logger.debug("Registering specialized handlers");
        this.registry.replace(new CausalHandler());
        this.registry.replace(new BayesianHandler());
        this.registry.replace(new GameTheoryHandler());
        this.registry.replace(new CounterfactualHandler());
        this.registry.replace(new SynthesisHandler());
        this.registry.replace(new SystemsThinkingHandler());
        this.registry.replace(new CritiqueHandler());
        this.logger.debug("Specialized handlers registered", {
          handlers: [
            "CausalHandler",
            "BayesianHandler",
            "GameTheoryHandler",
            "CounterfactualHandler",
            "SynthesisHandler",
            "SystemsThinkingHandler",
            "CritiqueHandler"
          ]
        });
      }
      /**
       * Create a thought object from input
       *
       * Routes to appropriate handler based on mode and configuration:
       * - If specialized handler exists, use it
       * - If useRegistryForAll is true, use generic handler from registry
       * - Otherwise, fall back to legacy ThoughtFactory
       *
       * @param input - Tool input
       * @param sessionId - Session ID
       * @returns Created thought
       */
      createThought(input, sessionId) {
        const mode = input.mode || "hybrid" /* HYBRID */;
        this.logger.debug("Creating thought", {
          sessionId,
          mode,
          hasSpecializedHandler: this.registry.hasSpecializedHandler(mode),
          useRegistryForAll: this.useRegistryForAll
        });
        if (this.shouldUseRegistry(mode)) {
          this.logger.debug("Using registry handler", { mode });
          return this.registry.createThought(input, sessionId);
        }
        this.logger.debug("Using legacy factory", { mode });
        return this.legacyFactory.createThought(input, sessionId);
      }
      /**
       * Validate input using appropriate handler
       *
       * @param input - Tool input to validate
       * @returns Validation result
       */
      validate(input) {
        const mode = input.mode || "hybrid" /* HYBRID */;
        if (this.shouldUseRegistry(mode)) {
          return this.registry.validate(input);
        }
        return this.registry.validate(input);
      }
      /**
       * Get mode status for API response
       *
       * @param mode - The thinking mode
       * @returns Mode status information
       */
      getModeStatus(mode) {
        return this.registry.getModeStatus(mode);
      }
      /**
       * Check if a specialized handler exists for a mode
       *
       * @param mode - The thinking mode
       * @returns true if specialized handler is registered
       */
      hasSpecializedHandler(mode) {
        return this.registry.hasSpecializedHandler(mode);
      }
      /**
       * Get the underlying registry for direct access
       *
       * Use this to register new handlers or access registry stats.
       *
       * @returns The ModeHandlerRegistry instance
       */
      getRegistry() {
        return this.registry;
      }
      /**
       * Get registry statistics
       */
      getStats() {
        return this.registry.getStats();
      }
      /**
       * Determine if registry should be used for a mode
       */
      shouldUseRegistry(mode) {
        if (this.registry.hasSpecializedHandler(mode)) {
          return true;
        }
        if (this.useRegistryForAll) {
          return true;
        }
        return false;
      }
    };
  }
});

// src/export/visual/utils.ts
function sanitizeId(id) {
  return id.replace(/[^a-zA-Z0-9_]/g, "_");
}
var init_utils = __esm({
  "src/export/visual/utils.ts"() {
    init_esm_shims();
  }
});

// src/export/visual/mermaid-utils.ts
function sanitizeMermaidId(id) {
  return id.replace(/[^a-zA-Z0-9_]/g, "_").replace(/^(\d)/, "_$1").replace(/__+/g, "_").replace(/^_+|_+$/g, "") || "node";
}
function escapeMermaidLabel(label) {
  return label.replace(/"/g, "#quot;").replace(/</g, "#lt;").replace(/>/g, "#gt;").replace(/\[/g, "#91;").replace(/\]/g, "#93;").replace(/\{/g, "#123;").replace(/\}/g, "#125;").replace(/\(/g, "#40;").replace(/\)/g, "#41;").replace(/\|/g, "#124;").replace(/\n/g, "<br/>");
}
function truncateLabel(label, maxLength = 40) {
  if (label.length <= maxLength) return label;
  return label.substring(0, maxLength - 3) + "...";
}
function getNodeShapeBrackets(shape) {
  switch (shape) {
    case "rectangle":
      return ["[", "]"];
    case "rounded":
      return ["(", ")"];
    case "stadium":
      return ["([", "])"];
    case "subroutine":
      return ["[[", "]]"];
    case "cylinder":
      return ["[(", ")]"];
    case "circle":
      return ["((", "))"];
    case "asymmetric":
      return [">", "]"];
    case "rhombus":
      return ["{", "}"];
    case "hexagon":
      return ["{{", "}}"];
    case "parallelogram":
      return ["[/", "/]"];
    case "parallelogram-alt":
      return ["[\\", "\\]"];
    case "trapezoid":
      return ["[/", "\\]"];
    case "trapezoid-alt":
      return ["[\\", "/]"];
    case "double-circle":
      return ["(((", ")))"];
    default:
      return ["[", "]"];
  }
}
function renderMermaidNode(node) {
  const id = sanitizeMermaidId(node.id);
  const label = escapeMermaidLabel(node.label);
  const [open, close] = getNodeShapeBrackets(node.shape || "rectangle");
  let nodeStr = `  ${id}${open}"${label}"${close}`;
  if (node.className) {
    nodeStr += `:::${node.className}`;
  }
  return nodeStr;
}
function renderMermaidNodeStyle(nodeId, style) {
  if (!style) return "";
  const id = sanitizeMermaidId(nodeId);
  const styles = [];
  if (style.fill) styles.push(`fill:${style.fill}`);
  if (style.stroke) styles.push(`stroke:${style.stroke}`);
  if (style.strokeWidth) styles.push(`stroke-width:${style.strokeWidth}`);
  if (style.color) styles.push(`color:${style.color}`);
  if (styles.length === 0) return "";
  return `  style ${id} ${styles.join(",")}`;
}
function getEdgeArrow(style) {
  switch (style) {
    case "arrow":
      return "-->";
    case "open":
      return "---";
    case "dotted":
      return "-.->";
    case "thick":
      return "==>";
    case "invisible":
      return "~~~";
    default:
      return "-->";
  }
}
function renderMermaidEdge(edge) {
  const source = sanitizeMermaidId(edge.source);
  const target = sanitizeMermaidId(edge.target);
  const arrow = getEdgeArrow(edge.style || "arrow");
  if (edge.label) {
    const label = escapeMermaidLabel(edge.label);
    return `  ${source} ${arrow}|${label}| ${target}`;
  }
  return `  ${source} ${arrow} ${target}`;
}
function getMermaidColor(type, scheme = "default") {
  return MERMAID_COLORS[scheme][type];
}
function generateMermaidFlowchart(nodes, edges, options = {}) {
  const { direction = "TD", colorScheme = "default" } = options;
  const lines = [];
  lines.push(`graph ${direction}`);
  if (nodes.length > 0) {
    lines.push("");
    for (const node of nodes) {
      lines.push(renderMermaidNode(node));
    }
  }
  if (edges.length > 0) {
    lines.push("");
    for (const edge of edges) {
      lines.push(renderMermaidEdge(edge));
    }
  }
  if (colorScheme !== "monochrome") {
    const styledNodes = nodes.filter((n) => n.style);
    if (styledNodes.length > 0) {
      lines.push("");
      for (const node of styledNodes) {
        const styleStr = renderMermaidNodeStyle(node.id, node.style);
        if (styleStr) lines.push(styleStr);
      }
    }
  }
  return lines.join("\n");
}
var MERMAID_COLORS;
var init_mermaid_utils = __esm({
  "src/export/visual/mermaid-utils.ts"() {
    init_esm_shims();
    MERMAID_COLORS = {
      default: {
        primary: "#a8d5ff",
        secondary: "#ffd699",
        success: "#81c784",
        warning: "#ffb74d",
        danger: "#e57373",
        info: "#4fc3f7",
        neutral: "#e0e0e0"
      },
      pastel: {
        primary: "#e1f5ff",
        secondary: "#fff3e0",
        success: "#c8e6c9",
        warning: "#ffecb3",
        danger: "#ffcdd2",
        info: "#b3e5fc",
        neutral: "#f5f5f5"
      },
      monochrome: {
        primary: "#e0e0e0",
        secondary: "#bdbdbd",
        success: "#9e9e9e",
        warning: "#757575",
        danger: "#616161",
        info: "#424242",
        neutral: "#f5f5f5"
      }
    };
  }
});

// src/export/visual/dot-utils.ts
function sanitizeDotId(id) {
  if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(id)) {
    return id;
  }
  return `"${escapeDotString(id)}"`;
}
function escapeDotString(str) {
  return str.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
}
function truncateDotLabel(label, maxLength = 50) {
  if (label.length <= maxLength) return label;
  return label.substring(0, maxLength - 3) + "...";
}
function renderDotNodeAttrs(node) {
  const attrs = [];
  if (node.label !== void 0) {
    attrs.push(`label="${escapeDotString(node.label)}"`);
  }
  if (node.shape) {
    attrs.push(`shape=${node.shape}`);
  }
  if (node.style) {
    const styleStr = Array.isArray(node.style) ? node.style.join(",") : node.style;
    attrs.push(`style="${styleStr}"`);
  }
  if (node.fillColor) {
    attrs.push(`fillcolor="${node.fillColor}"`);
  }
  if (node.color) {
    attrs.push(`color="${node.color}"`);
  }
  if (node.fontColor) {
    attrs.push(`fontcolor="${node.fontColor}"`);
  }
  if (node.fontName) {
    attrs.push(`fontname="${node.fontName}"`);
  }
  if (node.fontSize) {
    attrs.push(`fontsize=${node.fontSize}`);
  }
  if (node.width) {
    attrs.push(`width=${node.width}`);
  }
  if (node.height) {
    attrs.push(`height=${node.height}`);
  }
  if (node.tooltip) {
    attrs.push(`tooltip="${escapeDotString(node.tooltip)}"`);
  }
  if (node.url) {
    attrs.push(`URL="${escapeDotString(node.url)}"`);
  }
  return attrs.length > 0 ? ` [${attrs.join(", ")}]` : "";
}
function renderDotEdgeAttrs(edge) {
  const attrs = [];
  if (edge.label) {
    attrs.push(`label="${escapeDotString(edge.label)}"`);
  }
  if (edge.style) {
    attrs.push(`style=${edge.style}`);
  }
  if (edge.color) {
    attrs.push(`color="${edge.color}"`);
  }
  if (edge.fontColor) {
    attrs.push(`fontcolor="${edge.fontColor}"`);
  }
  if (edge.arrowHead) {
    attrs.push(`arrowhead=${edge.arrowHead}`);
  }
  if (edge.arrowTail) {
    attrs.push(`arrowtail=${edge.arrowTail}`);
  }
  if (edge.constraint === false) {
    attrs.push("constraint=false");
  }
  if (edge.weight !== void 0) {
    attrs.push(`weight=${edge.weight}`);
  }
  if (edge.penWidth !== void 0) {
    attrs.push(`penwidth=${edge.penWidth}`);
  }
  if (edge.tooltip) {
    attrs.push(`tooltip="${escapeDotString(edge.tooltip)}"`);
  }
  return attrs.length > 0 ? ` [${attrs.join(", ")}]` : "";
}
function renderDotNode(node) {
  const id = sanitizeDotId(node.id);
  const attrs = renderDotNodeAttrs(node);
  return `  ${id}${attrs};`;
}
function renderDotEdge(edge, directed = true) {
  const source = sanitizeDotId(edge.source);
  const target = sanitizeDotId(edge.target);
  const arrow = directed ? "->" : "--";
  const attrs = renderDotEdgeAttrs(edge);
  return `  ${source} ${arrow} ${target}${attrs};`;
}
function generateDotGraph(nodes, edges, options = {}) {
  const {
    graphType = "digraph",
    graphName = "G",
    rankDir = "TB",
    splines,
    overlap,
    concentrate,
    compound,
    bgcolor,
    fontName,
    fontSize,
    nodeDefaults,
    edgeDefaults
  } = options;
  const lines = [];
  const directed = graphType === "digraph";
  lines.push(`${graphType} ${sanitizeDotId(graphName)} {`);
  lines.push(`  rankdir=${rankDir};`);
  if (splines) lines.push(`  splines=${splines};`);
  if (overlap !== void 0) lines.push(`  overlap=${overlap};`);
  if (concentrate) lines.push("  concentrate=true;");
  if (compound) lines.push("  compound=true;");
  if (bgcolor) lines.push(`  bgcolor="${bgcolor}";`);
  if (fontName) lines.push(`  fontname="${fontName}";`);
  if (fontSize) lines.push(`  fontsize=${fontSize};`);
  if (nodeDefaults) {
    const defaultAttrs = [];
    if (nodeDefaults.shape) defaultAttrs.push(`shape=${nodeDefaults.shape}`);
    if (nodeDefaults.style) {
      const styleStr = Array.isArray(nodeDefaults.style) ? nodeDefaults.style.join(",") : nodeDefaults.style;
      defaultAttrs.push(`style="${styleStr}"`);
    }
    if (nodeDefaults.fillColor) defaultAttrs.push(`fillcolor="${nodeDefaults.fillColor}"`);
    if (nodeDefaults.fontName) defaultAttrs.push(`fontname="${nodeDefaults.fontName}"`);
    if (nodeDefaults.fontSize) defaultAttrs.push(`fontsize=${nodeDefaults.fontSize}`);
    if (defaultAttrs.length > 0) {
      lines.push(`  node [${defaultAttrs.join(", ")}];`);
    }
  }
  if (edgeDefaults) {
    const defaultAttrs = [];
    if (edgeDefaults.style) defaultAttrs.push(`style=${edgeDefaults.style}`);
    if (edgeDefaults.color) defaultAttrs.push(`color="${edgeDefaults.color}"`);
    if (edgeDefaults.arrowHead) defaultAttrs.push(`arrowhead=${edgeDefaults.arrowHead}`);
    if (defaultAttrs.length > 0) {
      lines.push(`  edge [${defaultAttrs.join(", ")}];`);
    }
  }
  lines.push("");
  for (const node of nodes) {
    lines.push(renderDotNode(node));
  }
  if (edges.length > 0) {
    lines.push("");
    for (const edge of edges) {
      lines.push(renderDotEdge(edge, directed));
    }
  }
  lines.push("}");
  return lines.join("\n");
}
var init_dot_utils = __esm({
  "src/export/visual/dot-utils.ts"() {
    init_esm_shims();
  }
});

// src/export/visual/ascii-utils.ts
function generateAsciiHeader(title, style = "equals") {
  const underlineChar = style === "double" ? "\u2550" : style === "equals" ? "=" : style === "single" ? "\u2500" : "-";
  const underline = underlineChar.repeat(title.length);
  return `${title}
${underline}`;
}
function generateAsciiSectionHeader(title, icon) {
  const prefix = "";
  return `${prefix}${title}:
${"-".repeat((prefix + title + ":").length)}`;
}
function generateAsciiBulletList(items, bullet = "bullet", indent = 2) {
  const bulletChar = BULLETS[bullet];
  const indentStr = " ".repeat(indent);
  return items.map((item) => `${indentStr}${bulletChar} ${item}`).join("\n");
}
var BULLETS;
var init_ascii_utils = __esm({
  "src/export/visual/ascii-utils.ts"() {
    init_esm_shims();
    BULLETS = {
      circle: "\u25CB",
      filledCircle: "\u25CF",
      square: "\u25A1",
      filledSquare: "\u25A0",
      diamond: "\u25C7",
      filledDiamond: "\u25C6",
      triangle: "\u25B3",
      filledTriangle: "\u25B2",
      star: "\u2606",
      filledStar: "\u2605",
      check: "\u2713",
      cross: "\u2717",
      dash: "\u2500",
      bullet: "\u2022",
      asciiBullet: "*",
      asciiDash: "-"
    };
  }
});

// src/export/visual/svg-utils.ts
function getNodeColor(type, colorScheme = "default") {
  const palette = COLOR_PALETTES[colorScheme] || COLOR_PALETTES.default;
  return palette[type] || palette.neutral;
}
function escapeSVGText(text) {
  return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
}
function truncateText(text, maxChars = 30) {
  if (text.length <= maxChars) return text;
  return text.substring(0, maxChars - 3) + "...";
}
function generateSVGHeader(width, height, title) {
  return `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${width} ${height}" width="${width}" height="${height}">
  <defs>
    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" fill="#333"/>
    </marker>
    <marker id="arrowhead-red" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" fill="#e53935"/>
    </marker>
    <marker id="arrowhead-green" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" fill="#388e3c"/>
    </marker>
    <marker id="arrowhead-blue" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" fill="#1976d2"/>
    </marker>
  </defs>

  <style>
    .title { font-family: Arial, sans-serif; font-size: 16px; font-weight: bold; }
    .subtitle { font-family: Arial, sans-serif; font-size: 12px; fill: #666; font-style: italic; }
    .node-label { font-family: Arial, sans-serif; font-size: 12px; }
    .edge-label { font-family: Arial, sans-serif; font-size: 10px; fill: #666; }
    .metrics { font-family: Arial, sans-serif; font-size: 11px; fill: #444; }
    .legend-text { font-family: Arial, sans-serif; font-size: 10px; }
  </style>

  <!-- Background -->
  <rect width="100%" height="100%" fill="#fafafa"/>
${title ? `
  <!-- Title -->
  <text x="${width / 2}" y="25" text-anchor="middle" class="title">${escapeSVGText(truncateText(title, 60))}</text>
` : ""}`;
}
function generateSVGFooter() {
  return "</svg>";
}
function renderRectNode(pos, colors, rx = 8) {
  const escapedLabel = escapeSVGText(truncateText(pos.label, 25));
  return `
    <g class="node" data-id="${pos.id}">
      <rect x="${pos.x}" y="${pos.y}" width="${pos.width}" height="${pos.height}"
            rx="${rx}" ry="${rx}" fill="${colors.fill}" stroke="${colors.stroke}" stroke-width="2"/>
      <text x="${pos.x + pos.width / 2}" y="${pos.y + pos.height / 2 + 5}"
            text-anchor="middle" class="node-label">${escapedLabel}</text>
    </g>`;
}
function renderStadiumNode(pos, colors) {
  const escapedLabel = escapeSVGText(truncateText(pos.label, 25));
  return `
    <g class="node" data-id="${pos.id}">
      <rect x="${pos.x}" y="${pos.y}" width="${pos.width}" height="${pos.height}"
            rx="20" ry="20" fill="${colors.fill}" stroke="${colors.stroke}" stroke-width="2"/>
      <text x="${pos.x + pos.width / 2}" y="${pos.y + pos.height / 2 + 5}"
            text-anchor="middle" class="node-label">${escapedLabel}</text>
    </g>`;
}
function renderDiamondNode(pos, colors) {
  const cx = pos.x + pos.width / 2;
  const cy = pos.y + pos.height / 2;
  const escapedLabel = escapeSVGText(truncateText(pos.label, 20));
  return `
    <g class="node" data-id="${pos.id}">
      <polygon points="${cx},${pos.y} ${pos.x + pos.width},${cy} ${cx},${pos.y + pos.height} ${pos.x},${cy}"
               fill="${colors.fill}" stroke="${colors.stroke}" stroke-width="2"/>
      <text x="${cx}" y="${cy + 5}"
            text-anchor="middle" class="node-label">${escapedLabel}</text>
    </g>`;
}
function renderEllipseNode(pos, colors) {
  const cx = pos.x + pos.width / 2;
  const cy = pos.y + pos.height / 2;
  const escapedLabel = escapeSVGText(truncateText(pos.label, 20));
  return `
    <g class="node" data-id="${pos.id}">
      <ellipse cx="${cx}" cy="${cy}" rx="${pos.width / 2}" ry="${pos.height / 2}"
               fill="${colors.fill}" stroke="${colors.stroke}" stroke-width="2"/>
      <text x="${cx}" y="${cy + 5}"
            text-anchor="middle" class="node-label">${escapedLabel}</text>
    </g>`;
}
function renderEdge(fromPos, toPos, options = {}) {
  const { label, style = "solid", color = "#333333", markerEnd = "arrowhead" } = options;
  const fromX = fromPos.x + fromPos.width / 2;
  const fromY = fromPos.y + fromPos.height;
  const toX = toPos.x + toPos.width / 2;
  const toY = toPos.y;
  const midY = (fromY + toY) / 2;
  const path4 = `M ${fromX} ${fromY} C ${fromX} ${midY}, ${toX} ${midY}, ${toX} ${toY - 8}`;
  const dashStyle = style === "dashed" ? 'stroke-dasharray="8,4"' : style === "dotted" ? 'stroke-dasharray="2,2"' : "";
  const labelElement = label ? `<text x="${(fromX + toX) / 2}" y="${midY - 5}" text-anchor="middle" class="edge-label">${escapeSVGText(label)}</text>` : "";
  return `
    <g class="edge">
      <path d="${path4}" fill="none" stroke="${color}" stroke-width="2" ${dashStyle} marker-end="url(#${markerEnd})"/>
      ${labelElement}
    </g>`;
}
function renderHorizontalEdge(fromPos, toPos, options = {}) {
  const { label, style = "solid", color = "#333333" } = options;
  const fromX = fromPos.x + fromPos.width;
  const fromY = fromPos.y + fromPos.height / 2;
  const toX = toPos.x;
  const toY = toPos.y + toPos.height / 2;
  const dashStyle = style === "dashed" ? 'stroke-dasharray="8,4"' : style === "dotted" ? 'stroke-dasharray="2,2"' : "";
  const labelElement = label ? `<text x="${(fromX + toX) / 2}" y="${(fromY + toY) / 2 - 8}" text-anchor="middle" class="edge-label">${escapeSVGText(label)}</text>` : "";
  return `
    <g class="edge">
      <line x1="${fromX}" y1="${fromY}" x2="${toX - 8}" y2="${toY}"
            stroke="${color}" stroke-width="2" ${dashStyle} marker-end="url(#arrowhead)"/>
      ${labelElement}
    </g>`;
}
function renderMetricsPanel(x, y, metrics) {
  const panelHeight = 30 + metrics.length * 16;
  let svg = `
  <g class="metrics-panel">
    <rect x="${x}" y="${y}" width="160" height="${panelHeight}" rx="8" fill="#f5f5f5" stroke="#ddd" stroke-width="1"/>
    <text x="${x + 10}" y="${y + 20}" class="metrics" font-weight="bold">Metrics</text>`;
  metrics.forEach((metric, i) => {
    svg += `
    <text x="${x + 10}" y="${y + 38 + i * 16}" class="metrics">${escapeSVGText(metric.label)}: ${escapeSVGText(String(metric.value))}</text>`;
  });
  svg += "\n  </g>";
  return svg;
}
function renderLegend(x, y, items) {
  let svg = `
  <g class="legend" transform="translate(${x}, ${y})">
    <text x="0" y="0" font-weight="bold" class="legend-text">Legend</text>`;
  items.forEach((item, i) => {
    const itemY = 12 + i * 18;
    let shapeEl;
    switch (item.shape) {
      case "diamond":
        shapeEl = `<polygon points="10,${itemY} 20,${itemY + 6} 10,${itemY + 12} 0,${itemY + 6}" fill="${item.color.fill}" stroke="${item.color.stroke}"/>`;
        break;
      case "ellipse":
        shapeEl = `<ellipse cx="10" cy="${itemY + 6}" rx="10" ry="6" fill="${item.color.fill}" stroke="${item.color.stroke}"/>`;
        break;
      case "stadium":
        shapeEl = `<rect x="0" y="${itemY}" width="20" height="12" rx="6" ry="6" fill="${item.color.fill}" stroke="${item.color.stroke}"/>`;
        break;
      default:
        shapeEl = `<rect x="0" y="${itemY}" width="20" height="12" rx="4" fill="${item.color.fill}" stroke="${item.color.stroke}"/>`;
    }
    svg += `
    ${shapeEl}
    <text x="25" y="${itemY + 10}" class="legend-text">${escapeSVGText(item.label)}</text>`;
  });
  svg += "\n  </g>";
  return svg;
}
function layoutNodesInLayers(layers, options = {}) {
  const opts = { ...DEFAULT_SVG_OPTIONS, ...options };
  const positions = /* @__PURE__ */ new Map();
  let currentY = opts.padding + (opts.title ? 40 : 0);
  for (const layer of layers) {
    if (layer.length === 0) continue;
    const layerWidth = layer.length * (opts.nodeWidth + opts.nodeSpacing) - opts.nodeSpacing;
    let startX = (opts.width - layerWidth) / 2;
    for (const node of layer) {
      positions.set(node.id, {
        id: node.id,
        x: startX,
        y: currentY,
        width: opts.nodeWidth,
        height: opts.nodeHeight,
        label: node.label,
        type: node.type
      });
      startX += opts.nodeWidth + opts.nodeSpacing;
    }
    currentY += opts.nodeHeight + opts.layerSpacing;
  }
  return positions;
}
function layoutNodesHorizontally(nodes, options = {}) {
  const opts = { ...DEFAULT_SVG_OPTIONS, ...options };
  const positions = /* @__PURE__ */ new Map();
  const totalWidth = nodes.length * (opts.nodeWidth + opts.nodeSpacing) - opts.nodeSpacing;
  let startX = Math.max(opts.padding, (opts.width - totalWidth) / 2);
  const y = opts.height / 2 - opts.nodeHeight / 2;
  for (const node of nodes) {
    positions.set(node.id, {
      id: node.id,
      x: startX,
      y,
      width: opts.nodeWidth,
      height: opts.nodeHeight,
      label: node.label,
      type: node.type
    });
    startX += opts.nodeWidth + opts.nodeSpacing;
  }
  return positions;
}
function calculateSVGHeight(positions, padding = 40, extraSpace = 120) {
  let maxY = 0;
  for (const pos of positions.values()) {
    maxY = Math.max(maxY, pos.y + pos.height);
  }
  return maxY + padding + extraSpace;
}
var DEFAULT_SVG_OPTIONS, COLOR_PALETTES;
var init_svg_utils = __esm({
  "src/export/visual/svg-utils.ts"() {
    init_esm_shims();
    DEFAULT_SVG_OPTIONS = {
      width: 800,
      height: 600,
      nodeWidth: 150,
      nodeHeight: 40,
      nodeSpacing: 20,
      layerSpacing: 100,
      padding: 40,
      colorScheme: "default",
      includeLabels: true,
      includeMetrics: true,
      title: ""
    };
    COLOR_PALETTES = {
      default: {
        primary: { fill: "#64b5f6", stroke: "#1976d2" },
        secondary: { fill: "#81c784", stroke: "#388e3c" },
        tertiary: { fill: "#ffb74d", stroke: "#f57c00" },
        quaternary: { fill: "#ba68c8", stroke: "#7b1fa2" },
        neutral: { fill: "#bdbdbd", stroke: "#616161" },
        success: { fill: "#81c784", stroke: "#388e3c" },
        warning: { fill: "#ffb74d", stroke: "#f57c00" },
        error: { fill: "#e57373", stroke: "#d32f2f" },
        info: { fill: "#64b5f6", stroke: "#1976d2" },
        highlight: { fill: "#fff176", stroke: "#fbc02d" }
      },
      pastel: {
        primary: { fill: "#bbdefb", stroke: "#2196f3" },
        secondary: { fill: "#c8e6c9", stroke: "#4caf50" },
        tertiary: { fill: "#ffe0b2", stroke: "#ff9800" },
        quaternary: { fill: "#e1bee7", stroke: "#9c27b0" },
        neutral: { fill: "#e0e0e0", stroke: "#757575" },
        success: { fill: "#c8e6c9", stroke: "#4caf50" },
        warning: { fill: "#fff9c4", stroke: "#ffc107" },
        error: { fill: "#ffcdd2", stroke: "#e53935" },
        info: { fill: "#bbdefb", stroke: "#2196f3" },
        highlight: { fill: "#fff9c4", stroke: "#fbc02d" }
      },
      monochrome: {
        primary: { fill: "#ffffff", stroke: "#333333" },
        secondary: { fill: "#f5f5f5", stroke: "#333333" },
        tertiary: { fill: "#eeeeee", stroke: "#333333" },
        quaternary: { fill: "#e0e0e0", stroke: "#333333" },
        neutral: { fill: "#fafafa", stroke: "#333333" },
        success: { fill: "#ffffff", stroke: "#333333" },
        warning: { fill: "#f5f5f5", stroke: "#333333" },
        error: { fill: "#eeeeee", stroke: "#333333" },
        info: { fill: "#ffffff", stroke: "#333333" },
        highlight: { fill: "#e0e0e0", stroke: "#333333" }
      }
    };
  }
});

// src/export/visual/graphml-utils.ts
function escapeXML(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
function generateGraphMLHeader(options = {}) {
  const { graphId = "G", directed = true, graphName } = options;
  let header = `<?xml version="1.0" encoding="UTF-8"?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns
         http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">

  <!-- Node attributes -->
  <key id="label" for="node" attr.name="label" attr.type="string"/>
  <key id="type" for="node" attr.name="type" attr.type="string"/>
  <key id="description" for="node" attr.name="description" attr.type="string"/>

  <!-- Edge attributes -->
  <key id="edgeLabel" for="edge" attr.name="label" attr.type="string"/>
  <key id="weight" for="edge" attr.name="weight" attr.type="double"/>
  <key id="edgeType" for="edge" attr.name="type" attr.type="string"/>

  <!-- Graph attributes -->
  <key id="graphName" for="graph" attr.name="name" attr.type="string"/>

  <graph id="${escapeXML(graphId)}" edgedefault="${directed ? "directed" : "undirected"}">`;
  if (graphName) {
    header += `
    <data key="graphName">${escapeXML(graphName)}</data>`;
  }
  return header;
}
function generateGraphMLFooter() {
  return `
  </graph>
</graphml>`;
}
function renderGraphMLNode(node, options = {}) {
  const { includeLabels = true, includeMetadata = true } = options;
  let nodeXML = `
    <node id="${escapeXML(node.id)}">`;
  if (includeLabels && node.label) {
    nodeXML += `
      <data key="label">${escapeXML(node.label)}</data>`;
  }
  if (node.type) {
    nodeXML += `
      <data key="type">${escapeXML(node.type)}</data>`;
  }
  if (includeMetadata && node.metadata) {
    if (node.metadata.description) {
      nodeXML += `
      <data key="description">${escapeXML(String(node.metadata.description))}</data>`;
    }
  }
  nodeXML += `
    </node>`;
  return nodeXML;
}
function renderGraphMLEdge(edge, options = {}) {
  const { includeLabels = true, includeMetadata = true } = options;
  let edgeXML = `
    <edge id="${escapeXML(edge.id)}" source="${escapeXML(edge.source)}" target="${escapeXML(edge.target)}">`;
  if (includeLabels && edge.label) {
    edgeXML += `
      <data key="edgeLabel">${escapeXML(edge.label)}</data>`;
  }
  if (includeMetadata && edge.metadata) {
    if (edge.metadata.weight !== void 0) {
      edgeXML += `
      <data key="weight">${edge.metadata.weight}</data>`;
    }
    if (edge.metadata.type) {
      edgeXML += `
      <data key="edgeType">${escapeXML(String(edge.metadata.type))}</data>`;
    }
  }
  edgeXML += `
    </edge>`;
  return edgeXML;
}
function generateGraphML(nodes, edges, options = {}) {
  const mergedOptions = { ...DEFAULT_GRAPHML_OPTIONS, ...options };
  let graphml = generateGraphMLHeader(mergedOptions);
  graphml += "\n\n    <!-- Nodes -->";
  for (const node of nodes) {
    graphml += renderGraphMLNode(node, mergedOptions);
  }
  graphml += "\n\n    <!-- Edges -->";
  for (const edge of edges) {
    graphml += renderGraphMLEdge(edge, mergedOptions);
  }
  graphml += generateGraphMLFooter();
  return graphml;
}
function createLinearGraphML(nodeLabels, options = {}) {
  const nodes = nodeLabels.map((label, i) => ({
    id: `n${i}`,
    label,
    type: "step"
  }));
  const edges = [];
  for (let i = 0; i < nodeLabels.length - 1; i++) {
    edges.push({
      id: `e${i}`,
      source: `n${i}`,
      target: `n${i + 1}`
    });
  }
  return generateGraphML(nodes, edges, options);
}
function createTreeGraphML(root, options = {}) {
  const nodes = [];
  const edges = [];
  let edgeCount = 0;
  function traverse(node, depth = 0) {
    nodes.push({
      id: node.id,
      label: node.label,
      type: depth === 0 ? "root" : "node",
      metadata: { depth }
    });
    if (node.children && Array.isArray(node.children)) {
      for (const child of node.children) {
        edges.push({
          id: `e${edgeCount++}`,
          source: node.id,
          target: child.id
        });
        traverse(child, depth + 1);
      }
    }
  }
  traverse(root);
  return generateGraphML(nodes, edges, options);
}
var DEFAULT_GRAPHML_OPTIONS;
var init_graphml_utils = __esm({
  "src/export/visual/graphml-utils.ts"() {
    init_esm_shims();
    DEFAULT_GRAPHML_OPTIONS = {
      directed: true,
      includeMetadata: true,
      includeLabels: true,
      graphId: "G",
      graphName: "Graph"
    };
  }
});

// src/export/visual/tikz-utils.ts
function getTikZColor(nodeType, colorScheme = "default") {
  const palette = COLOR_PALETTES2[colorScheme] || COLOR_PALETTES2.default;
  const colorMap = {
    primary: "primary",
    secondary: "secondary",
    tertiary: "tertiary",
    neutral: "neutral",
    success: "success",
    warning: "warning",
    danger: "danger",
    info: "info",
    cause: "primary",
    effect: "tertiary",
    mediator: "secondary",
    confounder: "warning",
    root: "primary",
    current: "primary",
    terminal: "success",
    hypothesis: "info",
    evidence: "secondary",
    conclusion: "success"
  };
  const key = colorMap[nodeType] || "neutral";
  return palette[key];
}
function escapeLatex2(str) {
  return str.replace(/\\/g, "\\textbackslash{}").replace(/%/g, "\\%").replace(/\$/g, "\\$").replace(/&/g, "\\&").replace(/#/g, "\\#").replace(/_/g, "\\_").replace(/{/g, "\\{").replace(/}/g, "\\}").replace(/\^/g, "\\textasciicircum{}").replace(/~/g, "\\textasciitilde{}");
}
function generateTikZHeader(options = {}) {
  const { standalone = false, title, scale = 1 } = options;
  let header = "";
  if (standalone) {
    header += `\\documentclass[tikz,border=10pt]{standalone}
\\usepackage{tikz}
\\usetikzlibrary{shapes,arrows,positioning,calc,backgrounds,fit}
\\begin{document}
`;
  }
  header += `\\begin{tikzpicture}[
  scale=${scale},
  every node/.style={font=\\small},
  box/.style={rectangle, draw, rounded corners=3pt, minimum width=2cm, minimum height=0.8cm, text centered},
  circle node/.style={circle, draw, minimum size=0.8cm, text centered},
  ellipse node/.style={ellipse, draw, minimum width=2cm, minimum height=0.8cm, text centered},
  diamond node/.style={diamond, draw, aspect=2, minimum width=1.5cm, text centered},
  stadium node/.style={rectangle, draw, rounded corners=0.4cm, minimum width=2cm, minimum height=0.8cm, text centered},
  arrow/.style={->, >=stealth, thick},
  dashed arrow/.style={->, >=stealth, thick, dashed},
  dotted arrow/.style={->, >=stealth, thick, dotted},
  edge label/.style={font=\\footnotesize, fill=white, inner sep=1pt}
]`;
  if (title) {
    header += `

% Title
\\node[font=\\large\\bfseries] at (4, 0.5) {${escapeLatex2(title)}};`;
  }
  return header;
}
function generateTikZFooter(options = {}) {
  const { standalone = false } = options;
  let footer = "\n\\end{tikzpicture}";
  if (standalone) {
    footer += "\n\\end{document}";
  }
  return footer;
}
function getShapeStyle(shape) {
  switch (shape) {
    case "circle":
      return "circle node";
    case "ellipse":
      return "ellipse node";
    case "diamond":
      return "diamond node";
    case "stadium":
    case "rounded":
      return "stadium node";
    case "rectangle":
    default:
      return "box";
  }
}
function renderTikZNode(node, options = {}) {
  const { colorScheme = "default", includeLabels = true } = options;
  const colors = getTikZColor(node.type || "neutral", colorScheme);
  const shapeStyle = getShapeStyle(node.shape);
  const label = includeLabels ? escapeLatex2(node.label) : escapeLatex2(node.id);
  const position = node.x !== void 0 && node.y !== void 0 ? `at (${node.x}, ${node.y})` : "";
  return `
  \\node[${shapeStyle}, fill=${colors.fill}, draw=${colors.stroke}] (${node.id}) ${position} {${label}};`;
}
function renderTikZEdge(edge, options = {}) {
  const { includeLabels = true } = options;
  let style = "arrow";
  if (edge.style === "dashed") style = "dashed arrow";
  if (edge.style === "dotted") style = "dotted arrow";
  if (edge.directed === false) style = style.replace("->", "-");
  let bendOption = "";
  if (edge.bend) {
    if (typeof edge.bend === "number") {
      bendOption = `, bend ${edge.bend > 0 ? "left" : "right"}=${Math.abs(edge.bend)}`;
    } else {
      bendOption = `, bend ${edge.bend}`;
    }
  }
  let labelOption = "";
  if (includeLabels && edge.label) {
    labelOption = ` node[edge label, midway] {${escapeLatex2(edge.label)}}`;
  }
  return `
  \\draw[${style}${bendOption}] (${edge.source}) --${labelOption} (${edge.target});`;
}
function renderTikZMetrics(x, y, metrics) {
  let tikz = `

  % Metrics Panel
  \\node[draw, fill=white, rounded corners, align=left, font=\\footnotesize] at (${x}, ${y}) {`;
  const lines = metrics.map((m) => `${escapeLatex2(m.label)}: ${escapeLatex2(String(m.value))}`);
  tikz += lines.join(" \\\\ ");
  tikz += "};";
  return tikz;
}
function renderTikZLegend(x, y, items) {
  let tikz = "\n\n  % Legend";
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    const itemY = y - i * 0.5;
    const shapeStyle = getShapeStyle(item.shape);
    tikz += `
  \\node[${shapeStyle}, fill=${item.color.fill}, draw=${item.color.stroke}, minimum width=0.5cm, minimum height=0.3cm] at (${x}, ${itemY}) {};`;
    tikz += `
  \\node[right, font=\\footnotesize] at (${x + 0.4}, ${itemY}) {${escapeLatex2(item.label)}};`;
  }
  return tikz;
}
function generateTikZ(nodes, edges, options = {}) {
  const mergedOptions = { ...DEFAULT_TIKZ_OPTIONS, ...options };
  let tikz = generateTikZHeader(mergedOptions);
  tikz += "\n\n  % Nodes";
  for (const node of nodes) {
    tikz += renderTikZNode(node, mergedOptions);
  }
  tikz += "\n\n  % Edges";
  for (const edge of edges) {
    tikz += renderTikZEdge(edge, mergedOptions);
  }
  tikz += generateTikZFooter(mergedOptions);
  return tikz;
}
function createLinearTikZ(nodeLabels, options = {}) {
  const nodes = nodeLabels.map((label, i) => ({
    id: `n${i}`,
    label,
    x: i * 3,
    y: 0,
    type: i === 0 ? "primary" : i === nodeLabels.length - 1 ? "success" : "neutral",
    shape: "rectangle"
  }));
  const edges = [];
  for (let i = 0; i < nodeLabels.length - 1; i++) {
    edges.push({
      source: `n${i}`,
      target: `n${i + 1}`,
      directed: true
    });
  }
  return generateTikZ(nodes, edges, options);
}
function createTreeTikZ(root, options = {}) {
  const nodes = [];
  const edges = [];
  function traverse(node, x, y, width) {
    nodes.push({
      id: node.id,
      label: node.label,
      x,
      y,
      type: y === 0 ? "primary" : "neutral",
      shape: "rectangle"
    });
    if (node.children && Array.isArray(node.children)) {
      const children = node.children;
      const childWidth = width / children.length;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        const childX = x - width / 2 + childWidth / 2 + i * childWidth;
        edges.push({
          source: node.id,
          target: child.id,
          directed: true
        });
        traverse(child, childX, y - 2, childWidth);
      }
    }
  }
  traverse(root, 4, 0, 8);
  return generateTikZ(nodes, edges, options);
}
var DEFAULT_TIKZ_OPTIONS, COLOR_PALETTES2;
var init_tikz_utils = __esm({
  "src/export/visual/tikz-utils.ts"() {
    init_esm_shims();
    DEFAULT_TIKZ_OPTIONS = {
      standalone: false,
      includeLabels: true,
      includeMetrics: true,
      colorScheme: "default",
      scale: 1,
      nodeDistance: "2cm",
      levelDistance: "1.5cm"
    };
    COLOR_PALETTES2 = {
      default: {
        primary: { fill: "blue!20", stroke: "blue!60" },
        secondary: { fill: "green!20", stroke: "green!60" },
        tertiary: { fill: "orange!20", stroke: "orange!60" },
        neutral: { fill: "gray!20", stroke: "gray!60" },
        success: { fill: "green!30", stroke: "green!70" },
        warning: { fill: "yellow!30", stroke: "yellow!70" },
        danger: { fill: "red!20", stroke: "red!60" },
        info: { fill: "cyan!20", stroke: "cyan!60" }
      },
      pastel: {
        primary: { fill: "blue!10", stroke: "blue!40" },
        secondary: { fill: "green!10", stroke: "green!40" },
        tertiary: { fill: "orange!10", stroke: "orange!40" },
        neutral: { fill: "gray!10", stroke: "gray!40" },
        success: { fill: "green!15", stroke: "green!50" },
        warning: { fill: "yellow!15", stroke: "yellow!50" },
        danger: { fill: "red!10", stroke: "red!40" },
        info: { fill: "cyan!10", stroke: "cyan!40" }
      },
      monochrome: {
        primary: { fill: "black!10", stroke: "black!60" },
        secondary: { fill: "black!15", stroke: "black!70" },
        tertiary: { fill: "black!20", stroke: "black!80" },
        neutral: { fill: "black!5", stroke: "black!50" },
        success: { fill: "black!10", stroke: "black!60" },
        warning: { fill: "black!15", stroke: "black!70" },
        danger: { fill: "black!20", stroke: "black!80" },
        info: { fill: "black!10", stroke: "black!60" }
      }
    };
  }
});

// src/export/visual/html-utils.ts
function getHTMLThemeColors(theme = "light") {
  if (theme === "dark") {
    return {
      background: "#1a1a2e",
      text: "#eaeaea",
      primary: "#4a90d9",
      secondary: "#6c757d",
      success: "#28a745",
      warning: "#ffc107",
      danger: "#dc3545",
      info: "#17a2b8",
      border: "#444",
      tableHeader: "#2d2d44",
      tableRow: "#1a1a2e",
      tableRowAlt: "#252538"
    };
  }
  return {
    background: "#ffffff",
    text: "#333333",
    primary: "#2563eb",
    secondary: "#6b7280",
    success: "#16a34a",
    warning: "#ca8a04",
    danger: "#dc2626",
    info: "#0891b2",
    border: "#e5e7eb",
    tableHeader: "#f3f4f6",
    tableRow: "#ffffff",
    tableRowAlt: "#f9fafb"
  };
}
function generateHTMLHeader(title, options = {}) {
  const { standalone = true, theme = "light", customStyles = "" } = options;
  const colors = getHTMLThemeColors(theme);
  if (!standalone) {
    return `<div class="visual-export" data-theme="${theme}">
`;
  }
  return `<!DOCTYPE html>
<html lang="en" data-theme="${theme}">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${escapeHTML(title)}</title>
  <style>
    :root {
      --bg-color: ${colors.background};
      --text-color: ${colors.text};
      --primary-color: ${colors.primary};
      --secondary-color: ${colors.secondary};
      --success-color: ${colors.success};
      --warning-color: ${colors.warning};
      --danger-color: ${colors.danger};
      --info-color: ${colors.info};
      --border-color: ${colors.border};
      --table-header-bg: ${colors.tableHeader};
      --table-row-bg: ${colors.tableRow};
      --table-row-alt-bg: ${colors.tableRowAlt};
    }

    * { box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.6;
      color: var(--text-color);
      background-color: var(--bg-color);
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
    }

    h1, h2, h3, h4 { margin-top: 1.5rem; margin-bottom: 0.5rem; }
    h1 { font-size: 2rem; border-bottom: 2px solid var(--primary-color); padding-bottom: 0.5rem; }
    h2 { font-size: 1.5rem; color: var(--primary-color); }
    h3 { font-size: 1.25rem; }

    .section {
      margin: 1.5rem 0;
      padding: 1rem;
      border: 1px solid var(--border-color);
      border-radius: 8px;
    }

    .section-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .badge {
      display: inline-block;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .badge-primary { background: var(--primary-color); color: white; }
    .badge-success { background: var(--success-color); color: white; }
    .badge-warning { background: var(--warning-color); color: black; }
    .badge-danger { background: var(--danger-color); color: white; }
    .badge-info { background: var(--info-color); color: white; }
    .badge-secondary { background: var(--secondary-color); color: white; }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
      font-size: 0.9rem;
    }

    th, td {
      padding: 0.75rem;
      text-align: left;
      border: 1px solid var(--border-color);
    }

    th {
      background: var(--table-header-bg);
      font-weight: 600;
    }

    tr:nth-child(even) { background: var(--table-row-alt-bg); }
    tr:nth-child(odd) { background: var(--table-row-bg); }

    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
      margin: 1rem 0;
    }

    .metric-card {
      padding: 1rem;
      background: var(--table-header-bg);
      border-radius: 8px;
      text-align: center;
    }

    .metric-value {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--primary-color);
    }

    .metric-label {
      font-size: 0.85rem;
      color: var(--secondary-color);
    }

    .progress-bar {
      height: 8px;
      background: var(--border-color);
      border-radius: 4px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: var(--primary-color);
      transition: width 0.3s ease;
    }

    .list-styled {
      list-style: none;
      padding: 0;
    }

    .list-styled li {
      padding: 0.5rem 0;
      border-bottom: 1px solid var(--border-color);
    }

    .list-styled li:last-child { border-bottom: none; }

    .icon { margin-right: 0.5rem; }

    .text-success { color: var(--success-color); }
    .text-warning { color: var(--warning-color); }
    .text-danger { color: var(--danger-color); }
    .text-info { color: var(--info-color); }
    .text-secondary { color: var(--secondary-color); }

    .card {
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 1rem;
      margin: 0.5rem 0;
    }

    .card-header {
      font-weight: 600;
      margin-bottom: 0.5rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--border-color);
    }

    .flex { display: flex; }
    .flex-wrap { flex-wrap: wrap; }
    .gap-1 { gap: 0.5rem; }
    .gap-2 { gap: 1rem; }

    .footer {
      margin-top: 2rem;
      padding-top: 1rem;
      border-top: 1px solid var(--border-color);
      font-size: 0.85rem;
      color: var(--secondary-color);
      text-align: center;
    }

    ${customStyles}
  </style>
</head>
<body>
`;
}
function generateHTMLFooter(standalone = true) {
  if (!standalone) {
    return "</div>\n";
  }
  return `
  <div class="footer">
    Generated by DeepThinking MCP v7.1.0
  </div>
</body>
</html>`;
}
function escapeHTML(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
function renderMetricCard(label, value, color) {
  const colorClass = color ? ` style="color: var(--${color}-color)"` : "";
  return `
    <div class="metric-card">
      <div class="metric-value"${colorClass}>${escapeHTML(String(value))}</div>
      <div class="metric-label">${escapeHTML(label)}</div>
    </div>`;
}
function renderProgressBar(percent, color = "primary") {
  const clampedPercent = Math.max(0, Math.min(100, percent));
  return `
    <div class="progress-bar">
      <div class="progress-fill" style="width: ${clampedPercent}%; background: var(--${color}-color)"></div>
    </div>`;
}
function renderBadge(text, type = "primary") {
  return `<span class="badge badge-${type}">${escapeHTML(text)}</span>`;
}
function renderTable(headers, rows, options = {}) {
  const headerCells = headers.map((h) => `<th>${escapeHTML(h)}</th>`).join("");
  const bodyRows = rows.map((row) => {
    const cells = row.map((cell) => `<td>${escapeHTML(String(cell))}</td>`).join("");
    return `<tr>${cells}</tr>`;
  }).join("\n");
  let html = "<table>";
  if (options.caption) {
    html += `<caption>${escapeHTML(options.caption)}</caption>`;
  }
  html += `<thead><tr>${headerCells}</tr></thead>`;
  html += `<tbody>${bodyRows}</tbody>`;
  html += "</table>";
  return html;
}
function renderSection(title, content, icon) {
  const iconHtml = icon ? `<span class="icon">${icon}</span>` : "";
  return `
    <div class="section">
      <div class="section-header">
        ${iconHtml}<h3>${escapeHTML(title)}</h3>
      </div>
      ${content}
    </div>`;
}
function renderList(items, ordered = false) {
  const tag = ordered ? "ol" : "ul";
  const listItems = items.map((item) => `<li>${escapeHTML(item)}</li>`).join("\n");
  return `<${tag} class="list-styled">${listItems}</${tag}>`;
}
var init_html_utils = __esm({
  "src/export/visual/html-utils.ts"() {
    init_esm_shims();
  }
});

// src/export/visual/modelica-utils.ts
function sanitizeModelicaId(id) {
  let sanitized = id.replace(/[-\s]/g, "_");
  sanitized = sanitized.replace(/[^a-zA-Z0-9_]/g, "");
  if (!/^[a-zA-Z]/.test(sanitized)) {
    sanitized = "id_" + sanitized;
  }
  return sanitized || "unnamed";
}
function escapeModelicaString(str) {
  return str.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
}
function generateModelicaPackageHeader(name, description, options = {}) {
  const packageName = options.packageName || sanitizeModelicaId(name);
  const lines = [];
  lines.push(`package ${packageName}`);
  lines.push(`  "${escapeModelicaString(description)}"`);
  lines.push("");
  return lines.join("\n");
}
function generateModelicaPackageFooter(name, options = {}) {
  const packageName = options.packageName || sanitizeModelicaId(name);
  const lines = [];
  if (options.includeAnnotations !== false) {
    lines.push("  annotation(");
    lines.push('    Documentation(info="<html>');
    lines.push(`      <p>Generated by DeepThinking MCP v${options.version || "7.1.0"}</p>`);
    lines.push('    </html>"),');
    lines.push('    version="1.0.0"');
    lines.push("  );");
  }
  lines.push(`end ${packageName};`);
  return lines.join("\n");
}
function generateModelicaRecord(recordName, description, fields, _options = {}) {
  const lines = [];
  const safeRecordName = sanitizeModelicaId(recordName);
  lines.push(`  record ${safeRecordName}`);
  lines.push(`    "${escapeModelicaString(description)}"`);
  lines.push("");
  for (const field of fields) {
    const safeName = sanitizeModelicaId(field.name);
    const desc = field.description ? ` "${escapeModelicaString(field.description)}"` : "";
    lines.push(`    ${field.type} ${safeName} = ${field.value}${desc};`);
  }
  lines.push(`  end ${safeRecordName};`);
  lines.push("");
  return lines.join("\n");
}
function generateLinearFlowModelica(stages2, currentStage, options = {}) {
  const packageName = options.packageName || "LinearFlow";
  const lines = [];
  lines.push(`package ${sanitizeModelicaId(packageName)}`);
  lines.push('  "Linear stage flow representation"');
  lines.push("");
  lines.push("  type Stage = enumeration(");
  for (let i = 0; i < stages2.length; i++) {
    const stage = stages2[i];
    const comma = i < stages2.length - 1 ? "," : "";
    lines.push(`    ${sanitizeModelicaId(stage)} "${escapeModelicaString(stage)}"${comma}`);
  }
  lines.push("  );");
  lines.push("");
  lines.push(`  parameter Stage currentStage = Stage.${sanitizeModelicaId(currentStage)};`);
  lines.push(`  final parameter Integer stageIndex = ${stages2.indexOf(currentStage) + 1};`);
  lines.push(`  final parameter Integer totalStages = ${stages2.length};`);
  lines.push(`  final parameter Real progress = stageIndex / totalStages;`);
  lines.push("");
  lines.push(generateModelicaPackageFooter(packageName, options));
  return lines.join("\n");
}
function generateHierarchyModelica(rootName, rootDescription, children, options = {}) {
  const packageName = options.packageName || sanitizeModelicaId(rootName);
  const lines = [];
  lines.push(`package ${packageName}`);
  lines.push(`  "${escapeModelicaString(rootDescription)}"`);
  lines.push("");
  for (const child of children) {
    const childId = sanitizeModelicaId(child.name);
    lines.push(`  record ${childId}`);
    lines.push(`    "${escapeModelicaString(child.description)}"`);
    if (child.score !== void 0 && options.includeMetrics !== false) {
      lines.push(`    constant Real score = ${child.score.toFixed(3)};`);
    }
    lines.push(`  end ${childId};`);
    lines.push("");
  }
  lines.push(generateModelicaPackageFooter(packageName, options));
  return lines.join("\n");
}
var init_modelica_utils = __esm({
  "src/export/visual/modelica-utils.ts"() {
    init_esm_shims();
  }
});

// src/export/visual/uml-utils.ts
function sanitizeUmlId(id) {
  let sanitized = id.replace(/[^a-zA-Z0-9_]/g, "_");
  if (!/^[a-zA-Z]/.test(sanitized)) {
    sanitized = "id_" + sanitized;
  }
  return sanitized || "unnamed";
}
function escapeUml(str) {
  return str.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/<(?![\/#])/g, "&lt;").replace(/(?<![\/#])>/g, "&gt;");
}
function getArrowSyntax(type) {
  switch (type) {
    case "dependency":
      return "..>";
    case "inheritance":
      return "--|>";
    case "implementation":
      return "..|>";
    case "composition":
      return "*--";
    case "aggregation":
      return "o--";
    case "dashed":
      return "..";
    case "arrow":
      return "-->";
    case "association":
    default:
      return "--";
  }
}
function generateUmlHeader(options = {}) {
  const lines = ["@startuml"];
  if (options.title) {
    lines.push(`title ${escapeUml(options.title)}`);
  }
  if (options.theme && options.theme !== "default") {
    lines.push(`!theme ${options.theme}`);
  }
  if (options.direction) {
    lines.push(options.direction === "left to right" ? "left to right direction" : "top to bottom direction");
  }
  if (options.scale) {
    lines.push(`scale ${options.scale}`);
  }
  lines.push("");
  return lines.join("\n");
}
function generateUmlFooter() {
  return "@enduml\n";
}
function renderUmlNode(node) {
  const lines = [];
  const id = sanitizeUmlId(node.id);
  const label = node.label || node.id;
  const shape = node.shape || "rectangle";
  switch (shape) {
    case "class":
    case "interface":
    case "abstract":
      lines.push(`${shape} "${escapeUml(label)}" as ${id} {`);
      if (node.attributes && node.attributes.length > 0) {
        for (const attr of node.attributes) {
          lines.push(`  ${escapeUml(attr)}`);
        }
      }
      if (node.methods && node.methods.length > 0) {
        lines.push("  --");
        for (const method of node.methods) {
          lines.push(`  ${escapeUml(method)}`);
        }
      }
      lines.push("}");
      break;
    case "usecase":
      lines.push(`usecase "${escapeUml(label)}" as ${id}`);
      break;
    case "actor":
      lines.push(`actor "${escapeUml(label)}" as ${id}`);
      break;
    case "component":
      lines.push(`component "${escapeUml(label)}" as ${id}`);
      break;
    case "node":
      lines.push(`node "${escapeUml(label)}" as ${id}`);
      break;
    case "database":
      lines.push(`database "${escapeUml(label)}" as ${id}`);
      break;
    case "package":
      lines.push(`package "${escapeUml(label)}" as ${id} {`);
      lines.push("}");
      break;
    case "folder":
      lines.push(`folder "${escapeUml(label)}" as ${id}`);
      break;
    case "cloud":
      lines.push(`cloud "${escapeUml(label)}" as ${id}`);
      break;
    case "state":
      lines.push(`state "${escapeUml(label)}" as ${id}`);
      break;
    case "activity":
      lines.push(`:${escapeUml(label)};`);
      break;
    case "entity":
      lines.push(`entity "${escapeUml(label)}" as ${id}`);
      break;
    case "rectangle":
    default:
      if (node.stereotype) {
        lines.push(`rectangle "${escapeUml(label)}" <<${escapeUml(node.stereotype)}>> as ${id}`);
      } else {
        lines.push(`rectangle "${escapeUml(label)}" as ${id}`);
      }
  }
  if (node.color) {
    const lastLine = lines.pop();
    if (lastLine) {
      lines.push(lastLine.replace(/}$/, "") + ` #${node.color}`);
      if (lastLine.endsWith("}")) {
        lines.push("}");
      }
    }
  }
  return lines.join("\n");
}
function renderUmlEdge(edge) {
  const sourceId = sanitizeUmlId(edge.source);
  const targetId = sanitizeUmlId(edge.target);
  const arrow = getArrowSyntax(edge.type);
  let line = `${sourceId} ${arrow} ${targetId}`;
  if (edge.label) {
    line += ` : ${escapeUml(edge.label)}`;
  }
  return line;
}
function generateUmlDiagram(nodes, edges, options = {}) {
  const lines = [];
  lines.push(generateUmlHeader(options));
  if (nodes.length > 0) {
    lines.push("' Nodes");
    for (const node of nodes) {
      lines.push(renderUmlNode(node));
    }
    lines.push("");
  }
  if (edges.length > 0) {
    lines.push("' Relationships");
    for (const edge of edges) {
      lines.push(renderUmlEdge(edge));
    }
    lines.push("");
  }
  lines.push(generateUmlFooter());
  return lines.join("\n");
}
function generateActivityDiagram(activities, currentActivity, options = {}) {
  const lines = [];
  lines.push(generateUmlHeader({ ...options}));
  lines.push("start");
  for (const activity of activities) {
    const isCurrent = activity === currentActivity;
    if (isCurrent) {
      lines.push(`#lightblue:${escapeUml(activity)};`);
    } else {
      lines.push(`:${escapeUml(activity)};`);
    }
  }
  lines.push("stop");
  lines.push("");
  lines.push(generateUmlFooter());
  return lines.join("\n");
}
function generateStateDiagram(states, transitions, currentState, options = {}) {
  const lines = [];
  lines.push(generateUmlHeader({ ...options}));
  for (const state of states) {
    const id = sanitizeUmlId(state);
    const isCurrent = state === currentState;
    if (isCurrent) {
      lines.push(`state "${escapeUml(state)}" as ${id} #lightblue`);
    } else {
      lines.push(`state "${escapeUml(state)}" as ${id}`);
    }
  }
  lines.push("");
  if (states.length > 0) {
    lines.push(`[*] --> ${sanitizeUmlId(states[0])}`);
  }
  for (const t of transitions) {
    const label = t.event ? ` : ${escapeUml(t.event)}` : "";
    lines.push(`${sanitizeUmlId(t.from)} --> ${sanitizeUmlId(t.to)}${label}`);
  }
  lines.push("");
  lines.push(generateUmlFooter());
  return lines.join("\n");
}
var init_uml_utils = __esm({
  "src/export/visual/uml-utils.ts"() {
    init_esm_shims();
  }
});

// src/export/visual/json-utils.ts
function createJsonGraph(title, mode, options = {}) {
  return {
    type: "deepthinking-visual-graph",
    version: "1.0.0",
    metadata: {
      title,
      mode,
      exportedAt: (/* @__PURE__ */ new Date()).toISOString(),
      generator: "DeepThinking MCP v7.1.0"
    },
    nodes: [],
    edges: [],
    layout: options.includeLayout !== false ? { type: "hierarchical", direction: "TB" } : void 0,
    metrics: options.includeMetrics !== false ? {} : void 0,
    legend: options.includeLegend !== false ? [] : void 0
  };
}
function addNode(graph, node) {
  graph.nodes.push(node);
}
function addEdge(graph, edge) {
  graph.edges.push(edge);
}
function addMetric(graph, key, value) {
  if (graph.metrics) {
    graph.metrics[key] = value;
  }
}
function addLegendItem(graph, label, color, shape) {
  if (graph.legend) {
    graph.legend.push({ label, color, shape });
  }
}
function serializeGraph(graph, options = {}) {
  const indent = options.prettyPrint !== false ? options.indent || 2 : 0;
  return JSON.stringify(graph, null, indent);
}
function generateLinearFlowJson(title, mode, stages2, currentStage, options = {}) {
  const graph = createJsonGraph(title, mode, options);
  if (graph.layout) {
    graph.layout.type = "linear";
    graph.layout.direction = "LR";
  }
  for (let i = 0; i < stages2.length; i++) {
    const stage = stages2[i];
    const isCurrent = stage === currentStage;
    addNode(graph, {
      id: `stage_${i}`,
      label: stage,
      type: isCurrent ? "current" : "stage",
      x: i * 150,
      y: 0,
      color: isCurrent ? "#a8d5ff" : "#e0e0e0",
      shape: isCurrent ? "stadium" : "rectangle"
    });
    if (i > 0) {
      addEdge(graph, {
        id: `edge_${i - 1}_${i}`,
        source: `stage_${i - 1}`,
        target: `stage_${i}`,
        directed: true,
        style: "solid"
      });
    }
  }
  if (graph.metrics) {
    graph.metrics.totalStages = stages2.length;
    graph.metrics.currentStageIndex = stages2.indexOf(currentStage);
    graph.metrics.progress = (stages2.indexOf(currentStage) + 1) / stages2.length;
  }
  if (graph.legend) {
    addLegendItem(graph, "Current Stage", "#a8d5ff", "stadium");
    addLegendItem(graph, "Stage", "#e0e0e0", "rectangle");
  }
  return serializeGraph(graph, options);
}
function generateHierarchyJson(title, mode, root, children, options = {}) {
  const graph = createJsonGraph(title, mode, options);
  if (graph.layout) {
    graph.layout.type = "tree";
    graph.layout.direction = "TB";
  }
  addNode(graph, {
    id: "root",
    label: root.label,
    type: "root",
    x: 0,
    y: 0,
    color: "#a8d5ff",
    shape: "ellipse",
    metadata: root.metadata
  });
  const childCount = children.length;
  const spacing = 150;
  const startX = -((childCount - 1) * spacing) / 2;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    addNode(graph, {
      id: child.id,
      label: child.label,
      type: "child",
      x: startX + i * spacing,
      y: 100,
      color: "#e0e0e0",
      shape: "rectangle",
      metadata: {
        ...child.metadata,
        score: child.score
      }
    });
    addEdge(graph, {
      id: `edge_root_${child.id}`,
      source: "root",
      target: child.id,
      directed: true,
      style: "solid"
    });
  }
  if (graph.metrics) {
    graph.metrics.childCount = children.length;
    if (children.some((c) => c.score !== void 0)) {
      graph.metrics.averageScore = children.reduce((sum, c) => sum + (c.score || 0), 0) / children.length;
      graph.metrics.maxScore = Math.max(...children.map((c) => c.score || 0));
    }
  }
  return serializeGraph(graph, options);
}
function generateBayesianJson(title, prior, posterior, bayesFactor, hypothesis, evidence, options = {}) {
  const graph = createJsonGraph(title, "bayesian", options);
  if (graph.layout) {
    graph.layout.type = "hierarchical";
    graph.layout.direction = "TB";
  }
  addNode(graph, {
    id: "prior",
    label: `Prior: ${prior.toFixed(3)}`,
    type: "prior",
    x: 0,
    y: 0,
    color: "#a8d5ff",
    shape: "stadium"
  });
  addNode(graph, {
    id: "evidence",
    label: "Evidence",
    type: "evidence",
    x: 200,
    y: 0,
    color: "#81c784",
    shape: "rectangle",
    metadata: { items: evidence }
  });
  addNode(graph, {
    id: "hypothesis",
    label: hypothesis,
    type: "hypothesis",
    x: 100,
    y: 100,
    color: "#e0e0e0",
    shape: "ellipse"
  });
  addNode(graph, {
    id: "posterior",
    label: `Posterior: ${posterior.toFixed(3)}`,
    type: "posterior",
    x: 100,
    y: 200,
    color: "#4caf50",
    shape: "stadium"
  });
  addEdge(graph, {
    id: "edge_prior_hyp",
    source: "prior",
    target: "hypothesis",
    directed: true
  });
  addEdge(graph, {
    id: "edge_evidence_hyp",
    source: "evidence",
    target: "hypothesis",
    directed: true
  });
  addEdge(graph, {
    id: "edge_hyp_post",
    source: "hypothesis",
    target: "posterior",
    directed: true
  });
  if (graph.metrics) {
    graph.metrics.prior = prior;
    graph.metrics.posterior = posterior;
    graph.metrics.bayesFactor = bayesFactor;
    graph.metrics.evidenceCount = evidence.length;
    graph.metrics.probabilityChange = posterior - prior;
  }
  if (graph.legend) {
    addLegendItem(graph, "Prior", "#a8d5ff", "stadium");
    addLegendItem(graph, "Evidence", "#81c784", "rectangle");
    addLegendItem(graph, "Hypothesis", "#e0e0e0", "ellipse");
    addLegendItem(graph, "Posterior", "#4caf50", "stadium");
  }
  return serializeGraph(graph, options);
}
function generateCausalJson(title, mode, causes, effects, links, options = {}) {
  const graph = createJsonGraph(title, mode, options);
  if (graph.layout) {
    graph.layout.type = "hierarchical";
    graph.layout.direction = "LR";
  }
  for (let i = 0; i < causes.length; i++) {
    const cause = causes[i];
    addNode(graph, {
      id: cause.id,
      label: cause.label,
      type: "cause",
      x: 0,
      y: i * 80,
      color: "#ffb74d",
      shape: "rectangle",
      metadata: { strength: cause.strength }
    });
  }
  for (let i = 0; i < effects.length; i++) {
    const effect = effects[i];
    addNode(graph, {
      id: effect.id,
      label: effect.label,
      type: "effect",
      x: 250,
      y: i * 80,
      color: "#4fc3f7",
      shape: "rectangle"
    });
  }
  let edgeId = 0;
  for (const link of links) {
    addEdge(graph, {
      id: `causal_${edgeId++}`,
      source: link.cause,
      target: link.effect,
      weight: link.strength,
      directed: true,
      style: "solid"
    });
  }
  if (graph.metrics) {
    graph.metrics.causeCount = causes.length;
    graph.metrics.effectCount = effects.length;
    graph.metrics.linkCount = links.length;
  }
  if (graph.legend) {
    addLegendItem(graph, "Cause", "#ffb74d", "rectangle");
    addLegendItem(graph, "Effect", "#4fc3f7", "rectangle");
  }
  return serializeGraph(graph, options);
}
var init_json_utils = __esm({
  "src/export/visual/json-utils.ts"() {
    init_esm_shims();
  }
});

// src/export/visual/markdown-utils.ts
function heading(text, level = 1) {
  const prefix = "#".repeat(level);
  return `${prefix} ${text}
`;
}
function bold(text) {
  return `**${text}**`;
}
function codeBlock(code, language = "") {
  return `\`\`\`${language}
${code}
\`\`\`
`;
}
function listItem(text, style = "bullet", indent = 0) {
  const indentStr = "  ".repeat(indent);
  switch (style) {
    case "numbered":
      return `${indentStr}1. ${text}`;
    case "checkbox":
      return `${indentStr}- [ ] ${text}`;
    case "checkbox-checked":
      return `${indentStr}- [x] ${text}`;
    case "bullet":
    default:
      return `${indentStr}- ${text}`;
  }
}
function list(items, style = "bullet") {
  return items.map((item, index) => {
    if (style === "numbered") {
      return `${index + 1}. ${item}`;
    }
    return listItem(item, style);
  }).join("\n") + "\n";
}
function getAlignmentSeparator(alignment) {
  switch (alignment) {
    case "center":
      return ":---:";
    case "right":
      return "---:";
    case "left":
    default:
      return ":---";
  }
}
function escapeTableCell(text) {
  return text.replace(/\|/g, "\\|");
}
function table(headers, rows, alignments) {
  const aligns = headers.map(() => "left");
  const headerRow = "| " + headers.map(escapeTableCell).join(" | ") + " |";
  const separatorRow = "| " + aligns.map(getAlignmentSeparator).join(" | ") + " |";
  const dataRows = rows.map((row) => {
    const cells = row.map(escapeTableCell);
    while (cells.length < headers.length) {
      cells.push("");
    }
    return "| " + cells.join(" | ") + " |";
  });
  return [headerRow, separatorRow, ...dataRows].join("\n") + "\n";
}
function progressBar(value, max = 100, width = 20) {
  const percentage = Math.min(100, Math.max(0, value / max * 100));
  const filled = Math.round(percentage / 100 * width);
  const empty = width - filled;
  const bar = "\u2588".repeat(filled) + "\u2591".repeat(empty);
  return `${bar} ${percentage.toFixed(0)}%`;
}
function keyValueSection(items) {
  return Object.entries(items).map(([key, value]) => `- ${bold(key)}: ${value}`).join("\n") + "\n";
}
function mermaidBlock(diagram) {
  return codeBlock(diagram, "mermaid");
}
function section(title, content, level = 2) {
  return heading(title, level) + "\n" + content + "\n";
}
function frontmatter(metadata) {
  const lines = ["---"];
  for (const [key, value] of Object.entries(metadata)) {
    if (Array.isArray(value)) {
      lines.push(`${key}:`);
      value.forEach((v) => lines.push(`  - ${v}`));
    } else {
      lines.push(`${key}: ${typeof value === "string" ? `"${value}"` : value}`);
    }
  }
  lines.push("---", "");
  return lines.join("\n");
}
function document(title, content, options = {}) {
  const { includeFrontmatter = false, metadata = {}, includeTableOfContents = false } = options;
  const parts = [];
  if (includeFrontmatter) {
    const fm = {
      title,
      date: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
      ...metadata
    };
    parts.push(frontmatter(fm));
  }
  parts.push(heading(title, 1));
  if (includeTableOfContents) {
    parts.push("\n## Table of Contents\n\n[TOC]\n");
  }
  parts.push(content);
  return parts.join("\n");
}
var init_markdown_utils = __esm({
  "src/export/visual/markdown-utils.ts"() {
    init_esm_shims();
  }
});

// src/export/visual/causal.ts
function exportCausalGraph(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return causalGraphToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return causalGraphToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return causalGraphToASCII(thought);
    case "svg":
      return causalGraphToSVG(thought, options);
    case "graphml":
      return causalGraphToGraphML(thought, options);
    case "tikz":
      return causalGraphToTikZ(thought, options);
    case "html":
      return causalGraphToHTML(thought, options);
    case "modelica":
      return causalToModelica(thought, options);
    case "uml":
      return causalToUML(thought, options);
    case "json":
      return causalToJSON(thought, options);
    case "markdown":
      return causalToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function causalGraphToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TB\n";
  if (!thought.causalGraph || !thought.causalGraph.nodes) {
    return mermaid + '  NoData["No causal graph data"]\n';
  }
  for (const node of thought.causalGraph.nodes) {
    const nodeId = sanitizeId(node.id);
    const label = includeLabels ? node.name : nodeId;
    let shape;
    switch (node.type) {
      case "cause":
        shape = ["([", "])"];
        break;
      case "effect":
        shape = ["[[", "]]"];
        break;
      case "mediator":
        shape = ["[", "]"];
        break;
      case "confounder":
        shape = ["{", "}"];
        break;
      default:
        shape = ["[", "]"];
    }
    mermaid += `  ${nodeId}${shape[0]}${label}${shape[1]}
`;
  }
  mermaid += "\n";
  for (const edge of thought.causalGraph.edges) {
    const fromId = sanitizeId(edge.from);
    const toId = sanitizeId(edge.to);
    if (includeMetrics && edge.strength !== void 0) {
      mermaid += `  ${fromId} --> |${edge.strength.toFixed(2)}| ${toId}
`;
    } else {
      mermaid += `  ${fromId} --> ${toId}
`;
    }
  }
  if (colorScheme !== "monochrome") {
    mermaid += "\n";
    const causes = thought.causalGraph.nodes.filter((n) => n.type === "cause");
    const effects = thought.causalGraph.nodes.filter((n) => n.type === "effect");
    for (const node of causes) {
      const color = colorScheme === "pastel" ? "#e1f5ff" : "#a8d5ff";
      mermaid += `  style ${sanitizeId(node.id)} fill:${color}
`;
    }
    for (const node of effects) {
      const color = colorScheme === "pastel" ? "#fff3e0" : "#ffd699";
      mermaid += `  style ${sanitizeId(node.id)} fill:${color}
`;
    }
  }
  return mermaid;
}
function causalGraphToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph CausalGraph {\n";
  dot += "  rankdir=TB;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  if (!thought.causalGraph || !thought.causalGraph.nodes) {
    dot += '  NoData [label="No causal graph data"];\n}\n';
    return dot;
  }
  for (const node of thought.causalGraph.nodes) {
    const nodeId = sanitizeId(node.id);
    const label = includeLabels ? node.name : nodeId;
    let shape = "box";
    switch (node.type) {
      case "cause":
        shape = "ellipse";
        break;
      case "effect":
        shape = "doubleoctagon";
        break;
      case "mediator":
        shape = "box";
        break;
      case "confounder":
        shape = "diamond";
        break;
    }
    dot += `  ${nodeId} [label="${label}", shape=${shape}];
`;
  }
  dot += "\n";
  for (const edge of thought.causalGraph.edges) {
    const fromId = sanitizeId(edge.from);
    const toId = sanitizeId(edge.to);
    if (includeMetrics && edge.strength !== void 0) {
      dot += `  ${fromId} -> ${toId} [label="${edge.strength.toFixed(2)}"];
`;
    } else {
      dot += `  ${fromId} -> ${toId};
`;
    }
  }
  dot += "}\n";
  return dot;
}
function causalGraphToASCII(thought) {
  let ascii = "Causal Graph:\n";
  ascii += "=============\n\n";
  if (!thought.causalGraph || !thought.causalGraph.nodes) {
    return ascii + "No causal graph data\n";
  }
  ascii += "Nodes:\n";
  for (const node of thought.causalGraph.nodes) {
    ascii += `  [${node.type.toUpperCase()}] ${node.name}: ${node.description}
`;
  }
  ascii += "\nEdges:\n";
  for (const edge of thought.causalGraph.edges) {
    const fromNode = thought.causalGraph.nodes.find((n) => n.id === edge.from);
    const toNode = thought.causalGraph.nodes.find((n) => n.id === edge.to);
    const strength = edge.strength !== void 0 ? ` (strength: ${edge.strength.toFixed(2)})` : "";
    ascii += `  ${fromNode?.name} --> ${toNode?.name}${strength}
`;
  }
  return ascii;
}
function causalGraphToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width
  } = options;
  if (!thought.causalGraph || !thought.causalGraph.nodes) {
    return generateSVGHeader(svgWidth, 200, "Causal Graph") + '\n  <text x="400" y="100" text-anchor="middle" class="subtitle">No causal graph data</text>\n' + generateSVGFooter();
  }
  const causes = thought.causalGraph.nodes.filter((n) => n.type === "cause");
  const mediators = thought.causalGraph.nodes.filter((n) => n.type === "mediator");
  const confounders = thought.causalGraph.nodes.filter((n) => n.type === "confounder");
  const effects = thought.causalGraph.nodes.filter((n) => n.type === "effect");
  const layers = [
    causes.map((n) => ({ id: n.id, label: includeLabels ? n.name : n.id, type: "cause" })),
    [...mediators, ...confounders].map((n) => ({ id: n.id, label: includeLabels ? n.name : n.id, type: n.type })),
    effects.map((n) => ({ id: n.id, label: includeLabels ? n.name : n.id, type: "effect" }))
  ].filter((layer) => layer.length > 0);
  const positions = layoutNodesInLayers(layers, { width: svgWidth, title: "Causal Graph" });
  const actualHeight = calculateSVGHeight(positions);
  let svg = generateSVGHeader(svgWidth, actualHeight, "Causal Graph");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  for (const edge of thought.causalGraph.edges) {
    const fromPos = positions.get(edge.from);
    const toPos = positions.get(edge.to);
    if (fromPos && toPos) {
      const label = includeMetrics && edge.strength !== void 0 ? edge.strength.toFixed(2) : void 0;
      svg += renderEdge(fromPos, toPos, { label });
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  for (const [, pos] of positions) {
    const colors = getNodeColor(pos.type === "cause" ? "primary" : pos.type === "effect" ? "tertiary" : "neutral", colorScheme);
    switch (pos.type) {
      case "cause":
        svg += renderStadiumNode(pos, colors);
        break;
      case "effect":
        svg += renderEllipseNode(pos, colors);
        break;
      case "confounder":
        svg += renderDiamondNode(pos, colors);
        break;
      default:
        svg += renderRectNode(pos, colors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Nodes", value: thought.causalGraph.nodes.length },
      { label: "Edges", value: thought.causalGraph.edges.length },
      { label: "Causes", value: causes.length },
      { label: "Effects", value: effects.length }
    ];
    svg += renderMetricsPanel(svgWidth - 180, actualHeight - 110, metrics);
  }
  const legendItems = [
    { label: "Cause", color: getNodeColor("primary", colorScheme) },
    { label: "Mediator", color: getNodeColor("neutral", colorScheme) },
    { label: "Confounder", color: getNodeColor("neutral", colorScheme), shape: "diamond" },
    { label: "Effect", color: getNodeColor("tertiary", colorScheme), shape: "ellipse" }
  ];
  svg += renderLegend(20, actualHeight - 100, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function causalGraphToGraphML(thought, options) {
  const { includeMetrics = true } = options;
  if (!thought.causalGraph || !thought.causalGraph.nodes) {
    const emptyNodes = [
      { id: "no_data", label: "No causal graph data", type: "message" }
    ];
    return generateGraphML(emptyNodes, [], { graphName: "Causal Graph" });
  }
  const nodes = thought.causalGraph.nodes.map((node) => ({
    id: node.id,
    label: node.name,
    type: node.type
  }));
  const edges = thought.causalGraph.edges.map((edge, index) => {
    const edgeData = {
      id: `e${index}`,
      source: edge.from,
      target: edge.to
    };
    if (includeMetrics && edge.strength !== void 0) {
      edgeData.metadata = { weight: edge.strength };
    }
    return edgeData;
  });
  const graphmlOptions = {
    graphName: "Causal Graph"
  };
  return generateGraphML(nodes, edges, graphmlOptions);
}
function causalGraphToTikZ(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  if (!thought.causalGraph || !thought.causalGraph.nodes) {
    const emptyNodes = [
      { id: "no_data", x: 0, y: 0, label: "No causal graph data", shape: "rectangle" }
    ];
    return generateTikZ(emptyNodes, [], { title: "Causal Graph" });
  }
  const causes = thought.causalGraph.nodes.filter((n) => n.type === "cause");
  const mediators = thought.causalGraph.nodes.filter((n) => n.type === "mediator");
  const confounders = thought.causalGraph.nodes.filter((n) => n.type === "confounder");
  const effects = thought.causalGraph.nodes.filter((n) => n.type === "effect");
  const nodes = [];
  causes.forEach((node, index) => {
    const spacing = 3;
    const offset = (causes.length - 1) * spacing / 2;
    nodes.push({
      id: node.id,
      x: index * spacing - offset,
      y: 0,
      label: includeLabels ? node.name : node.id,
      shape: "stadium",
      type: node.type
    });
  });
  const middleNodes = [...mediators, ...confounders];
  middleNodes.forEach((node, index) => {
    const spacing = 3;
    const offset = (middleNodes.length - 1) * spacing / 2;
    nodes.push({
      id: node.id,
      x: index * spacing - offset,
      y: -2,
      label: includeLabels ? node.name : node.id,
      shape: node.type === "confounder" ? "diamond" : "rectangle",
      type: node.type
    });
  });
  effects.forEach((node, index) => {
    const spacing = 3;
    const offset = (effects.length - 1) * spacing / 2;
    nodes.push({
      id: node.id,
      x: index * spacing - offset,
      y: -4,
      label: includeLabels ? node.name : node.id,
      shape: "ellipse",
      type: node.type
    });
  });
  const edges = thought.causalGraph.edges.map((edge) => {
    const edgeData = {
      source: edge.from,
      target: edge.to
    };
    if (includeMetrics && edge.strength !== void 0) {
      edgeData.label = edge.strength.toFixed(2);
    }
    return edgeData;
  });
  const tikzOptions = {
    title: "Causal Graph"
  };
  return generateTikZ(nodes, edges, tikzOptions);
}
function causalGraphToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Causal Graph Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  if (!thought.causalGraph || !thought.causalGraph.nodes) {
    html += '<p class="text-secondary">No causal graph data available.</p>\n';
    html += generateHTMLFooter(htmlStandalone);
    return html;
  }
  if (includeMetrics) {
    const causes = thought.causalGraph.nodes.filter((n) => n.type === "cause");
    const effects = thought.causalGraph.nodes.filter((n) => n.type === "effect");
    const mediators = thought.causalGraph.nodes.filter((n) => n.type === "mediator");
    const confounders2 = thought.causalGraph.nodes.filter((n) => n.type === "confounder");
    html += '<div class="metrics-grid">';
    html += renderMetricCard("Total Nodes", thought.causalGraph.nodes.length, "primary");
    html += renderMetricCard("Edges", thought.causalGraph.edges.length, "info");
    html += renderMetricCard("Causes", causes.length, "success");
    html += renderMetricCard("Effects", effects.length, "warning");
    if (mediators.length > 0) {
      html += renderMetricCard("Mediators", mediators.length);
    }
    if (confounders2.length > 0) {
      html += renderMetricCard("Confounders", confounders2.length, "danger");
    }
    html += "</div>\n";
  }
  const nodeRows = thought.causalGraph.nodes.map((node) => {
    const typeBadge = renderBadge(
      node.type,
      node.type === "cause" ? "success" : node.type === "effect" ? "warning" : node.type === "confounder" ? "danger" : "secondary"
    );
    return [node.id, node.name, typeBadge, node.description || "-"];
  });
  html += renderSection("Nodes", renderTable(
    ["ID", "Name", "Type", "Description"],
    nodeRows.map((row) => row.map((cell) => typeof cell === "string" && cell.startsWith("<") ? cell : escapeHTML(String(cell))))
  ), "\u{1F4CA}");
  const edgeRows = thought.causalGraph.edges.map((edge) => {
    const fromNode = thought.causalGraph.nodes.find((n) => n.id === edge.from);
    const toNode = thought.causalGraph.nodes.find((n) => n.id === edge.to);
    return [
      fromNode?.name || edge.from,
      "\u2192",
      toNode?.name || edge.to,
      edge.strength !== void 0 ? edge.strength.toFixed(2) : "-",
      edge.mechanism || "-"
    ];
  });
  html += renderSection("Causal Relationships", renderTable(
    ["From", "", "To", "Strength", "Mechanism"],
    edgeRows
  ), "\u{1F517}");
  const confounders = thought.causalGraph.nodes.filter((n) => n.type === "confounder");
  if (confounders.length > 0) {
    html += renderSection("\u26A0\uFE0F Confounding Variables", `
      <p class="text-warning">The following variables may confound causal inference:</p>
      <ul class="list-styled">
        ${confounders.map((c) => `<li><strong>${escapeHTML(c.name)}</strong>: ${escapeHTML(c.description)}</li>`).join("\n")}
      </ul>
    `);
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function causalToModelica(thought, options) {
  const { modelicaPackageName, modelicaIncludeAnnotations = true, includeMetrics = true } = options;
  const packageName = modelicaPackageName || "CausalGraph";
  const lines = [];
  lines.push(`package ${sanitizeModelicaId(packageName)}`);
  lines.push(`  "Causal analysis graph"`);
  lines.push("");
  if (!thought.causalGraph || !thought.causalGraph.nodes) {
    lines.push("  // No causal graph data");
    lines.push(`end ${sanitizeModelicaId(packageName)};`);
    return lines.join("\n");
  }
  const causes = thought.causalGraph.nodes.filter((n) => n.type === "cause");
  if (causes.length > 0) {
    lines.push("  // Causes");
    for (const cause of causes) {
      const causeId = sanitizeModelicaId(cause.id);
      lines.push(`  record Cause_${causeId}`);
      lines.push(`    constant String description = "${escapeModelicaString(cause.description)}";`);
      lines.push(`    constant String name = "${escapeModelicaString(cause.name)}";`);
      lines.push(`  end Cause_${causeId};`);
      lines.push("");
    }
  }
  const effects = thought.causalGraph.nodes.filter((n) => n.type === "effect");
  if (effects.length > 0) {
    lines.push("  // Effects");
    for (const effect of effects) {
      const effectId = sanitizeModelicaId(effect.id);
      lines.push(`  record Effect_${effectId}`);
      lines.push(`    constant String description = "${escapeModelicaString(effect.description)}";`);
      lines.push(`    constant String name = "${escapeModelicaString(effect.name)}";`);
      lines.push(`  end Effect_${effectId};`);
      lines.push("");
    }
  }
  if (thought.causalGraph.edges && thought.causalGraph.edges.length > 0) {
    lines.push("  // Causal Links");
    for (let i = 0; i < thought.causalGraph.edges.length; i++) {
      const link = thought.causalGraph.edges[i];
      lines.push(`  record Link_${i + 1}`);
      lines.push(`    constant String cause = "${sanitizeModelicaId(link.from)}";`);
      lines.push(`    constant String effect = "${sanitizeModelicaId(link.to)}";`);
      if (link.strength !== void 0 && includeMetrics) {
        lines.push(`    constant Real strength = ${link.strength.toFixed(3)};`);
      }
      if (link.confidence !== void 0 && includeMetrics) {
        lines.push(`    constant Real confidence = ${link.confidence.toFixed(3)};`);
      }
      if (link.mechanism) {
        lines.push(`    constant String mechanism = "${escapeModelicaString(link.mechanism)}";`);
      }
      lines.push(`  end Link_${i + 1};`);
      lines.push("");
    }
  }
  if (modelicaIncludeAnnotations) {
    lines.push("  annotation(");
    lines.push('    Documentation(info="<html>');
    lines.push(`      <p>Causes: ${causes.length}</p>`);
    lines.push(`      <p>Effects: ${effects.length}</p>`);
    lines.push(`      <p>Total Nodes: ${thought.causalGraph.nodes.length}</p>`);
    lines.push(`      <p>Edges: ${thought.causalGraph.edges?.length || 0}</p>`);
    lines.push("      <p>Generated by DeepThinking MCP v7.1.0</p>");
    lines.push('    </html>")');
    lines.push("  );");
  }
  lines.push(`end ${sanitizeModelicaId(packageName)};`);
  return lines.join("\n");
}
function causalToUML(thought, options) {
  const { umlTheme, umlDirection, includeLabels = true, includeMetrics = true } = options;
  if (!thought.causalGraph || !thought.causalGraph.nodes) {
    const emptyNodes = [
      { id: "no_data", label: "No causal graph data", shape: "rectangle" }
    ];
    return generateUmlDiagram(emptyNodes, [], {
      title: "Causal Graph",
      theme: umlTheme,
      direction: umlDirection
    });
  }
  const nodes = [];
  const edges = [];
  const causes = thought.causalGraph.nodes.filter((n) => n.type === "cause");
  for (const cause of causes) {
    const id = sanitizeModelicaId(cause.id);
    nodes.push({
      id: `cause_${id}`,
      label: includeLabels ? cause.name.substring(0, 40) : id,
      shape: "rectangle",
      color: "FFB74D"
    });
  }
  const effects = thought.causalGraph.nodes.filter((n) => n.type === "effect");
  for (const effect of effects) {
    const id = sanitizeModelicaId(effect.id);
    nodes.push({
      id: `effect_${id}`,
      label: includeLabels ? effect.name.substring(0, 40) : id,
      shape: "rectangle",
      color: "4FC3F7"
    });
  }
  const mediators = thought.causalGraph.nodes.filter((n) => n.type === "mediator");
  for (const mediator of mediators) {
    const id = sanitizeModelicaId(mediator.id);
    nodes.push({
      id: `mediator_${id}`,
      label: includeLabels ? mediator.name.substring(0, 40) : id,
      shape: "rectangle",
      color: "81C784"
    });
  }
  const confounders = thought.causalGraph.nodes.filter((n) => n.type === "confounder");
  for (const confounder of confounders) {
    const id = sanitizeModelicaId(confounder.id);
    nodes.push({
      id: `confounder_${id}`,
      label: includeLabels ? confounder.name.substring(0, 40) : id,
      shape: "cloud",
      color: "E57373"
    });
  }
  if (thought.causalGraph.edges) {
    for (const link of thought.causalGraph.edges) {
      const label = includeMetrics && link.strength !== void 0 ? `${link.strength.toFixed(2)}` : void 0;
      const sourceNode = thought.causalGraph.nodes.find((n) => n.id === link.from);
      const targetNode = thought.causalGraph.nodes.find((n) => n.id === link.to);
      const sourcePrefix = sourceNode?.type || "node";
      const targetPrefix = targetNode?.type || "node";
      edges.push({
        source: `${sourcePrefix}_${sanitizeModelicaId(link.from)}`,
        target: `${targetPrefix}_${sanitizeModelicaId(link.to)}`,
        type: "arrow",
        label
      });
    }
  }
  return generateUmlDiagram(nodes, edges, {
    title: "Causal Graph",
    theme: umlTheme,
    direction: umlDirection
  });
}
function causalToJSON(thought, options) {
  const { jsonPrettyPrint = true, jsonIndent = 2, includeMetrics = true } = options;
  if (!thought.causalGraph || !thought.causalGraph.nodes) {
    const emptyData = {
      type: "causal",
      title: "Causal Graph",
      nodes: [],
      edges: []
    };
    return jsonPrettyPrint ? JSON.stringify(emptyData, null, jsonIndent) : JSON.stringify(emptyData);
  }
  const causes = thought.causalGraph.nodes.filter((n) => n.type === "cause").map((c) => ({
    id: sanitizeModelicaId(c.id),
    label: c.name,
    description: c.description
  }));
  const effects = thought.causalGraph.nodes.filter((n) => n.type === "effect").map((e) => ({
    id: sanitizeModelicaId(e.id),
    label: e.name,
    description: e.description
  }));
  const links = (thought.causalGraph.edges || []).map((l) => ({
    cause: sanitizeModelicaId(l.from),
    effect: sanitizeModelicaId(l.to),
    strength: includeMetrics ? l.strength : void 0,
    confidence: includeMetrics ? l.confidence : void 0,
    mechanism: l.mechanism
  }));
  return generateCausalJson(
    "Causal Graph",
    "causal",
    causes,
    effects,
    links,
    {
      prettyPrint: jsonPrettyPrint,
      indent: jsonIndent,
      includeMetrics
    }
  );
}
function causalToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  if (!thought.causalGraph || !thought.causalGraph.nodes) {
    parts.push(section("Status", "No causal graph data available."));
    return document("Causal Graph Analysis", parts.join("\n"), {
      includeFrontmatter: markdownIncludeFrontmatter,
      includeTableOfContents: markdownIncludeToc
    });
  }
  const causes = thought.causalGraph.nodes.filter((n) => n.type === "cause");
  const effects = thought.causalGraph.nodes.filter((n) => n.type === "effect");
  const mediators = thought.causalGraph.nodes.filter((n) => n.type === "mediator");
  const confounders = thought.causalGraph.nodes.filter((n) => n.type === "confounder");
  if (includeMetrics) {
    const metricsContent = keyValueSection({
      "Total Nodes": thought.causalGraph.nodes.length,
      "Edges": thought.causalGraph.edges.length,
      "Causes": causes.length,
      "Effects": effects.length,
      "Mediators": mediators.length,
      "Confounders": confounders.length
    });
    parts.push(section("Metrics", metricsContent));
  }
  const nodeRows = thought.causalGraph.nodes.map((node) => [
    node.id,
    node.name,
    node.type.toUpperCase(),
    node.description || "-"
  ]);
  parts.push(section("Nodes", table(["ID", "Name", "Type", "Description"], nodeRows)));
  const edgeRows = thought.causalGraph.edges.map((edge) => {
    const fromNode = thought.causalGraph.nodes.find((n) => n.id === edge.from);
    const toNode = thought.causalGraph.nodes.find((n) => n.id === edge.to);
    return [
      fromNode?.name || edge.from,
      toNode?.name || edge.to,
      edge.strength !== void 0 ? edge.strength.toFixed(2) : "-",
      edge.mechanism || "-"
    ];
  });
  parts.push(section("Causal Relationships", table(["From", "To", "Strength", "Mechanism"], edgeRows)));
  if (confounders.length > 0) {
    const confounderList = confounders.map((c) => `**${c.name}**: ${c.description}`);
    parts.push(section("\u26A0\uFE0F Confounding Variables", list(confounderList)));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = causalGraphToMermaid(thought, "default", true, true);
    parts.push(section("Causal Graph Diagram", mermaidBlock(mermaidDiagram)));
  }
  return document("Causal Graph Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "causal",
      nodeCount: thought.causalGraph.nodes.length,
      edgeCount: thought.causalGraph.edges.length
    }
  });
}
var init_causal = __esm({
  "src/export/visual/causal.ts"() {
    init_esm_shims();
    init_utils();
    init_svg_utils();
    init_graphml_utils();
    init_tikz_utils();
    init_html_utils();
    init_modelica_utils();
    init_uml_utils();
    init_json_utils();
    init_markdown_utils();
  }
});

// src/export/visual/temporal.ts
function exportTemporalTimeline(thought, options) {
  const { format, includeLabels = true } = options;
  switch (format) {
    case "mermaid":
      return timelineToMermaidGantt(thought, includeLabels);
    case "dot":
      return timelineToDOT(thought, includeLabels);
    case "ascii":
      return timelineToASCII(thought);
    case "svg":
      return timelineToSVG(thought, options);
    case "graphml":
      return timelineToGraphML(thought);
    case "tikz":
      return timelineToTikZ(thought);
    case "html":
      return timelineToHTML(thought, options);
    case "modelica":
      return temporalToModelica(thought);
    case "uml":
      return temporalToUML(thought);
    case "json":
      return temporalToJSON(thought, options);
    case "markdown":
      return temporalToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function timelineToMermaidGantt(thought, includeLabels) {
  let gantt = "gantt\n";
  gantt += `  title ${thought.timeline?.name || "Timeline"}
`;
  gantt += "  dateFormat X\n";
  gantt += "  axisFormat %s\n\n";
  if (!thought.events || thought.events.length === 0) {
    return gantt + "  No events\n";
  }
  gantt += "  section Events\n";
  for (const event of thought.events) {
    const label = includeLabels ? event.name : event.id;
    if (event.type === "instant") {
      gantt += `  ${label} :milestone, ${event.timestamp}, 0s
`;
    } else if (event.type === "interval" && event.duration) {
      gantt += `  ${label} :${event.timestamp}, ${event.duration}s
`;
    }
  }
  return gantt;
}
function timelineToDOT(thought, includeLabels) {
  let dot = "digraph Timeline {\n";
  dot += "  rankdir=LR;\n";
  dot += "  node [shape=box];\n\n";
  if (!thought.events) {
    dot += "}\n";
    return dot;
  }
  const sortedEvents = [...thought.events].sort((a, b) => a.timestamp - b.timestamp);
  for (const event of sortedEvents) {
    const nodeId = sanitizeId(event.id);
    const label = includeLabels ? `${event.name}\\n(t=${event.timestamp})` : nodeId;
    const shape = event.type === "instant" ? "ellipse" : "box";
    dot += `  ${nodeId} [label="${label}", shape=${shape}];
`;
  }
  dot += "\n";
  for (let i = 0; i < sortedEvents.length - 1; i++) {
    const from = sanitizeId(sortedEvents[i].id);
    const to = sanitizeId(sortedEvents[i + 1].id);
    dot += `  ${from} -> ${to};
`;
  }
  if (thought.relations) {
    dot += "\n  // Causal relations\n";
    for (const rel of thought.relations) {
      const from = sanitizeId(rel.from);
      const to = sanitizeId(rel.to);
      dot += `  ${from} -> ${to} [style=dashed, label="${rel.relationType}"];
`;
    }
  }
  dot += "}\n";
  return dot;
}
function timelineToASCII(thought) {
  let ascii = `Timeline: ${thought.timeline?.name || "Untitled"}
`;
  ascii += "=".repeat(40) + "\n\n";
  if (!thought.events || thought.events.length === 0) {
    return ascii + "No events\n";
  }
  const sortedEvents = [...thought.events].sort((a, b) => a.timestamp - b.timestamp);
  for (const event of sortedEvents) {
    const marker = event.type === "instant" ? "\u29BF" : "\u2501";
    ascii += `t=${event.timestamp.toString().padStart(4)} ${marker} ${event.name}
`;
    if (event.duration) {
      ascii += `       ${"\u2514".padStart(5)}\u2192 duration: ${event.duration}
`;
    }
  }
  return ascii;
}
function timelineToGraphML(thought, _options) {
  if (!thought.events || thought.events.length === 0) {
    return createLinearGraphML([], {
      graphName: thought.timeline?.name || "Timeline",
      directed: true
    });
  }
  const sortedEvents = [...thought.events].sort((a, b) => a.timestamp - b.timestamp);
  const labels = sortedEvents.map((event) => event.name);
  return createLinearGraphML(labels, {
    graphName: thought.timeline?.name || "Timeline",
    directed: true
  });
}
function timelineToTikZ(thought, _options) {
  if (!thought.events || thought.events.length === 0) {
    return createLinearTikZ([], {
      title: thought.timeline?.name || "Timeline"
    });
  }
  const sortedEvents = [...thought.events].sort((a, b) => a.timestamp - b.timestamp);
  const labels = sortedEvents.map((event) => event.name);
  return createLinearTikZ(labels, {
    title: thought.timeline?.name || "Timeline"
  });
}
function timelineToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width,
    svgHeight = 300
  } = options;
  const title = thought.timeline?.name || "Timeline";
  if (!thought.events || thought.events.length === 0) {
    return generateSVGHeader(svgWidth, 200, title) + '\n  <text x="400" y="100" text-anchor="middle" class="subtitle">No events</text>\n' + generateSVGFooter();
  }
  const sortedEvents = [...thought.events].sort((a, b) => a.timestamp - b.timestamp);
  const nodes = sortedEvents.map((event) => ({
    id: event.id,
    label: includeLabels ? event.name : event.id,
    type: event.type
  }));
  const positions = layoutNodesHorizontally(nodes, {
    width: svgWidth,
    height: svgHeight,
    nodeWidth: 120,
    nodeHeight: 40,
    nodeSpacing: 30
  });
  let svg = generateSVGHeader(svgWidth, svgHeight, title);
  const axisY = svgHeight / 2 + 40;
  svg += `
  <!-- Timeline Axis -->
  <line x1="40" y1="${axisY}" x2="${svgWidth - 40}" y2="${axisY}" stroke="#333" stroke-width="2" marker-end="url(#arrowhead)"/>`;
  svg += '\n\n  <!-- Edges -->\n  <g class="edges">';
  for (let i = 0; i < sortedEvents.length - 1; i++) {
    const fromPos = positions.get(sortedEvents[i].id);
    const toPos = positions.get(sortedEvents[i + 1].id);
    if (fromPos && toPos) {
      svg += renderHorizontalEdge(fromPos, toPos, {});
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  for (const event of sortedEvents) {
    const pos = positions.get(event.id);
    if (pos) {
      const colors = event.type === "instant" ? getNodeColor("primary", colorScheme) : getNodeColor("secondary", colorScheme);
      if (event.type === "instant") {
        svg += renderEllipseNode(pos, colors);
      } else {
        svg += renderRectNode(pos, colors);
      }
      svg += `
    <text x="${pos.x}" y="${pos.y + pos.height + 15}" text-anchor="middle" class="edge-label">t=${event.timestamp}</text>`;
    }
  }
  svg += "\n  </g>";
  const legendItems = [
    { label: "Instant", color: getNodeColor("primary", colorScheme), shape: "ellipse" },
    { label: "Interval", color: getNodeColor("secondary", colorScheme) }
  ];
  svg += renderLegend(20, svgHeight - 60, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function timelineToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = thought.timeline?.name || "Timeline Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  if (!thought.events || thought.events.length === 0) {
    html += '<p class="text-secondary">No events in timeline.</p>\n';
    html += generateHTMLFooter(htmlStandalone);
    return html;
  }
  const sortedEvents = [...thought.events].sort((a, b) => a.timestamp - b.timestamp);
  if (includeMetrics) {
    const instants = sortedEvents.filter((e) => e.type === "instant");
    const intervals = sortedEvents.filter((e) => e.type === "interval");
    const minTime = sortedEvents[0].timestamp;
    const maxTime = sortedEvents[sortedEvents.length - 1].timestamp;
    html += '<div class="metrics-grid">';
    html += renderMetricCard("Total Events", sortedEvents.length, "primary");
    html += renderMetricCard("Instants", instants.length, "info");
    html += renderMetricCard("Intervals", intervals.length, "success");
    html += renderMetricCard("Time Span", `${minTime} - ${maxTime}`);
    html += "</div>\n";
  }
  const eventRows = sortedEvents.map((event) => {
    const typeBadge = renderBadge(event.type, event.type === "instant" ? "info" : "success");
    return [
      event.timestamp.toString(),
      event.name,
      typeBadge,
      event.duration ? `${event.duration}` : "-",
      event.description || "-"
    ];
  });
  html += renderSection("Events", renderTable(
    ["Timestamp", "Name", "Type", "Duration", "Description"],
    eventRows.map((row) => row.map((cell) => typeof cell === "string" && cell.startsWith("<") ? cell : escapeHTML(String(cell))))
  ), "\u{1F4C5}");
  if (thought.relations && thought.relations.length > 0) {
    const relationRows = thought.relations.map((rel) => {
      const fromEvent = thought.events?.find((e) => e.id === rel.from);
      const toEvent = thought.events?.find((e) => e.id === rel.to);
      return [
        fromEvent?.name || rel.from,
        rel.relationType,
        toEvent?.name || rel.to
      ];
    });
    html += renderSection("Temporal Relations", renderTable(
      ["From", "Relation", "To"],
      relationRows
    ), "\u{1F517}");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function temporalToModelica(thought, _options) {
  const pkgName = sanitizeModelicaId(thought.timeline?.name || "Timeline");
  let modelica = `package ${pkgName}
`;
  modelica += `  "${escapeModelicaString(thought.timeline?.name || "Timeline")} - Temporal Event System"

`;
  if (!thought.events || thought.events.length === 0) {
    modelica += "  // No events\n";
    modelica += `end ${pkgName};
`;
    return modelica;
  }
  const sortedEvents = [...thought.events].sort((a, b) => a.timestamp - b.timestamp);
  modelica += "  // Event Records\n";
  for (const event of sortedEvents) {
    const eventId = sanitizeModelicaId(event.id);
    modelica += `  record ${eventId}
`;
    modelica += `    "${escapeModelicaString(event.name)}"
`;
    modelica += `    parameter Real timestamp = ${event.timestamp} "Event timestamp";
`;
    if (event.duration !== void 0) {
      modelica += `    parameter Real duration = ${event.duration} "Event duration";
`;
    }
    modelica += `    parameter String eventType = "${event.type}" "Event type (instant/interval)";
`;
    if (event.description) {
      modelica += `    parameter String description = "${escapeModelicaString(event.description)}";
`;
    }
    modelica += `  end ${eventId};

`;
  }
  modelica += "  model TimelineModel\n";
  modelica += '    "Temporal event sequence model"\n\n';
  modelica += "    parameter Real timeStart = " + sortedEvents[0].timestamp + ' "Timeline start";\n';
  modelica += "    parameter Real timeEnd = " + sortedEvents[sortedEvents.length - 1].timestamp + ' "Timeline end";\n';
  modelica += `    parameter Integer eventCount = ${sortedEvents.length} "Total number of events";

`;
  modelica += "    // Event instances\n";
  for (const event of sortedEvents) {
    const eventId = sanitizeModelicaId(event.id);
    modelica += `    ${eventId} ${eventId.toLowerCase()}_inst;
`;
  }
  modelica += "\n    // Timeline progression\n";
  modelica += "    discrete Real currentTime(start=timeStart);\n";
  modelica += "  equation\n";
  modelica += "    when time >= timeEnd then\n";
  modelica += "      currentTime = timeEnd;\n";
  modelica += "    end when;\n";
  modelica += "  end TimelineModel;\n\n";
  modelica += `end ${pkgName};
`;
  return modelica;
}
function temporalToUML(thought, _options) {
  if (!thought.events || thought.events.length === 0) {
    return generateStateDiagram([], [], void 0, { title: thought.timeline?.name || "Timeline" });
  }
  const sortedEvents = [...thought.events].sort((a, b) => a.timestamp - b.timestamp);
  const states = sortedEvents.map((event) => event.name);
  const transitions = [];
  for (let i = 0; i < sortedEvents.length - 1; i++) {
    transitions.push({
      from: sortedEvents[i].id,
      to: sortedEvents[i + 1].id,
      event: `\u0394t=${sortedEvents[i + 1].timestamp - sortedEvents[i].timestamp}`
    });
  }
  if (thought.relations) {
    for (const rel of thought.relations) {
      transitions.push({
        from: rel.from,
        to: rel.to,
        event: rel.relationType
      });
    }
  }
  return generateStateDiagram(states, transitions, void 0, { title: thought.timeline?.name || "Timeline" });
}
function temporalToJSON(thought, _options) {
  const graph = createJsonGraph(
    thought.timeline?.name || "Timeline",
    "temporal",
    _options
  );
  if (!thought.events || thought.events.length === 0) {
    return serializeGraph(graph, _options);
  }
  const sortedEvents = [...thought.events].sort((a, b) => a.timestamp - b.timestamp);
  for (const event of sortedEvents) {
    addNode(graph, {
      id: event.id,
      label: event.name,
      type: event.type,
      metadata: {
        timestamp: event.timestamp,
        duration: event.duration,
        description: event.description
      }
    });
  }
  for (let i = 0; i < sortedEvents.length - 1; i++) {
    addEdge(graph, {
      id: `edge_${i}`,
      source: sortedEvents[i].id,
      target: sortedEvents[i + 1].id,
      label: "temporal_next",
      metadata: {
        timeDelta: sortedEvents[i + 1].timestamp - sortedEvents[i].timestamp
      }
    });
  }
  if (thought.relations) {
    let relIdx = sortedEvents.length - 1;
    for (const rel of thought.relations) {
      addEdge(graph, {
        id: `edge_rel_${relIdx++}`,
        source: rel.from,
        target: rel.to,
        label: rel.relationType,
        metadata: {
          edgeType: "causal"
        }
      });
    }
  }
  const instants = sortedEvents.filter((e) => e.type === "instant");
  const intervals = sortedEvents.filter((e) => e.type === "interval");
  addMetric(graph, "totalEvents", sortedEvents.length);
  addMetric(graph, "instantEvents", instants.length);
  addMetric(graph, "intervalEvents", intervals.length);
  addMetric(graph, "timeStart", sortedEvents[0].timestamp);
  addMetric(graph, "timeEnd", sortedEvents[sortedEvents.length - 1].timestamp);
  addMetric(graph, "timeSpan", sortedEvents[sortedEvents.length - 1].timestamp - sortedEvents[0].timestamp);
  return serializeGraph(graph, _options);
}
function temporalToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  const title = thought.timeline?.name || "Timeline";
  if (!thought.events || thought.events.length === 0) {
    parts.push(section("Status", "No events in timeline."));
    return document(`Temporal Analysis: ${title}`, parts.join("\n"), {
      includeFrontmatter: markdownIncludeFrontmatter,
      includeTableOfContents: markdownIncludeToc
    });
  }
  const sortedEvents = [...thought.events].sort((a, b) => a.timestamp - b.timestamp);
  const instants = sortedEvents.filter((e) => e.type === "instant");
  const intervals = sortedEvents.filter((e) => e.type === "interval");
  if (includeMetrics) {
    const metricsContent = keyValueSection({
      "Total Events": sortedEvents.length,
      "Instant Events": instants.length,
      "Interval Events": intervals.length,
      "Time Span": `${sortedEvents[0].timestamp} - ${sortedEvents[sortedEvents.length - 1].timestamp}`
    });
    parts.push(section("Metrics", metricsContent));
  }
  const eventRows = sortedEvents.map((event) => [
    event.timestamp.toString(),
    event.name,
    event.type.toUpperCase(),
    event.duration ? `${event.duration}` : "-",
    event.description || "-"
  ]);
  parts.push(section("Events", table(["Timestamp", "Name", "Type", "Duration", "Description"], eventRows)));
  if (thought.relations && thought.relations.length > 0) {
    const relationRows = thought.relations.map((rel) => {
      const fromEvent = thought.events?.find((e) => e.id === rel.from);
      const toEvent = thought.events?.find((e) => e.id === rel.to);
      return [
        fromEvent?.name || rel.from,
        rel.relationType,
        toEvent?.name || rel.to
      ];
    });
    parts.push(section("Temporal Relations", table(["From", "Relation", "To"], relationRows)));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = timelineToMermaidGantt(thought, true);
    parts.push(section("Timeline Diagram", mermaidBlock(mermaidDiagram)));
  }
  return document(`Temporal Analysis: ${title}`, parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "temporal",
      eventCount: sortedEvents.length
    }
  });
}
var init_temporal = __esm({
  "src/export/visual/temporal.ts"() {
    init_esm_shims();
    init_utils();
    init_svg_utils();
    init_graphml_utils();
    init_tikz_utils();
    init_html_utils();
    init_modelica_utils();
    init_uml_utils();
    init_json_utils();
    init_markdown_utils();
  }
});

// src/export/visual/game-theory.ts
function exportGameTree(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return gameTreeToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return gameTreeToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return gameTreeToASCII(thought);
    case "svg":
      return gameTreeToSVG(thought, options);
    case "graphml":
      return gameTreeToGraphML(thought, options);
    case "tikz":
      return gameTreeToTikZ(thought, options);
    case "html":
      return gameTreeToHTML(thought, options);
    case "modelica":
      return gameTheoryToModelica(thought, options);
    case "uml":
      return gameTheoryToUML(thought, options);
    case "json":
      return gameTheoryToJSON(thought, options);
    case "markdown":
      return gameTheoryToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function gameTreeToMermaid(thought, _colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TD\n";
  if (!thought.game) {
    return mermaid + "  root[No game defined]\n";
  }
  if (thought.gameTree && thought.gameTree.nodes) {
    for (const node of thought.gameTree.nodes) {
      const nodeId = sanitizeId(node.id);
      const label = includeLabels ? node.action || node.id : nodeId;
      const shape = node.type === "terminal" ? ["[[", "]]"] : ["[", "]"];
      mermaid += `  ${nodeId}${shape[0]}${label}${shape[1]}
`;
    }
    mermaid += "\n";
    for (const node of thought.gameTree.nodes) {
      if (node.childNodes && node.childNodes.length > 0) {
        for (const childId of node.childNodes) {
          const fromId = sanitizeId(node.id);
          const toId = sanitizeId(childId);
          const childNode = thought.gameTree.nodes.find((n) => n.id === childId);
          if (includeMetrics && childNode?.action) {
            mermaid += `  ${fromId} --> |${childNode.action}| ${toId}
`;
          } else {
            mermaid += `  ${fromId} --> ${toId}
`;
          }
        }
      }
    }
  } else {
    mermaid += "  root[Game]\n";
    if (thought.strategies) {
      for (const strategy of thought.strategies.slice(0, 5)) {
        const stratId = sanitizeId(strategy.id);
        mermaid += `  root --> ${stratId}[${strategy.name}]
`;
      }
    }
  }
  return mermaid;
}
function gameTreeToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph GameTree {\n";
  dot += "  rankdir=TD;\n";
  dot += "  node [shape=circle];\n\n";
  if (!thought.game) {
    dot += '  root [label="No game"];\n}\n';
    return dot;
  }
  if (thought.gameTree && thought.gameTree.nodes) {
    for (const node of thought.gameTree.nodes) {
      const nodeId = sanitizeId(node.id);
      const label = includeLabels ? node.action || node.id : nodeId;
      const shape = node.type === "terminal" ? "doublecircle" : "circle";
      dot += `  ${nodeId} [label="${label}", shape=${shape}];
`;
    }
    dot += "\n";
    for (const node of thought.gameTree.nodes) {
      if (node.childNodes && node.childNodes.length > 0) {
        for (const childId of node.childNodes) {
          const fromId = sanitizeId(node.id);
          const toId = sanitizeId(childId);
          const childNode = thought.gameTree.nodes.find((n) => n.id === childId);
          if (includeMetrics && childNode?.action) {
            dot += `  ${fromId} -> ${toId} [label="${childNode.action}"];
`;
          } else {
            dot += `  ${fromId} -> ${toId};
`;
          }
        }
      }
    }
  }
  dot += "}\n";
  return dot;
}
function gameTreeToASCII(thought) {
  let ascii = `Game: ${thought.game?.name || "Untitled"}
`;
  ascii += "=".repeat(40) + "\n\n";
  if (thought.strategies && thought.strategies.length > 0) {
    ascii += "Strategies:\n";
    for (const strategy of thought.strategies) {
      const strategyType = strategy.isPure ? "Pure" : "Mixed";
      ascii += `  \u2022 ${strategy.name} (${strategyType})
`;
    }
  }
  if (thought.nashEquilibria && thought.nashEquilibria.length > 0) {
    ascii += "\nEquilibria:\n";
    for (const eq of thought.nashEquilibria) {
      ascii += `  \u2696 ${eq.type}: ${eq.strategyProfile.join(", ")}
`;
      ascii += `    Payoffs: [${eq.payoffs.join(", ")}]
`;
    }
  }
  return ascii;
}
function gameTreeToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width,
    svgHeight = 500
  } = options;
  const title = thought.game?.name || "Game Tree";
  if (!thought.game) {
    return generateSVGHeader(svgWidth, 200, title) + '\n  <text x="400" y="100" text-anchor="middle" class="subtitle">No game defined</text>\n' + generateSVGFooter();
  }
  const positions = /* @__PURE__ */ new Map();
  const nodeWidth = 120;
  const nodeHeight = 40;
  if (thought.gameTree && thought.gameTree.nodes) {
    const nodeDepths = /* @__PURE__ */ new Map();
    const rootNodes = thought.gameTree.nodes.filter((n) => !n.parentNode);
    const queue = rootNodes.map((n) => ({ nodeId: n.id, depth: 0 }));
    while (queue.length > 0) {
      const { nodeId, depth } = queue.shift();
      nodeDepths.set(nodeId, depth);
      const node = thought.gameTree.nodes.find((n) => n.id === nodeId);
      if (node) {
        for (const childId of node.childNodes) {
          queue.push({ nodeId: childId, depth: depth + 1 });
        }
      }
    }
    const nodesByDepth = /* @__PURE__ */ new Map();
    for (const node of thought.gameTree.nodes) {
      const depth = nodeDepths.get(node.id) || 0;
      if (!nodesByDepth.has(depth)) {
        nodesByDepth.set(depth, []);
      }
      nodesByDepth.get(depth).push(node);
    }
    const depths = Array.from(nodesByDepth.keys()).sort((a, b) => a - b);
    const verticalSpacing = 100;
    let currentY = 60;
    for (const depth of depths) {
      const nodesAtDepth = nodesByDepth.get(depth);
      const layerWidth = nodesAtDepth.length * (nodeWidth + 20) - 20;
      let startX = (svgWidth - layerWidth) / 2;
      for (const node of nodesAtDepth) {
        const label = includeLabels ? node.action || node.id : sanitizeId(node.id);
        positions.set(node.id, {
          id: node.id,
          x: startX,
          y: currentY,
          width: nodeWidth,
          height: nodeHeight,
          label,
          type: node.type
        });
        startX += nodeWidth + 20;
      }
      currentY += verticalSpacing;
    }
  } else if (thought.strategies) {
    positions.set("root", {
      id: "root",
      x: svgWidth / 2 - nodeWidth / 2,
      y: 60,
      width: nodeWidth,
      height: nodeHeight,
      label: "Game",
      type: "root"
    });
    const stratCount = Math.min(thought.strategies.length, 5);
    const layerWidth = stratCount * (nodeWidth + 20) - 20;
    let startX = (svgWidth - layerWidth) / 2;
    for (let i = 0; i < stratCount; i++) {
      const strategy = thought.strategies[i];
      positions.set(strategy.id, {
        id: strategy.id,
        x: startX,
        y: 180,
        width: nodeWidth,
        height: nodeHeight,
        label: strategy.name,
        type: "strategy"
      });
      startX += nodeWidth + 20;
    }
  }
  let svg = generateSVGHeader(svgWidth, svgHeight, title);
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  if (thought.gameTree && thought.gameTree.nodes) {
    for (const node of thought.gameTree.nodes) {
      if (node.childNodes) {
        for (const childId of node.childNodes) {
          const fromPos = positions.get(node.id);
          const toPos = positions.get(childId);
          if (fromPos && toPos) {
            svg += renderEdge(fromPos, toPos, {});
          }
        }
      }
    }
  } else if (thought.strategies) {
    const rootPos = positions.get("root");
    if (rootPos) {
      for (const strategy of thought.strategies.slice(0, 5)) {
        const stratPos = positions.get(strategy.id);
        if (stratPos) {
          svg += renderEdge(rootPos, stratPos, {});
        }
      }
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  for (const [, pos] of positions) {
    const colors = pos.type === "terminal" ? getNodeColor("success", colorScheme) : pos.type === "root" ? getNodeColor("primary", colorScheme) : getNodeColor("neutral", colorScheme);
    if (pos.type === "terminal") {
      svg += renderEllipseNode(pos, colors);
    } else {
      svg += renderRectNode(pos, colors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics && thought.nashEquilibria) {
    const metrics = [
      { label: "Equilibria", value: thought.nashEquilibria.length },
      { label: "Strategies", value: thought.strategies?.length || 0 }
    ];
    svg += renderMetricsPanel(svgWidth - 180, svgHeight - 80, metrics);
  }
  const legendItems = [
    { label: "Decision", color: getNodeColor("neutral", colorScheme) },
    { label: "Terminal", color: getNodeColor("success", colorScheme), shape: "ellipse" }
  ];
  svg += renderLegend(20, svgHeight - 60, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function gameTreeToGraphML(thought, options) {
  const { includeLabels = true } = options;
  if (!thought.game) {
    const nodes2 = [{ id: "root", label: "No game defined", type: "root" }];
    return generateGraphML(nodes2, [], { graphName: "Empty Game Tree" });
  }
  if (thought.gameTree && thought.gameTree.nodes && thought.gameTree.nodes.length > 0) {
    const nodes2 = thought.gameTree.nodes.map((node) => ({
      id: sanitizeId(node.id),
      label: includeLabels ? node.action || node.id : node.id,
      type: node.type || "node",
      metadata: {
        action: node.action,
        player: node.playerId
      }
    }));
    const edges = [];
    let edgeCount = 0;
    for (const node of thought.gameTree.nodes) {
      if (node.childNodes && node.childNodes.length > 0) {
        for (const childId of node.childNodes) {
          const childNode = thought.gameTree.nodes.find((n) => n.id === childId);
          edges.push({
            id: `e${edgeCount++}`,
            source: sanitizeId(node.id),
            target: sanitizeId(childId),
            label: includeLabels && childNode?.action ? childNode.action : void 0,
            directed: true
          });
        }
      }
    }
    return generateGraphML(nodes2, edges, { graphName: thought.game?.name || "Game Tree" });
  } else if (thought.strategies && thought.strategies.length > 0) {
    const root = {
      id: "root",
      label: "Game",
      children: thought.strategies.slice(0, 5).map((strategy) => ({
        id: sanitizeId(strategy.id),
        label: strategy.name
      }))
    };
    return createTreeGraphML(root, { graphName: thought.game?.name || "Game Tree" });
  }
  const nodes = [{ id: "root", label: "No game tree", type: "root" }];
  return generateGraphML(nodes, [], { graphName: thought.game?.name || "Game Tree" });
}
function gameTreeToTikZ(thought, options) {
  const { includeLabels = true, colorScheme = "default" } = options;
  if (!thought.game) {
    const nodes2 = [{ id: "root", label: "No game defined", x: 4, y: 0, type: "root", shape: "rectangle" }];
    return generateTikZ(nodes2, [], { title: "Empty Game Tree", colorScheme });
  }
  if (thought.gameTree && thought.gameTree.nodes && thought.gameTree.nodes.length > 0) {
    const nodeDepths = /* @__PURE__ */ new Map();
    const rootNodes = thought.gameTree.nodes.filter((n) => !n.parentNode);
    const queue = rootNodes.map((n) => ({ nodeId: n.id, depth: 0 }));
    while (queue.length > 0) {
      const { nodeId, depth } = queue.shift();
      nodeDepths.set(nodeId, depth);
      const node = thought.gameTree.nodes.find((n) => n.id === nodeId);
      if (node && node.childNodes) {
        for (const childId of node.childNodes) {
          queue.push({ nodeId: childId, depth: depth + 1 });
        }
      }
    }
    const nodesByDepth = /* @__PURE__ */ new Map();
    for (const node of thought.gameTree.nodes) {
      const depth = nodeDepths.get(node.id) || 0;
      if (!nodesByDepth.has(depth)) {
        nodesByDepth.set(depth, []);
      }
      nodesByDepth.get(depth).push(node);
    }
    const nodes2 = [];
    const depths = Array.from(nodesByDepth.keys()).sort((a, b) => a - b);
    for (const depth of depths) {
      const nodesAtDepth = nodesByDepth.get(depth);
      const layerWidth = nodesAtDepth.length * 3;
      const startX = (8 - layerWidth) / 2 + 1.5;
      for (let i = 0; i < nodesAtDepth.length; i++) {
        const node = nodesAtDepth[i];
        nodes2.push({
          id: sanitizeId(node.id),
          label: includeLabels ? node.action || node.id : node.id,
          x: startX + i * 3,
          y: -depth * 2,
          // y decreases by 2 per level
          type: node.type || "neutral",
          shape: node.type === "terminal" ? "ellipse" : "rectangle"
          // Use 'ellipse' for terminal nodes
        });
      }
    }
    const edges = [];
    for (const node of thought.gameTree.nodes) {
      if (node.childNodes && node.childNodes.length > 0) {
        for (const childId of node.childNodes) {
          const childNode = thought.gameTree.nodes.find((n) => n.id === childId);
          edges.push({
            source: sanitizeId(node.id),
            target: sanitizeId(childId),
            label: includeLabels && childNode?.action ? childNode.action : void 0,
            directed: true
          });
        }
      }
    }
    return generateTikZ(nodes2, edges, { title: thought.game?.name || "Game Tree", colorScheme });
  } else if (thought.strategies && thought.strategies.length > 0) {
    const root = {
      id: "root",
      label: "Game",
      children: thought.strategies.slice(0, 5).map((strategy) => ({
        id: sanitizeId(strategy.id),
        label: strategy.name
      }))
    };
    return createTreeTikZ(root, { title: thought.game?.name || "Game Tree", colorScheme });
  }
  const nodes = [{ id: "root", label: "No game tree", x: 4, y: 0, type: "root", shape: "rectangle" }];
  return generateTikZ(nodes, [], { title: thought.game?.name || "Game Tree", colorScheme });
}
function gameTreeToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = thought.game?.name || "Game Theory Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  if (!thought.game) {
    html += '<p class="text-secondary">No game defined.</p>\n';
    html += generateHTMLFooter(htmlStandalone);
    return html;
  }
  html += renderSection("Game Information", `
    <p><strong>Type:</strong> ${escapeHTML(thought.game.type)}</p>
    <p><strong>Players:</strong> ${thought.players ? thought.players.map((p) => escapeHTML(p.name)).join(", ") : thought.game.numPlayers}</p>
    ${thought.game.description ? `<p>${escapeHTML(thought.game.description)}</p>` : ""}
  `, "\u{1F3AE}");
  if (includeMetrics) {
    html += '<div class="metrics-grid">';
    html += renderMetricCard("Players", thought.players ? thought.players.length : thought.game.numPlayers, "primary");
    html += renderMetricCard("Strategies", thought.strategies?.length || 0, "info");
    html += renderMetricCard("Equilibria", thought.nashEquilibria?.length || 0, "success");
    html += "</div>\n";
  }
  if (thought.strategies && thought.strategies.length > 0) {
    const strategyRows = thought.strategies.map((strategy) => {
      const typeBadge = renderBadge(strategy.isPure ? "Pure" : "Mixed", strategy.isPure ? "success" : "info");
      return [
        strategy.name,
        typeBadge,
        strategy.description || "-"
      ];
    });
    html += renderSection("Strategies", renderTable(
      ["Name", "Type", "Description"],
      strategyRows.map((row) => row.map((cell) => typeof cell === "string" && cell.startsWith("<") ? cell : escapeHTML(String(cell))))
    ), "\u{1F4CB}");
  }
  if (thought.nashEquilibria && thought.nashEquilibria.length > 0) {
    const eqRows = thought.nashEquilibria.map((eq) => {
      const typeBadge = renderBadge(eq.type, eq.type === "pure" ? "success" : "info");
      return [
        typeBadge,
        eq.strategyProfile.join(", "),
        `[${eq.payoffs.join(", ")}]`,
        eq.isStrict ? "Yes" : "No"
      ];
    });
    html += renderSection("Nash Equilibria", renderTable(
      ["Type", "Strategy Profile", "Payoffs", "Strict"],
      eqRows.map((row) => row.map((cell) => typeof cell === "string" && cell.startsWith("<") ? cell : escapeHTML(String(cell))))
    ), "\u2696\uFE0F");
  }
  if (thought.payoffMatrix) {
    html += renderSection("Payoff Matrix", `
      <p class="text-secondary">Payoff matrix visualization available in other formats.</p>
    `, "\u{1F4CA}");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function gameTheoryToModelica(thought, options) {
  const { includeMetrics = true } = options;
  const gameName = sanitizeModelicaId(thought.game?.name || "Game");
  let modelica = `package ${gameName}
`;
  modelica += `  "Game Theory Analysis: ${escapeModelicaString(thought.game?.name || "Untitled")}"

`;
  if (thought.players && thought.players.length > 0) {
    modelica += "  record Player\n";
    modelica += '    "Player in the game"\n';
    modelica += '    String id "Player identifier";\n';
    modelica += '    String name "Player name";\n';
    modelica += "  end Player;\n\n";
    for (const player of thought.players) {
      const playerId = sanitizeModelicaId(player.id || player.name);
      modelica += `  constant Player ${playerId} = Player(
`;
      modelica += `    id="${escapeModelicaString(player.id || player.name)}",
`;
      modelica += `    name="${escapeModelicaString(player.name)}"
`;
      modelica += "  );\n";
    }
    modelica += "\n";
  }
  if (thought.strategies && thought.strategies.length > 0) {
    modelica += "  type StrategyType = enumeration(\n";
    const strategyNames = thought.strategies.map((s) => sanitizeModelicaId(s.name));
    modelica += strategyNames.map((name) => `    ${name}`).join(",\n");
    modelica += '\n  ) "Available strategies";\n\n';
    modelica += "  record Strategy\n";
    modelica += '    "Strategy definition"\n';
    modelica += '    String id "Strategy identifier";\n';
    modelica += '    String name "Strategy name";\n';
    modelica += '    Boolean isPure "Whether strategy is pure or mixed";\n';
    modelica += "  end Strategy;\n\n";
    for (const strategy of thought.strategies) {
      const stratId = sanitizeModelicaId(strategy.id);
      modelica += `  constant Strategy ${stratId} = Strategy(
`;
      modelica += `    id="${escapeModelicaString(strategy.id)}",
`;
      modelica += `    name="${escapeModelicaString(strategy.name)}",
`;
      modelica += `    isPure=${strategy.isPure ? "true" : "false"}
`;
      modelica += "  );\n";
    }
    modelica += "\n";
  }
  if (thought.nashEquilibria && thought.nashEquilibria.length > 0) {
    modelica += "  record NashEquilibrium\n";
    modelica += '    "Nash equilibrium definition"\n';
    modelica += '    String equilibriumType "Type: pure or mixed";\n';
    modelica += '    String strategyProfile[:] "Strategy profile";\n';
    modelica += '    Real payoffs[:] "Payoffs for each player";\n';
    modelica += '    Boolean isStrict "Whether equilibrium is strict";\n';
    modelica += "  end NashEquilibrium;\n\n";
    for (let i = 0; i < thought.nashEquilibria.length; i++) {
      const eq = thought.nashEquilibria[i];
      modelica += `  constant NashEquilibrium equilibrium${i + 1} = NashEquilibrium(
`;
      modelica += `    equilibriumType="${escapeModelicaString(eq.type)}",
`;
      modelica += `    strategyProfile={${eq.strategyProfile.map((s) => `"${escapeModelicaString(s)}"`).join(", ")}},
`;
      modelica += `    payoffs={${eq.payoffs.join(", ")}},
`;
      modelica += `    isStrict=${eq.isStrict ? "true" : "false"}
`;
      modelica += "  );\n";
    }
    modelica += "\n";
  }
  if (includeMetrics) {
    modelica += "  // Game Metrics\n";
    modelica += `  constant Integer numPlayers = ${thought.players?.length || thought.game?.numPlayers || 0};
`;
    modelica += `  constant Integer numStrategies = ${thought.strategies?.length || 0};
`;
    modelica += `  constant Integer numEquilibria = ${thought.nashEquilibria?.length || 0};
`;
    modelica += `  constant String gameType = "${escapeModelicaString(thought.game?.type || "unknown")}";
`;
  }
  modelica += `end ${gameName};
`;
  return modelica;
}
function gameTheoryToUML(thought, options) {
  const { includeLabels = true } = options;
  const nodes = [];
  const edges = [];
  if (!thought.game) {
    nodes.push({
      id: "nogame",
      label: "No Game Defined",
      shape: "class",
      stereotype: "error"
    });
    return generateUmlDiagram(nodes, edges, { title: "Game Theory Analysis" });
  }
  const gameNode = {
    id: "game",
    label: thought.game.name || "Game",
    shape: "class",
    attributes: [
      `type: ${thought.game.type}`,
      `players: ${thought.players?.length || thought.game.numPlayers}`
    ]
  };
  nodes.push(gameNode);
  if (thought.players && thought.players.length > 0) {
    for (const player of thought.players) {
      const playerId = sanitizeId(player.id || player.name);
      nodes.push({
        id: playerId,
        label: player.name,
        shape: "class",
        stereotype: "player",
        attributes: [`id: ${player.id || player.name}`]
      });
      edges.push({
        source: "game",
        target: playerId,
        type: "association",
        label: includeLabels ? "has player" : void 0
      });
    }
  }
  if (thought.strategies && thought.strategies.length > 0) {
    for (const strategy of thought.strategies.slice(0, 10)) {
      const stratId = sanitizeId(strategy.id);
      nodes.push({
        id: stratId,
        label: strategy.name,
        shape: "class",
        stereotype: strategy.isPure ? "pure strategy" : "mixed strategy",
        attributes: [
          `id: ${strategy.id}`,
          ...strategy.description ? [`description: ${strategy.description}`] : []
        ]
      });
      edges.push({
        source: "game",
        target: stratId,
        type: "association",
        label: includeLabels ? "uses" : void 0
      });
    }
  }
  if (thought.nashEquilibria && thought.nashEquilibria.length > 0) {
    for (let i = 0; i < thought.nashEquilibria.length; i++) {
      const eq = thought.nashEquilibria[i];
      const eqId = `equilibrium_${i}`;
      nodes.push({
        id: eqId,
        label: `Nash Equilibrium ${i + 1}`,
        shape: "class",
        stereotype: eq.type,
        attributes: [
          `profile: [${eq.strategyProfile.join(", ")}]`,
          `payoffs: [${eq.payoffs.join(", ")}]`,
          `strict: ${eq.isStrict}`
        ]
      });
      edges.push({
        source: "game",
        target: eqId,
        type: "dependency",
        label: includeLabels ? "achieves" : void 0
      });
    }
  }
  return generateUmlDiagram(nodes, edges, {
    title: thought.game.name || "Game Theory Analysis",
    direction: "top to bottom"
  });
}
function gameTheoryToJSON(thought, options) {
  const { includeMetrics = true, includeLabels = true } = options;
  const graph = createJsonGraph(
    thought.game?.name || "Game Theory Analysis",
    "game-theory"
  );
  if (!thought.game) {
    addNode(graph, {
      id: "nogame",
      label: "No Game Defined",
      type: "error"
    });
    return serializeGraph(graph);
  }
  addNode(graph, {
    id: "game",
    label: thought.game.name || "Game",
    type: "game",
    metadata: {
      gameType: thought.game.type,
      numPlayers: thought.players?.length || thought.game.numPlayers,
      description: thought.game.description
    }
  });
  let edgeId = 0;
  if (thought.players && thought.players.length > 0) {
    for (const player of thought.players) {
      const playerId = sanitizeId(player.id || player.name);
      addNode(graph, {
        id: playerId,
        label: player.name,
        type: "player",
        metadata: {
          originalId: player.id
        }
      });
      addEdge(graph, {
        id: `edge_${edgeId++}`,
        source: "game",
        target: playerId,
        label: includeLabels ? "has player" : void 0,
        type: "participates"
      });
    }
  }
  if (thought.strategies && thought.strategies.length > 0) {
    for (const strategy of thought.strategies) {
      const stratId = sanitizeId(strategy.id);
      addNode(graph, {
        id: stratId,
        label: strategy.name,
        type: strategy.isPure ? "pure-strategy" : "mixed-strategy",
        metadata: {
          originalId: strategy.id,
          description: strategy.description,
          isPure: strategy.isPure
        }
      });
      addEdge(graph, {
        id: `edge_${edgeId++}`,
        source: "game",
        target: stratId,
        label: includeLabels ? "uses strategy" : void 0,
        type: "strategy"
      });
    }
  }
  if (thought.nashEquilibria && thought.nashEquilibria.length > 0) {
    for (let i = 0; i < thought.nashEquilibria.length; i++) {
      const eq = thought.nashEquilibria[i];
      const eqId = `equilibrium_${i}`;
      addNode(graph, {
        id: eqId,
        label: `Nash Equilibrium ${i + 1}`,
        type: "equilibrium",
        metadata: {
          equilibriumType: eq.type,
          strategyProfile: eq.strategyProfile,
          payoffs: eq.payoffs,
          isStrict: eq.isStrict
        }
      });
      addEdge(graph, {
        id: `edge_${edgeId++}`,
        source: "game",
        target: eqId,
        label: includeLabels ? "achieves" : void 0,
        type: "outcome"
      });
    }
  }
  if (includeMetrics) {
    addMetric(graph, "Players", thought.players?.length || thought.game?.numPlayers || 0);
    addMetric(graph, "Strategies", thought.strategies?.length || 0);
    addMetric(graph, "Nash Equilibria", thought.nashEquilibria?.length || 0);
  }
  addLegendItem(graph, "Game", "#4A90E2");
  addLegendItem(graph, "Player", "#50C878");
  addLegendItem(graph, "Pure Strategy", "#FFD700");
  addLegendItem(graph, "Mixed Strategy", "#FFA500");
  addLegendItem(graph, "Nash Equilibrium", "#9370DB");
  return serializeGraph(graph);
}
function gameTheoryToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  if (!thought.game) {
    parts.push(section("Status", "No game defined."));
    return document("Game Theory Analysis", parts.join("\n"), {
      includeFrontmatter: markdownIncludeFrontmatter,
      includeTableOfContents: markdownIncludeToc
    });
  }
  const gameInfo = keyValueSection({
    "Game Name": thought.game.name || "Untitled",
    "Type": thought.game.type,
    "Players": thought.players ? thought.players.map((p) => p.name).join(", ") : String(thought.game.numPlayers),
    ...thought.game.description ? { "Description": thought.game.description } : {}
  });
  parts.push(section("Game Information", gameInfo));
  if (includeMetrics) {
    const metricsContent = keyValueSection({
      "Players": thought.players?.length || thought.game.numPlayers,
      "Strategies": thought.strategies?.length || 0,
      "Nash Equilibria": thought.nashEquilibria?.length || 0
    });
    parts.push(section("Metrics", metricsContent));
  }
  if (thought.strategies && thought.strategies.length > 0) {
    const strategyRows = thought.strategies.map((strategy) => [
      strategy.name,
      strategy.isPure ? "Pure" : "Mixed",
      strategy.description || "-"
    ]);
    parts.push(section("Strategies", table(["Name", "Type", "Description"], strategyRows)));
  }
  if (thought.nashEquilibria && thought.nashEquilibria.length > 0) {
    const eqRows = thought.nashEquilibria.map((eq) => [
      eq.type,
      eq.strategyProfile.join(", "),
      `[${eq.payoffs.join(", ")}]`,
      eq.isStrict ? "Yes" : "No"
    ]);
    parts.push(section("Nash Equilibria", table(["Type", "Strategy Profile", "Payoffs", "Strict"], eqRows)));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = gameTreeToMermaid(thought, "default", true, true);
    parts.push(section("Game Tree Diagram", mermaidBlock(mermaidDiagram)));
  }
  return document(`Game Theory Analysis: ${thought.game.name || "Untitled"}`, parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "game-theory",
      gameType: thought.game.type,
      playerCount: thought.players?.length || thought.game.numPlayers
    }
  });
}
var init_game_theory = __esm({
  "src/export/visual/game-theory.ts"() {
    init_esm_shims();
    init_utils();
    init_svg_utils();
    init_graphml_utils();
    init_tikz_utils();
    init_html_utils();
    init_modelica_utils();
    init_uml_utils();
    init_json_utils();
    init_markdown_utils();
  }
});

// src/export/visual/bayesian.ts
function exportBayesianNetwork(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return bayesianToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return bayesianToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return bayesianToASCII(thought);
    case "svg":
      return bayesianToSVG(thought, options);
    case "graphml":
      return bayesianToGraphML(thought, options);
    case "tikz":
      return bayesianToTikZ(thought, options);
    case "html":
      return bayesianToHTML(thought, options);
    case "modelica":
      return bayesianToModelica(thought, options);
    case "uml":
      return bayesianToUML(thought, options);
    case "json":
      return bayesianToJSON(thought, options);
    case "markdown":
      return bayesianToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function bayesianToMermaid(thought, colorScheme, _includeLabels, includeMetrics) {
  let mermaid = "graph LR\n";
  mermaid += `  H([Hypothesis])
`;
  mermaid += `  Prior[Prior: ${includeMetrics ? thought.prior.probability.toFixed(3) : "?"}]
`;
  mermaid += `  Evidence[Evidence]
`;
  mermaid += `  Posterior[[Posterior: ${includeMetrics ? thought.posterior.probability.toFixed(3) : "?"}]]
`;
  mermaid += "\n";
  mermaid += "  Prior --> H\n";
  mermaid += "  Evidence --> H\n";
  mermaid += "  H --> Posterior\n";
  if (colorScheme !== "monochrome") {
    mermaid += "\n";
    const priorColor = colorScheme === "pastel" ? "#e1f5ff" : "#a8d5ff";
    const posteriorColor = colorScheme === "pastel" ? "#c8e6c9" : "#81c784";
    mermaid += `  style Prior fill:${priorColor}
`;
    mermaid += `  style Posterior fill:${posteriorColor}
`;
  }
  return mermaid;
}
function bayesianToDOT(thought, _includeLabels, includeMetrics) {
  let dot = "digraph BayesianNetwork {\n";
  dot += "  rankdir=LR;\n";
  dot += "  node [shape=ellipse];\n\n";
  const priorProb = includeMetrics ? `: ${thought.prior.probability.toFixed(3)}` : "";
  const posteriorProb = includeMetrics ? `: ${thought.posterior.probability.toFixed(3)}` : "";
  dot += `  Prior [label="Prior${priorProb}"];
`;
  dot += `  Hypothesis [label="Hypothesis", shape=box];
`;
  dot += `  Evidence [label="Evidence"];
`;
  dot += `  Posterior [label="Posterior${posteriorProb}", shape=doublecircle];
`;
  dot += "\n";
  dot += "  Prior -> Hypothesis;\n";
  dot += "  Evidence -> Hypothesis;\n";
  dot += "  Hypothesis -> Posterior;\n";
  dot += "}\n";
  return dot;
}
function bayesianToASCII(thought) {
  let ascii = "Bayesian Network:\n";
  ascii += "=================\n\n";
  ascii += `Hypothesis: ${thought.hypothesis.statement}

`;
  ascii += `Prior Probability: ${thought.prior.probability.toFixed(3)}
`;
  ascii += `  Justification: ${thought.prior.justification}

`;
  if (thought.evidence && thought.evidence.length > 0) {
    ascii += "Evidence:\n";
    for (const ev of thought.evidence) {
      ascii += `  \u2022 ${ev.description}
`;
    }
    ascii += "\n";
  }
  ascii += `Posterior Probability: ${thought.posterior.probability.toFixed(3)}
`;
  ascii += `  Calculation: ${thought.posterior.calculation}
`;
  if (thought.bayesFactor !== void 0) {
    ascii += `
Bayes Factor: ${thought.bayesFactor.toFixed(2)}
`;
  }
  return ascii;
}
function bayesianToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width,
    svgHeight = 400
  } = options;
  const nodeWidth = 140;
  const nodeHeight = 50;
  const centerX = svgWidth / 2;
  const positions = /* @__PURE__ */ new Map();
  positions.set("prior", {
    id: "prior",
    x: centerX - 200,
    y: 80,
    width: nodeWidth,
    height: nodeHeight,
    label: `Prior: ${includeMetrics ? thought.prior.probability.toFixed(3) : "?"}`,
    type: "prior"
  });
  positions.set("evidence", {
    id: "evidence",
    x: centerX + 60,
    y: 80,
    width: nodeWidth,
    height: nodeHeight,
    label: "Evidence",
    type: "evidence"
  });
  positions.set("hypothesis", {
    id: "hypothesis",
    x: centerX - nodeWidth / 2,
    y: 180,
    width: nodeWidth,
    height: nodeHeight,
    label: "Hypothesis",
    type: "hypothesis"
  });
  positions.set("posterior", {
    id: "posterior",
    x: centerX - nodeWidth / 2,
    y: 280,
    width: nodeWidth,
    height: nodeHeight,
    label: `Posterior: ${includeMetrics ? thought.posterior.probability.toFixed(3) : "?"}`,
    type: "posterior"
  });
  let svg = generateSVGHeader(svgWidth, svgHeight, "Bayesian Network");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  svg += renderEdge(positions.get("prior"), positions.get("hypothesis"), {});
  svg += renderEdge(positions.get("evidence"), positions.get("hypothesis"), {});
  svg += renderEdge(positions.get("hypothesis"), positions.get("posterior"), {});
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  svg += renderStadiumNode(positions.get("prior"), getNodeColor("primary", colorScheme));
  svg += renderRectNode(positions.get("evidence"), getNodeColor("info", colorScheme));
  svg += renderEllipseNode(positions.get("hypothesis"), getNodeColor("neutral", colorScheme));
  svg += renderStadiumNode(positions.get("posterior"), getNodeColor("success", colorScheme));
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Prior", value: thought.prior.probability.toFixed(3) },
      { label: "Posterior", value: thought.posterior.probability.toFixed(3) },
      { label: "Bayes Factor", value: thought.bayesFactor?.toFixed(2) || "N/A" }
    ];
    svg += renderMetricsPanel(svgWidth - 180, svgHeight - 100, metrics);
  }
  const legendItems = [
    { label: "Prior", color: getNodeColor("primary", colorScheme) },
    { label: "Evidence", color: getNodeColor("info", colorScheme) },
    { label: "Hypothesis", color: getNodeColor("neutral", colorScheme), shape: "ellipse" },
    { label: "Posterior", color: getNodeColor("success", colorScheme) }
  ];
  svg += renderLegend(20, svgHeight - 100, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function bayesianToGraphML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [
    { id: "prior", label: includeLabels ? `Prior: ${thought.prior.probability.toFixed(3)}` : "Prior", type: "prior" },
    { id: "hypothesis", label: "Hypothesis", type: "hypothesis" },
    { id: "evidence", label: "Evidence", type: "evidence" },
    { id: "posterior", label: includeLabels ? `Posterior: ${thought.posterior.probability.toFixed(3)}` : "Posterior", type: "posterior" }
  ];
  const edges = [
    { id: "e1", source: "prior", target: "hypothesis" },
    { id: "e2", source: "evidence", target: "hypothesis" },
    { id: "e3", source: "hypothesis", target: "posterior" }
  ];
  return generateGraphML(nodes, edges, {
    graphName: "Bayesian Network",
    includeLabels,
    includeMetadata: includeMetrics
  });
}
function bayesianToTikZ(thought, options) {
  const { includeLabels = true, includeMetrics = true, colorScheme = "default" } = options;
  const nodes = [
    { id: "prior", label: includeLabels ? `Prior: ${thought.prior.probability.toFixed(3)}` : "Prior", x: 0, y: 0, type: "primary", shape: "stadium" },
    { id: "evidence", label: "Evidence", x: 4, y: 0, type: "info", shape: "rectangle" },
    { id: "hypothesis", label: "Hypothesis", x: 2, y: -2, type: "neutral", shape: "ellipse" },
    { id: "posterior", label: includeLabels ? `Posterior: ${thought.posterior.probability.toFixed(3)}` : "Posterior", x: 2, y: -4, type: "success", shape: "stadium" }
  ];
  const edges = [
    { source: "prior", target: "hypothesis", directed: true },
    { source: "evidence", target: "hypothesis", directed: true },
    { source: "hypothesis", target: "posterior", directed: true }
  ];
  return generateTikZ(nodes, edges, {
    title: "Bayesian Network",
    includeLabels,
    includeMetrics,
    colorScheme
  });
}
function bayesianToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Bayesian Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  html += renderSection("Hypothesis", `
    <p><strong>${escapeHTML(thought.hypothesis.statement)}</strong></p>
    ${thought.hypothesis.alternatives && thought.hypothesis.alternatives.length > 0 ? `<p class="text-secondary">Alternatives: ${thought.hypothesis.alternatives.join(", ")}</p>` : ""}
  `, "\u{1F3AF}");
  if (includeMetrics) {
    html += '<div class="metrics-grid">';
    html += renderMetricCard("Prior", (thought.prior.probability * 100).toFixed(1) + "%", "primary");
    html += renderMetricCard("Posterior", (thought.posterior.probability * 100).toFixed(1) + "%", "success");
    if (thought.bayesFactor !== void 0) {
      html += renderMetricCard("Bayes Factor", thought.bayesFactor.toFixed(2), "info");
    }
    html += "</div>\n";
    html += '<div class="card">';
    html += '<div class="card-header">Prior Probability</div>';
    html += renderProgressBar(thought.prior.probability * 100, "primary");
    html += `<p class="text-secondary" style="margin-top: 0.5rem">${escapeHTML(thought.prior.justification)}</p>`;
    html += "</div>\n";
    html += '<div class="card">';
    html += '<div class="card-header">Posterior Probability</div>';
    html += renderProgressBar(thought.posterior.probability * 100, "success");
    html += `<p class="text-secondary" style="margin-top: 0.5rem">${escapeHTML(thought.posterior.calculation)}</p>`;
    html += "</div>\n";
  }
  if (thought.evidence && thought.evidence.length > 0) {
    const evidenceRows = thought.evidence.map((ev, i) => [
      (i + 1).toString(),
      ev.description,
      ev.likelihoodGivenHypothesis?.toFixed(3) || "-",
      ev.likelihoodGivenNotHypothesis?.toFixed(3) || "-"
    ]);
    html += renderSection("Evidence", renderTable(
      ["#", "Description", "P(E|H)", "P(E|\xACH)"],
      evidenceRows
    ), "\u{1F4CA}");
  }
  const change = thought.posterior.probability - thought.prior.probability;
  const changeDirection = change > 0 ? "increased" : change < 0 ? "decreased" : "unchanged";
  const changeClass = change > 0 ? "text-success" : change < 0 ? "text-danger" : "text-secondary";
  html += renderSection("Interpretation", `
    <p>The posterior probability has <span class="${changeClass}"><strong>${changeDirection}</strong></span>
    by ${Math.abs(change * 100).toFixed(1)} percentage points from the prior.</p>
    ${thought.bayesFactor !== void 0 ? `
      <p>Bayes Factor of ${thought.bayesFactor.toFixed(2)} indicates
      ${thought.bayesFactor > 3 ? "substantial" : thought.bayesFactor > 1 ? "weak" : "evidence against"}
      support for the hypothesis.</p>
    ` : ""}
  `, "\u{1F4A1}");
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function bayesianToModelica(thought, options) {
  const { modelicaPackageName, modelicaIncludeAnnotations = true, includeMetrics = true } = options;
  const packageName = modelicaPackageName || "BayesianNetwork";
  const lines = [];
  lines.push(`package ${sanitizeModelicaId(packageName)}`);
  lines.push(`  "Bayesian network analysis"`);
  lines.push("");
  lines.push("  record Hypothesis");
  lines.push(`    constant String statement = "${escapeModelicaString(thought.hypothesis.statement)}";`);
  if (thought.hypothesis.alternatives && thought.hypothesis.alternatives.length > 0) {
    lines.push(`    constant Integer alternativeCount = ${thought.hypothesis.alternatives.length};`);
  }
  lines.push("  end Hypothesis;");
  lines.push("");
  lines.push("  // Probability parameters");
  lines.push(`  parameter Real prior = ${thought.prior.probability.toFixed(6)} "Prior probability";`);
  lines.push(`  parameter Real posterior = ${thought.posterior.probability.toFixed(6)} "Posterior probability";`);
  if (thought.bayesFactor !== void 0) {
    lines.push(`  parameter Real bayesFactor = ${thought.bayesFactor.toFixed(6)} "Bayes factor";`);
  }
  lines.push("");
  if (includeMetrics) {
    lines.push("  // Computed metrics");
    lines.push(`  final parameter Real probabilityChange = posterior - prior;`);
    lines.push(`  final parameter Real updateRatio = posterior / max(prior, 1e-10);`);
    lines.push("");
  }
  if (thought.evidence && thought.evidence.length > 0) {
    lines.push("  // Evidence");
    for (let i = 0; i < thought.evidence.length; i++) {
      const ev = thought.evidence[i];
      lines.push(`  record Evidence_${i + 1}`);
      lines.push(`    constant String description = "${escapeModelicaString(ev.description)}";`);
      if (ev.likelihoodGivenHypothesis !== void 0) {
        lines.push(`    constant Real likelihoodGivenH = ${ev.likelihoodGivenHypothesis.toFixed(6)};`);
      }
      if (ev.likelihoodGivenNotHypothesis !== void 0) {
        lines.push(`    constant Real likelihoodGivenNotH = ${ev.likelihoodGivenNotHypothesis.toFixed(6)};`);
      }
      lines.push(`  end Evidence_${i + 1};`);
      lines.push("");
    }
  }
  if (modelicaIncludeAnnotations) {
    lines.push("  annotation(");
    lines.push('    Documentation(info="<html>');
    lines.push(`      <p><b>Prior:</b> ${(thought.prior.probability * 100).toFixed(1)}%</p>`);
    lines.push(`      <p><b>Posterior:</b> ${(thought.posterior.probability * 100).toFixed(1)}%</p>`);
    lines.push("      <p>Generated by DeepThinking MCP v7.1.0</p>");
    lines.push('    </html>")');
    lines.push("  );");
  }
  lines.push(`end ${sanitizeModelicaId(packageName)};`);
  return lines.join("\n");
}
function bayesianToUML(thought, options) {
  const { umlTheme, umlDirection, includeMetrics = true } = options;
  const nodes = [
    {
      id: "prior",
      label: includeMetrics ? `Prior: ${thought.prior.probability.toFixed(3)}` : "Prior",
      shape: "entity"
    },
    {
      id: "evidence",
      label: "Evidence",
      shape: "rectangle"
    },
    {
      id: "hypothesis",
      label: "Hypothesis",
      shape: "usecase"
    },
    {
      id: "posterior",
      label: includeMetrics ? `Posterior: ${thought.posterior.probability.toFixed(3)}` : "Posterior",
      shape: "entity",
      color: "90EE90"
    }
  ];
  const edges = [
    { source: "prior", target: "hypothesis", type: "arrow" },
    { source: "evidence", target: "hypothesis", type: "arrow" },
    { source: "hypothesis", target: "posterior", type: "arrow" }
  ];
  return generateUmlDiagram(nodes, edges, {
    title: "Bayesian Network",
    theme: umlTheme,
    direction: umlDirection
  });
}
function bayesianToJSON(thought, options) {
  const { jsonPrettyPrint = true, jsonIndent = 2 } = options;
  const evidenceDescriptions = thought.evidence?.map((e) => e.description) || [];
  return generateBayesianJson(
    "Bayesian Network",
    thought.prior.probability,
    thought.posterior.probability,
    thought.bayesFactor,
    thought.hypothesis.statement,
    evidenceDescriptions,
    {
      prettyPrint: jsonPrettyPrint,
      indent: jsonIndent
    }
  );
}
function bayesianToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  const hypothesisContent = `**${thought.hypothesis.statement}**

` + (thought.hypothesis.alternatives && thought.hypothesis.alternatives.length > 0 ? `Alternatives: ${thought.hypothesis.alternatives.join(", ")}` : "");
  parts.push(section("Hypothesis", hypothesisContent));
  if (includeMetrics) {
    const priorPct = (thought.prior.probability * 100).toFixed(1);
    const posteriorPct = (thought.posterior.probability * 100).toFixed(1);
    const metricsContent = keyValueSection({
      "Prior Probability": `${priorPct}%`,
      "Posterior Probability": `${posteriorPct}%`,
      ...thought.bayesFactor !== void 0 ? { "Bayes Factor": thought.bayesFactor.toFixed(2) } : {}
    });
    parts.push(section("Probabilities", metricsContent));
    parts.push(section("Prior", `${progressBar(thought.prior.probability * 100)}

${thought.prior.justification}`));
    parts.push(section("Posterior", `${progressBar(thought.posterior.probability * 100)}

${thought.posterior.calculation}`));
  }
  if (thought.evidence && thought.evidence.length > 0) {
    const evidenceRows = thought.evidence.map((ev, i) => [
      (i + 1).toString(),
      ev.description,
      ev.likelihoodGivenHypothesis?.toFixed(3) || "-",
      ev.likelihoodGivenNotHypothesis?.toFixed(3) || "-"
    ]);
    parts.push(section("Evidence", table(["#", "Description", "P(E|H)", "P(E|\xACH)"], evidenceRows)));
  }
  const change = thought.posterior.probability - thought.prior.probability;
  const changeDirection = change > 0 ? "increased" : change < 0 ? "decreased" : "unchanged";
  const interpretation = `The posterior probability has **${changeDirection}** by ${Math.abs(change * 100).toFixed(1)} percentage points from the prior.` + (thought.bayesFactor !== void 0 ? `

Bayes Factor of ${thought.bayesFactor.toFixed(2)} indicates ${thought.bayesFactor > 3 ? "substantial" : thought.bayesFactor > 1 ? "weak" : "evidence against"} support for the hypothesis.` : "");
  parts.push(section("Interpretation", interpretation));
  if (markdownIncludeMermaid) {
    const mermaidDiagram = bayesianToMermaid(thought, "default", true, true);
    parts.push(section("Bayesian Network Diagram", mermaidBlock(mermaidDiagram)));
  }
  return document("Bayesian Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "bayesian",
      prior: thought.prior.probability,
      posterior: thought.posterior.probability
    }
  });
}
var init_bayesian = __esm({
  "src/export/visual/bayesian.ts"() {
    init_esm_shims();
    init_svg_utils();
    init_graphml_utils();
    init_tikz_utils();
    init_html_utils();
    init_modelica_utils();
    init_uml_utils();
    init_json_utils();
    init_markdown_utils();
  }
});

// src/export/visual/sequential.ts
function exportSequentialDependencyGraph(thought, options) {
  const { format, colorScheme = "default", includeLabels = true } = options;
  switch (format) {
    case "mermaid":
      return sequentialToMermaid(thought, colorScheme, includeLabels);
    case "dot":
      return sequentialToDOT(thought, includeLabels);
    case "ascii":
      return sequentialToASCII(thought);
    case "svg":
      return sequentialToSVG(thought, options);
    case "graphml":
      return sequentialToGraphML(thought, options);
    case "tikz":
      return sequentialToTikZ(thought, options);
    case "html":
      return sequentialToHTML(thought, options);
    case "modelica":
      return sequentialToModelica(thought, options);
    case "uml":
      return sequentialToUML(thought, options);
    case "json":
      return sequentialToJSON(thought, options);
    case "markdown":
      return sequentialToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function sequentialToMermaid(thought, colorScheme, includeLabels) {
  const scheme = colorScheme;
  const nodes = [];
  const edges = [];
  const nodeId = sanitizeId(thought.id);
  const label = includeLabels ? truncateLabel(thought.content, 50) : nodeId;
  nodes.push({
    id: nodeId,
    label,
    shape: thought.isRevision ? "hexagon" : "stadium",
    style: colorScheme !== "monochrome" ? {
      fill: thought.isRevision ? getMermaidColor("warning", scheme) : getMermaidColor("primary", scheme)
    } : void 0
  });
  if (thought.buildUpon && thought.buildUpon.length > 0) {
    for (const depId of thought.buildUpon) {
      const depNodeId = sanitizeId(depId);
      nodes.push({
        id: depNodeId,
        label: depNodeId,
        shape: "rectangle"
      });
      edges.push({
        source: depNodeId,
        target: nodeId,
        style: "arrow"
      });
    }
  }
  if (thought.branchFrom) {
    const branchId = sanitizeId(thought.branchFrom);
    edges.push({
      source: branchId,
      target: nodeId,
      style: "dotted",
      label: "branch"
    });
  }
  if (thought.revisesThought) {
    const revisedId = sanitizeId(thought.revisesThought);
    edges.push({
      source: revisedId,
      target: nodeId,
      style: "thick",
      label: "revises"
    });
  }
  return generateMermaidFlowchart(nodes, edges, { direction: "TD", colorScheme: scheme });
}
function sequentialToDOT(thought, includeLabels) {
  const nodes = [];
  const edges = [];
  const nodeId = sanitizeId(thought.id);
  const label = includeLabels ? truncateDotLabel(thought.content, 50) : nodeId;
  nodes.push({
    id: nodeId,
    label,
    shape: thought.isRevision ? "hexagon" : "box",
    style: ["rounded", "filled"],
    fillColor: thought.isRevision ? "#ffd699" : "#a8d5ff"
  });
  if (thought.buildUpon && thought.buildUpon.length > 0) {
    for (const depId of thought.buildUpon) {
      const depNodeId = sanitizeId(depId);
      nodes.push({
        id: depNodeId,
        label: depNodeId,
        shape: "box",
        style: "rounded"
      });
      edges.push({
        source: depNodeId,
        target: nodeId
      });
    }
  }
  if (thought.branchFrom) {
    const branchId = sanitizeId(thought.branchFrom);
    edges.push({
      source: branchId,
      target: nodeId,
      style: "dashed",
      label: "branch"
    });
  }
  if (thought.revisesThought) {
    const revisedId = sanitizeId(thought.revisesThought);
    edges.push({
      source: revisedId,
      target: nodeId,
      style: "bold",
      label: "revises"
    });
  }
  return generateDotGraph(nodes, edges, {
    graphName: "SequentialDependency",
    rankDir: "TB",
    nodeDefaults: { shape: "box", style: "rounded" }
  });
}
function sequentialToASCII(thought) {
  const lines = [];
  lines.push(generateAsciiHeader("Sequential Dependency Graph", "equals"));
  lines.push("");
  lines.push(`Current Thought: ${thought.id}`);
  lines.push(`Content: ${thought.content.substring(0, 100)}...`);
  lines.push("");
  if (thought.buildUpon && thought.buildUpon.length > 0) {
    lines.push(generateAsciiSectionHeader("Builds Upon"));
    lines.push(generateAsciiBulletList(
      thought.buildUpon.map((depId) => `\u2193 ${depId}`),
      "asciiBullet",
      0
    ));
    lines.push("");
  }
  if (thought.branchFrom) {
    lines.push(generateAsciiSectionHeader("Branch Information"));
    lines.push(`  Branches From: ${thought.branchFrom}`);
    if (thought.branchId) {
      lines.push(`  Branch ID: ${thought.branchId}`);
    }
    lines.push("");
  }
  if (thought.revisesThought) {
    lines.push(generateAsciiSectionHeader("Revision Information"));
    lines.push(`  Revises: ${thought.revisesThought}`);
    if (thought.revisionReason) {
      lines.push(`  Reason: ${thought.revisionReason}`);
    }
    lines.push("");
  }
  return lines.join("\n");
}
function sequentialToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width
  } = options;
  const nodeWidth = 160;
  const nodeHeight = 50;
  const padding = 40;
  const verticalSpacing = 80;
  const positions = /* @__PURE__ */ new Map();
  let currentY = padding + 40;
  const mainNodeId = sanitizeId(thought.id);
  const mainLabel = includeLabels ? thought.content.substring(0, 40) + "..." : mainNodeId;
  if (thought.buildUpon && thought.buildUpon.length > 0) {
    const depWidth = thought.buildUpon.length * (nodeWidth + 20) - 20;
    let startX = (svgWidth - depWidth) / 2;
    for (const depId of thought.buildUpon) {
      const depNodeId = sanitizeId(depId);
      positions.set(depId, {
        id: depId,
        x: startX,
        y: currentY,
        width: nodeWidth,
        height: nodeHeight,
        label: depNodeId,
        type: "dependency"
      });
      startX += nodeWidth + 20;
    }
    currentY += nodeHeight + verticalSpacing;
  }
  positions.set(thought.id, {
    id: thought.id,
    x: (svgWidth - nodeWidth) / 2,
    y: currentY,
    width: nodeWidth,
    height: nodeHeight,
    label: mainLabel,
    type: thought.isRevision ? "revision" : "main"
  });
  currentY += nodeHeight + padding;
  const actualHeight = currentY + 80;
  let svg = generateSVGHeader(svgWidth, actualHeight, "Sequential Dependency Graph");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  if (thought.buildUpon) {
    for (const depId of thought.buildUpon) {
      const fromPos = positions.get(depId);
      const toPos = positions.get(thought.id);
      if (fromPos && toPos) {
        svg += renderEdge(fromPos, toPos, {});
      }
    }
  }
  if (thought.branchFrom) {
    const branchLabel = "branch";
    svg += `
    <text x="${svgWidth / 2 - 100}" y="${padding + 20}" class="edge-label">${branchLabel} from: ${thought.branchFrom}</text>`;
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  for (const [, pos] of positions) {
    const colors = pos.type === "revision" ? getNodeColor("warning", colorScheme) : pos.type === "main" ? getNodeColor("primary", colorScheme) : getNodeColor("neutral", colorScheme);
    if (pos.type === "main" || pos.type === "revision") {
      svg += renderStadiumNode(pos, colors);
    } else {
      svg += renderRectNode(pos, colors);
    }
  }
  svg += "\n  </g>";
  const legendItems = [
    { label: "Current", color: getNodeColor("primary", colorScheme) },
    { label: "Revision", color: getNodeColor("warning", colorScheme) },
    { label: "Dependency", color: getNodeColor("neutral", colorScheme) }
  ];
  svg += renderLegend(20, actualHeight - 80, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function sequentialToGraphML(thought, options) {
  const { includeLabels = true } = options;
  const nodes = [];
  const edges = [];
  if (thought.buildUpon && thought.buildUpon.length > 0) {
    thought.buildUpon.forEach((depId, index) => {
      nodes.push({
        id: sanitizeId(depId),
        label: includeLabels ? `Step ${index + 1}: ${depId}` : sanitizeId(depId),
        type: "dependency"
      });
    });
    nodes.push({
      id: sanitizeId(thought.id),
      label: includeLabels ? `Step ${nodes.length + 1}: ${thought.content.substring(0, 50)}...` : sanitizeId(thought.id),
      type: "current"
    });
    thought.buildUpon.forEach((depId, index) => {
      const sourceId = sanitizeId(depId);
      const targetId = index < thought.buildUpon.length - 1 ? sanitizeId(thought.buildUpon[index + 1]) : sanitizeId(thought.id);
      edges.push({
        id: `e${index}`,
        source: sourceId,
        target: targetId,
        directed: true
      });
    });
  } else {
    nodes.push({
      id: sanitizeId(thought.id),
      label: includeLabels ? thought.content.substring(0, 100) : sanitizeId(thought.id),
      type: "current"
    });
  }
  return generateGraphML(nodes, edges, {
    graphName: "Sequential Dependency Graph",
    directed: true,
    includeLabels
  });
}
function sequentialToTikZ(thought, options) {
  const { includeLabels = true, colorScheme = "default" } = options;
  const nodes = [];
  const edges = [];
  if (thought.buildUpon && thought.buildUpon.length > 0) {
    thought.buildUpon.forEach((depId, index) => {
      nodes.push({
        id: sanitizeId(depId),
        label: includeLabels ? `Step ${index + 1}` : sanitizeId(depId),
        x: index * 3,
        y: 0,
        type: "success",
        // Completed steps
        shape: "rectangle"
      });
    });
    nodes.push({
      id: sanitizeId(thought.id),
      label: includeLabels ? `Step ${nodes.length + 1}` : sanitizeId(thought.id),
      x: nodes.length * 3,
      y: 0,
      type: "primary",
      // Current step
      shape: "rectangle"
    });
    thought.buildUpon.forEach((depId, index) => {
      const sourceId = sanitizeId(depId);
      const targetId = index < thought.buildUpon.length - 1 ? sanitizeId(thought.buildUpon[index + 1]) : sanitizeId(thought.id);
      edges.push({
        source: sourceId,
        target: targetId,
        directed: true
      });
    });
  } else {
    nodes.push({
      id: sanitizeId(thought.id),
      label: includeLabels ? "Current" : sanitizeId(thought.id),
      x: 0,
      y: 0,
      type: "primary",
      shape: "rectangle"
    });
  }
  return generateTikZ(nodes, edges, {
    title: "Sequential Dependency Graph",
    colorScheme,
    includeLabels
  });
}
function sequentialToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Sequential Thinking Analysis",
    htmlTheme = "light"
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  html += '<div class="metrics-grid">';
  html += renderMetricCard("Thought #", thought.thoughtNumber, "primary");
  html += renderMetricCard("Total", thought.totalThoughts, "info");
  if (thought.buildUpon && thought.buildUpon.length > 0) {
    html += renderMetricCard("Dependencies", thought.buildUpon.length, "secondary");
  }
  html += "</div>\n";
  const badges = [];
  if (thought.isRevision) badges.push(renderBadge("Revision", "warning"));
  if (thought.branchFrom) badges.push(renderBadge("Branched", "info"));
  html += renderSection("Current Thought", `
    <div class="flex gap-1" style="margin-bottom: 0.5rem">${badges.join(" ")}</div>
    <p>${escapeHTML(thought.content)}</p>
    ${thought.nextThoughtNeeded ? '<p class="text-info">More thoughts needed...</p>' : '<p class="text-success">Reasoning complete.</p>'}
  `, "\u{1F4AD}");
  if (thought.buildUpon && thought.buildUpon.length > 0) {
    html += renderSection("Builds Upon", renderList(thought.buildUpon), "\u{1F517}");
  }
  if (thought.branchFrom) {
    html += renderSection("Branch Information", `
      <p><strong>Branched from:</strong> ${escapeHTML(thought.branchFrom)}</p>
      ${thought.branchId ? `<p><strong>Branch ID:</strong> ${escapeHTML(thought.branchId)}</p>` : ""}
    `, "\u{1F33F}");
  }
  if (thought.isRevision && thought.revisesThought) {
    html += renderSection("Revision Information", `
      <p><strong>Revises:</strong> ${escapeHTML(thought.revisesThought)}</p>
      ${thought.revisionReason ? `<p><strong>Reason:</strong> ${escapeHTML(thought.revisionReason)}</p>` : ""}
    `, "\u270F\uFE0F");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function sequentialToModelica(thought, options) {
  const { modelicaPackageName, modelicaIncludeAnnotations = true } = options;
  const packageName = modelicaPackageName || "SequentialDependency";
  const lines = [];
  lines.push(`package ${sanitizeModelicaId(packageName)}`);
  lines.push(`  "Sequential dependency graph for thought ${sanitizeId(thought.id)}"`);
  lines.push("");
  lines.push("  record CurrentThought");
  lines.push(`    constant String id = "${sanitizeModelicaId(thought.id)}";`);
  lines.push(`    constant Integer thoughtNumber = ${thought.thoughtNumber};`);
  lines.push(`    constant Integer totalThoughts = ${thought.totalThoughts};`);
  lines.push(`    constant Boolean isRevision = ${thought.isRevision || false};`);
  lines.push(`    constant Boolean nextThoughtNeeded = ${thought.nextThoughtNeeded};`);
  lines.push("  end CurrentThought;");
  lines.push("");
  if (thought.buildUpon && thought.buildUpon.length > 0) {
    lines.push("  // Dependencies");
    lines.push("  type Dependency = enumeration(");
    for (let i = 0; i < thought.buildUpon.length; i++) {
      const dep = thought.buildUpon[i];
      const comma = i < thought.buildUpon.length - 1 ? "," : "";
      lines.push(`    ${sanitizeModelicaId(dep)} "${escapeModelicaString(dep)}"${comma}`);
    }
    lines.push("  );");
    lines.push("");
  }
  if (thought.branchFrom) {
    lines.push("  record BranchInfo");
    lines.push(`    constant String branchFrom = "${sanitizeModelicaId(thought.branchFrom)}";`);
    if (thought.branchId) {
      lines.push(`    constant String branchId = "${sanitizeModelicaId(thought.branchId)}";`);
    }
    lines.push("  end BranchInfo;");
    lines.push("");
  }
  if (thought.revisesThought) {
    lines.push("  record RevisionInfo");
    lines.push(`    constant String revisesThought = "${sanitizeModelicaId(thought.revisesThought)}";`);
    if (thought.revisionReason) {
      lines.push(`    constant String revisionReason = "${escapeModelicaString(thought.revisionReason)}";`);
    }
    lines.push("  end RevisionInfo;");
    lines.push("");
  }
  if (modelicaIncludeAnnotations) {
    lines.push("  annotation(");
    lines.push('    Documentation(info="<html>');
    lines.push("      <p>Generated by DeepThinking MCP v7.1.0</p>");
    lines.push('    </html>")');
    lines.push("  );");
  }
  lines.push(`end ${sanitizeModelicaId(packageName)};`);
  return lines.join("\n");
}
function sequentialToUML(thought, options) {
  const { umlTheme, umlDirection } = options;
  const activities = [];
  if (thought.buildUpon && thought.buildUpon.length > 0) {
    for (const dep of thought.buildUpon) {
      activities.push(dep);
    }
  }
  activities.push(thought.content.substring(0, 50) + "...");
  return generateActivityDiagram(activities, thought.content.substring(0, 50) + "...", {
    title: "Sequential Dependency Graph",
    theme: umlTheme,
    direction: umlDirection
  });
}
function sequentialToJSON(thought, options) {
  const { jsonPrettyPrint = true, jsonIndent = 2, includeMetrics = true } = options;
  const graph = createJsonGraph("Sequential Dependency Graph", "sequential", {
    includeMetrics
  });
  if (thought.buildUpon && thought.buildUpon.length > 0) {
    for (let i = 0; i < thought.buildUpon.length; i++) {
      const dep = thought.buildUpon[i];
      addNode(graph, {
        id: sanitizeId(dep),
        label: dep,
        type: "dependency",
        x: i * 150,
        y: 0,
        color: "#e0e0e0",
        shape: "rectangle"
      });
    }
  }
  addNode(graph, {
    id: sanitizeId(thought.id),
    label: thought.content.substring(0, 50) + "...",
    type: thought.isRevision ? "revision" : "current",
    x: (thought.buildUpon?.length || 0) * 75,
    y: 100,
    color: thought.isRevision ? "#ffd699" : "#a8d5ff",
    shape: "stadium",
    metadata: {
      thoughtNumber: thought.thoughtNumber,
      totalThoughts: thought.totalThoughts,
      isRevision: thought.isRevision,
      nextThoughtNeeded: thought.nextThoughtNeeded
    }
  });
  if (thought.buildUpon && thought.buildUpon.length > 0) {
    for (let i = 0; i < thought.buildUpon.length; i++) {
      const dep = thought.buildUpon[i];
      addEdge(graph, {
        id: `edge_${i}`,
        source: sanitizeId(dep),
        target: sanitizeId(thought.id),
        directed: true,
        style: "solid"
      });
    }
  }
  if (includeMetrics && graph.metrics) {
    addMetric(graph, "thoughtNumber", thought.thoughtNumber);
    addMetric(graph, "totalThoughts", thought.totalThoughts);
    addMetric(graph, "dependencyCount", thought.buildUpon?.length || 0);
    addMetric(graph, "isRevision", thought.isRevision || false);
    addMetric(graph, "nextThoughtNeeded", thought.nextThoughtNeeded);
  }
  return serializeGraph(graph, { prettyPrint: jsonPrettyPrint, indent: jsonIndent });
}
function sequentialToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true
  } = options;
  const parts = [];
  const overviewContent = keyValueSection({
    "Thought Number": `${thought.thoughtNumber} of ${thought.totalThoughts}`,
    "Status": thought.nextThoughtNeeded ? "In Progress" : "Complete",
    "Revision": thought.isRevision ? "Yes" : "No"
  });
  parts.push(section("Overview", overviewContent));
  parts.push(section("Current Thought", thought.content));
  if (thought.buildUpon && thought.buildUpon.length > 0) {
    parts.push(section("Dependencies (Builds Upon)", list(thought.buildUpon)));
  }
  if (thought.branchFrom) {
    const branchContent = keyValueSection({
      "Branched From": thought.branchFrom,
      ...thought.branchId ? { "Branch ID": thought.branchId } : {}
    });
    parts.push(section("Branch Information", branchContent));
  }
  if (thought.isRevision && thought.revisesThought) {
    const revisionContent = keyValueSection({
      "Revises": thought.revisesThought,
      ...thought.revisionReason ? { "Reason": thought.revisionReason } : {}
    });
    parts.push(section("Revision Information", revisionContent));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = sequentialToMermaid(thought, "default", true);
    parts.push(section("Dependency Graph", mermaidBlock(mermaidDiagram)));
  }
  return document("Sequential Dependency Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "sequential",
      thoughtNumber: thought.thoughtNumber,
      totalThoughts: thought.totalThoughts
    }
  });
}
var init_sequential = __esm({
  "src/export/visual/sequential.ts"() {
    init_esm_shims();
    init_utils();
    init_mermaid_utils();
    init_dot_utils();
    init_ascii_utils();
    init_svg_utils();
    init_graphml_utils();
    init_tikz_utils();
    init_html_utils();
    init_modelica_utils();
    init_uml_utils();
    init_json_utils();
    init_markdown_utils();
  }
});

// src/export/visual/shannon.ts
function exportShannonStageFlow(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return shannonToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return shannonToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return shannonToASCII(thought);
    case "svg":
      return shannonToSVG(thought, options);
    case "graphml":
      return shannonToGraphML(thought, options);
    case "tikz":
      return shannonToTikZ(thought, options);
    case "html":
      return shannonToHTML(thought, options);
    case "modelica":
      return shannonToModelica(thought, options);
    case "uml":
      return shannonToUML(thought, options);
    case "json":
      return shannonToJSON(thought, options);
    case "markdown":
      return shannonToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function shannonToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph LR\n";
  for (let i = 0; i < stages.length; i++) {
    const stage = stages[i];
    const stageId = sanitizeId(stage);
    const label = includeLabels ? stageLabels[stage] : stageId;
    mermaid += `  ${stageId}["${label}"]
`;
    if (i < stages.length - 1) {
      const nextStageId = sanitizeId(stages[i + 1]);
      mermaid += `  ${stageId} --> ${nextStageId}
`;
    }
  }
  if (colorScheme !== "monochrome") {
    mermaid += "\n";
    const currentStageId = sanitizeId(thought.stage);
    const color = colorScheme === "pastel" ? "#e1f5ff" : "#a8d5ff";
    mermaid += `  style ${currentStageId} fill:${color},stroke:#333,stroke-width:3px
`;
  }
  if (includeMetrics && thought.uncertainty !== void 0) {
    mermaid += `
  uncertainty["Uncertainty: ${thought.uncertainty.toFixed(2)}"]
`;
    mermaid += `  uncertainty -.-> ${sanitizeId(thought.stage)}
`;
  }
  return mermaid;
}
function shannonToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph ShannonStageFlow {\n";
  dot += "  rankdir=LR;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  for (let i = 0; i < stages.length; i++) {
    const stage = stages[i];
    const stageId = sanitizeId(stage);
    const label = includeLabels ? stageLabels[stage] : stageId;
    const isCurrent = stage === thought.stage;
    const style = isCurrent ? ", style=filled, fillcolor=lightblue" : "";
    dot += `  ${stageId} [label="${label}"${style}];
`;
    if (i < stages.length - 1) {
      const nextStageId = sanitizeId(stages[i + 1]);
      dot += `  ${stageId} -> ${nextStageId};
`;
    }
  }
  if (includeMetrics && thought.uncertainty !== void 0) {
    dot += `
  uncertainty [label="Uncertainty: ${thought.uncertainty.toFixed(2)}", shape=ellipse];
`;
    dot += `  uncertainty -> ${sanitizeId(thought.stage)} [style=dashed];
`;
  }
  dot += "}\n";
  return dot;
}
function shannonToASCII(thought) {
  let ascii = "Shannon Stage Flow:\n";
  ascii += "===================\n\n";
  ascii += "Flow: ";
  for (let i = 0; i < stages.length; i++) {
    const stage = stages[i];
    const isCurrent = stage === thought.stage;
    if (isCurrent) {
      ascii += `[${stageLabels[stage]}]`;
    } else {
      ascii += stageLabels[stage];
    }
    if (i < stages.length - 1) {
      ascii += " \u2192 ";
    }
  }
  ascii += "\n\n";
  ascii += `Current Stage: ${stageLabels[thought.stage]}
`;
  ascii += `Uncertainty: ${thought.uncertainty.toFixed(2)}
`;
  if (thought.dependencies && thought.dependencies.length > 0) {
    ascii += "\nDependencies:\n";
    for (const dep of thought.dependencies) {
      ascii += `  \u2022 ${dep}
`;
    }
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    ascii += "\nAssumptions:\n";
    for (const assumption of thought.assumptions) {
      ascii += `  \u2022 ${assumption}
`;
    }
  }
  return ascii;
}
function shannonToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width,
    svgHeight = 300
  } = options;
  const nodes = stages.map((stage) => ({
    id: sanitizeId(stage),
    label: includeLabels ? stageLabels[stage] : sanitizeId(stage),
    type: stage === thought.stage ? "current" : "stage"
  }));
  const positions = layoutNodesHorizontally(nodes, {
    width: svgWidth,
    height: svgHeight,
    nodeWidth: 130,
    nodeHeight: 45,
    nodeSpacing: 25
  });
  let svg = generateSVGHeader(svgWidth, svgHeight, "Shannon Stage Flow");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  for (let i = 0; i < stages.length - 1; i++) {
    const fromPos = positions.get(sanitizeId(stages[i]));
    const toPos = positions.get(sanitizeId(stages[i + 1]));
    if (fromPos && toPos) {
      svg += renderHorizontalEdge(fromPos, toPos, {});
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  for (let i = 0; i < stages.length; i++) {
    const stage = stages[i];
    const pos = positions.get(sanitizeId(stage));
    if (pos) {
      const isCurrent = stage === thought.stage;
      const colors = isCurrent ? getNodeColor("primary", colorScheme) : getNodeColor("neutral", colorScheme);
      if (isCurrent) {
        svg += renderStadiumNode(pos, colors);
      } else {
        svg += renderRectNode(pos, colors);
      }
    }
  }
  svg += "\n  </g>";
  if (includeMetrics && thought.uncertainty !== void 0) {
    const metrics = [
      { label: "Stage", value: stageLabels[thought.stage] },
      { label: "Uncertainty", value: thought.uncertainty.toFixed(2) }
    ];
    svg += renderMetricsPanel(svgWidth - 180, svgHeight - 80, metrics);
  }
  const legendItems = [
    { label: "Current", color: getNodeColor("primary", colorScheme) },
    { label: "Stage", color: getNodeColor("neutral", colorScheme) }
  ];
  svg += renderLegend(20, svgHeight - 60, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function shannonToGraphML(_thought, options) {
  const { includeLabels = true } = options;
  const labels = stages.map(
    (stage) => includeLabels ? stageLabels[stage] : sanitizeId(stage)
  );
  return createLinearGraphML(labels, {
    graphName: "Shannon Stage Flow",
    directed: true
  });
}
function shannonToTikZ(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = stages.map((stage, i) => ({
    id: sanitizeId(stage),
    label: includeLabels ? stageLabels[stage] : sanitizeId(stage),
    x: i * 3,
    y: 0,
    shape: stage === thought.stage ? "stadium" : "rectangle",
    type: stage === thought.stage ? "primary" : "neutral"
  }));
  const edges = [];
  for (let i = 0; i < stages.length - 1; i++) {
    edges.push({
      source: sanitizeId(stages[i]),
      target: sanitizeId(stages[i + 1]),
      label: ""
    });
  }
  return generateTikZ(nodes, edges, {
    title: "Shannon Stage Flow",
    includeLabels,
    includeMetrics
  });
}
function shannonToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Shannon Problem-Solving Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  if (includeMetrics) {
    const stageIndex = stages.indexOf(thought.stage);
    const progress = (stageIndex + 1) / stages.length * 100;
    html += '<div class="metrics-grid">';
    html += renderMetricCard("Current Stage", stageLabels[thought.stage], "primary");
    html += renderMetricCard("Uncertainty", thought.uncertainty.toFixed(2), "info");
    html += renderMetricCard("Progress", `${progress.toFixed(0)}%`, "success");
    html += "</div>\n";
  }
  html += renderSection("Stage Flow", `
    <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap; margin: 1rem 0;">
      ${stages.map((stage) => {
    const isCurrent = stage === thought.stage;
    const badge = renderBadge(stageLabels[stage], isCurrent ? "primary" : "secondary");
    return badge;
  }).join(" \u2192 ")}
    </div>
    ${renderProgressBar((stages.indexOf(thought.stage) + 1) / stages.length * 100, "primary")}
  `, "\u{1F504}");
  html += renderSection("Current Stage", `
    <p><strong>${stageLabels[thought.stage]}</strong></p>
    <p class="text-secondary">Uncertainty: ${(thought.uncertainty * 100).toFixed(0)}%</p>
  `, "\u{1F4CD}");
  if (thought.dependencies && thought.dependencies.length > 0) {
    html += renderSection("Dependencies", renderList(thought.dependencies), "\u{1F517}");
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    html += renderSection("Assumptions", renderList(thought.assumptions), "\u{1F4A1}");
  }
  if (thought.knownLimitations && thought.knownLimitations.length > 0) {
    html += renderSection("Known Limitations", renderList(thought.knownLimitations), "\u26A0\uFE0F");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function shannonToModelica(thought, options) {
  const { modelicaPackageName, modelicaIncludeAnnotations = true, includeMetrics = true } = options;
  const stageLabelsArray = stages.map((s) => stageLabels[s]);
  let modelica = generateLinearFlowModelica(stageLabelsArray, stageLabels[thought.stage], {
    packageName: modelicaPackageName || "ShannonStageFlow",
    includeAnnotations: modelicaIncludeAnnotations});
  if (includeMetrics && thought.uncertainty !== void 0) {
    const insertPoint = modelica.lastIndexOf("end ");
    const metricsSection = `
  // Shannon-specific metrics
  parameter Real uncertainty = ${thought.uncertainty.toFixed(3)} "Current uncertainty level";

`;
    modelica = modelica.slice(0, insertPoint) + metricsSection + modelica.slice(insertPoint);
  }
  return modelica;
}
function shannonToUML(thought, options) {
  const { umlTheme, umlDirection } = options;
  const stageLabelsArray = stages.map((s) => stageLabels[s]);
  return generateActivityDiagram(stageLabelsArray, stageLabels[thought.stage], {
    title: "Shannon Stage Flow",
    theme: umlTheme,
    direction: umlDirection
  });
}
function shannonToJSON(thought, options) {
  const { jsonPrettyPrint = true, jsonIndent = 2, includeMetrics = true } = options;
  const stageLabelsArray = stages.map((s) => stageLabels[s]);
  let json = generateLinearFlowJson("Shannon Stage Flow", "shannon", stageLabelsArray, stageLabels[thought.stage], {
    prettyPrint: jsonPrettyPrint,
    indent: jsonIndent,
    includeMetrics
  });
  if (includeMetrics) {
    const graph = JSON.parse(json);
    graph.metadata.mode = "shannon";
    graph.metrics = graph.metrics || {};
    graph.metrics.uncertainty = thought.uncertainty;
    graph.metrics.stage = thought.stage;
    if (thought.dependencies) {
      graph.metrics.dependencyCount = thought.dependencies.length;
    }
    if (thought.assumptions) {
      graph.metrics.assumptionCount = thought.assumptions.length;
    }
    json = JSON.stringify(graph, null, jsonPrettyPrint !== false ? jsonIndent : 0);
  }
  return json;
}
function shannonToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  if (includeMetrics) {
    const stageIndex2 = stages.indexOf(thought.stage);
    const progress = (stageIndex2 + 1) / stages.length * 100;
    const metricsContent = keyValueSection({
      "Current Stage": stageLabels[thought.stage],
      "Uncertainty": thought.uncertainty.toFixed(2),
      "Progress": `${progress.toFixed(0)}%`
    });
    parts.push(section("Metrics", metricsContent));
  }
  const stageFlow = stages.map((stage) => {
    const isCurrent = stage === thought.stage;
    return isCurrent ? `**[${stageLabels[stage]}]**` : stageLabels[stage];
  }).join(" \u2192 ");
  const stageIndex = stages.indexOf(thought.stage);
  const progressPct = (stageIndex + 1) / stages.length * 100;
  parts.push(section("Stage Flow", `${stageFlow}

${progressBar(progressPct)}`));
  parts.push(section("Current Stage", `**${stageLabels[thought.stage]}**

Uncertainty: ${(thought.uncertainty * 100).toFixed(0)}%`));
  if (thought.dependencies && thought.dependencies.length > 0) {
    parts.push(section("Dependencies", list(thought.dependencies)));
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    parts.push(section("Assumptions", list(thought.assumptions)));
  }
  if (thought.knownLimitations && thought.knownLimitations.length > 0) {
    parts.push(section("Known Limitations", list(thought.knownLimitations)));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = shannonToMermaid(thought, "default", true, true);
    parts.push(section("Stage Flow Diagram", mermaidBlock(mermaidDiagram)));
  }
  return document("Shannon Problem-Solving Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "shannon",
      stage: thought.stage,
      uncertainty: thought.uncertainty
    }
  });
}
var stages, stageLabels;
var init_shannon = __esm({
  "src/export/visual/shannon.ts"() {
    init_esm_shims();
    init_utils();
    init_svg_utils();
    init_graphml_utils();
    init_tikz_utils();
    init_html_utils();
    init_modelica_utils();
    init_uml_utils();
    init_json_utils();
    init_markdown_utils();
    stages = [
      "problem_definition",
      "constraints",
      "model",
      "proof",
      "implementation"
    ];
    stageLabels = {
      problem_definition: "Problem Definition",
      constraints: "Constraints",
      model: "Model",
      proof: "Proof",
      implementation: "Implementation"
    };
  }
});

// src/export/visual/abductive.ts
function exportAbductiveHypotheses(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return abductiveToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return abductiveToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return abductiveToASCII(thought);
    case "svg":
      return abductiveToSVG(thought, options);
    case "graphml":
      return abductiveToGraphML(thought, options);
    case "tikz":
      return abductiveToTikZ(thought, options);
    case "html":
      return abductiveToHTML(thought, options);
    case "modelica":
      return abductiveToModelica(thought, options);
    case "uml":
      return abductiveToUML(thought, options);
    case "json":
      return abductiveToJSON(thought, options);
    case "markdown":
      return abductiveToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function abductiveToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TD\n";
  mermaid += '  Observations["Observations"]\n';
  for (const hypothesis of thought.hypotheses) {
    const hypId = sanitizeId(hypothesis.id);
    const label = includeLabels ? hypothesis.explanation.substring(0, 50) + "..." : hypId;
    const scoreLabel = includeMetrics ? ` (${hypothesis.score.toFixed(2)})` : "";
    mermaid += `  ${hypId}["${label}${scoreLabel}"]
`;
    mermaid += `  Observations --> ${hypId}
`;
  }
  if (thought.bestExplanation && colorScheme !== "monochrome") {
    mermaid += "\n";
    const bestId = sanitizeId(thought.bestExplanation.id);
    const color = colorScheme === "pastel" ? "#e1f5ff" : "#a8d5ff";
    mermaid += `  style ${bestId} fill:${color},stroke:#333,stroke-width:3px
`;
  }
  return mermaid;
}
function abductiveToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph AbductiveHypotheses {\n";
  dot += "  rankdir=TD;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  dot += '  Observations [label="Observations", shape=ellipse];\n\n';
  for (const hypothesis of thought.hypotheses) {
    const hypId = sanitizeId(hypothesis.id);
    const label = includeLabels ? hypothesis.explanation.substring(0, 50) + "..." : hypId;
    const scoreLabel = includeMetrics ? ` (${hypothesis.score.toFixed(2)})` : "";
    const isBest = thought.bestExplanation?.id === hypothesis.id;
    const style = isBest ? ", style=filled, fillcolor=lightblue" : "";
    dot += `  ${hypId} [label="${label}${scoreLabel}"${style}];
`;
    dot += `  Observations -> ${hypId};
`;
  }
  dot += "}\n";
  return dot;
}
function abductiveToASCII(thought) {
  let ascii = "Abductive Hypothesis Comparison:\n";
  ascii += "================================\n\n";
  ascii += "Observations:\n";
  for (const obs of thought.observations) {
    ascii += `  \u2022 ${obs.description} (confidence: ${obs.confidence.toFixed(2)})
`;
  }
  ascii += "\nHypotheses:\n";
  for (const hypothesis of thought.hypotheses) {
    const isBest = thought.bestExplanation?.id === hypothesis.id;
    const marker = isBest ? "\u2605" : "\u2022";
    ascii += `  ${marker} ${hypothesis.explanation}
`;
    ascii += `    Score: ${hypothesis.score.toFixed(2)}
`;
    ascii += `    Assumptions: ${hypothesis.assumptions.join(", ")}
`;
    ascii += "\n";
  }
  if (thought.bestExplanation) {
    ascii += `Best Explanation: ${thought.bestExplanation.explanation}
`;
  }
  return ascii;
}
function abductiveToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width,
    svgHeight = 450
  } = options;
  const positions = /* @__PURE__ */ new Map();
  const nodeWidth = 180;
  const nodeHeight = 50;
  const centerX = svgWidth / 2;
  positions.set("observations", {
    id: "observations",
    x: centerX - nodeWidth / 2,
    y: 60,
    width: nodeWidth,
    height: nodeHeight,
    label: "Observations",
    type: "observations"
  });
  const hypCount = thought.hypotheses.length;
  const layerWidth = hypCount * (nodeWidth + 20) - 20;
  let startX = (svgWidth - layerWidth) / 2;
  for (const hypothesis of thought.hypotheses) {
    const hypId = sanitizeId(hypothesis.id);
    const label = includeLabels ? hypothesis.explanation.substring(0, 30) + "..." : hypId;
    const scoreLabel = includeMetrics ? ` (${hypothesis.score.toFixed(2)})` : "";
    positions.set(hypothesis.id, {
      id: hypothesis.id,
      x: startX,
      y: 180,
      width: nodeWidth,
      height: nodeHeight,
      label: label + scoreLabel,
      type: thought.bestExplanation?.id === hypothesis.id ? "best" : "hypothesis"
    });
    startX += nodeWidth + 20;
  }
  let svg = generateSVGHeader(svgWidth, svgHeight, "Abductive Hypotheses");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  const obsPos = positions.get("observations");
  for (const hypothesis of thought.hypotheses) {
    const hypPos = positions.get(hypothesis.id);
    if (obsPos && hypPos) {
      svg += renderEdge(obsPos, hypPos, {});
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  svg += renderEllipseNode(positions.get("observations"), getNodeColor("info", colorScheme));
  for (const hypothesis of thought.hypotheses) {
    const pos = positions.get(hypothesis.id);
    const isBest = thought.bestExplanation?.id === hypothesis.id;
    const colors = isBest ? getNodeColor("success", colorScheme) : getNodeColor("neutral", colorScheme);
    if (isBest) {
      svg += renderStadiumNode(pos, colors);
    } else {
      svg += renderRectNode(pos, colors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Hypotheses", value: thought.hypotheses.length },
      { label: "Observations", value: thought.observations.length },
      { label: "Best Score", value: thought.bestExplanation?.score.toFixed(2) || "N/A" }
    ];
    svg += renderMetricsPanel(svgWidth - 180, svgHeight - 100, metrics);
  }
  const legendItems = [
    { label: "Observations", color: getNodeColor("info", colorScheme), shape: "ellipse" },
    { label: "Hypothesis", color: getNodeColor("neutral", colorScheme) },
    { label: "Best", color: getNodeColor("success", colorScheme) }
  ];
  svg += renderLegend(20, svgHeight - 80, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function abductiveToGraphML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = thought.hypotheses.map((hypothesis) => ({
    id: sanitizeId(hypothesis.id),
    label: includeLabels ? hypothesis.explanation.substring(0, 50) + "..." : hypothesis.id,
    type: "hypothesis",
    metadata: includeMetrics ? {
      description: hypothesis.explanation,
      score: hypothesis.score,
      assumptions: hypothesis.assumptions.join(", ")
    } : void 0
  }));
  if (thought.observations && thought.observations.length > 0) {
    for (const obs of thought.observations) {
      nodes.push({
        id: sanitizeId(`obs_${obs.id}`),
        label: includeLabels ? obs.description : `obs_${obs.id}`,
        type: "observation",
        metadata: includeMetrics ? {
          description: obs.description,
          confidence: obs.confidence
        } : void 0
      });
    }
  }
  const edges = [];
  let edgeId = 0;
  if (thought.observations && thought.observations.length > 0) {
    for (const obs of thought.observations) {
      for (const hypothesis of thought.hypotheses) {
        edges.push({
          id: `e${edgeId++}`,
          source: sanitizeId(`obs_${obs.id}`),
          target: sanitizeId(hypothesis.id),
          metadata: includeMetrics ? { weight: obs.confidence } : void 0
        });
      }
    }
  }
  return generateGraphML(nodes, edges, {
    graphName: "Abductive Hypotheses",
    includeLabels,
    includeMetadata: includeMetrics
  });
}
function abductiveToTikZ(thought, options) {
  const { includeLabels = true, includeMetrics = true, colorScheme = "default" } = options;
  const nodes = [];
  const edges = [];
  const hypCount = thought.hypotheses.length;
  const spacing = 3;
  const totalWidth = (hypCount - 1) * spacing;
  const startX = 4 - totalWidth / 2;
  for (let i = 0; i < thought.hypotheses.length; i++) {
    const hypothesis = thought.hypotheses[i];
    const isBest = thought.bestExplanation?.id === hypothesis.id;
    const label = includeLabels ? hypothesis.explanation.substring(0, 30) + "..." : hypothesis.id;
    const scoreLabel = includeMetrics ? ` (${hypothesis.score.toFixed(2)})` : "";
    nodes.push({
      id: sanitizeId(hypothesis.id),
      label: label + scoreLabel,
      x: startX + i * spacing,
      y: -2,
      type: isBest ? "success" : "hypothesis",
      shape: "ellipse"
    });
  }
  if (thought.observations && thought.observations.length > 0) {
    const obsCount = thought.observations.length;
    const obsSpacing = Math.min(spacing, totalWidth / Math.max(1, obsCount - 1));
    const obsStartX = 4 - (obsCount - 1) * obsSpacing / 2;
    for (let i = 0; i < thought.observations.length; i++) {
      const obs = thought.observations[i];
      nodes.push({
        id: sanitizeId(`obs_${obs.id}`),
        label: includeLabels ? obs.description.substring(0, 30) + "..." : `obs_${obs.id}`,
        x: obsStartX + i * obsSpacing,
        y: 0,
        type: "info",
        shape: "rectangle"
      });
      for (const hypothesis of thought.hypotheses) {
        edges.push({
          source: sanitizeId(`obs_${obs.id}`),
          target: sanitizeId(hypothesis.id),
          directed: true
        });
      }
    }
  }
  return generateTikZ(nodes, edges, {
    title: "Abductive Hypotheses",
    includeLabels,
    includeMetrics,
    colorScheme
  });
}
function abductiveToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Abductive Reasoning Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  if (includeMetrics) {
    html += '<div class="metrics-grid">';
    html += renderMetricCard("Observations", thought.observations.length, "info");
    html += renderMetricCard("Hypotheses", thought.hypotheses.length, "primary");
    if (thought.bestExplanation) {
      html += renderMetricCard("Best Score", thought.bestExplanation.score.toFixed(2), "success");
    }
    html += "</div>\n";
  }
  const obsRows = thought.observations.map((obs, i) => [
    (i + 1).toString(),
    obs.description,
    obs.confidence.toFixed(2),
    obs.timestamp || "-"
  ]);
  html += renderSection("Observations", renderTable(
    ["#", "Description", "Confidence", "Time"],
    obsRows
  ), "\u{1F441}\uFE0F");
  const hypRows = thought.hypotheses.map((hyp) => {
    const isBest = thought.bestExplanation?.id === hyp.id;
    const badge = isBest ? renderBadge("Best", "success") : "";
    return [
      hyp.explanation.substring(0, 60) + (hyp.explanation.length > 60 ? "..." : ""),
      hyp.score.toFixed(2),
      badge,
      hyp.assumptions.slice(0, 3).join(", ") + (hyp.assumptions.length > 3 ? "..." : "")
    ];
  });
  html += renderSection("Hypotheses", renderTable(
    ["Explanation", "Score", "Status", "Key Assumptions"],
    hypRows.map((row) => row.map((cell) => typeof cell === "string" && cell.startsWith("<") ? cell : escapeHTML(String(cell))))
  ), "\u{1F4A1}");
  if (thought.bestExplanation) {
    html += renderSection("Best Explanation", `
      <div class="card">
        <div class="card-header">${escapeHTML(thought.bestExplanation.explanation)}</div>
        <p><strong>Score:</strong> ${thought.bestExplanation.score.toFixed(2)}</p>
        <p><strong>Assumptions:</strong></p>
        <ul class="list-styled">
          ${thought.bestExplanation.assumptions.map((a) => `<li>${escapeHTML(a)}</li>`).join("\n")}
        </ul>
      </div>
    `, "\u2B50");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function abductiveToModelica(thought, options) {
  const { modelicaPackageName, includeMetrics = true } = options;
  const children = thought.hypotheses.map((h) => ({
    name: sanitizeId(h.id),
    description: h.explanation.substring(0, 100),
    score: includeMetrics ? h.score : void 0
  }));
  return generateHierarchyModelica(
    "Observations",
    `Abductive reasoning with ${thought.observations.length} observations`,
    children,
    {
      packageName: modelicaPackageName || "AbductiveHypotheses",
      includeMetrics
    }
  );
}
function abductiveToUML(thought, options) {
  const { umlTheme, umlDirection, includeLabels = true, includeMetrics = true } = options;
  const nodes = [
    {
      id: "observations",
      label: "Observations",
      shape: "database"
    }
  ];
  const edges = [];
  for (const hyp of thought.hypotheses) {
    const isBest = thought.bestExplanation?.id === hyp.id;
    const label = includeLabels ? hyp.explanation.substring(0, 40) + (hyp.explanation.length > 40 ? "..." : "") : hyp.id;
    const scoreLabel = includeMetrics ? ` (${hyp.score.toFixed(2)})` : "";
    nodes.push({
      id: sanitizeId(hyp.id),
      label: label + scoreLabel,
      shape: "class",
      color: isBest ? "90EE90" : void 0,
      stereotype: isBest ? "best" : void 0
    });
    edges.push({
      source: "observations",
      target: sanitizeId(hyp.id),
      type: "arrow"
    });
  }
  return generateUmlDiagram(nodes, edges, {
    title: "Abductive Hypotheses",
    theme: umlTheme,
    direction: umlDirection
  });
}
function abductiveToJSON(thought, options) {
  const { jsonPrettyPrint = true, jsonIndent = 2, includeMetrics = true } = options;
  const children = thought.hypotheses.map((h) => ({
    id: sanitizeId(h.id),
    label: h.explanation.substring(0, 60),
    score: h.score,
    metadata: {
      assumptions: h.assumptions,
      isBest: thought.bestExplanation?.id === h.id
    }
  }));
  let json = generateHierarchyJson(
    "Abductive Hypotheses",
    "abductive",
    { label: "Observations", metadata: { count: thought.observations.length } },
    children,
    {
      prettyPrint: jsonPrettyPrint,
      indent: jsonIndent,
      includeMetrics
    }
  );
  if (includeMetrics) {
    const graph = JSON.parse(json);
    graph.metadata.observationCount = thought.observations.length;
    graph.metadata.hypothesisCount = thought.hypotheses.length;
    if (thought.bestExplanation) {
      graph.metadata.bestHypothesisId = thought.bestExplanation.id;
      graph.metadata.bestScore = thought.bestExplanation.score;
    }
    json = JSON.stringify(graph, null, jsonPrettyPrint !== false ? jsonIndent : 0);
  }
  return json;
}
function abductiveToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  if (includeMetrics) {
    parts.push(section("Metrics", keyValueSection({
      "Total Hypotheses": thought.hypotheses.length,
      "Total Observations": thought.observations.length,
      "Best Hypothesis Score": thought.bestExplanation?.score.toFixed(2) || "N/A"
    })));
  }
  const obsRows = thought.observations.map((obs) => [
    obs.id,
    obs.description,
    obs.confidence.toFixed(2),
    obs.timestamp || "-"
  ]);
  parts.push(section("Observations", table(
    ["ID", "Description", "Confidence", "Timestamp"],
    obsRows
  )));
  const hypRows = thought.hypotheses.map((hyp) => [
    hyp.id,
    hyp.explanation.substring(0, 60) + (hyp.explanation.length > 60 ? "..." : ""),
    hyp.score.toFixed(2),
    thought.bestExplanation?.id === hyp.id ? "\u2605 Best" : ""
  ]);
  parts.push(section("Hypotheses", table(
    ["ID", "Explanation", "Score", "Status"],
    hypRows
  )));
  if (thought.bestExplanation) {
    const assumptions = list(thought.bestExplanation.assumptions);
    parts.push(section(
      "Best Explanation",
      `**Score:** ${thought.bestExplanation.score.toFixed(2)}

**Explanation:** ${thought.bestExplanation.explanation}

**Assumptions:**
${assumptions}`
    ));
  }
  if (markdownIncludeMermaid) {
    const mermaid = abductiveToMermaid(thought, "default", true, includeMetrics);
    parts.push(section("Visualization", mermaidBlock(mermaid)));
  }
  return document("Abductive Reasoning Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: { mode: "abductive", hypotheses: thought.hypotheses.length }
  });
}
var init_abductive = __esm({
  "src/export/visual/abductive.ts"() {
    init_esm_shims();
    init_utils();
    init_svg_utils();
    init_graphml_utils();
    init_tikz_utils();
    init_html_utils();
    init_modelica_utils();
    init_uml_utils();
    init_json_utils();
    init_markdown_utils();
  }
});

// src/export/visual/counterfactual.ts
function exportCounterfactualScenarios(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return counterfactualToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return counterfactualToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return counterfactualToASCII(thought);
    case "svg":
      return counterfactualToSVG(thought, options);
    case "graphml":
      return counterfactualToGraphML(thought, options);
    case "tikz":
      return counterfactualToTikZ(thought, options);
    case "html":
      return counterfactualToHTML(thought, options);
    case "modelica":
      return counterfactualToModelica(thought, options);
    case "uml":
      return counterfactualToUML(thought, options);
    case "json":
      return counterfactualToJSON(thought, options);
    case "markdown":
      return counterfactualToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function counterfactualToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TD\n";
  const interventionId = "intervention";
  mermaid += `  ${interventionId}["${thought.interventionPoint.description}"]
`;
  const actualId = sanitizeId(thought.actual.id);
  const actualLabel = includeLabels ? thought.actual.name : actualId;
  mermaid += `  ${actualId}["Actual: ${actualLabel}"]
`;
  mermaid += `  ${interventionId} -->|no change| ${actualId}
`;
  for (const scenario of thought.counterfactuals) {
    const scenarioId = sanitizeId(scenario.id);
    const label = includeLabels ? scenario.name : scenarioId;
    const likelihoodLabel = includeMetrics && scenario.likelihood ? ` (${scenario.likelihood.toFixed(2)})` : "";
    mermaid += `  ${scenarioId}["CF: ${label}${likelihoodLabel}"]
`;
    mermaid += `  ${interventionId} -->|intervene| ${scenarioId}
`;
  }
  if (colorScheme !== "monochrome") {
    mermaid += "\n";
    const actualColor = colorScheme === "pastel" ? "#fff3e0" : "#ffd699";
    mermaid += `  style ${actualId} fill:${actualColor}
`;
    const cfColor = colorScheme === "pastel" ? "#e1f5ff" : "#a8d5ff";
    for (const scenario of thought.counterfactuals) {
      const scenarioId = sanitizeId(scenario.id);
      mermaid += `  style ${scenarioId} fill:${cfColor}
`;
    }
  }
  return mermaid;
}
function counterfactualToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph CounterfactualScenarios {\n";
  dot += "  rankdir=TD;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  const interventionId = "intervention";
  dot += `  ${interventionId} [label="${thought.interventionPoint.description}", shape=diamond];

`;
  const actualId = sanitizeId(thought.actual.id);
  const actualLabel = includeLabels ? thought.actual.name : actualId;
  dot += `  ${actualId} [label="Actual: ${actualLabel}", style=filled, fillcolor=lightyellow];
`;
  dot += `  ${interventionId} -> ${actualId} [label="no change"];

`;
  for (const scenario of thought.counterfactuals) {
    const scenarioId = sanitizeId(scenario.id);
    const label = includeLabels ? scenario.name : scenarioId;
    const likelihoodLabel = includeMetrics && scenario.likelihood ? ` (${scenario.likelihood.toFixed(2)})` : "";
    dot += `  ${scenarioId} [label="CF: ${label}${likelihoodLabel}", style=filled, fillcolor=lightblue];
`;
    dot += `  ${interventionId} -> ${scenarioId} [label="intervene"];
`;
  }
  dot += "}\n";
  return dot;
}
function counterfactualToASCII(thought) {
  let ascii = "Counterfactual Scenario Tree:\n";
  ascii += "=============================\n\n";
  ascii += `Intervention Point: ${thought.interventionPoint.description}
`;
  ascii += `Timing: ${thought.interventionPoint.timing}
`;
  ascii += `Feasibility: ${thought.interventionPoint.feasibility.toFixed(2)}

`;
  ascii += "\u250C\u2500 Actual Scenario:\n";
  ascii += `\u2502  ${thought.actual.name}
`;
  ascii += `\u2502  ${thought.actual.description}

`;
  ascii += "\u2514\u2500 Counterfactual Scenarios:\n";
  for (const scenario of thought.counterfactuals) {
    const likelihoodStr = scenario.likelihood ? ` (likelihood: ${scenario.likelihood.toFixed(2)})` : "";
    ascii += `   \u251C\u2500 ${scenario.name}${likelihoodStr}
`;
    ascii += `   \u2502  ${scenario.description}
`;
  }
  return ascii;
}
function counterfactualToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width
  } = options;
  const positions = /* @__PURE__ */ new Map();
  const nodeWidth = 150;
  const nodeHeight = 40;
  const interventionId = "intervention";
  positions.set(interventionId, {
    id: interventionId,
    label: includeLabels ? thought.interventionPoint.description : interventionId,
    x: svgWidth / 2,
    y: 80,
    width: nodeWidth,
    height: nodeHeight,
    type: "intervention"
  });
  const actualId = thought.actual.id;
  const actualLabel = includeLabels ? `Actual: ${thought.actual.name}` : actualId;
  positions.set(actualId, {
    id: actualId,
    label: actualLabel,
    x: svgWidth / 4,
    y: 200,
    width: nodeWidth,
    height: nodeHeight,
    type: "actual"
  });
  const cfCount = thought.counterfactuals.length;
  const cfStartY = 200;
  const cfSpacing = 120;
  thought.counterfactuals.forEach((scenario, index) => {
    const cfLabel = includeLabels ? `CF: ${scenario.name}` : scenario.id;
    positions.set(scenario.id, {
      id: scenario.id,
      label: cfLabel,
      x: svgWidth * 3 / 4,
      y: cfStartY + index * cfSpacing,
      width: nodeWidth,
      height: nodeHeight,
      type: "counterfactual"
    });
  });
  const actualHeight = Math.max(DEFAULT_SVG_OPTIONS.height, cfStartY + (cfCount - 1) * cfSpacing + 150);
  let svg = generateSVGHeader(svgWidth, actualHeight, "Counterfactual Scenarios");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  const interventionPos = positions.get(interventionId);
  const actualPos = positions.get(actualId);
  svg += renderEdge(interventionPos, actualPos, { label: "no change" });
  for (const scenario of thought.counterfactuals) {
    const cfPos = positions.get(scenario.id);
    if (cfPos) {
      const label = includeMetrics && scenario.likelihood ? `${scenario.likelihood.toFixed(2)}` : "intervene";
      svg += renderEdge(interventionPos, cfPos, { label });
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  const interventionColors = getNodeColor("warning", colorScheme);
  svg += `
    <polygon points="${interventionPos.x},${interventionPos.y - 30} ${interventionPos.x + 40},${interventionPos.y} ${interventionPos.x},${interventionPos.y + 30} ${interventionPos.x - 40},${interventionPos.y}" fill="${interventionColors.fill}" stroke="${interventionColors.stroke}" stroke-width="2"/>`;
  svg += `
    <text x="${interventionPos.x}" y="${interventionPos.y + 5}" text-anchor="middle" class="node-label">${interventionPos.label}</text>`;
  const actualColors = getNodeColor("tertiary", colorScheme);
  svg += renderRectNode(actualPos, actualColors);
  const cfColors = getNodeColor("primary", colorScheme);
  for (const [id, pos] of positions) {
    if (id !== interventionId && id !== actualId) {
      svg += renderStadiumNode(pos, cfColors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Counterfactuals", value: thought.counterfactuals.length },
      { label: "Feasibility", value: thought.interventionPoint.feasibility.toFixed(2) }
    ];
    svg += renderMetricsPanel(svgWidth - 180, actualHeight - 110, metrics);
  }
  const legendItems = [
    { label: "Intervention", color: interventionColors, shape: "diamond" },
    { label: "Actual", color: actualColors },
    { label: "Counterfactual", color: cfColors, shape: "stadium" }
  ];
  svg += renderLegend(20, actualHeight - 110, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function counterfactualToGraphML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  nodes.push({
    id: "intervention",
    label: includeLabels ? thought.interventionPoint.description : "intervention",
    type: "intervention",
    metadata: {
      timing: thought.interventionPoint.timing,
      feasibility: thought.interventionPoint.feasibility
    }
  });
  nodes.push({
    id: thought.actual.id,
    label: includeLabels ? `Actual: ${thought.actual.name}` : thought.actual.id,
    type: "actual",
    metadata: {
      description: thought.actual.description
    }
  });
  for (const scenario of thought.counterfactuals) {
    nodes.push({
      id: scenario.id,
      label: includeLabels ? `CF: ${scenario.name}` : scenario.id,
      type: "counterfactual",
      metadata: {
        description: scenario.description,
        likelihood: scenario.likelihood
      }
    });
  }
  const edges = [];
  edges.push({
    id: "e_intervention_actual",
    source: "intervention",
    target: thought.actual.id,
    label: "no change"
  });
  for (let i = 0; i < thought.counterfactuals.length; i++) {
    const scenario = thought.counterfactuals[i];
    edges.push({
      id: `e_intervention_cf${i}`,
      source: "intervention",
      target: scenario.id,
      label: "intervene",
      metadata: includeMetrics && scenario.likelihood !== void 0 ? { weight: scenario.likelihood } : void 0
    });
  }
  const graphmlOptions = {
    graphName: "Counterfactual Scenarios"
  };
  return generateGraphML(nodes, edges, graphmlOptions);
}
function counterfactualToTikZ(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  nodes.push({
    id: "intervention",
    label: includeLabels ? thought.interventionPoint.description : "intervention",
    x: 4,
    y: 0,
    type: "intervention",
    shape: "diamond"
  });
  nodes.push({
    id: thought.actual.id,
    label: includeLabels ? `Actual: ${thought.actual.name}` : thought.actual.id,
    x: 2,
    y: -2,
    type: "actual",
    shape: "rectangle"
  });
  const cfCount = thought.counterfactuals.length;
  const cfSpacing = 1.5;
  const cfStartY = -2;
  thought.counterfactuals.forEach((scenario, index) => {
    const yOffset = (cfCount - 1) * cfSpacing / 2;
    nodes.push({
      id: scenario.id,
      label: includeLabels ? `CF: ${scenario.name}` : scenario.id,
      x: 6,
      y: cfStartY - index * cfSpacing + yOffset,
      type: "counterfactual",
      shape: "ellipse"
    });
  });
  const edges = [];
  edges.push({
    source: "intervention",
    target: thought.actual.id,
    label: "no change",
    directed: true
  });
  for (const scenario of thought.counterfactuals) {
    edges.push({
      source: "intervention",
      target: scenario.id,
      label: includeMetrics && scenario.likelihood !== void 0 ? scenario.likelihood.toFixed(2) : "intervene",
      directed: true
    });
  }
  const tikzOptions = {
    title: "Counterfactual Scenarios"
  };
  return generateTikZ(nodes, edges, tikzOptions);
}
function counterfactualToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Counterfactual Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  if (includeMetrics) {
    html += '<div class="metrics-grid">';
    html += renderMetricCard("Counterfactuals", thought.counterfactuals.length, "primary");
    html += renderMetricCard("Feasibility", (thought.interventionPoint.feasibility * 100).toFixed(0) + "%", "info");
    html += renderMetricCard("Expected Impact", (thought.interventionPoint.expectedImpact * 100).toFixed(0) + "%", "success");
    html += "</div>\n";
  }
  html += renderSection("Intervention Point", `
    <p><strong>Description:</strong> ${escapeHTML(thought.interventionPoint.description)}</p>
    <p><strong>Timing:</strong> ${escapeHTML(thought.interventionPoint.timing)}</p>
    <p><strong>Feasibility:</strong> ${(thought.interventionPoint.feasibility * 100).toFixed(0)}%</p>
    <p><strong>Expected Impact:</strong> ${(thought.interventionPoint.expectedImpact * 100).toFixed(0)}%</p>
  `, "\u{1F500}");
  html += renderSection("Actual Outcome", `
    <div class="card">
      <div class="card-header">${escapeHTML(thought.actual.name)}</div>
      <p>${escapeHTML(thought.actual.description)}</p>
    </div>
  `, "\u2713");
  const cfRows = thought.counterfactuals.map((cf) => {
    const primaryOutcome = cf.outcomes[0];
    return [
      cf.name,
      primaryOutcome ? primaryOutcome.description.substring(0, 60) + (primaryOutcome.description.length > 60 ? "..." : "") : "-",
      cf.likelihood !== void 0 ? cf.likelihood.toFixed(2) : "-",
      primaryOutcome?.impact || "-"
    ];
  });
  html += renderSection("Counterfactual Scenarios", renderTable(
    ["Scenario", "Outcome", "Likelihood", "Impact"],
    cfRows
  ), "\u{1F52E}");
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function counterfactualToModelica(thought, options) {
  const { includeMetrics = true } = options;
  let modelica = "package CounterfactualScenarios\n";
  modelica += '  "Counterfactual scenario analysis with original vs. alternative outcomes"\n\n';
  modelica += "  record InterventionPoint\n";
  modelica += '    "The point at which the counterfactual diverges from the actual"\n';
  modelica += `    String description = "${escapeModelicaString(thought.interventionPoint.description)}";
`;
  modelica += `    String timing = "${escapeModelicaString(thought.interventionPoint.timing)}";
`;
  modelica += `    Real feasibility = ${thought.interventionPoint.feasibility};
`;
  modelica += `    Real expectedImpact = ${thought.interventionPoint.expectedImpact};
`;
  modelica += "  end InterventionPoint;\n\n";
  modelica += "  record ActualScenario\n";
  modelica += '    "The actual outcome that occurred"\n';
  modelica += `    String id = "${sanitizeModelicaId(thought.actual.id)}";
`;
  modelica += `    String name = "${escapeModelicaString(thought.actual.name)}";
`;
  modelica += `    String description = "${escapeModelicaString(thought.actual.description)}";
`;
  modelica += "  end ActualScenario;\n\n";
  for (let i = 0; i < thought.counterfactuals.length; i++) {
    const scenario = thought.counterfactuals[i];
    const recordName = sanitizeModelicaId(`CF_${scenario.id}`);
    modelica += `  record ${recordName}
`;
    modelica += `    "Counterfactual: ${escapeModelicaString(scenario.name)}"
`;
    modelica += `    String id = "${sanitizeModelicaId(scenario.id)}";
`;
    modelica += `    String name = "${escapeModelicaString(scenario.name)}";
`;
    modelica += `    String description = "${escapeModelicaString(scenario.description)}";
`;
    if (includeMetrics && scenario.likelihood !== void 0) {
      modelica += `    Real likelihood = ${scenario.likelihood};
`;
    }
    if (scenario.outcomes && scenario.outcomes.length > 0) {
      modelica += `    String outcomes[${scenario.outcomes.length}] = {`;
      modelica += scenario.outcomes.map((o) => `"${escapeModelicaString(o.description)}"`).join(", ");
      modelica += "};\n";
    }
    modelica += `  end ${recordName};

`;
  }
  modelica += "  model ScenarioDivergence\n";
  modelica += '    "Model showing the branching from intervention point to outcomes"\n';
  modelica += "    InterventionPoint intervention;\n";
  modelica += "    ActualScenario actual;\n";
  for (let i = 0; i < thought.counterfactuals.length; i++) {
    const scenario = thought.counterfactuals[i];
    const recordName = sanitizeModelicaId(`CF_${scenario.id}`);
    modelica += `    ${recordName} counterfactual${i + 1};
`;
  }
  if (includeMetrics) {
    modelica += '\n    annotation(Documentation(info="<html>\n';
    modelica += `      <p>Counterfactuals: ${thought.counterfactuals.length}</p>
`;
    modelica += `      <p>Feasibility: ${(thought.interventionPoint.feasibility * 100).toFixed(1)}%</p>
`;
    modelica += `      <p>Expected Impact: ${(thought.interventionPoint.expectedImpact * 100).toFixed(1)}%</p>
`;
    modelica += '    </html>"));\n';
  }
  modelica += "  end ScenarioDivergence;\n";
  modelica += "end CounterfactualScenarios;\n";
  return modelica;
}
function counterfactualToUML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  nodes.push({
    id: "intervention",
    label: includeLabels ? thought.interventionPoint.description : "Intervention",
    shape: "state",
    stereotype: "decision"
  });
  nodes.push({
    id: thought.actual.id,
    label: includeLabels ? `Actual: ${thought.actual.name}` : "Actual",
    shape: "state"
  });
  edges.push({
    source: "intervention",
    target: thought.actual.id,
    label: "no change",
    type: "arrow"
  });
  for (const scenario of thought.counterfactuals) {
    nodes.push({
      id: scenario.id,
      label: includeLabels ? `CF: ${scenario.name}` : scenario.id,
      shape: "state"
    });
    const edgeLabel = includeMetrics && scenario.likelihood !== void 0 ? `intervene (${scenario.likelihood.toFixed(2)})` : "intervene";
    edges.push({
      source: "intervention",
      target: scenario.id,
      label: edgeLabel,
      type: "arrow"
    });
  }
  return generateUmlDiagram(nodes, edges, {
    title: "Counterfactual Scenarios"});
}
function counterfactualToJSON(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const graph = createJsonGraph("counterfactual", "Counterfactual Scenarios");
  addNode(graph, {
    id: "intervention",
    label: includeLabels ? thought.interventionPoint.description : "Intervention",
    type: "intervention",
    metadata: {
      timing: thought.interventionPoint.timing,
      feasibility: thought.interventionPoint.feasibility,
      expectedImpact: thought.interventionPoint.expectedImpact
    }
  });
  addNode(graph, {
    id: thought.actual.id,
    label: includeLabels ? `Actual: ${thought.actual.name}` : thought.actual.id,
    type: "actual",
    metadata: {
      name: thought.actual.name,
      description: thought.actual.description
    }
  });
  addEdge(graph, {
    id: "e_intervention_actual",
    source: "intervention",
    target: thought.actual.id,
    label: "no change",
    type: "no_intervention"
  });
  for (let i = 0; i < thought.counterfactuals.length; i++) {
    const scenario = thought.counterfactuals[i];
    addNode(graph, {
      id: scenario.id,
      label: includeLabels ? `CF: ${scenario.name}` : scenario.id,
      type: "counterfactual",
      metadata: {
        name: scenario.name,
        description: scenario.description,
        likelihood: scenario.likelihood,
        outcomes: scenario.outcomes?.map((o) => ({
          description: o.description,
          impact: o.impact
        }))
      }
    });
    addEdge(graph, {
      id: `e_intervention_cf${i}`,
      source: "intervention",
      target: scenario.id,
      label: "intervene",
      type: "intervention",
      metadata: includeMetrics && scenario.likelihood !== void 0 ? { likelihood: scenario.likelihood } : void 0
    });
  }
  if (includeMetrics) {
    addMetric(graph, "counterfactualCount", thought.counterfactuals.length);
    addMetric(graph, "feasibility", thought.interventionPoint.feasibility);
    addMetric(graph, "expectedImpact", thought.interventionPoint.expectedImpact);
  }
  return serializeGraph(graph);
}
function counterfactualToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  if (includeMetrics) {
    parts.push(section("Metrics", keyValueSection({
      "Counterfactual Scenarios": thought.counterfactuals.length,
      "Intervention Feasibility": (thought.interventionPoint.feasibility * 100).toFixed(0) + "%",
      "Expected Impact": (thought.interventionPoint.expectedImpact * 100).toFixed(0) + "%"
    })));
  }
  parts.push(section("Intervention Point", keyValueSection({
    "Description": thought.interventionPoint.description,
    "Timing": thought.interventionPoint.timing,
    "Feasibility": (thought.interventionPoint.feasibility * 100).toFixed(0) + "%",
    "Expected Impact": (thought.interventionPoint.expectedImpact * 100).toFixed(0) + "%"
  })));
  parts.push(section(
    "Actual Scenario",
    `**Name:** ${thought.actual.name}

**Description:** ${thought.actual.description}`
  ));
  const cfRows = thought.counterfactuals.map((cf) => {
    const primaryOutcome = cf.outcomes[0];
    return [
      cf.name,
      cf.description.substring(0, 50) + (cf.description.length > 50 ? "..." : ""),
      cf.likelihood !== void 0 ? cf.likelihood.toFixed(2) : "N/A",
      primaryOutcome?.impact || "-"
    ];
  });
  parts.push(section("Counterfactual Scenarios", table(
    ["Name", "Description", "Likelihood", "Impact"],
    cfRows
  )));
  if (markdownIncludeMermaid) {
    const mermaid = counterfactualToMermaid(thought, "default", true, includeMetrics);
    parts.push(section("Visualization", mermaidBlock(mermaid)));
  }
  return document("Counterfactual Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: { mode: "counterfactual", scenarios: thought.counterfactuals.length }
  });
}
var init_counterfactual = __esm({
  "src/export/visual/counterfactual.ts"() {
    init_esm_shims();
    init_utils();
    init_svg_utils();
    init_graphml_utils();
    init_tikz_utils();
    init_html_utils();
    init_modelica_utils();
    init_uml_utils();
    init_json_utils();
    init_markdown_utils();
  }
});

// src/export/visual/analogical.ts
function exportAnalogicalMapping(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return analogicalToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return analogicalToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return analogicalToASCII(thought);
    case "svg":
      return analogicalToSVG(thought, options);
    case "graphml":
      return analogicalToGraphML(thought, options);
    case "tikz":
      return analogicalToTikZ(thought, options);
    case "html":
      return analogicalToHTML(thought, options);
    case "modelica":
      return analogicalToModelica(thought, options);
    case "uml":
      return analogicalToUML(thought, options);
    case "json":
      return analogicalToJSON(thought, options);
    case "markdown":
      return analogicalToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function analogicalToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph LR\n";
  mermaid += '  subgraph Source["Source Domain"]\n';
  for (const entity of thought.sourceDomain.entities) {
    const entityId = sanitizeId("src_" + entity.id);
    const label = includeLabels ? entity.name : entityId;
    mermaid += `    ${entityId}["${label}"]
`;
  }
  mermaid += "  end\n\n";
  mermaid += '  subgraph Target["Target Domain"]\n';
  for (const entity of thought.targetDomain.entities) {
    const entityId = sanitizeId("tgt_" + entity.id);
    const label = includeLabels ? entity.name : entityId;
    mermaid += `    ${entityId}["${label}"]
`;
  }
  mermaid += "  end\n\n";
  for (const mapping of thought.mapping) {
    const srcId = sanitizeId("src_" + mapping.sourceEntityId);
    const tgtId = sanitizeId("tgt_" + mapping.targetEntityId);
    const confidenceLabel = includeMetrics ? `|${mapping.confidence.toFixed(2)}|` : "";
    mermaid += `  ${srcId} -.->${confidenceLabel} ${tgtId}
`;
  }
  if (colorScheme !== "monochrome") {
    mermaid += "\n";
    const srcColor = colorScheme === "pastel" ? "#fff3e0" : "#ffd699";
    const tgtColor = colorScheme === "pastel" ? "#e1f5ff" : "#a8d5ff";
    for (const entity of thought.sourceDomain.entities) {
      const entityId = sanitizeId("src_" + entity.id);
      mermaid += `  style ${entityId} fill:${srcColor}
`;
    }
    for (const entity of thought.targetDomain.entities) {
      const entityId = sanitizeId("tgt_" + entity.id);
      mermaid += `  style ${entityId} fill:${tgtColor}
`;
    }
  }
  return mermaid;
}
function analogicalToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph AnalogicalMapping {\n";
  dot += "  rankdir=LR;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  dot += "  subgraph cluster_source {\n";
  dot += '    label="Source Domain";\n';
  dot += "    style=filled;\n";
  dot += "    fillcolor=lightyellow;\n\n";
  for (const entity of thought.sourceDomain.entities) {
    const entityId = sanitizeId("src_" + entity.id);
    const label = includeLabels ? entity.name : entityId;
    dot += `    ${entityId} [label="${label}"];
`;
  }
  dot += "  }\n\n";
  dot += "  subgraph cluster_target {\n";
  dot += '    label="Target Domain";\n';
  dot += "    style=filled;\n";
  dot += "    fillcolor=lightblue;\n\n";
  for (const entity of thought.targetDomain.entities) {
    const entityId = sanitizeId("tgt_" + entity.id);
    const label = includeLabels ? entity.name : entityId;
    dot += `    ${entityId} [label="${label}"];
`;
  }
  dot += "  }\n\n";
  for (const mapping of thought.mapping) {
    const srcId = sanitizeId("src_" + mapping.sourceEntityId);
    const tgtId = sanitizeId("tgt_" + mapping.targetEntityId);
    const confidenceLabel = includeMetrics ? `, label="${mapping.confidence.toFixed(2)}"` : "";
    dot += `  ${srcId} -> ${tgtId} [style=dashed${confidenceLabel}];
`;
  }
  dot += "}\n";
  return dot;
}
function analogicalToASCII(thought) {
  let ascii = "Analogical Domain Mapping:\n";
  ascii += "==========================\n\n";
  ascii += `Source Domain: ${thought.sourceDomain.name}
`;
  ascii += `${thought.sourceDomain.description}

`;
  ascii += `Target Domain: ${thought.targetDomain.name}
`;
  ascii += `${thought.targetDomain.description}

`;
  ascii += "Mappings:\n";
  for (const mapping of thought.mapping) {
    const srcEntity = thought.sourceDomain.entities.find((e) => e.id === mapping.sourceEntityId);
    const tgtEntity = thought.targetDomain.entities.find((e) => e.id === mapping.targetEntityId);
    if (srcEntity && tgtEntity) {
      ascii += `  ${srcEntity.name} \u2190\u2192 ${tgtEntity.name} (confidence: ${mapping.confidence.toFixed(2)})
`;
      ascii += `    ${mapping.justification}
`;
    }
  }
  ascii += `
Analogy Strength: ${thought.analogyStrength.toFixed(2)}
`;
  return ascii;
}
function analogicalToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width
  } = options;
  const positions = /* @__PURE__ */ new Map();
  const sourceY = 100;
  const entitySpacing = 100;
  const nodeWidth = 150;
  const nodeHeight = 40;
  thought.sourceDomain.entities.forEach((entity, index) => {
    const srcId = "src_" + entity.id;
    positions.set(srcId, {
      id: srcId,
      label: includeLabels ? entity.name : srcId,
      x: 150,
      y: sourceY + index * entitySpacing,
      width: nodeWidth,
      height: nodeHeight,
      type: "source"
    });
  });
  const targetY = 100;
  thought.targetDomain.entities.forEach((entity, index) => {
    const tgtId = "tgt_" + entity.id;
    positions.set(tgtId, {
      id: tgtId,
      label: includeLabels ? entity.name : tgtId,
      x: svgWidth - 150,
      y: targetY + index * entitySpacing,
      width: nodeWidth,
      height: nodeHeight,
      type: "target"
    });
  });
  const actualHeight = Math.max(
    DEFAULT_SVG_OPTIONS.height,
    Math.max(thought.sourceDomain.entities.length, thought.targetDomain.entities.length) * entitySpacing + 150
  );
  let svg = generateSVGHeader(svgWidth, actualHeight, "Analogical Domain Mapping");
  svg += '\n  <!-- Mappings -->\n  <g class="edges">';
  for (const mapping of thought.mapping) {
    const srcPos = positions.get("src_" + mapping.sourceEntityId);
    const tgtPos = positions.get("tgt_" + mapping.targetEntityId);
    if (srcPos && tgtPos) {
      const label = includeMetrics ? mapping.confidence.toFixed(2) : void 0;
      svg += renderEdge(srcPos, tgtPos, { label, style: "dashed" });
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  const sourceColors = getNodeColor("tertiary", colorScheme);
  const targetColors = getNodeColor("primary", colorScheme);
  for (const [, pos] of positions) {
    if (pos.type === "source") {
      svg += renderRectNode(pos, sourceColors);
    } else {
      svg += renderRectNode(pos, targetColors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Analogy Strength", value: thought.analogyStrength.toFixed(2) },
      { label: "Mappings", value: thought.mapping.length },
      { label: "Source Entities", value: thought.sourceDomain.entities.length },
      { label: "Target Entities", value: thought.targetDomain.entities.length }
    ];
    svg += renderMetricsPanel(svgWidth - 180, actualHeight - 140, metrics);
  }
  const legendItems = [
    { label: "Source Domain", color: sourceColors },
    { label: "Target Domain", color: targetColors }
  ];
  svg += renderLegend(20, actualHeight - 80, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function analogicalToGraphML(thought, options) {
  const { includeMetrics = true } = options;
  const nodes = [];
  for (const entity of thought.sourceDomain.entities) {
    nodes.push({
      id: "src_" + entity.id,
      label: entity.name,
      type: "source",
      metadata: {
        description: entity.description,
        domain: thought.sourceDomain.name
      }
    });
  }
  for (const entity of thought.targetDomain.entities) {
    nodes.push({
      id: "tgt_" + entity.id,
      label: entity.name,
      type: "target",
      metadata: {
        description: entity.description,
        domain: thought.targetDomain.name
      }
    });
  }
  const edges = thought.mapping.map((mapping, index) => {
    const edge = {
      id: `mapping_${index}`,
      source: "src_" + mapping.sourceEntityId,
      target: "tgt_" + mapping.targetEntityId
    };
    if (includeMetrics) {
      edge.metadata = {
        weight: mapping.confidence,
        type: "mapping"
      };
      edge.label = mapping.confidence.toFixed(2);
    }
    return edge;
  });
  const graphmlOptions = {
    graphName: "Analogical Mapping"
  };
  return generateGraphML(nodes, edges, graphmlOptions);
}
function analogicalToTikZ(thought, options) {
  const { includeLabels = true, includeMetrics = true, colorScheme = "default" } = options;
  const nodes = [];
  thought.sourceDomain.entities.forEach((entity, index) => {
    nodes.push({
      id: "src_" + entity.id,
      x: -3,
      y: -index * 1.5,
      label: includeLabels ? entity.name : entity.id,
      shape: "rectangle",
      type: "tertiary"
    });
  });
  thought.targetDomain.entities.forEach((entity, index) => {
    nodes.push({
      id: "tgt_" + entity.id,
      x: 3,
      y: -index * 1.5,
      label: includeLabels ? entity.name : entity.id,
      shape: "rectangle",
      type: "primary"
    });
  });
  const edges = thought.mapping.map((mapping) => {
    const edge = {
      source: "src_" + mapping.sourceEntityId,
      target: "tgt_" + mapping.targetEntityId,
      style: "dashed"
    };
    if (includeMetrics) {
      edge.label = mapping.confidence.toFixed(2);
    }
    return edge;
  });
  const tikzOptions = {
    title: "Analogical Mapping",
    colorScheme,
    includeLabels,
    includeMetrics
  };
  let tikz = generateTikZ(nodes, edges, tikzOptions);
  if (includeMetrics) {
    const metrics = [
      { label: "Analogy Strength", value: thought.analogyStrength.toFixed(2) },
      { label: "Mappings", value: thought.mapping.length.toString() },
      { label: "Source Entities", value: thought.sourceDomain.entities.length.toString() },
      { label: "Target Entities", value: thought.targetDomain.entities.length.toString() }
    ];
    tikz = tikz.replace(
      /\\end\{tikzpicture\}/,
      renderTikZMetrics(6, -6, metrics) + "\n\\end{tikzpicture}"
    );
  }
  const sourceColors = getTikZColor("tertiary", colorScheme);
  const targetColors = getTikZColor("primary", colorScheme);
  const legendItems = [
    { label: "Source Domain", color: sourceColors },
    { label: "Target Domain", color: targetColors }
  ];
  tikz = tikz.replace(
    /\\end\{tikzpicture\}/,
    renderTikZLegend(-3, -6, legendItems) + "\n\\end{tikzpicture}"
  );
  return tikz;
}
function analogicalToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Analogical Reasoning Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  if (includeMetrics) {
    html += '<div class="metrics-grid">';
    html += renderMetricCard("Analogy Strength", (thought.analogyStrength * 100).toFixed(0) + "%", "primary");
    html += renderMetricCard("Mappings", thought.mapping.length, "info");
    html += renderMetricCard("Source Entities", thought.sourceDomain.entities.length, "success");
    html += renderMetricCard("Target Entities", thought.targetDomain.entities.length, "warning");
    html += "</div>\n";
    html += renderProgressBar(thought.analogyStrength * 100, "primary");
  }
  const srcRows = thought.sourceDomain.entities.map((e) => [e.id, e.name, e.type || "-", e.description || "-"]);
  html += renderSection("Source Domain: " + thought.sourceDomain.name, renderTable(
    ["ID", "Name", "Type", "Description"],
    srcRows
  ), "\u{1F4D8}");
  const tgtRows = thought.targetDomain.entities.map((e) => [e.id, e.name, e.type || "-", e.description || "-"]);
  html += renderSection("Target Domain: " + thought.targetDomain.name, renderTable(
    ["ID", "Name", "Type", "Description"],
    tgtRows
  ), "\u{1F4D7}");
  const mapRows = thought.mapping.map((m) => [
    m.sourceEntityId,
    "\u2192",
    m.targetEntityId,
    (m.confidence * 100).toFixed(0) + "%",
    m.justification || "-"
  ]);
  html += renderSection("Entity Mappings", renderTable(
    ["Source", "", "Target", "Confidence", "Justification"],
    mapRows
  ), "\u{1F517}");
  if (thought.inferences && thought.inferences.length > 0) {
    const infRows = thought.inferences.map((inf, i) => [
      (i + 1).toString(),
      inf.sourcePattern,
      inf.targetPrediction,
      (inf.confidence * 100).toFixed(0) + "%"
    ]);
    html += renderSection("Inferences", renderTable(
      ["#", "Source Pattern", "Target Prediction", "Confidence"],
      infRows
    ), "\u{1F4A1}");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function analogicalToModelica(thought, options) {
  const { includeMetrics = true } = options;
  const pkgName = sanitizeModelicaId("AnalogicalMapping");
  let modelica = `package ${pkgName}
`;
  modelica += `  "${escapeModelicaString("Analogical domain mapping: " + thought.sourceDomain.name + " \u2192 " + thought.targetDomain.name)}"

`;
  modelica += `  record SourceDomain "${escapeModelicaString(thought.sourceDomain.name)}"
`;
  modelica += `    String name = "${escapeModelicaString(thought.sourceDomain.name)}";
`;
  modelica += `    String description = "${escapeModelicaString(thought.sourceDomain.description || "")}";
`;
  thought.sourceDomain.entities.forEach((entity) => {
    const entityId = sanitizeModelicaId(entity.id);
    modelica += `    parameter String entity_${entityId} = "${escapeModelicaString(entity.name)}";
`;
    if (entity.description) {
      modelica += `    parameter String entity_${entityId}_desc = "${escapeModelicaString(entity.description)}";
`;
    }
  });
  modelica += `  end SourceDomain;

`;
  modelica += `  record TargetDomain "${escapeModelicaString(thought.targetDomain.name)}"
`;
  modelica += `    String name = "${escapeModelicaString(thought.targetDomain.name)}";
`;
  modelica += `    String description = "${escapeModelicaString(thought.targetDomain.description || "")}";
`;
  thought.targetDomain.entities.forEach((entity) => {
    const entityId = sanitizeModelicaId(entity.id);
    modelica += `    parameter String entity_${entityId} = "${escapeModelicaString(entity.name)}";
`;
    if (entity.description) {
      modelica += `    parameter String entity_${entityId}_desc = "${escapeModelicaString(entity.description)}";
`;
    }
  });
  modelica += `  end TargetDomain;

`;
  modelica += `  record Mapping "Entity mapping with confidence"
`;
  thought.mapping.forEach((mapping, index) => {
    const srcId = sanitizeModelicaId(mapping.sourceEntityId);
    const tgtId = sanitizeModelicaId(mapping.targetEntityId);
    modelica += `    parameter String map_${index}_source = "${escapeModelicaString(srcId)}";
`;
    modelica += `    parameter String map_${index}_target = "${escapeModelicaString(tgtId)}";
`;
    modelica += `    parameter Real map_${index}_confidence = ${mapping.confidence.toFixed(3)};
`;
    if (mapping.justification) {
      modelica += `    parameter String map_${index}_justification = "${escapeModelicaString(mapping.justification)}";
`;
    }
  });
  modelica += `  end Mapping;

`;
  if (includeMetrics) {
    modelica += `  record Metrics "Analogy metrics"
`;
    modelica += `    parameter Real analogyStrength = ${thought.analogyStrength.toFixed(3)};
`;
    modelica += `    parameter Integer mappingCount = ${thought.mapping.length};
`;
    modelica += `    parameter Integer sourceEntityCount = ${thought.sourceDomain.entities.length};
`;
    modelica += `    parameter Integer targetEntityCount = ${thought.targetDomain.entities.length};
`;
    modelica += `  end Metrics;

`;
  }
  modelica += `  model AnalogicalSystem "Complete analogical mapping system"
`;
  modelica += `    SourceDomain source;
`;
  modelica += `    TargetDomain target;
`;
  modelica += `    Mapping mappings;
`;
  if (includeMetrics) {
    modelica += `    Metrics metrics;
`;
  }
  modelica += `  end AnalogicalSystem;

`;
  modelica += `  annotation(Documentation(info="<html>
`;
  modelica += `    <p>Analogical mapping between ${escapeModelicaString(thought.sourceDomain.name)} and ${escapeModelicaString(thought.targetDomain.name)}</p>
`;
  modelica += `    <p>Analogy strength: ${(thought.analogyStrength * 100).toFixed(1)}%</p>
`;
  modelica += `  </html>"));
`;
  modelica += `end ${pkgName};
`;
  return modelica;
}
function analogicalToUML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  nodes.push({
    id: "source_domain",
    label: thought.sourceDomain.name,
    shape: "package",
    stereotype: "source"
  });
  thought.sourceDomain.entities.forEach((entity) => {
    const nodeId = "src_" + entity.id;
    nodes.push({
      id: nodeId,
      label: includeLabels ? entity.name : entity.id,
      shape: "rectangle",
      color: "FFE0B2",
      attributes: entity.description ? [entity.description] : []
    });
  });
  nodes.push({
    id: "target_domain",
    label: thought.targetDomain.name,
    shape: "package",
    stereotype: "target"
  });
  thought.targetDomain.entities.forEach((entity) => {
    const nodeId = "tgt_" + entity.id;
    nodes.push({
      id: nodeId,
      label: includeLabels ? entity.name : entity.id,
      shape: "rectangle",
      color: "B3E5FC",
      attributes: entity.description ? [entity.description] : []
    });
  });
  thought.mapping.forEach((mapping) => {
    const srcId = "src_" + mapping.sourceEntityId;
    const tgtId = "tgt_" + mapping.targetEntityId;
    edges.push({
      source: srcId,
      target: tgtId,
      type: "dependency",
      label: includeMetrics ? `${mapping.confidence.toFixed(2)}` : void 0
    });
  });
  if (includeMetrics) {
    nodes.push({
      id: "metrics_info",
      label: `Metrics
Analogy Strength: ${(thought.analogyStrength * 100).toFixed(1)}%
Mappings: ${thought.mapping.length}`,
      shape: "rectangle",
      color: "E8EAF6"
    });
  }
  return generateUmlDiagram(nodes, edges, {
    title: "Analogical Domain Mapping"});
}
function analogicalToJSON(thought, options) {
  const { includeMetrics = true } = options;
  const graph = createJsonGraph("Analogical Domain Mapping", "analogical");
  graph.metadata.sourceDomainName = thought.sourceDomain.name;
  graph.metadata.sourceDomainDescription = thought.sourceDomain.description;
  graph.metadata.targetDomainName = thought.targetDomain.name;
  graph.metadata.targetDomainDescription = thought.targetDomain.description;
  thought.sourceDomain.entities.forEach((entity) => {
    addNode(graph, {
      id: "src_" + entity.id,
      label: entity.name,
      type: "source_entity",
      metadata: {
        originalId: entity.id,
        description: entity.description,
        entityType: entity.type,
        domain: "source"
      }
    });
  });
  thought.targetDomain.entities.forEach((entity) => {
    addNode(graph, {
      id: "tgt_" + entity.id,
      label: entity.name,
      type: "target_entity",
      metadata: {
        originalId: entity.id,
        description: entity.description,
        entityType: entity.type,
        domain: "target"
      }
    });
  });
  thought.mapping.forEach((mapping, index) => {
    addEdge(graph, {
      id: `mapping_${index}`,
      source: "src_" + mapping.sourceEntityId,
      target: "tgt_" + mapping.targetEntityId,
      label: `confidence: ${mapping.confidence.toFixed(2)}`,
      type: "mapping",
      metadata: {
        confidence: mapping.confidence,
        justification: mapping.justification
      }
    });
  });
  if (includeMetrics) {
    addMetric(graph, "analogyStrength", thought.analogyStrength);
    addMetric(graph, "mappingCount", thought.mapping.length);
    addMetric(graph, "sourceEntityCount", thought.sourceDomain.entities.length);
    addMetric(graph, "targetEntityCount", thought.targetDomain.entities.length);
    if (thought.mapping.length > 0) {
      const avgConfidence = thought.mapping.reduce((sum, m) => sum + m.confidence, 0) / thought.mapping.length;
      addMetric(graph, "averageMappingConfidence", avgConfidence);
    }
  }
  if (thought.inferences && thought.inferences.length > 0) {
    graph.metadata.inferences = thought.inferences.map((inf) => ({
      sourcePattern: inf.sourcePattern,
      targetPrediction: inf.targetPrediction,
      confidence: inf.confidence
    }));
    if (includeMetrics) {
      addMetric(graph, "inferenceCount", thought.inferences.length);
    }
  }
  return serializeGraph(graph);
}
function analogicalToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  if (includeMetrics) {
    parts.push(section("Metrics", keyValueSection({
      "Analogy Strength": (thought.analogyStrength * 100).toFixed(0) + "%",
      "Mappings": thought.mapping.length,
      "Source Entities": thought.sourceDomain.entities.length,
      "Target Entities": thought.targetDomain.entities.length
    })));
  }
  parts.push(section(
    "Source Domain",
    `**Name:** ${thought.sourceDomain.name}

**Description:** ${thought.sourceDomain.description || "N/A"}

**Entities:**
${list(thought.sourceDomain.entities.map((e) => `${e.name}: ${e.description || "N/A"}`))}`
  ));
  parts.push(section(
    "Target Domain",
    `**Name:** ${thought.targetDomain.name}

**Description:** ${thought.targetDomain.description || "N/A"}

**Entities:**
${list(thought.targetDomain.entities.map((e) => `${e.name}: ${e.description || "N/A"}`))}`
  ));
  const mapRows = thought.mapping.map((m) => [
    m.sourceEntityId,
    "\u2192",
    m.targetEntityId,
    (m.confidence * 100).toFixed(0) + "%",
    m.justification || "-"
  ]);
  parts.push(section("Entity Mappings", table(
    ["Source", "", "Target", "Confidence", "Justification"],
    mapRows
  )));
  if (thought.inferences && thought.inferences.length > 0) {
    const infRows = thought.inferences.map((inf) => [
      inf.sourcePattern,
      inf.targetPrediction,
      (inf.confidence * 100).toFixed(0) + "%"
    ]);
    parts.push(section("Inferences", table(
      ["Source Pattern", "Target Prediction", "Confidence"],
      infRows
    )));
  }
  if (markdownIncludeMermaid) {
    const mermaid = analogicalToMermaid(thought, "default", true, includeMetrics);
    parts.push(section("Visualization", mermaidBlock(mermaid)));
  }
  return document("Analogical Reasoning Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "analogical",
      mappings: thought.mapping.length,
      analogyStrength: thought.analogyStrength.toFixed(2)
    }
  });
}
var init_analogical = __esm({
  "src/export/visual/analogical.ts"() {
    init_esm_shims();
    init_utils();
    init_svg_utils();
    init_graphml_utils();
    init_tikz_utils();
    init_html_utils();
    init_modelica_utils();
    init_uml_utils();
    init_json_utils();
    init_markdown_utils();
  }
});

// src/export/visual/evidential.ts
function exportEvidentialBeliefs(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return evidentialToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return evidentialToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return evidentialToASCII(thought);
    case "svg":
      return evidentialToSVG(thought, options);
    case "graphml":
      return evidentialToGraphML(thought, options);
    case "tikz":
      return evidentialToTikZ(thought, options);
    case "html":
      return evidentialToHTML(thought, options);
    case "modelica":
      return evidentialToModelica(thought, options);
    case "uml":
      return evidentialToUML(thought, options);
    case "json":
      return evidentialToJSON(thought, options);
    case "markdown":
      return evidentialToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function evidentialToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TD\n";
  mermaid += '  Frame["Frame of Discernment"]\n';
  if (thought.frameOfDiscernment) {
    for (const hypothesis of thought.frameOfDiscernment) {
      const hypId = sanitizeId(hypothesis);
      const label = includeLabels ? hypothesis : hypId;
      mermaid += `  ${hypId}["${label}"]
`;
      mermaid += `  Frame --> ${hypId}
`;
    }
  }
  if (includeMetrics && thought.massAssignments && thought.massAssignments.length > 0) {
    mermaid += "\n";
    for (const mass of thought.massAssignments) {
      const massId = sanitizeId(mass.subset.join("_"));
      const label = `{${mass.subset.join(", ")}}`;
      mermaid += `  ${massId}["${label}: ${mass.mass.toFixed(3)}"]
`;
    }
  }
  if (colorScheme !== "monochrome" && thought.frameOfDiscernment) {
    mermaid += "\n";
    const color = colorScheme === "pastel" ? "#e1f5ff" : "#a8d5ff";
    for (const hypothesis of thought.frameOfDiscernment) {
      const hypId = sanitizeId(hypothesis);
      mermaid += `  style ${hypId} fill:${color}
`;
    }
  }
  return mermaid;
}
function evidentialToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph EvidentialBeliefs {\n";
  dot += "  rankdir=TD;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  dot += '  Frame [label="Frame of Discernment", shape=ellipse];\n\n';
  if (thought.frameOfDiscernment) {
    for (const hypothesis of thought.frameOfDiscernment) {
      const hypId = sanitizeId(hypothesis);
      const label = includeLabels ? hypothesis : hypId;
      dot += `  ${hypId} [label="${label}"];
`;
      dot += `  Frame -> ${hypId};
`;
    }
  }
  if (includeMetrics && thought.massAssignments && thought.massAssignments.length > 0) {
    dot += "\n";
    for (const mass of thought.massAssignments) {
      const massId = sanitizeId(mass.subset.join("_"));
      const label = `{${mass.subset.join(", ")}}: ${mass.mass.toFixed(3)}`;
      dot += `  ${massId} [label="${label}", shape=note];
`;
    }
  }
  dot += "}\n";
  return dot;
}
function evidentialToASCII(thought) {
  let ascii = "Evidential Belief Visualization:\n";
  ascii += "================================\n\n";
  ascii += "Frame of Discernment:\n";
  if (thought.frameOfDiscernment) {
    ascii += `  {${thought.frameOfDiscernment.join(", ")}}

`;
  } else {
    ascii += "  (not defined)\n\n";
  }
  if (thought.massAssignments && thought.massAssignments.length > 0) {
    ascii += "Mass Assignments:\n";
    for (const mass of thought.massAssignments) {
      ascii += `  m({${mass.subset.join(", ")}}) = ${mass.mass.toFixed(3)}
`;
    }
    ascii += "\n";
  }
  if (thought.beliefFunctions && thought.beliefFunctions.length > 0) {
    ascii += `Belief Functions: ${thought.beliefFunctions.length} defined
`;
  }
  if (thought.plausibilityFunction) {
    ascii += `Plausibility: ${thought.plausibilityFunction.toFixed(3)}
`;
  }
  return ascii;
}
function evidentialToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width
  } = options;
  if (!thought.frameOfDiscernment || thought.frameOfDiscernment.length === 0) {
    return generateSVGHeader(svgWidth, 200, "Evidential Beliefs") + '\n  <text x="400" y="100" text-anchor="middle" class="subtitle">No frame of discernment defined</text>\n' + generateSVGFooter();
  }
  const positions = /* @__PURE__ */ new Map();
  const nodeWidth = 150;
  const nodeHeight = 40;
  positions.set("frame", {
    id: "frame",
    label: "Frame of Discernment",
    x: svgWidth / 2,
    y: 80,
    width: nodeWidth,
    height: nodeHeight,
    type: "frame"
  });
  const hypSpacing = Math.min(200, svgWidth / (thought.frameOfDiscernment.length + 1));
  const hypStartX = (svgWidth - (thought.frameOfDiscernment.length - 1) * hypSpacing) / 2;
  thought.frameOfDiscernment.forEach((hypothesis, index) => {
    const hypId = sanitizeId(hypothesis);
    positions.set(hypId, {
      id: hypId,
      label: includeLabels ? hypothesis : hypId,
      x: hypStartX + index * hypSpacing,
      y: 200,
      width: nodeWidth,
      height: nodeHeight,
      type: "hypothesis"
    });
  });
  const actualHeight = 400;
  let svg = generateSVGHeader(svgWidth, actualHeight, "Evidential Beliefs");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  const framePos = positions.get("frame");
  for (const hypothesis of thought.frameOfDiscernment) {
    const hypPos = positions.get(sanitizeId(hypothesis));
    if (hypPos) {
      svg += renderEdge(framePos, hypPos);
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  const frameColors = getNodeColor("warning", colorScheme);
  const hypColors = getNodeColor("primary", colorScheme);
  svg += renderEllipseNode(framePos, frameColors);
  for (const [id, pos] of positions) {
    if (id !== "frame") {
      svg += renderRectNode(pos, hypColors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Hypotheses", value: thought.frameOfDiscernment.length },
      { label: "Belief Functions", value: thought.beliefFunctions?.length || 0 }
    ];
    svg += renderMetricsPanel(svgWidth - 180, actualHeight - 110, metrics);
  }
  const legendItems = [
    { label: "Frame", color: frameColors, shape: "ellipse" },
    { label: "Hypothesis", color: hypColors }
  ];
  svg += renderLegend(20, actualHeight - 80, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function evidentialToGraphML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  let edgeId = 0;
  if (thought.evidence && thought.evidence.length > 0) {
    for (const evidence of thought.evidence) {
      nodes.push({
        id: evidence.id,
        label: includeLabels ? evidence.description : evidence.id,
        type: "evidence",
        metadata: {
          source: evidence.source,
          reliability: evidence.reliability,
          description: evidence.description
        }
      });
    }
  }
  if (thought.beliefFunctions && thought.beliefFunctions.length > 0) {
    for (const belief of thought.beliefFunctions) {
      const label = includeLabels ? `Belief: ${belief.source}` : belief.id;
      nodes.push({
        id: belief.id,
        label,
        type: "belief",
        metadata: belief.conflictMass !== void 0 ? { conflictMass: belief.conflictMass } : void 0
      });
      if (thought.evidence && thought.evidence.length > 0) {
        const sourceEvidence = thought.evidence.find((e) => e.id === belief.source);
        if (sourceEvidence) {
          edges.push({
            id: `e${edgeId++}`,
            source: sourceEvidence.id,
            target: belief.id,
            label: includeMetrics ? `strength: ${sourceEvidence.reliability.toFixed(3)}` : void 0,
            metadata: includeMetrics ? { weight: sourceEvidence.reliability } : void 0
          });
        }
      }
    }
  }
  if (nodes.length === 0 && thought.frameOfDiscernment && thought.frameOfDiscernment.length > 0) {
    nodes.push({
      id: "frame",
      label: "Frame of Discernment",
      type: "frame"
    });
    for (const hypothesis of thought.frameOfDiscernment) {
      const hypId = sanitizeId(hypothesis);
      nodes.push({
        id: hypId,
        label: includeLabels ? hypothesis : hypId,
        type: "hypothesis"
      });
      edges.push({
        id: `e${edgeId++}`,
        source: "frame",
        target: hypId
      });
    }
  }
  return generateGraphML(nodes, edges, {
    graphName: "Evidential Beliefs",
    includeLabels,
    includeMetadata: includeMetrics
  });
}
function evidentialToTikZ(thought, options) {
  const { includeLabels = true, includeMetrics = true, colorScheme = "default" } = options;
  const nodes = [];
  const edges = [];
  if (thought.evidence && thought.evidence.length > 0) {
    const evidenceCount = thought.evidence.length;
    const evidenceSpacing = Math.min(3, 8 / evidenceCount);
    const startX = (8 - (evidenceCount - 1) * evidenceSpacing) / 2;
    for (let i = 0; i < thought.evidence.length; i++) {
      const evidence = thought.evidence[i];
      const label = includeLabels ? `${evidence.description.substring(0, 20)}${evidence.description.length > 20 ? "..." : ""}` : evidence.id;
      nodes.push({
        id: evidence.id,
        label,
        x: startX + i * evidenceSpacing,
        y: 0,
        type: "evidence",
        shape: "rectangle"
      });
    }
  }
  if (thought.beliefFunctions && thought.beliefFunctions.length > 0) {
    const beliefCount = thought.beliefFunctions.length;
    const beliefSpacing = Math.min(3, 8 / beliefCount);
    const startX = (8 - (beliefCount - 1) * beliefSpacing) / 2;
    for (let i = 0; i < thought.beliefFunctions.length; i++) {
      const belief = thought.beliefFunctions[i];
      const label = includeLabels ? `Belief: ${belief.source}` : belief.id;
      nodes.push({
        id: belief.id,
        label,
        x: startX + i * beliefSpacing,
        y: -3,
        type: "primary",
        shape: "ellipse"
      });
      if (thought.evidence && thought.evidence.length > 0) {
        const sourceEvidence = thought.evidence.find((e) => e.id === belief.source);
        if (sourceEvidence) {
          edges.push({
            source: sourceEvidence.id,
            target: belief.id,
            label: includeMetrics ? sourceEvidence.reliability.toFixed(3) : void 0,
            directed: true
          });
        }
      }
    }
  }
  if (nodes.length === 0 && thought.frameOfDiscernment && thought.frameOfDiscernment.length > 0) {
    nodes.push({
      id: "frame",
      label: "Frame of Discernment",
      x: 4,
      y: 0,
      type: "warning",
      shape: "ellipse"
    });
    const hypCount = thought.frameOfDiscernment.length;
    const hypSpacing = Math.min(2.5, 8 / hypCount);
    const startX = (8 - (hypCount - 1) * hypSpacing) / 2;
    for (let i = 0; i < thought.frameOfDiscernment.length; i++) {
      const hypothesis = thought.frameOfDiscernment[i];
      const hypId = sanitizeId(hypothesis);
      nodes.push({
        id: hypId,
        label: includeLabels ? hypothesis : hypId,
        x: startX + i * hypSpacing,
        y: -2.5,
        type: "info",
        shape: "rectangle"
      });
      edges.push({
        source: "frame",
        target: hypId,
        directed: true
      });
    }
  }
  return generateTikZ(nodes, edges, {
    title: "Evidential Beliefs",
    includeLabels,
    includeMetrics,
    colorScheme
  });
}
function evidentialToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Evidential Reasoning Analysis",
    htmlTheme = "light"
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  if (thought.frameOfDiscernment && thought.frameOfDiscernment.length > 0) {
    html += renderSection("Frame of Discernment", `
      <p>Hypotheses under consideration:</p>
      <ul class="list-styled">
        ${thought.frameOfDiscernment.map((h) => `<li>${escapeHTML(h)}</li>`).join("\n")}
      </ul>
    `, "\u{1F3AF}");
  }
  if (thought.evidence && thought.evidence.length > 0) {
    const evRows = thought.evidence.map((ev) => [
      ev.id,
      ev.description,
      ev.reliability.toFixed(2),
      ev.source || "-"
    ]);
    html += renderSection("Evidence", renderTable(
      ["ID", "Description", "Reliability", "Source"],
      evRows
    ), "\u{1F4CA}");
  }
  if (thought.beliefFunctions && thought.beliefFunctions.length > 0) {
    const bfContent = thought.beliefFunctions.map((bf) => {
      const massRows = bf.massAssignments.map(
        (ma) => `<tr><td>{${ma.hypothesisSet.join(", ")}}</td><td>${ma.mass.toFixed(3)}</td><td>${escapeHTML(ma.justification)}</td></tr>`
      ).join("\n");
      return `
        <div class="card">
          <div class="card-header">Belief from: ${escapeHTML(bf.source)}</div>
          ${bf.conflictMass ? `<p><strong>Conflict Mass:</strong> ${bf.conflictMass.toFixed(3)}</p>` : ""}
          <table class="table">
            <thead><tr><th>Hypothesis Set</th><th>Mass</th><th>Justification</th></tr></thead>
            <tbody>${massRows}</tbody>
          </table>
        </div>
      `;
    }).join("\n");
    html += renderSection("Belief Functions", bfContent, "\u{1F4C8}");
  }
  if (thought.combinedBelief) {
    const massRows = thought.combinedBelief.massAssignments.map(
      (ma) => `<tr><td>{${ma.hypothesisSet.join(", ")}}</td><td>${ma.mass.toFixed(3)}</td><td>${escapeHTML(ma.justification)}</td></tr>`
    ).join("\n");
    html += renderSection("Combined Belief", `
      <table class="table">
        <thead><tr><th>Hypothesis Set</th><th>Mass</th><th>Justification</th></tr></thead>
        <tbody>${massRows}</tbody>
      </table>
      ${thought.combinedBelief.conflictMass ? `<p><strong>Conflict Mass:</strong> ${thought.combinedBelief.conflictMass.toFixed(3)}</p>` : ""}
    `, "\u{1F52E}");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function evidentialToModelica(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  let modelica = "package EvidentialBeliefs\n";
  modelica += '  "Evidential reasoning with belief degrees and evidence"\n\n';
  if (thought.evidence && thought.evidence.length > 0) {
    modelica += "  // Evidence Items\n";
    for (const evidence of thought.evidence) {
      const evId = sanitizeModelicaId(evidence.id);
      const desc = includeLabels ? escapeModelicaString(evidence.description) : "";
      modelica += `  record ${evId}
`;
      modelica += `    "Evidence: ${desc}"
`;
      modelica += `    parameter Real reliability = ${evidence.reliability};
`;
      if (evidence.source) {
        modelica += `    parameter String source = "${escapeModelicaString(evidence.source)}";
`;
      }
      modelica += `    parameter String description = "${desc}";
`;
      modelica += `  end ${evId};

`;
    }
  }
  if (thought.beliefFunctions && thought.beliefFunctions.length > 0) {
    modelica += "  // Belief Functions\n";
    for (const belief of thought.beliefFunctions) {
      const bfId = sanitizeModelicaId(belief.id);
      modelica += `  record ${bfId}
`;
      modelica += `    "Belief function from ${escapeModelicaString(belief.source)}"
`;
      if (belief.massAssignments && belief.massAssignments.length > 0) {
        for (let i = 0; i < belief.massAssignments.length; i++) {
          const ma = belief.massAssignments[i];
          const hypSet = ma.hypothesisSet.map((h) => sanitizeModelicaId(h)).join("_");
          modelica += `    parameter Real mass_${hypSet} = ${ma.mass};
`;
        }
      }
      if (belief.conflictMass !== void 0 && includeMetrics) {
        modelica += `    parameter Real conflictMass = ${belief.conflictMass};
`;
      }
      modelica += `  end ${bfId};

`;
    }
  }
  if (thought.combinedBelief && includeMetrics) {
    modelica += "  // Combined Belief\n";
    modelica += "  record CombinedBelief\n";
    modelica += '    "Result of combining all evidence"\n';
    if (thought.combinedBelief.massAssignments) {
      for (let i = 0; i < thought.combinedBelief.massAssignments.length; i++) {
        const ma = thought.combinedBelief.massAssignments[i];
        const hypSet = ma.hypothesisSet.map((h) => sanitizeModelicaId(h)).join("_");
        modelica += `    parameter Real mass_${hypSet} = ${ma.mass};
`;
      }
    }
    if (thought.combinedBelief.conflictMass !== void 0) {
      modelica += `    parameter Real conflictMass = ${thought.combinedBelief.conflictMass};
`;
    }
    modelica += "  end CombinedBelief;\n\n";
  }
  if (thought.frameOfDiscernment && thought.frameOfDiscernment.length > 0) {
    modelica += "  // Frame of Discernment\n";
    modelica += "  type Hypothesis = enumeration(\n";
    const hypEnums = thought.frameOfDiscernment.map((h) => `    ${sanitizeModelicaId(h)}`);
    modelica += hypEnums.join(",\n");
    modelica += "\n  );\n\n";
  }
  modelica += "end EvidentialBeliefs;\n";
  return modelica;
}
function evidentialToUML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  if (thought.evidence && thought.evidence.length > 0) {
    for (const evidence of thought.evidence) {
      const attributes = [
        `reliability: Real = ${evidence.reliability}`
      ];
      if (includeLabels) {
        attributes.unshift(`description: String = "${evidence.description.substring(0, 30)}${evidence.description.length > 30 ? "..." : ""}"`);
      }
      if (evidence.source) {
        attributes.push(`source: String = "${evidence.source}"`);
      }
      nodes.push({
        id: evidence.id,
        label: evidence.id,
        shape: "class",
        stereotype: "<<evidence>>",
        attributes
      });
    }
  }
  if (thought.beliefFunctions && thought.beliefFunctions.length > 0) {
    for (const belief of thought.beliefFunctions) {
      const attributes = [];
      if (includeMetrics && belief.massAssignments && belief.massAssignments.length > 0) {
        for (const ma of belief.massAssignments) {
          const hypSet = ma.hypothesisSet.join(", ");
          attributes.push(`m({${hypSet}}): Real = ${ma.mass.toFixed(3)}`);
        }
      }
      if (belief.conflictMass !== void 0 && includeMetrics) {
        attributes.push(`conflictMass: Real = ${belief.conflictMass.toFixed(3)}`);
      }
      nodes.push({
        id: belief.id,
        label: includeLabels ? `Belief from ${belief.source}` : belief.id,
        shape: "class",
        stereotype: "<<belief>>",
        attributes
      });
      if (thought.evidence && thought.evidence.length > 0) {
        const sourceEvidence = thought.evidence.find((e) => e.id === belief.source);
        if (sourceEvidence) {
          edges.push({
            source: sourceEvidence.id,
            target: belief.id,
            type: "association",
            label: includeMetrics ? `[${sourceEvidence.reliability.toFixed(3)}]` : "supports"
          });
        }
      }
    }
  }
  if (thought.combinedBelief && includeMetrics) {
    const attributes = [];
    if (thought.combinedBelief.massAssignments) {
      for (const ma of thought.combinedBelief.massAssignments) {
        const hypSet = ma.hypothesisSet.join(", ");
        attributes.push(`m({${hypSet}}): Real = ${ma.mass.toFixed(3)}`);
      }
    }
    if (thought.combinedBelief.conflictMass !== void 0) {
      attributes.push(`conflictMass: Real = ${thought.combinedBelief.conflictMass.toFixed(3)}`);
    }
    nodes.push({
      id: "combined_belief",
      label: "Combined Belief",
      shape: "class",
      stereotype: "<<conclusion>>",
      attributes
    });
    if (thought.beliefFunctions && thought.beliefFunctions.length > 0) {
      for (const belief of thought.beliefFunctions) {
        edges.push({
          source: belief.id,
          target: "combined_belief",
          type: "dependency",
          label: "combines"
        });
      }
    }
  }
  if (nodes.length === 0 && thought.frameOfDiscernment && thought.frameOfDiscernment.length > 0) {
    nodes.push({
      id: "frame",
      label: "Frame of Discernment",
      shape: "class",
      stereotype: "<<enumeration>>",
      attributes: thought.frameOfDiscernment.map((h) => `${sanitizeId(h)}`)
    });
  }
  return generateUmlDiagram(nodes, edges, {
    title: "Evidential Reasoning"});
}
function evidentialToJSON(thought, options) {
  const { includeMetrics = true } = options;
  const graph = createJsonGraph("evidential", "Evidential Beliefs");
  if (thought.evidence && thought.evidence.length > 0) {
    for (const evidence of thought.evidence) {
      addNode(graph, {
        id: evidence.id,
        label: evidence.description,
        type: "evidence",
        metadata: {
          reliability: evidence.reliability,
          source: evidence.source
        }
      });
    }
  }
  if (thought.beliefFunctions && thought.beliefFunctions.length > 0) {
    for (const belief of thought.beliefFunctions) {
      const metadata = {
        source: belief.source
      };
      if (includeMetrics && belief.massAssignments) {
        metadata.massAssignments = belief.massAssignments.map((ma) => ({
          hypothesisSet: ma.hypothesisSet,
          mass: ma.mass,
          justification: ma.justification
        }));
      }
      if (belief.conflictMass !== void 0) {
        metadata.conflictMass = belief.conflictMass;
      }
      addNode(graph, {
        id: belief.id,
        label: `Belief: ${belief.source}`,
        type: "belief",
        metadata
      });
      if (thought.evidence && thought.evidence.length > 0) {
        const sourceEvidence = thought.evidence.find((e) => e.id === belief.source);
        if (sourceEvidence) {
          addEdge(graph, {
            id: `edge_${sourceEvidence.id}_${belief.id}`,
            source: sourceEvidence.id,
            target: belief.id,
            label: "supports",
            weight: sourceEvidence.reliability,
            metadata: includeMetrics ? {
              reliability: sourceEvidence.reliability
            } : void 0
          });
        }
      }
    }
  }
  if (thought.combinedBelief) {
    const metadata = {};
    if (includeMetrics && thought.combinedBelief.massAssignments) {
      metadata.massAssignments = thought.combinedBelief.massAssignments.map((ma) => ({
        hypothesisSet: ma.hypothesisSet,
        mass: ma.mass,
        justification: ma.justification
      }));
    }
    if (thought.combinedBelief.conflictMass !== void 0) {
      metadata.conflictMass = thought.combinedBelief.conflictMass;
    }
    addNode(graph, {
      id: "combined_belief",
      label: "Combined Belief",
      type: "conclusion",
      metadata
    });
    if (thought.beliefFunctions && thought.beliefFunctions.length > 0) {
      for (const belief of thought.beliefFunctions) {
        addEdge(graph, {
          id: `edge_${belief.id}_combined`,
          source: belief.id,
          target: "combined_belief",
          label: "combines"
        });
      }
    }
  }
  if (graph.nodes.length === 0 && thought.frameOfDiscernment && thought.frameOfDiscernment.length > 0) {
    addNode(graph, {
      id: "frame",
      label: "Frame of Discernment",
      type: "frame",
      metadata: {
        hypotheses: thought.frameOfDiscernment
      }
    });
  }
  if (includeMetrics) {
    if (thought.frameOfDiscernment) {
      addMetric(graph, "hypotheses", thought.frameOfDiscernment.length);
    }
    if (thought.evidence) {
      addMetric(graph, "evidenceCount", thought.evidence.length);
    }
    if (thought.beliefFunctions) {
      addMetric(graph, "beliefFunctions", thought.beliefFunctions.length);
    }
    if (thought.combinedBelief) {
      addMetric(graph, "hasCombinedBelief", true);
    }
  }
  return serializeGraph(graph);
}
function evidentialToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  if (includeMetrics) {
    parts.push(section("Metrics", keyValueSection({
      "Hypotheses": thought.frameOfDiscernment?.length || 0,
      "Evidence Items": thought.evidence?.length || 0,
      "Belief Functions": thought.beliefFunctions?.length || 0
    })));
  }
  if (thought.frameOfDiscernment && thought.frameOfDiscernment.length > 0) {
    parts.push(section(
      "Frame of Discernment",
      list(thought.frameOfDiscernment)
    ));
  }
  if (thought.evidence && thought.evidence.length > 0) {
    const evRows = thought.evidence.map((ev) => [
      ev.id,
      ev.description,
      ev.reliability.toFixed(2),
      ev.source || "-"
    ]);
    parts.push(section("Evidence", table(
      ["ID", "Description", "Reliability", "Source"],
      evRows
    )));
  }
  if (thought.beliefFunctions && thought.beliefFunctions.length > 0) {
    const beliefContent = [];
    for (const bf of thought.beliefFunctions) {
      beliefContent.push(`**Source:** ${bf.source}
`);
      if (bf.conflictMass !== void 0) {
        beliefContent.push(`**Conflict Mass:** ${bf.conflictMass.toFixed(3)}
`);
      }
      const massRows = bf.massAssignments.map((ma) => [
        `{${ma.hypothesisSet.join(", ")}}`,
        ma.mass.toFixed(3),
        ma.justification
      ]);
      beliefContent.push(table(
        ["Hypothesis Set", "Mass", "Justification"],
        massRows
      ));
      beliefContent.push("\n");
    }
    parts.push(section("Belief Functions", beliefContent.join("")));
  }
  if (thought.combinedBelief) {
    const massRows = thought.combinedBelief.massAssignments.map((ma) => [
      `{${ma.hypothesisSet.join(", ")}}`,
      ma.mass.toFixed(3),
      ma.justification
    ]);
    let combinedContent = table(
      ["Hypothesis Set", "Mass", "Justification"],
      massRows
    );
    if (thought.combinedBelief.conflictMass !== void 0) {
      combinedContent += `
**Conflict Mass:** ${thought.combinedBelief.conflictMass.toFixed(3)}
`;
    }
    parts.push(section("Combined Belief", combinedContent));
  }
  if (markdownIncludeMermaid) {
    const mermaid = evidentialToMermaid(thought, "default", true, includeMetrics);
    parts.push(section("Visualization", mermaidBlock(mermaid)));
  }
  return document("Evidential Reasoning Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "evidential",
      hypotheses: thought.frameOfDiscernment?.length || 0
    }
  });
}
var init_evidential = __esm({
  "src/export/visual/evidential.ts"() {
    init_esm_shims();
    init_utils();
    init_svg_utils();
    init_graphml_utils();
    init_tikz_utils();
    init_html_utils();
    init_modelica_utils();
    init_uml_utils();
    init_json_utils();
    init_markdown_utils();
  }
});

// src/export/visual/first-principles.ts
function exportFirstPrinciplesDerivation(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return firstPrinciplesToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return firstPrinciplesToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return firstPrinciplesToASCII(thought);
    case "svg":
      return firstPrinciplesToSVG(thought, options);
    case "graphml":
      return firstPrinciplesToGraphML(thought, options);
    case "tikz":
      return firstPrinciplesToTikZ(thought, options);
    case "html":
      return firstPrinciplesToHTML(thought, options);
    case "modelica":
      return firstPrinciplesToModelica(thought, options);
    case "uml":
      return firstPrinciplesToUML(thought, options);
    case "json":
      return firstPrinciplesToJSON(thought, options);
    case "markdown":
      return firstPrinciplesToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function firstPrinciplesToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TD\n";
  mermaid += `  Q["Question: ${thought.question}"]
`;
  mermaid += "\n";
  for (const principle of thought.principles) {
    const principleId = sanitizeId(principle.id);
    const label = includeLabels ? `${principle.type.toUpperCase()}: ${principle.statement.substring(0, 50)}...` : principleId;
    let shape;
    switch (principle.type) {
      case "axiom":
        shape = ["([", "])"];
        break;
      case "definition":
        shape = ["[[", "]]"];
        break;
      case "observation":
        shape = ["[(", ")]"];
        break;
      case "logical_inference":
        shape = ["[", "]"];
        break;
      case "assumption":
        shape = ["{", "}"];
        break;
      default:
        shape = ["[", "]"];
    }
    mermaid += `  ${principleId}${shape[0]}${label}${shape[1]}
`;
    if (principle.dependsOn) {
      for (const depId of principle.dependsOn) {
        const sanitizedDepId = sanitizeId(depId);
        mermaid += `  ${sanitizedDepId} --> ${principleId}
`;
      }
    }
  }
  mermaid += "\n";
  for (const step of thought.derivationSteps) {
    const stepId = `Step${step.stepNumber}`;
    const principleId = sanitizeId(step.principle);
    const label = includeLabels ? `Step ${step.stepNumber}: ${step.inference.substring(0, 50)}...` : stepId;
    mermaid += `  ${stepId}["${label}"]
`;
    mermaid += `  ${principleId} -.->|applies| ${stepId}
`;
    if (includeMetrics && step.confidence !== void 0) {
      mermaid += `  ${stepId} -.->|conf: ${step.confidence.toFixed(2)}| ${stepId}
`;
    }
  }
  mermaid += "\n";
  const conclusionLabel = includeLabels ? `Conclusion: ${thought.conclusion.statement.substring(0, 50)}...` : "Conclusion";
  mermaid += `  C["${conclusionLabel}"]
`;
  for (const stepNum of thought.conclusion.derivationChain) {
    mermaid += `  Step${stepNum} --> C
`;
  }
  if (includeMetrics) {
    mermaid += `  C -.->|certainty: ${thought.conclusion.certainty.toFixed(2)}| C
`;
  }
  if (colorScheme !== "monochrome") {
    mermaid += "\n";
    const axiomColor = colorScheme === "pastel" ? "#e1f5ff" : "#a8d5ff";
    const definitionColor = colorScheme === "pastel" ? "#f3e5f5" : "#ce93d8";
    const observationColor = colorScheme === "pastel" ? "#fff3e0" : "#ffd699";
    const inferenceColor = colorScheme === "pastel" ? "#e8f5e9" : "#a5d6a7";
    const assumptionColor = colorScheme === "pastel" ? "#ffebee" : "#ef9a9a";
    for (const principle of thought.principles) {
      const principleId = sanitizeId(principle.id);
      let color = axiomColor;
      switch (principle.type) {
        case "axiom":
          color = axiomColor;
          break;
        case "definition":
          color = definitionColor;
          break;
        case "observation":
          color = observationColor;
          break;
        case "logical_inference":
          color = inferenceColor;
          break;
        case "assumption":
          color = assumptionColor;
          break;
      }
      mermaid += `  style ${principleId} fill:${color}
`;
    }
    const conclusionColor = colorScheme === "pastel" ? "#c8e6c9" : "#66bb6a";
    mermaid += `  style C fill:${conclusionColor}
`;
  }
  return mermaid;
}
function firstPrinciplesToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph FirstPrinciples {\n";
  dot += "  rankdir=TD;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  dot += `  Q [label="Question:\\n${thought.question}", shape=ellipse, style=bold];

`;
  for (const principle of thought.principles) {
    const principleId = sanitizeId(principle.id);
    const label = includeLabels ? `${principle.type.toUpperCase()}:\\n${principle.statement.substring(0, 60)}...` : principleId;
    let shape = "box";
    switch (principle.type) {
      case "axiom":
        shape = "ellipse";
        break;
      case "definition":
        shape = "box";
        break;
      case "observation":
        shape = "cylinder";
        break;
      case "logical_inference":
        shape = "box";
        break;
      case "assumption":
        shape = "diamond";
        break;
    }
    const confidenceLabel = includeMetrics && principle.confidence ? `\\nconf: ${principle.confidence.toFixed(2)}` : "";
    dot += `  ${principleId} [label="${label}${confidenceLabel}", shape=${shape}];
`;
    if (principle.dependsOn) {
      for (const depId of principle.dependsOn) {
        const sanitizedDepId = sanitizeId(depId);
        dot += `  ${sanitizedDepId} -> ${principleId};
`;
      }
    }
  }
  dot += "\n";
  for (const step of thought.derivationSteps) {
    const stepId = `Step${step.stepNumber}`;
    const principleId = sanitizeId(step.principle);
    const label = includeLabels ? `Step ${step.stepNumber}:\\n${step.inference.substring(0, 60)}...` : stepId;
    const confidenceLabel = includeMetrics ? `\\nconf: ${step.confidence.toFixed(2)}` : "";
    dot += `  ${stepId} [label="${label}${confidenceLabel}"];
`;
    dot += `  ${principleId} -> ${stepId} [style=dashed, label="applies"];
`;
  }
  dot += "\n";
  const conclusionLabel = includeLabels ? `Conclusion:\\n${thought.conclusion.statement.substring(0, 60)}...` : "Conclusion";
  const certaintyLabel = includeMetrics ? `\\ncertainty: ${thought.conclusion.certainty.toFixed(2)}` : "";
  dot += `  C [label="${conclusionLabel}${certaintyLabel}", shape=doubleoctagon, style=bold];
`;
  for (const stepNum of thought.conclusion.derivationChain) {
    dot += `  Step${stepNum} -> C;
`;
  }
  dot += "}\n";
  return dot;
}
function firstPrinciplesToASCII(thought) {
  let ascii = "First-Principles Derivation:\n";
  ascii += "============================\n\n";
  ascii += `Question: ${thought.question}

`;
  ascii += "Foundational Principles:\n";
  ascii += "------------------------\n";
  for (const principle of thought.principles) {
    ascii += `[${principle.id}] ${principle.type.toUpperCase()}
`;
    ascii += `  Statement: ${principle.statement}
`;
    ascii += `  Justification: ${principle.justification}
`;
    if (principle.dependsOn && principle.dependsOn.length > 0) {
      ascii += `  Depends on: ${principle.dependsOn.join(", ")}
`;
    }
    if (principle.confidence !== void 0) {
      ascii += `  Confidence: ${principle.confidence.toFixed(2)}
`;
    }
    ascii += "\n";
  }
  ascii += "Derivation Chain:\n";
  ascii += "----------------\n";
  for (const step of thought.derivationSteps) {
    ascii += `Step ${step.stepNumber} (using principle: ${step.principle})
`;
    ascii += `  Inference: ${step.inference}
`;
    if (step.logicalForm) {
      ascii += `  Logical form: ${step.logicalForm}
`;
    }
    ascii += `  Confidence: ${step.confidence.toFixed(2)}
`;
    ascii += "\n";
  }
  ascii += "Conclusion:\n";
  ascii += "----------\n";
  ascii += `${thought.conclusion.statement}
`;
  ascii += `Derivation chain: Steps [${thought.conclusion.derivationChain.join(", ")}]
`;
  ascii += `Certainty: ${thought.conclusion.certainty.toFixed(2)}
`;
  if (thought.conclusion.limitations && thought.conclusion.limitations.length > 0) {
    ascii += "\nLimitations:\n";
    for (const limitation of thought.conclusion.limitations) {
      ascii += `  - ${limitation}
`;
    }
  }
  if (thought.alternativeInterpretations && thought.alternativeInterpretations.length > 0) {
    ascii += "\nAlternative Interpretations:\n";
    for (const alt of thought.alternativeInterpretations) {
      ascii += `  - ${alt}
`;
    }
  }
  return ascii;
}
function firstPrinciplesToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width
  } = options;
  const positions = /* @__PURE__ */ new Map();
  const nodeWidth = 150;
  const nodeHeight = 40;
  const principleY = 100;
  const principleSpacing = Math.min(180, svgWidth / (thought.principles.length + 1));
  const principleStartX = (svgWidth - (thought.principles.length - 1) * principleSpacing) / 2;
  thought.principles.forEach((p, index) => {
    positions.set(p.id, {
      id: p.id,
      label: includeLabels ? `${p.type}: ${p.statement.substring(0, 30)}...` : p.id,
      x: principleStartX + index * principleSpacing,
      y: principleY,
      width: nodeWidth,
      height: nodeHeight,
      type: p.type
    });
  });
  const stepY = 250;
  thought.derivationSteps.forEach((step, index) => {
    const stepId = `Step${step.stepNumber}`;
    positions.set(stepId, {
      id: stepId,
      label: includeLabels ? `Step ${step.stepNumber}` : stepId,
      x: 150 + index * 200,
      y: stepY,
      width: nodeWidth,
      height: nodeHeight,
      type: "step"
    });
  });
  positions.set("conclusion", {
    id: "conclusion",
    label: includeLabels ? `Conclusion: ${thought.conclusion.statement.substring(0, 30)}...` : "Conclusion",
    x: svgWidth / 2,
    y: stepY + 150,
    width: nodeWidth,
    height: nodeHeight,
    type: "conclusion"
  });
  const actualHeight = calculateSVGHeight(positions);
  let svg = generateSVGHeader(svgWidth, actualHeight, "First Principles Derivation");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  for (const step of thought.derivationSteps) {
    const principlePos = positions.get(step.principle);
    const stepPos = positions.get(`Step${step.stepNumber}`);
    if (principlePos && stepPos) {
      svg += renderEdge(principlePos, stepPos, { style: "dashed", label: "applies" });
    }
  }
  const conclusionPos = positions.get("conclusion");
  for (const stepNum of thought.conclusion.derivationChain) {
    const stepPos = positions.get(`Step${stepNum}`);
    if (stepPos) {
      svg += renderEdge(stepPos, conclusionPos);
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  const axiomColors = getNodeColor("primary", colorScheme);
  const stepColors = getNodeColor("neutral", colorScheme);
  const conclusionColors = getNodeColor("success", colorScheme);
  for (const [id, pos] of positions) {
    if (id === "conclusion") {
      svg += renderStadiumNode(pos, conclusionColors);
    } else if (id.startsWith("Step")) {
      svg += renderRectNode(pos, stepColors);
    } else {
      svg += renderEllipseNode(pos, axiomColors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Principles", value: thought.principles.length },
      { label: "Steps", value: thought.derivationSteps.length },
      { label: "Certainty", value: thought.conclusion.certainty.toFixed(2) }
    ];
    svg += renderMetricsPanel(svgWidth - 180, actualHeight - 110, metrics);
  }
  const legendItems = [
    { label: "Principle", color: axiomColors, shape: "ellipse" },
    { label: "Derivation Step", color: stepColors },
    { label: "Conclusion", color: conclusionColors, shape: "stadium" }
  ];
  svg += renderLegend(20, actualHeight - 100, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function firstPrinciplesToGraphML(thought, options) {
  const { includeLabels = true } = options;
  const nodes = [];
  const edges = [];
  let edgeCount = 0;
  nodes.push({
    id: "question",
    label: includeLabels ? `Question: ${thought.question}` : "Question",
    type: "question"
  });
  for (const principle of thought.principles) {
    const principleId = sanitizeId(principle.id);
    nodes.push({
      id: principleId,
      label: includeLabels ? `${principle.type.toUpperCase()}: ${principle.statement.substring(0, 60)}...` : principleId,
      type: principle.type,
      metadata: {
        justification: principle.justification,
        confidence: principle.confidence
      }
    });
    if (principle.dependsOn) {
      for (const depId of principle.dependsOn) {
        const sanitizedDepId = sanitizeId(depId);
        edges.push({
          id: `e${edgeCount++}`,
          source: sanitizedDepId,
          target: principleId,
          label: "depends on",
          directed: true
        });
      }
    }
  }
  for (const step of thought.derivationSteps) {
    const stepId = `Step${step.stepNumber}`;
    nodes.push({
      id: stepId,
      label: includeLabels ? `Step ${step.stepNumber}: ${step.inference.substring(0, 60)}...` : stepId,
      type: "derivation_step",
      metadata: {
        logicalForm: step.logicalForm,
        confidence: step.confidence
      }
    });
    const principleId = sanitizeId(step.principle);
    edges.push({
      id: `e${edgeCount++}`,
      source: principleId,
      target: stepId,
      label: "applies",
      directed: true
    });
  }
  nodes.push({
    id: "conclusion",
    label: includeLabels ? `Conclusion: ${thought.conclusion.statement.substring(0, 60)}...` : "Conclusion",
    type: "conclusion",
    metadata: {
      certainty: thought.conclusion.certainty,
      limitations: thought.conclusion.limitations
    }
  });
  for (const stepNum of thought.conclusion.derivationChain) {
    edges.push({
      id: `e${edgeCount++}`,
      source: `Step${stepNum}`,
      target: "conclusion",
      directed: true
    });
  }
  return generateGraphML(nodes, edges, {
    graphName: "First Principles Derivation",
    directed: true,
    includeLabels
  });
}
function firstPrinciplesToTikZ(thought, options) {
  const { includeLabels = true, colorScheme = "default" } = options;
  const nodes = [];
  const edges = [];
  const principleCount = thought.principles.length;
  thought.principles.forEach((principle, index) => {
    const principleId = sanitizeId(principle.id);
    nodes.push({
      id: principleId,
      label: includeLabels ? `${principle.type}: ${principle.statement.substring(0, 25)}...` : principleId,
      x: index * 3,
      y: 0,
      type: principle.type === "axiom" ? "primary" : "secondary",
      shape: "stadium"
    });
    if (principle.dependsOn) {
      for (const depId of principle.dependsOn) {
        const sanitizedDepId = sanitizeId(depId);
        edges.push({
          source: sanitizedDepId,
          target: principleId,
          directed: true,
          style: "dashed"
        });
      }
    }
  });
  const stepY = -2;
  thought.derivationSteps.forEach((step, index) => {
    const stepId = `Step${step.stepNumber}`;
    const principleId = sanitizeId(step.principle);
    nodes.push({
      id: stepId,
      label: includeLabels ? `Step ${step.stepNumber}` : stepId,
      x: index * 3,
      y: stepY,
      type: "neutral",
      shape: "rectangle"
    });
    edges.push({
      source: principleId,
      target: stepId,
      label: "applies",
      directed: true,
      style: "dashed"
    });
  });
  const conclusionX = (principleCount - 1) * 3 / 2;
  nodes.push({
    id: "conclusion",
    label: includeLabels ? "Conclusion" : "C",
    x: conclusionX,
    y: -4,
    type: "success",
    shape: "stadium"
  });
  for (const stepNum of thought.conclusion.derivationChain) {
    edges.push({
      source: `Step${stepNum}`,
      target: "conclusion",
      directed: true
    });
  }
  return generateTikZ(nodes, edges, {
    title: "First Principles Derivation",
    colorScheme,
    includeLabels
  });
}
function firstPrinciplesToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "First Principles Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  html += renderSection("Question", `<p class="text-primary"><strong>${escapeHTML(thought.question)}</strong></p>`, "\u2753");
  if (includeMetrics) {
    html += '<div class="metrics-grid">';
    html += renderMetricCard("Principles", thought.principles.length, "primary");
    html += renderMetricCard("Derivation Steps", thought.derivationSteps.length, "info");
    html += renderMetricCard("Certainty", (thought.conclusion.certainty * 100).toFixed(0) + "%", "success");
    html += "</div>\n";
  }
  const principleRows = thought.principles.map((p) => {
    const typeBadge = renderBadge(p.type, p.type === "axiom" ? "primary" : p.type === "observation" ? "info" : "secondary");
    return [
      p.id,
      typeBadge,
      p.statement,
      p.confidence !== void 0 ? (p.confidence * 100).toFixed(0) + "%" : "N/A"
    ];
  });
  html += renderSection("First Principles", renderTable(
    ["ID", "Type", "Statement", "Confidence"],
    principleRows.map((row) => row.map((cell) => typeof cell === "string" && cell.startsWith("<") ? cell : escapeHTML(String(cell))))
  ), "\u{1F3DB}\uFE0F");
  const stepRows = thought.derivationSteps.map((s) => [
    s.stepNumber.toString(),
    s.principle,
    s.inference,
    s.logicalForm || "-"
  ]);
  html += renderSection("Derivation Chain", renderTable(
    ["Step", "Principle", "Inference", "Logical Form"],
    stepRows
  ), "\u{1F517}");
  html += renderSection("Conclusion", `
    <div class="card">
      <div class="card-header">${escapeHTML(thought.conclusion.statement)}</div>
      <p><strong>Certainty:</strong> ${(thought.conclusion.certainty * 100).toFixed(0)}%</p>
      <p><strong>Derivation Chain:</strong> Steps ${thought.conclusion.derivationChain.join(" \u2192 ")}</p>
      ${thought.conclusion.limitations && thought.conclusion.limitations.length > 0 ? `
        <p><strong>Limitations:</strong></p>
        ${renderList(thought.conclusion.limitations)}
      ` : ""}
    </div>
  `, "\u2713");
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function firstPrinciplesToModelica(thought, options) {
  const { includeMetrics = true } = options;
  const packageName = "FirstPrinciplesDerivation";
  let modelica = generateModelicaPackageHeader(
    packageName,
    `First principles derivation: ${thought.question}`
  );
  modelica += "  // Fundamental Principles\n";
  for (const principle of thought.principles) {
    const fields = [
      { name: "id", type: "String", value: `"${escapeModelicaString(principle.id)}"` },
      { name: "principleType", type: "String", value: `"${escapeModelicaString(principle.type)}"` },
      { name: "statement", type: "String", value: `"${escapeModelicaString(principle.statement)}"` },
      { name: "justification", type: "String", value: `"${escapeModelicaString(principle.justification)}"` }
    ];
    if (includeMetrics && principle.confidence !== void 0) {
      fields.push({
        name: "confidence",
        type: "Real",
        value: principle.confidence.toFixed(3),
        description: "Confidence level in this principle"
      });
    }
    modelica += generateModelicaRecord(
      sanitizeModelicaId(principle.id),
      `${principle.type}: ${principle.statement.substring(0, 60)}`,
      fields
    );
  }
  modelica += "  // Derivation Process\n";
  modelica += "  model Derivation\n";
  modelica += `    "Derivation chain from principles to conclusion"
`;
  modelica += "\n";
  modelica += "    // Principle instances\n";
  for (const principle of thought.principles) {
    const safeId = sanitizeModelicaId(principle.id);
    modelica += `    ${safeId} ${safeId}_instance;
`;
  }
  modelica += "\n";
  modelica += "    // Derivation steps\n";
  for (const step of thought.derivationSteps) {
    const stepId = `step_${step.stepNumber}`;
    modelica += `    parameter String ${stepId}_principle = "${escapeModelicaString(step.principle)}";
`;
    modelica += `    parameter String ${stepId}_inference = "${escapeModelicaString(step.inference)}";
`;
    if (step.logicalForm) {
      modelica += `    parameter String ${stepId}_logicalForm = "${escapeModelicaString(step.logicalForm)}";
`;
    }
    if (includeMetrics) {
      modelica += `    parameter Real ${stepId}_confidence = ${step.confidence.toFixed(3)};
`;
    }
  }
  modelica += "\n";
  modelica += "    // Conclusion\n";
  modelica += `    parameter String conclusion = "${escapeModelicaString(thought.conclusion.statement)}";
`;
  if (includeMetrics) {
    modelica += `    parameter Real certainty = ${thought.conclusion.certainty.toFixed(3)};
`;
  }
  modelica += `    parameter Integer derivationChainLength = ${thought.conclusion.derivationChain.length};
`;
  modelica += "\n";
  modelica += "    annotation(\n";
  modelica += '      Documentation(info="<html>\n';
  modelica += `        <h3>Question</h3>
`;
  modelica += `        <p>${escapeModelicaString(thought.question)}</p>
`;
  modelica += `        <h3>Principles</h3>
`;
  modelica += `        <p>Count: ${thought.principles.length}</p>
`;
  modelica += `        <h3>Derivation Steps</h3>
`;
  modelica += `        <p>Count: ${thought.derivationSteps.length}</p>
`;
  modelica += `        <h3>Conclusion</h3>
`;
  modelica += `        <p>${escapeModelicaString(thought.conclusion.statement)}</p>
`;
  if (includeMetrics) {
    modelica += `        <p>Certainty: ${(thought.conclusion.certainty * 100).toFixed(1)}%</p>
`;
  }
  modelica += '      </html>")\n';
  modelica += "    );\n";
  modelica += "  end Derivation;\n";
  modelica += "\n";
  modelica += generateModelicaPackageFooter(packageName, { includeAnnotations: true, version: "7.1.0" });
  return modelica;
}
function firstPrinciplesToUML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  for (const principle of thought.principles) {
    const attributes = [
      `type: ${principle.type}`,
      `statement: "${principle.statement.substring(0, 40)}..."`,
      `justification: "${principle.justification.substring(0, 40)}..."`
    ];
    if (includeMetrics && principle.confidence !== void 0) {
      attributes.push(`confidence: ${principle.confidence.toFixed(2)}`);
    }
    nodes.push({
      id: sanitizeUmlId(principle.id),
      label: includeLabels ? principle.id : sanitizeUmlId(principle.id),
      shape: principle.type === "axiom" ? "class" : "rectangle",
      stereotype: principle.type,
      attributes
    });
    if (principle.dependsOn && principle.dependsOn.length > 0) {
      for (const depId of principle.dependsOn) {
        edges.push({
          source: sanitizeUmlId(depId),
          target: sanitizeUmlId(principle.id),
          type: "dependency",
          label: "depends on"
        });
      }
    }
  }
  for (const step of thought.derivationSteps) {
    const stepId = `Step${step.stepNumber}`;
    const attributes = [
      `inference: "${step.inference.substring(0, 40)}..."`
    ];
    if (step.logicalForm) {
      attributes.push(`logicalForm: "${step.logicalForm.substring(0, 30)}..."`);
    }
    if (includeMetrics) {
      attributes.push(`confidence: ${step.confidence.toFixed(2)}`);
    }
    nodes.push({
      id: stepId,
      label: includeLabels ? `Step ${step.stepNumber}` : stepId,
      shape: "component",
      attributes
    });
    edges.push({
      source: sanitizeUmlId(step.principle),
      target: stepId,
      type: "dashed",
      label: "applies"
    });
  }
  const conclusionAttributes = [
    `statement: "${thought.conclusion.statement.substring(0, 40)}..."`,
    `derivationChain: [${thought.conclusion.derivationChain.join(", ")}]`
  ];
  if (includeMetrics) {
    conclusionAttributes.push(`certainty: ${thought.conclusion.certainty.toFixed(2)}`);
  }
  if (thought.conclusion.limitations && thought.conclusion.limitations.length > 0) {
    conclusionAttributes.push(`limitations: ${thought.conclusion.limitations.length} items`);
  }
  nodes.push({
    id: "Conclusion",
    label: "Conclusion",
    shape: "class",
    stereotype: "conclusion",
    attributes: conclusionAttributes
  });
  for (const stepNum of thought.conclusion.derivationChain) {
    edges.push({
      source: `Step${stepNum}`,
      target: "Conclusion",
      type: "arrow"
    });
  }
  let uml = generateUmlHeader({
    title: "First Principles Derivation",
    direction: "top to bottom"
  });
  uml += `' Question: ${escapeUml(thought.question)}

`;
  uml += "' Principles\n";
  for (const node of nodes.filter((n) => !n.id.startsWith("Step") && n.id !== "Conclusion")) {
    uml += renderUmlNode(node) + "\n";
  }
  uml += "\n' Derivation Steps\n";
  for (const node of nodes.filter((n) => n.id.startsWith("Step"))) {
    uml += renderUmlNode(node) + "\n";
  }
  uml += "\n' Conclusion\n";
  const conclusionNode = nodes.find((n) => n.id === "Conclusion");
  if (conclusionNode) {
    uml += renderUmlNode(conclusionNode) + "\n";
  }
  uml += "\n' Relationships\n";
  for (const edge of edges) {
    uml += renderUmlEdge(edge) + "\n";
  }
  uml += "\n" + generateUmlFooter();
  return uml;
}
function firstPrinciplesToJSON(thought, options) {
  const { includeMetrics = true, includeLabels = true } = options;
  const graph = createJsonGraph(
    "First Principles Derivation",
    "first-principles",
    { includeMetrics, includeLayout: true, includeLegend: true }
  );
  if (graph.layout) {
    graph.layout.type = "hierarchical";
    graph.layout.direction = "TB";
  }
  graph.metadata.question = thought.question;
  const principleSpacing = 150;
  const principleStartX = -((thought.principles.length - 1) * principleSpacing) / 2;
  for (let i = 0; i < thought.principles.length; i++) {
    const principle = thought.principles[i];
    const principleId = sanitizeId(principle.id);
    let color = "#e0e0e0";
    switch (principle.type) {
      case "axiom":
        color = "#a8d5ff";
        break;
      case "definition":
        color = "#ce93d8";
        break;
      case "observation":
        color = "#ffd699";
        break;
      case "logical_inference":
        color = "#a5d6a7";
        break;
      case "assumption":
        color = "#ef9a9a";
        break;
    }
    addNode(graph, {
      id: principleId,
      label: includeLabels ? `${principle.type}: ${principle.statement.substring(0, 30)}...` : principleId,
      type: principle.type,
      x: principleStartX + i * principleSpacing,
      y: 0,
      width: 140,
      height: 60,
      color,
      shape: principle.type === "axiom" ? "ellipse" : "rectangle",
      metadata: {
        statement: principle.statement,
        justification: principle.justification,
        confidence: principle.confidence,
        dependsOn: principle.dependsOn
      }
    });
    if (principle.dependsOn && principle.dependsOn.length > 0) {
      for (const depId of principle.dependsOn) {
        addEdge(graph, {
          id: `edge_${sanitizeId(depId)}_${principleId}`,
          source: sanitizeId(depId),
          target: principleId,
          label: "depends on",
          directed: true,
          style: "dashed"
        });
      }
    }
  }
  const stepY = 150;
  const stepSpacing = 200;
  const stepStartX = -((thought.derivationSteps.length - 1) * stepSpacing) / 2;
  for (let i = 0; i < thought.derivationSteps.length; i++) {
    const step = thought.derivationSteps[i];
    const stepId = `step_${step.stepNumber}`;
    addNode(graph, {
      id: stepId,
      label: includeLabels ? `Step ${step.stepNumber}: ${step.inference.substring(0, 30)}...` : `Step ${step.stepNumber}`,
      type: "derivation_step",
      x: stepStartX + i * stepSpacing,
      y: stepY,
      width: 180,
      height: 50,
      color: "#81c784",
      shape: "rectangle",
      metadata: {
        inference: step.inference,
        logicalForm: step.logicalForm,
        confidence: step.confidence,
        principle: step.principle
      }
    });
    addEdge(graph, {
      id: `edge_${sanitizeId(step.principle)}_${stepId}`,
      source: sanitizeId(step.principle),
      target: stepId,
      label: "applies",
      directed: true,
      style: "dashed"
    });
  }
  addNode(graph, {
    id: "conclusion",
    label: includeLabels ? `Conclusion: ${thought.conclusion.statement.substring(0, 40)}...` : "Conclusion",
    type: "conclusion",
    x: 0,
    y: stepY + 150,
    width: 200,
    height: 60,
    color: "#66bb6a",
    shape: "stadium",
    metadata: {
      statement: thought.conclusion.statement,
      certainty: thought.conclusion.certainty,
      derivationChain: thought.conclusion.derivationChain,
      limitations: thought.conclusion.limitations
    }
  });
  for (const stepNum of thought.conclusion.derivationChain) {
    addEdge(graph, {
      id: `edge_step${stepNum}_conclusion`,
      source: `step_${stepNum}`,
      target: "conclusion",
      directed: true,
      style: "solid"
    });
  }
  if (includeMetrics && graph.metrics) {
    addMetric(graph, "principleCount", thought.principles.length);
    addMetric(graph, "derivationStepCount", thought.derivationSteps.length);
    addMetric(graph, "certainty", thought.conclusion.certainty);
    addMetric(graph, "axiomCount", thought.principles.filter((p) => p.type === "axiom").length);
    addMetric(graph, "definitionCount", thought.principles.filter((p) => p.type === "definition").length);
    addMetric(graph, "observationCount", thought.principles.filter((p) => p.type === "observation").length);
  }
  if (graph.legend) {
    addLegendItem(graph, "Axiom", "#a8d5ff", "ellipse");
    addLegendItem(graph, "Definition", "#ce93d8", "rectangle");
    addLegendItem(graph, "Observation", "#ffd699", "rectangle");
    addLegendItem(graph, "Logical Inference", "#a5d6a7", "rectangle");
    addLegendItem(graph, "Assumption", "#ef9a9a", "rectangle");
    addLegendItem(graph, "Derivation Step", "#81c784", "rectangle");
    addLegendItem(graph, "Conclusion", "#66bb6a", "stadium");
  }
  return serializeGraph(graph, { prettyPrint: true, indent: 2 });
}
function firstPrinciplesToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  parts.push(section("Question", thought.question));
  if (includeMetrics) {
    parts.push(section("Metrics", keyValueSection({
      "Principles": thought.principles.length,
      "Derivation Steps": thought.derivationSteps.length,
      "Certainty": (thought.conclusion.certainty * 100).toFixed(0) + "%",
      "Axioms": thought.principles.filter((p) => p.type === "axiom").length,
      "Definitions": thought.principles.filter((p) => p.type === "definition").length,
      "Observations": thought.principles.filter((p) => p.type === "observation").length
    })));
  }
  const principleRows = thought.principles.map((p) => [
    p.id,
    p.type,
    p.statement.substring(0, 60) + (p.statement.length > 60 ? "..." : ""),
    p.dependsOn?.join(", ") || "-",
    p.confidence !== void 0 ? (p.confidence * 100).toFixed(0) + "%" : "N/A"
  ]);
  parts.push(section("Foundational Principles", table(
    ["ID", "Type", "Statement", "Depends On", "Confidence"],
    principleRows
  )));
  const stepRows = thought.derivationSteps.map((s) => [
    s.stepNumber.toString(),
    s.principle,
    s.inference.substring(0, 60) + (s.inference.length > 60 ? "..." : ""),
    s.logicalForm || "-",
    (s.confidence * 100).toFixed(0) + "%"
  ]);
  parts.push(section("Derivation Chain", table(
    ["Step", "Principle", "Inference", "Logical Form", "Confidence"],
    stepRows
  )));
  let conclusionContent = `**Statement:** ${thought.conclusion.statement}

`;
  conclusionContent += `**Certainty:** ${(thought.conclusion.certainty * 100).toFixed(0)}%

`;
  conclusionContent += `**Derivation Chain:** Steps ${thought.conclusion.derivationChain.join(" \u2192 ")}
`;
  if (thought.conclusion.limitations && thought.conclusion.limitations.length > 0) {
    conclusionContent += `
**Limitations:**
${list(thought.conclusion.limitations)}`;
  }
  parts.push(section("Conclusion", conclusionContent));
  if (thought.alternativeInterpretations && thought.alternativeInterpretations.length > 0) {
    parts.push(section("Alternative Interpretations", list(thought.alternativeInterpretations)));
  }
  if (markdownIncludeMermaid) {
    const mermaid = firstPrinciplesToMermaid(thought, "default", true, includeMetrics);
    parts.push(section("Visualization", mermaidBlock(mermaid)));
  }
  return document("First Principles Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "first-principles",
      principles: thought.principles.length,
      certainty: thought.conclusion.certainty.toFixed(2)
    }
  });
}
var init_first_principles = __esm({
  "src/export/visual/first-principles.ts"() {
    init_esm_shims();
    init_utils();
    init_svg_utils();
    init_graphml_utils();
    init_tikz_utils();
    init_html_utils();
    init_modelica_utils();
    init_uml_utils();
    init_json_utils();
    init_markdown_utils();
  }
});

// src/export/visual/systems-thinking.ts
function exportSystemsThinkingCausalLoops(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return systemsThinkingToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return systemsThinkingToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return systemsThinkingToASCII(thought);
    case "svg":
      return systemsThinkingToSVG(thought, options);
    case "graphml":
      return systemsThinkingToGraphML(thought, options);
    case "tikz":
      return systemsThinkingToTikZ(thought, options);
    case "html":
      return systemsThinkingToHTML(thought, options);
    case "modelica":
      return systemsThinkingToModelica(thought, options);
    case "uml":
      return systemsThinkingToUML(thought, options);
    case "json":
      return systemsThinkingToJSON(thought, options);
    case "markdown":
      return systemsThinkingToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function systemsThinkingToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TB\n";
  if (thought.system) {
    mermaid += `  System["${thought.system.name}"]

`;
  }
  if (thought.components && thought.components.length > 0) {
    for (const component of thought.components) {
      const compId = sanitizeId(component.id);
      const label = includeLabels ? component.name : compId;
      const shape = component.type === "stock" ? ["[[", "]]"] : ["[", "]"];
      mermaid += `  ${compId}${shape[0]}${label}${shape[1]}
`;
    }
    mermaid += "\n";
  }
  if (thought.feedbackLoops && thought.feedbackLoops.length > 0) {
    for (const loop of thought.feedbackLoops) {
      const loopComponents = loop.components;
      for (let i = 0; i < loopComponents.length; i++) {
        const fromId = sanitizeId(loopComponents[i]);
        const toId = sanitizeId(loopComponents[(i + 1) % loopComponents.length]);
        const edgeLabel = includeMetrics ? `|${loop.type} (${loop.strength.toFixed(2)})| ` : `|${loop.type}| `;
        const edgeStyle = loop.type === "reinforcing" ? "-->" : "-..->";
        mermaid += `  ${fromId} ${edgeStyle}${edgeLabel}${toId}
`;
      }
    }
    mermaid += "\n";
  }
  if (colorScheme !== "monochrome" && thought.components) {
    const stockColor = colorScheme === "pastel" ? "#e1f5ff" : "#a8d5ff";
    const flowColor = colorScheme === "pastel" ? "#fff3e0" : "#ffd699";
    for (const component of thought.components) {
      const compId = sanitizeId(component.id);
      const color = component.type === "stock" ? stockColor : flowColor;
      mermaid += `  style ${compId} fill:${color}
`;
    }
  }
  return mermaid;
}
function systemsThinkingToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph SystemsThinking {\n";
  dot += "  rankdir=TB;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  if (thought.components && thought.components.length > 0) {
    for (const component of thought.components) {
      const compId = sanitizeId(component.id);
      const label = includeLabels ? component.name : compId;
      const shape = component.type === "stock" ? "box" : "ellipse";
      dot += `  ${compId} [label="${label}", shape=${shape}];
`;
    }
    dot += "\n";
  }
  if (thought.feedbackLoops && thought.feedbackLoops.length > 0) {
    for (const loop of thought.feedbackLoops) {
      const loopComponents = loop.components;
      for (let i = 0; i < loopComponents.length; i++) {
        const fromId = sanitizeId(loopComponents[i]);
        const toId = sanitizeId(loopComponents[(i + 1) % loopComponents.length]);
        const edgeLabel = includeMetrics ? `, label="${loop.type} (${loop.strength.toFixed(2)})"` : `, label="${loop.type}"`;
        const edgeStyle = loop.type === "reinforcing" ? "solid" : "dashed";
        dot += `  ${fromId} -> ${toId} [style=${edgeStyle}${edgeLabel}];
`;
      }
    }
  }
  dot += "}\n";
  return dot;
}
function systemsThinkingToASCII(thought) {
  let ascii = "Systems Thinking Model:\n";
  ascii += "======================\n\n";
  if (thought.system) {
    ascii += `System: ${thought.system.name}
`;
    ascii += `${thought.system.description}

`;
  }
  if (thought.components && thought.components.length > 0) {
    ascii += "Components:\n";
    for (const component of thought.components) {
      const typeIcon = component.type === "stock" ? "[\u25A0]" : "(\u25CB)";
      ascii += `  ${typeIcon} ${component.name}: ${component.description}
`;
    }
    ascii += "\n";
  }
  if (thought.feedbackLoops && thought.feedbackLoops.length > 0) {
    ascii += "Feedback Loops:\n";
    for (const loop of thought.feedbackLoops) {
      const loopIcon = loop.type === "reinforcing" ? "\u2295" : "\u2296";
      ascii += `  ${loopIcon} ${loop.name} (${loop.type})
`;
      ascii += `    Strength: ${loop.strength.toFixed(2)}
`;
      ascii += `    Components: ${loop.components.join(" \u2192 ")}
`;
    }
    ascii += "\n";
  }
  if (thought.leveragePoints && thought.leveragePoints.length > 0) {
    ascii += "Leverage Points:\n";
    for (const point of thought.leveragePoints) {
      ascii += `  \u2605 ${point.location} (effectiveness: ${point.effectiveness.toFixed(2)})
`;
      ascii += `    ${point.description}
`;
    }
  }
  return ascii;
}
function systemsThinkingToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width,
    svgHeight = DEFAULT_SVG_OPTIONS.height
  } = options;
  if (!thought.components || thought.components.length === 0) {
    return generateSVGHeader(svgWidth, 200, "Systems Thinking") + '\n  <text x="400" y="100" text-anchor="middle" class="subtitle">No system components defined</text>\n' + generateSVGFooter();
  }
  const positions = /* @__PURE__ */ new Map();
  const nodeWidth = 150;
  const nodeHeight = 40;
  const centerX = svgWidth / 2;
  const centerY = svgHeight / 2;
  const radius = Math.min(centerX, centerY) - 100;
  thought.components.forEach((component, index) => {
    const angle = 2 * Math.PI * index / (thought.components?.length || 1);
    const x = centerX + radius * Math.cos(angle - Math.PI / 2);
    const y = centerY + radius * Math.sin(angle - Math.PI / 2);
    positions.set(component.id, {
      id: component.id,
      label: includeLabels ? component.name : component.id,
      x,
      y,
      width: nodeWidth,
      height: nodeHeight,
      type: component.type
    });
  });
  let svg = generateSVGHeader(svgWidth, svgHeight, "Systems Thinking Model");
  svg += '\n  <!-- Feedback Loops -->\n  <g class="edges">';
  if (thought.feedbackLoops) {
    for (const loop of thought.feedbackLoops) {
      for (let i = 0; i < loop.components.length; i++) {
        const fromId = loop.components[i];
        const toId = loop.components[(i + 1) % loop.components.length];
        const fromPos = positions.get(fromId);
        const toPos = positions.get(toId);
        if (fromPos && toPos) {
          const label = includeMetrics ? `${loop.type[0].toUpperCase()} (${loop.strength.toFixed(1)})` : void 0;
          const style = loop.type === "reinforcing" ? "solid" : "dashed";
          svg += renderEdge(fromPos, toPos, { label, style });
        }
      }
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Components -->\n  <g class="nodes">';
  const stockColors = getNodeColor("primary", colorScheme);
  const flowColors = getNodeColor("secondary", colorScheme);
  for (const [, pos] of positions) {
    if (pos.type === "stock") {
      svg += renderRectNode(pos, stockColors);
    } else {
      svg += renderEllipseNode(pos, flowColors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Components", value: thought.components.length },
      { label: "Feedback Loops", value: thought.feedbackLoops?.length || 0 },
      { label: "Leverage Points", value: thought.leveragePoints?.length || 0 }
    ];
    svg += renderMetricsPanel(svgWidth - 180, svgHeight - 110, metrics);
  }
  const legendItems = [
    { label: "Stock", color: stockColors },
    { label: "Flow", color: flowColors, shape: "ellipse" }
  ];
  svg += renderLegend(20, svgHeight - 80, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function systemsThinkingToGraphML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  if (thought.components && thought.components.length > 0) {
    for (const component of thought.components) {
      nodes.push({
        id: sanitizeId(component.id),
        label: component.name,
        type: component.type,
        metadata: {
          description: component.description,
          unit: component.unit,
          initialValue: component.initialValue
        }
      });
    }
  }
  if (thought.feedbackLoops && thought.feedbackLoops.length > 0) {
    let edgeCount = 0;
    for (const loop of thought.feedbackLoops) {
      const loopComponents = loop.components;
      for (let i = 0; i < loopComponents.length; i++) {
        const fromId = sanitizeId(loopComponents[i]);
        const toId = sanitizeId(loopComponents[(i + 1) % loopComponents.length]);
        const label = includeLabels && includeMetrics ? `${loop.type} (${loop.strength.toFixed(2)})` : includeLabels ? loop.type : void 0;
        edges.push({
          id: `e${edgeCount++}`,
          source: fromId,
          target: toId,
          label,
          directed: true,
          metadata: {
            type: loop.type,
            weight: loop.strength,
            polarity: loop.polarity,
            loopName: loop.name
          }
        });
      }
    }
  }
  return generateGraphML(nodes, edges, {
    graphName: "Systems Thinking Causal Loops",
    directed: true,
    includeLabels,
    includeMetadata: includeMetrics
  });
}
function systemsThinkingToTikZ(thought, options) {
  const { colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  if (thought.components && thought.components.length > 0) {
    const numComponents = thought.components.length;
    const radius = 4;
    thought.components.forEach((component, index) => {
      const angle = 2 * Math.PI * index / numComponents;
      const x = 4 + radius * Math.cos(angle - Math.PI / 2);
      const y = -2 + radius * Math.sin(angle - Math.PI / 2);
      nodes.push({
        id: sanitizeId(component.id),
        label: component.name,
        x,
        y,
        type: component.type === "stock" ? "primary" : "secondary",
        shape: component.type === "stock" ? "rectangle" : "ellipse"
      });
    });
  }
  if (thought.feedbackLoops && thought.feedbackLoops.length > 0) {
    for (const loop of thought.feedbackLoops) {
      const loopComponents = loop.components;
      for (let i = 0; i < loopComponents.length; i++) {
        const fromId = sanitizeId(loopComponents[i]);
        const toId = sanitizeId(loopComponents[(i + 1) % loopComponents.length]);
        const label = includeLabels && includeMetrics ? `${loop.type[0].toUpperCase()} (${loop.strength.toFixed(2)})` : includeLabels ? loop.type[0].toUpperCase() : void 0;
        const style = loop.type === "reinforcing" ? "solid" : "dashed";
        const bend = loop.type === "reinforcing" ? "left" : "right";
        edges.push({
          source: fromId,
          target: toId,
          label,
          style,
          directed: true,
          bend
        });
      }
    }
  }
  return generateTikZ(nodes, edges, {
    title: "Systems Thinking Causal Loops",
    colorScheme,
    includeLabels,
    includeMetrics
  });
}
function systemsThinkingToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Systems Thinking Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  if (thought.system) {
    const systemContent = `
      <p><strong>Name:</strong> ${escapeHTML(thought.system.name)}</p>
      <p>${escapeHTML(thought.system.description)}</p>
    `;
    html += renderSection("System Overview", systemContent, "\u{1F50D}");
  }
  if (includeMetrics) {
    html += '<div class="metrics-grid">\n';
    html += renderMetricCard("Components", thought.components?.length || 0, "primary");
    html += renderMetricCard("Feedback Loops", thought.feedbackLoops?.length || 0, "info");
    html += renderMetricCard("Leverage Points", thought.leveragePoints?.length || 0, "success");
    html += "</div>\n";
  }
  if (thought.components && thought.components.length > 0) {
    const componentRows = thought.components.map((c) => [
      c.name,
      c.type,
      c.description,
      c.unit || "N/A",
      c.initialValue !== void 0 ? String(c.initialValue) : "N/A"
    ]);
    const componentsTable = renderTable(
      ["Name", "Type", "Description", "Unit", "Initial Value"],
      componentRows,
      { caption: "System Components" }
    );
    html += renderSection("Components", componentsTable, "\u{1F527}");
  }
  if (thought.feedbackLoops && thought.feedbackLoops.length > 0) {
    let loopsContent = "";
    for (const loop of thought.feedbackLoops) {
      const loopType = loop.type === "reinforcing" ? "success" : "warning";
      const badge = renderBadge(loop.type.toUpperCase(), loopType);
      loopsContent += `
        <div class="card">
          <div class="card-header">${escapeHTML(loop.name)} ${badge}</div>
          <p><strong>Polarity:</strong> ${escapeHTML(loop.polarity)}</p>
          <p><strong>Strength:</strong> ${loop.strength.toFixed(2)}</p>
          <p><strong>Components:</strong> ${loop.components.map((c) => escapeHTML(c)).join(" \u2192 ")}</p>
          ${loop.description ? `<p>${escapeHTML(loop.description)}</p>` : ""}
        </div>
      `;
    }
    html += renderSection("Feedback Loops", loopsContent, "\u{1F504}");
  }
  if (thought.leveragePoints && thought.leveragePoints.length > 0) {
    const leverageRows = thought.leveragePoints.map((lp) => [
      lp.location,
      lp.effectiveness.toFixed(2),
      lp.description
    ]);
    const leverageTable = renderTable(
      ["Location", "Effectiveness", "Description"],
      leverageRows,
      { caption: "Leverage Points" }
    );
    html += renderSection("Leverage Points", leverageTable, "\u2B50");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function systemsThinkingToModelica(thought, options) {
  const { includeMetrics = true } = options;
  const systemName = thought.system ? sanitizeModelicaId(thought.system.name) : "SystemsThinking";
  let modelica = `package ${systemName}
`;
  modelica += `  "${thought.system?.description || "Systems thinking model with feedback loops"}"

`;
  if (thought.components && thought.components.length > 0) {
    modelica += "  // System Components\n";
    for (const component of thought.components) {
      const compName = sanitizeModelicaId(component.name);
      const unit = component.unit ? escapeModelicaString(component.unit) : "";
      const initialValue = component.initialValue !== void 0 ? component.initialValue : 0;
      if (component.type === "stock") {
        modelica += `  model ${compName}
`;
        modelica += `    "${escapeModelicaString(component.description)}"
`;
        modelica += `    parameter Real initial_value = ${initialValue}${unit ? ` "${unit}"` : ""};
`;
        modelica += `    Real value(start=initial_value)${unit ? `(unit="${unit}")` : ""};
`;
        modelica += `    input Real inflow${unit ? `(unit="${unit}/s")` : ""};
`;
        modelica += `    input Real outflow${unit ? `(unit="${unit}/s")` : ""};
`;
        modelica += "  equation\n";
        modelica += "    der(value) = inflow - outflow;\n";
        modelica += "  end " + compName + ";\n\n";
      } else {
        modelica += `  model ${compName}
`;
        modelica += `    "${escapeModelicaString(component.description)}"
`;
        modelica += `    output Real flow_rate${unit ? `(unit="${unit}/s")` : ""};
`;
        modelica += `    input Real source_value${unit ? `(unit="${unit}")` : ""};
`;
        modelica += `    input Real sink_value${unit ? `(unit="${unit}")` : ""};
`;
        modelica += `    parameter Real coefficient = 1.0;
`;
        modelica += "  equation\n";
        modelica += "    flow_rate = coefficient * (source_value - sink_value);\n";
        modelica += "  end " + compName + ";\n\n";
      }
    }
  }
  if (thought.feedbackLoops && thought.feedbackLoops.length > 0) {
    modelica += "  // Feedback Loop Models\n";
    for (const loop of thought.feedbackLoops) {
      const loopName = sanitizeModelicaId(loop.name);
      const loopType = loop.type === "reinforcing" ? "Reinforcing" : "Balancing";
      modelica += `  model ${loopName}
`;
      modelica += `    "${loopType} feedback loop: ${escapeModelicaString(loop.description || loop.name)}"
`;
      if (includeMetrics) {
        modelica += `    // Strength: ${loop.strength.toFixed(3)}
`;
        modelica += `    // Polarity: ${loop.polarity}
`;
      }
      modelica += `    parameter Real strength = ${loop.strength.toFixed(3)};
`;
      modelica += `    parameter String loop_type = "${loop.type}";
`;
      const loopComponents = loop.components.map((c) => sanitizeModelicaId(c));
      modelica += `    // Components in loop: ${loopComponents.join(" \u2192 ")}
`;
      modelica += "  equation\n";
      modelica += `    // ${loopType} feedback loop dynamics
`;
      modelica += "    // Loop components interact with strength factor\n";
      modelica += "  end " + loopName + ";\n\n";
    }
  }
  modelica += `  model ${systemName}_Complete
`;
  modelica += `    "${thought.system?.description || "Complete systems thinking model"}"
`;
  if (includeMetrics && thought.leveragePoints && thought.leveragePoints.length > 0) {
    modelica += "\n    // Leverage Points:\n";
    for (const lp of thought.leveragePoints) {
      modelica += `    // - ${lp.location} (effectiveness: ${lp.effectiveness.toFixed(2)})
`;
      modelica += `    //   ${lp.description}
`;
    }
  }
  modelica += "\n    // Integrate component models and feedback loops here\n";
  modelica += "  end " + systemName + "_Complete;\n\n";
  modelica += "end " + systemName + ";\n";
  return modelica;
}
function systemsThinkingToUML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  if (thought.components && thought.components.length > 0) {
    for (const component of thought.components) {
      const attributes = [];
      if (component.unit) {
        attributes.push(`unit: ${component.unit}`);
      }
      if (component.initialValue !== void 0) {
        attributes.push(`initialValue: ${component.initialValue}`);
      }
      if (includeMetrics) {
        attributes.push(`type: ${component.type}`);
      }
      nodes.push({
        id: sanitizeId(component.id),
        label: component.name,
        shape: component.type === "stock" ? "class" : "component",
        stereotype: component.type,
        attributes
      });
    }
  }
  if (thought.feedbackLoops && thought.feedbackLoops.length > 0) {
    for (const loop of thought.feedbackLoops) {
      const loopComponents = loop.components;
      for (let i = 0; i < loopComponents.length; i++) {
        const fromId = sanitizeId(loopComponents[i]);
        const toId = sanitizeId(loopComponents[(i + 1) % loopComponents.length]);
        const label = includeLabels && includeMetrics ? `${loop.type} (${loop.strength.toFixed(2)})` : includeLabels ? loop.type : void 0;
        const edgeType = loop.type === "reinforcing" ? "association" : "dependency";
        edges.push({
          source: fromId,
          target: toId,
          type: edgeType,
          label
        });
      }
    }
  }
  return generateUmlDiagram(nodes, edges, {
    title: "Systems Thinking Causal Loop Diagram"});
}
function systemsThinkingToJSON(thought, options) {
  const { includeMetrics = true } = options;
  const graph = createJsonGraph("Systems Thinking Causal Loop Diagram", "systems-thinking", {
    includeMetrics
  });
  if (thought.system) {
    graph.metadata.systemName = thought.system.name;
    graph.metadata.systemDescription = thought.system.description;
  }
  if (thought.components && thought.components.length > 0) {
    for (const component of thought.components) {
      addNode(graph, {
        id: component.id,
        label: component.name,
        type: component.type,
        shape: component.type === "stock" ? "rectangle" : "ellipse",
        metadata: {
          description: component.description,
          unit: component.unit,
          initialValue: component.initialValue
        }
      });
    }
  }
  if (thought.feedbackLoops && thought.feedbackLoops.length > 0) {
    let edgeCount = 0;
    for (const loop of thought.feedbackLoops) {
      const loopComponents = loop.components;
      for (let i = 0; i < loopComponents.length; i++) {
        const fromId = loopComponents[i];
        const toId = loopComponents[(i + 1) % loopComponents.length];
        addEdge(graph, {
          id: `edge_${edgeCount++}`,
          source: fromId,
          target: toId,
          label: `${loop.type} (${loop.strength.toFixed(2)})`,
          type: loop.type,
          weight: loop.strength,
          style: loop.type === "reinforcing" ? "solid" : "dashed",
          directed: true,
          metadata: {
            loopName: loop.name,
            polarity: loop.polarity,
            description: loop.description
          }
        });
      }
    }
  }
  if (includeMetrics) {
    addMetric(graph, "components", thought.components?.length || 0);
    addMetric(graph, "feedbackLoops", thought.feedbackLoops?.length || 0);
    addMetric(graph, "leveragePoints", thought.leveragePoints?.length || 0);
    if (thought.feedbackLoops && thought.feedbackLoops.length > 0) {
      const avgStrength = thought.feedbackLoops.reduce((sum, loop) => sum + loop.strength, 0) / thought.feedbackLoops.length;
      addMetric(graph, "averageLoopStrength", parseFloat(avgStrength.toFixed(3)));
    }
    if (thought.feedbackLoops && thought.feedbackLoops.length > 0) {
      const reinforcingCount = thought.feedbackLoops.filter((l) => l.type === "reinforcing").length;
      const balancingCount = thought.feedbackLoops.filter((l) => l.type === "balancing").length;
      addMetric(graph, "reinforcingLoops", reinforcingCount);
      addMetric(graph, "balancingLoops", balancingCount);
    }
  }
  addLegendItem(graph, "stock", "#a8d5ff");
  addLegendItem(graph, "flow", "#ffd699");
  addLegendItem(graph, "reinforcing", "#90ee90", "solid");
  addLegendItem(graph, "balancing", "#ffb3ba", "dashed");
  if (thought.leveragePoints && thought.leveragePoints.length > 0) {
    graph.metadata.leveragePoints = thought.leveragePoints.map((lp) => ({
      location: lp.location,
      effectiveness: lp.effectiveness,
      description: lp.description
    }));
  }
  return serializeGraph(graph);
}
function systemsThinkingToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  if (thought.system) {
    const systemContent = keyValueSection({
      "Name": thought.system.name,
      "Description": thought.system.description
    });
    parts.push(section("System Overview", systemContent));
  }
  if (includeMetrics) {
    const metricsContent = keyValueSection({
      "Components": thought.components?.length || 0,
      "Feedback Loops": thought.feedbackLoops?.length || 0,
      "Leverage Points": thought.leveragePoints?.length || 0
    });
    parts.push(section("Metrics", metricsContent));
  }
  if (thought.components && thought.components.length > 0) {
    const componentRows = thought.components.map((c) => [
      c.name,
      c.type,
      c.description,
      c.unit || "N/A",
      c.initialValue !== void 0 ? String(c.initialValue) : "N/A"
    ]);
    const componentsTable = table(
      ["Name", "Type", "Description", "Unit", "Initial Value"],
      componentRows
    );
    parts.push(section("Components", componentsTable));
  }
  if (thought.feedbackLoops && thought.feedbackLoops.length > 0) {
    const loopItems = thought.feedbackLoops.map(
      (loop) => `**${loop.name}** (${loop.type})
  - Strength: ${loop.strength.toFixed(2)}
  - Polarity: ${loop.polarity}
  - Components: ${loop.components.join(" \u2192 ")}`
    );
    parts.push(section("Feedback Loops", list(loopItems)));
  }
  if (thought.leveragePoints && thought.leveragePoints.length > 0) {
    const leverageRows = thought.leveragePoints.map((lp) => [
      lp.location,
      lp.effectiveness.toFixed(2),
      lp.description
    ]);
    const leverageTable = table(
      ["Location", "Effectiveness", "Description"],
      leverageRows
    );
    parts.push(section("Leverage Points", leverageTable));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = systemsThinkingToMermaid(thought, "default", true, true);
    parts.push(section("Causal Loop Diagram", mermaidBlock(mermaidDiagram)));
  }
  return document("Systems Thinking Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: { mode: "systems-thinking" }
  });
}
var init_systems_thinking = __esm({
  "src/export/visual/systems-thinking.ts"() {
    init_esm_shims();
    init_utils();
    init_svg_utils();
    init_graphml_utils();
    init_tikz_utils();
    init_html_utils();
    init_modelica_utils();
    init_uml_utils();
    init_json_utils();
    init_markdown_utils();
  }
});

// src/export/visual/scientific-method.ts
function exportScientificMethodExperiment(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return scientificMethodToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return scientificMethodToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return scientificMethodToASCII(thought);
    case "svg":
      return scientificMethodToSVG(thought, options);
    case "graphml":
      return scientificMethodToGraphML(thought, options);
    case "tikz":
      return scientificMethodToTikZ(thought, options);
    case "html":
      return scientificMethodToHTML(thought, options);
    case "modelica":
      return scientificMethodToModelica(thought, options);
    case "uml":
      return scientificMethodToUML(thought, options);
    case "json":
      return scientificMethodToJSON(thought, options);
    case "markdown":
      return scientificMethodToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function scientificMethodToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TD\n";
  if (thought.researchQuestion) {
    mermaid += `  RQ["Research Question: ${thought.researchQuestion.question.substring(0, 60)}..."]
`;
    mermaid += "\n";
  }
  if (thought.scientificHypotheses && thought.scientificHypotheses.length > 0) {
    for (const hypothesis of thought.scientificHypotheses) {
      const hypId = sanitizeId(hypothesis.id);
      const label = includeLabels ? hypothesis.statement.substring(0, 50) + "..." : hypId;
      mermaid += `  ${hypId}["H: ${label}"]
`;
      if (thought.researchQuestion) {
        mermaid += `  RQ --> ${hypId}
`;
      }
    }
    mermaid += "\n";
  }
  if (thought.experiment) {
    mermaid += `  Exp["Experiment: ${thought.experiment.design}"]
`;
    if (thought.scientificHypotheses && thought.scientificHypotheses.length > 0) {
      for (const hypothesis of thought.scientificHypotheses) {
        const hypId = sanitizeId(hypothesis.id);
        mermaid += `  ${hypId} --> Exp
`;
      }
    }
    mermaid += "\n";
  }
  if (thought.data) {
    mermaid += `  Data["Data Collection: ${thought.experiment?.sampleSize || 0} samples"]
`;
    if (thought.experiment) {
      mermaid += `  Exp --> Data
`;
    }
    mermaid += "\n";
  }
  if (thought.analysis) {
    mermaid += `  Stats["Statistical Analysis"]
`;
    if (thought.data) {
      mermaid += `  Data --> Stats
`;
    }
    mermaid += "\n";
  }
  if (thought.conclusion) {
    const conclusionId = "Conclusion";
    const supportLabel = includeMetrics && thought.conclusion.confidence ? ` (conf: ${thought.conclusion.confidence.toFixed(2)})` : "";
    mermaid += `  ${conclusionId}["Conclusion: ${thought.conclusion.statement.substring(0, 50)}...${supportLabel}"]
`;
    if (thought.analysis) {
      mermaid += `  Stats --> ${conclusionId}
`;
    }
  }
  if (colorScheme !== "monochrome") {
    mermaid += "\n";
    const questionColor = colorScheme === "pastel" ? "#fff3e0" : "#ffd699";
    const hypothesisColor = colorScheme === "pastel" ? "#e1f5ff" : "#a8d5ff";
    const conclusionColor = colorScheme === "pastel" ? "#e8f5e9" : "#a5d6a7";
    if (thought.researchQuestion) {
      mermaid += `  style RQ fill:${questionColor}
`;
    }
    if (thought.scientificHypotheses) {
      for (const hypothesis of thought.scientificHypotheses) {
        const hypId = sanitizeId(hypothesis.id);
        mermaid += `  style ${hypId} fill:${hypothesisColor}
`;
      }
    }
    if (thought.conclusion) {
      mermaid += `  style Conclusion fill:${conclusionColor}
`;
    }
  }
  return mermaid;
}
function scientificMethodToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph ScientificMethod {\n";
  dot += "  rankdir=TD;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  if (thought.researchQuestion) {
    const label = includeLabels ? thought.researchQuestion.question.substring(0, 60) + "..." : "RQ";
    dot += `  RQ [label="Research Question:\\n${label}", shape=ellipse];

`;
  }
  if (thought.scientificHypotheses && thought.scientificHypotheses.length > 0) {
    for (const hypothesis of thought.scientificHypotheses) {
      const hypId = sanitizeId(hypothesis.id);
      const label = includeLabels ? hypothesis.statement.substring(0, 50) + "..." : hypId;
      dot += `  ${hypId} [label="Hypothesis:\\n${label}"];
`;
      if (thought.researchQuestion) {
        dot += `  RQ -> ${hypId};
`;
      }
    }
    dot += "\n";
  }
  if (thought.experiment) {
    const label = includeLabels ? thought.experiment.design : "Exp";
    dot += `  Exp [label="Experiment:\\n${label}"];
`;
    if (thought.scientificHypotheses) {
      for (const hypothesis of thought.scientificHypotheses) {
        const hypId = sanitizeId(hypothesis.id);
        dot += `  ${hypId} -> Exp;
`;
      }
    }
    dot += "\n";
  }
  if (thought.data) {
    const sampleLabel = includeMetrics ? `\\nSamples: ${thought.experiment?.sampleSize || 0}` : "";
    dot += `  Data [label="Data Collection${sampleLabel}"];
`;
    if (thought.experiment) {
      dot += `  Exp -> Data;
`;
    }
  }
  if (thought.analysis) {
    dot += `  Stats [label="Statistical Analysis"];
`;
    if (thought.data) {
      dot += `  Data -> Stats;
`;
    }
  }
  if (thought.conclusion) {
    const label = includeLabels ? thought.conclusion.statement.substring(0, 50) + "..." : "Conclusion";
    const confLabel = includeMetrics && thought.conclusion.confidence ? `\\nconf: ${thought.conclusion.confidence.toFixed(2)}` : "";
    dot += `  Conclusion [label="Conclusion:\\n${label}${confLabel}", shape=doubleoctagon];
`;
    if (thought.analysis) {
      dot += `  Stats -> Conclusion;
`;
    }
  }
  dot += "}\n";
  return dot;
}
function scientificMethodToASCII(thought) {
  let ascii = "Scientific Method Process:\n";
  ascii += "==========================\n\n";
  if (thought.researchQuestion) {
    ascii += `Research Question: ${thought.researchQuestion.question}
`;
    ascii += `Background: ${thought.researchQuestion.background}

`;
  }
  if (thought.scientificHypotheses && thought.scientificHypotheses.length > 0) {
    ascii += "Hypotheses:\n";
    for (const hypothesis of thought.scientificHypotheses) {
      const typeIcon = hypothesis.type === "null" ? "H\u2080" : "H\u2081";
      ascii += `  ${typeIcon} ${hypothesis.statement}
`;
      if (hypothesis.prediction) {
        ascii += `    Prediction: ${hypothesis.prediction}
`;
      }
    }
    ascii += "\n";
  }
  if (thought.experiment) {
    ascii += `Experiment: ${thought.experiment.design}
`;
    ascii += `Type: ${thought.experiment.type}
`;
    ascii += `Design: ${thought.experiment.design}

`;
  }
  if (thought.data) {
    ascii += "Data Collection:\n";
    ascii += `  Sample Size: ${thought.experiment?.sampleSize || 0}
`;
    ascii += `  Method: ${thought.data.method}
`;
    if (thought.data.dataQuality) {
      ascii += `  Quality:
`;
      ascii += `    Completeness: ${thought.data.dataQuality.completeness.toFixed(2)}
`;
      ascii += `    Reliability: ${thought.data.dataQuality.reliability.toFixed(2)}
`;
    }
    ascii += "\n";
  }
  if (thought.analysis && thought.analysis.tests) {
    ascii += "Statistical Tests:\n";
    for (const test of thought.analysis.tests) {
      ascii += `  \u2022 ${test.name}
`;
      ascii += `    p-value: ${test.pValue.toFixed(4)}, \u03B1: ${test.alpha}
`;
      ascii += `    Result: ${test.result}
`;
    }
    ascii += "\n";
  }
  if (thought.conclusion) {
    ascii += "Conclusion:\n";
    ascii += `${thought.conclusion.statement}
`;
    if (thought.conclusion.supportedHypotheses) {
      ascii += `Supported hypotheses: ${thought.conclusion.supportedHypotheses.join(", ")}
`;
    }
    if (thought.conclusion.confidence) {
      ascii += `Confidence: ${thought.conclusion.confidence.toFixed(2)}
`;
    }
  }
  return ascii;
}
function scientificMethodToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width
  } = options;
  const positions = /* @__PURE__ */ new Map();
  const nodeWidth = 150;
  const nodeHeight = 40;
  const nodeSpacing = 120;
  let currentY = 80;
  if (thought.researchQuestion) {
    positions.set("RQ", {
      id: "RQ",
      label: includeLabels ? `RQ: ${thought.researchQuestion.question.substring(0, 40)}...` : "Research Question",
      x: svgWidth / 2,
      y: currentY,
      width: nodeWidth,
      height: nodeHeight,
      type: "question"
    });
    currentY += nodeSpacing;
  }
  if (thought.scientificHypotheses && thought.scientificHypotheses.length > 0) {
    thought.scientificHypotheses.forEach((hypothesis) => {
      positions.set(hypothesis.id, {
        id: hypothesis.id,
        label: includeLabels ? `H: ${hypothesis.statement.substring(0, 30)}...` : hypothesis.id,
        x: svgWidth / 2,
        y: currentY,
        width: nodeWidth,
        height: nodeHeight,
        type: "hypothesis"
      });
      currentY += nodeSpacing;
    });
  }
  if (thought.experiment) {
    positions.set("Exp", {
      id: "Exp",
      label: "Experiment",
      x: svgWidth / 2,
      y: currentY,
      width: nodeWidth,
      height: nodeHeight,
      type: "experiment"
    });
    currentY += nodeSpacing;
  }
  if (thought.data) {
    positions.set("Data", {
      id: "Data",
      label: "Data Collection",
      x: svgWidth / 2,
      y: currentY,
      width: nodeWidth,
      height: nodeHeight,
      type: "data"
    });
    currentY += nodeSpacing;
  }
  if (thought.analysis) {
    positions.set("Stats", {
      id: "Stats",
      label: "Statistical Analysis",
      x: svgWidth / 2,
      y: currentY,
      width: nodeWidth,
      height: nodeHeight,
      type: "analysis"
    });
    currentY += nodeSpacing;
  }
  if (thought.conclusion) {
    positions.set("Conclusion", {
      id: "Conclusion",
      label: includeLabels ? `Conclusion: ${thought.conclusion.statement.substring(0, 30)}...` : "Conclusion",
      x: svgWidth / 2,
      y: currentY,
      width: nodeWidth,
      height: nodeHeight,
      type: "conclusion"
    });
  }
  const actualHeight = Math.max(DEFAULT_SVG_OPTIONS.height, currentY + 100);
  let svg = generateSVGHeader(svgWidth, actualHeight, "Scientific Method Process");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  const nodeIds = ["RQ", ...thought.scientificHypotheses?.map((h) => h.id) || [], "Exp", "Data", "Stats", "Conclusion"];
  for (let i = 0; i < nodeIds.length - 1; i++) {
    const fromPos = positions.get(nodeIds[i]);
    const toPos = positions.get(nodeIds[i + 1]);
    if (fromPos && toPos) {
      svg += renderEdge(fromPos, toPos);
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  const questionColors = getNodeColor("tertiary", colorScheme);
  const hypothesisColors = getNodeColor("primary", colorScheme);
  const conclusionColors = getNodeColor("success", colorScheme);
  const neutralColors = getNodeColor("neutral", colorScheme);
  for (const [, pos] of positions) {
    if (pos.type === "question") {
      svg += renderEllipseNode(pos, questionColors);
    } else if (pos.type === "hypothesis") {
      svg += renderRectNode(pos, hypothesisColors);
    } else if (pos.type === "conclusion") {
      svg += renderStadiumNode(pos, conclusionColors);
    } else {
      svg += renderRectNode(pos, neutralColors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Hypotheses", value: thought.scientificHypotheses?.length || 0 },
      { label: "Confidence", value: thought.conclusion?.confidence?.toFixed(2) || "N/A" }
    ];
    svg += renderMetricsPanel(svgWidth - 180, actualHeight - 110, metrics);
  }
  const legendItems = [
    { label: "Research Question", color: questionColors, shape: "ellipse" },
    { label: "Hypothesis", color: hypothesisColors },
    { label: "Conclusion", color: conclusionColors, shape: "stadium" }
  ];
  svg += renderLegend(20, actualHeight - 110, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function scientificMethodToGraphML(thought, options) {
  const { includeLabels = true } = options;
  const nodes = [];
  const edges = [];
  let edgeIndex = 0;
  const stages2 = [];
  if (thought.researchQuestion) {
    stages2.push({
      id: "RQ",
      label: includeLabels ? `Research Question: ${thought.researchQuestion.question.substring(0, 60)}...` : "Research Question",
      type: "question",
      exists: true
    });
  }
  if (thought.scientificHypotheses && thought.scientificHypotheses.length > 0) {
    const hypLabel = includeLabels ? `Hypothesis: ${thought.scientificHypotheses[0].statement.substring(0, 60)}...` : "Hypothesis";
    stages2.push({
      id: "Hypothesis",
      label: hypLabel,
      type: "hypothesis",
      exists: true
    });
  }
  if (thought.experiment) {
    stages2.push({
      id: "Experiment",
      label: includeLabels ? `Experiment: ${thought.experiment.design}` : "Experiment",
      type: "experiment",
      exists: true
    });
  }
  if (thought.data) {
    const sampleSize = thought.experiment?.sampleSize || 0;
    stages2.push({
      id: "Data",
      label: includeLabels ? `Data Collection: ${sampleSize} samples` : "Data Collection",
      type: "data",
      exists: true
    });
  }
  if (thought.analysis) {
    stages2.push({
      id: "Analysis",
      label: "Statistical Analysis",
      type: "analysis",
      exists: true
    });
  }
  if (thought.conclusion) {
    const confLabel = thought.conclusion.confidence ? ` (confidence: ${thought.conclusion.confidence.toFixed(2)})` : "";
    stages2.push({
      id: "Conclusion",
      label: includeLabels ? `Conclusion: ${thought.conclusion.statement.substring(0, 60)}...${confLabel}` : "Conclusion",
      type: "conclusion",
      exists: true
    });
  }
  for (const stage of stages2) {
    nodes.push({
      id: stage.id,
      label: stage.label,
      type: stage.type
    });
  }
  for (let i = 0; i < stages2.length - 1; i++) {
    edges.push({
      id: `e${edgeIndex++}`,
      source: stages2[i].id,
      target: stages2[i + 1].id,
      directed: true
    });
  }
  return generateGraphML(nodes, edges, {
    graphName: "Scientific Method Experiment",
    directed: true,
    includeLabels
  });
}
function scientificMethodToTikZ(thought, options) {
  const { includeLabels = true, colorScheme = "default" } = options;
  const nodes = [];
  const edges = [];
  let xPosition = 0;
  const xSpacing = 3;
  const stages2 = [];
  if (thought.researchQuestion) {
    stages2.push({
      id: "RQ",
      label: includeLabels ? "Research\nQuestion" : "RQ",
      type: "tertiary",
      shape: "ellipse"
    });
  }
  if (thought.scientificHypotheses && thought.scientificHypotheses.length > 0) {
    stages2.push({
      id: "Hypothesis",
      label: includeLabels ? `Hypothesis
(${thought.scientificHypotheses.length})` : "H",
      type: "info",
      shape: "rectangle"
    });
  }
  if (thought.experiment) {
    stages2.push({
      id: "Experiment",
      label: "Experiment",
      type: "neutral",
      shape: "rectangle"
    });
  }
  if (thought.data) {
    stages2.push({
      id: "Data",
      label: "Data\nCollection",
      type: "neutral",
      shape: "rectangle"
    });
  }
  if (thought.analysis) {
    stages2.push({
      id: "Analysis",
      label: "Statistical\nAnalysis",
      type: "primary",
      shape: "rectangle"
    });
  }
  if (thought.conclusion) {
    stages2.push({
      id: "Conclusion",
      label: "Conclusion",
      type: "success",
      shape: "stadium"
    });
  }
  for (const stage of stages2) {
    nodes.push({
      id: stage.id,
      label: stage.label,
      x: xPosition,
      y: 0,
      type: stage.type,
      shape: stage.shape || "rectangle"
    });
    xPosition += xSpacing;
  }
  for (let i = 0; i < stages2.length - 1; i++) {
    edges.push({
      source: stages2[i].id,
      target: stages2[i + 1].id,
      directed: true
    });
  }
  return generateTikZ(nodes, edges, {
    title: "Scientific Method Experiment",
    colorScheme,
    includeLabels
  });
}
function scientificMethodToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Scientific Method Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  if (thought.researchQuestion) {
    const questionContent = `
      <p><strong>Question:</strong> ${escapeHTML(thought.researchQuestion.question)}</p>
      <p><strong>Background:</strong> ${escapeHTML(thought.researchQuestion.background)}</p>
      ${thought.researchQuestion.significance ? `<p><strong>Significance:</strong> ${escapeHTML(thought.researchQuestion.significance)}</p>` : ""}
    `;
    html += renderSection("Research Question", questionContent, "\u2753");
  }
  if (includeMetrics) {
    html += '<div class="metrics-grid">\n';
    html += renderMetricCard("Hypotheses", thought.scientificHypotheses?.length || 0, "primary");
    html += renderMetricCard("Tests", thought.analysis?.tests?.length || 0, "info");
    html += renderMetricCard("Confidence", thought.conclusion?.confidence?.toFixed(2) || "N/A", "success");
    html += "</div>\n";
  }
  if (thought.scientificHypotheses && thought.scientificHypotheses.length > 0) {
    let hypothesesContent = "";
    for (const hypothesis of thought.scientificHypotheses) {
      const typeColor = hypothesis.type === "null" ? "secondary" : "primary";
      const badge = renderBadge(hypothesis.type.toUpperCase(), typeColor);
      hypothesesContent += `
        <div class="card">
          <div class="card-header">${badge} ${escapeHTML(hypothesis.statement)}</div>
          ${hypothesis.prediction ? `<p><strong>Prediction:</strong> ${escapeHTML(hypothesis.prediction)}</p>` : ""}
          ${hypothesis.rationale ? `<p><strong>Rationale:</strong> ${escapeHTML(hypothesis.rationale)}</p>` : ""}
        </div>
      `;
    }
    html += renderSection("Hypotheses", hypothesesContent, "\u{1F4A1}");
  }
  if (thought.experiment) {
    const experimentContent = `
      <p><strong>Type:</strong> ${escapeHTML(thought.experiment.type)}</p>
      <p><strong>Design:</strong> ${escapeHTML(thought.experiment.design)}</p>
      ${thought.experiment.sampleSize ? `<p><strong>Sample Size:</strong> ${thought.experiment.sampleSize}</p>` : ""}
    `;
    html += renderSection("Experiment", experimentContent, "\u{1F52C}");
  }
  if (thought.data) {
    const dataContent = `
      <p><strong>Method:</strong> ${escapeHTML(thought.data.method.join(", "))}</p>
      ${thought.data.dataQuality ? `
        <p><strong>Quality Metrics:</strong></p>
        <ul>
          <li>Completeness: ${(thought.data.dataQuality.completeness * 100).toFixed(0)}%</li>
          <li>Reliability: ${(thought.data.dataQuality.reliability * 100).toFixed(0)}%</li>
        </ul>
      ` : ""}
    `;
    html += renderSection("Data Collection", dataContent, "\u{1F4CA}");
  }
  if (thought.analysis && thought.analysis.tests) {
    const testRows = thought.analysis.tests.map((test) => [
      test.name,
      test.pValue.toFixed(4),
      test.alpha.toString(),
      test.result
    ]);
    const testsTable = renderTable(
      ["Test", "p-value", "\u03B1", "Result"],
      testRows,
      { caption: "Statistical Tests" }
    );
    html += renderSection("Statistical Analysis", testsTable, "\u{1F4C8}");
  }
  if (thought.conclusion) {
    const conclusionBadge = thought.conclusion.confidence && thought.conclusion.confidence > 0.8 ? renderBadge("HIGH CONFIDENCE", "success") : thought.conclusion.confidence && thought.conclusion.confidence > 0.5 ? renderBadge("MODERATE CONFIDENCE", "warning") : renderBadge("LOW CONFIDENCE", "danger");
    const conclusionContent = `
      <p>${conclusionBadge}</p>
      <p>${escapeHTML(thought.conclusion.statement)}</p>
      ${thought.conclusion.confidence ? `<p><strong>Confidence:</strong> ${(thought.conclusion.confidence * 100).toFixed(0)}%</p>` : ""}
      ${thought.conclusion.supportedHypotheses ? `<p><strong>Supported Hypotheses:</strong> ${thought.conclusion.supportedHypotheses.join(", ")}</p>` : ""}
    `;
    html += renderSection("Conclusion", conclusionContent, "\u2705");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function scientificMethodToModelica(thought, options) {
  const { includeMetrics = true } = options;
  const lines = [];
  lines.push("package ScientificMethodExperiment");
  lines.push('  "Scientific method experiment modeling package"');
  lines.push("");
  const stages2 = [];
  if (thought.researchQuestion) stages2.push("ResearchQuestion");
  if (thought.scientificHypotheses && thought.scientificHypotheses.length > 0) stages2.push("Hypothesis");
  if (thought.experiment) stages2.push("Experiment");
  if (thought.data) stages2.push("DataCollection");
  if (thought.analysis) stages2.push("Analysis");
  if (thought.conclusion) stages2.push("Conclusion");
  if (stages2.length > 0) {
    lines.push("  type Stage = enumeration(");
    for (let i = 0; i < stages2.length; i++) {
      const comma = i < stages2.length - 1 ? "," : "";
      lines.push(`    ${stages2[i]} "${stages2[i]}"${comma}`);
    }
    lines.push("  );");
    lines.push("");
  }
  if (thought.researchQuestion) {
    lines.push("  record ResearchQuestionData");
    lines.push('    "Research question information"');
    lines.push(`    parameter String question = "${escapeModelicaString(thought.researchQuestion.question)}";`);
    lines.push(`    parameter String background = "${escapeModelicaString(thought.researchQuestion.background)}";`);
    if (thought.researchQuestion.significance) {
      lines.push(`    parameter String significance = "${escapeModelicaString(thought.researchQuestion.significance)}";`);
    }
    lines.push("  end ResearchQuestionData;");
    lines.push("");
  }
  if (thought.scientificHypotheses && thought.scientificHypotheses.length > 0) {
    lines.push("  record HypothesisData");
    lines.push('    "Hypothesis information"');
    lines.push(`    parameter Integer count = ${thought.scientificHypotheses.length};`);
    lines.push(`    parameter String primaryHypothesis = "${escapeModelicaString(thought.scientificHypotheses[0].statement)}";`);
    lines.push(`    parameter String hypothesisType = "${thought.scientificHypotheses[0].type}";`);
    lines.push("  end HypothesisData;");
    lines.push("");
  }
  if (thought.experiment) {
    lines.push("  record ExperimentData");
    lines.push('    "Experiment design information"');
    lines.push(`    parameter String experimentType = "${escapeModelicaString(thought.experiment.type)}";`);
    lines.push(`    parameter String design = "${escapeModelicaString(thought.experiment.design)}";`);
    const sampleSize = thought.experiment?.sampleSize || 0;
    if (sampleSize > 0) {
      lines.push(`    parameter Integer sampleSize = ${sampleSize};`);
    }
    lines.push("  end ExperimentData;");
    lines.push("");
  }
  if (thought.data) {
    lines.push("  record DataCollectionInfo");
    lines.push('    "Data collection and quality metrics"');
    lines.push(`    parameter String method = "${escapeModelicaString(thought.data.method.join(", "))}";`);
    if (thought.data.dataQuality) {
      lines.push(`    parameter Real completeness = ${thought.data.dataQuality.completeness.toFixed(3)};`);
      lines.push(`    parameter Real reliability = ${thought.data.dataQuality.reliability.toFixed(3)};`);
    }
    lines.push("  end DataCollectionInfo;");
    lines.push("");
  }
  if (thought.analysis && thought.analysis.tests) {
    lines.push("  record AnalysisData");
    lines.push('    "Statistical analysis results"');
    lines.push(`    parameter Integer testCount = ${thought.analysis.tests.length};`);
    if (thought.analysis.tests.length > 0) {
      lines.push(`    parameter String primaryTest = "${escapeModelicaString(thought.analysis.tests[0].name)}";`);
      lines.push(`    parameter Real primaryPValue = ${thought.analysis.tests[0].pValue.toFixed(4)};`);
    }
    lines.push("  end AnalysisData;");
    lines.push("");
  }
  if (thought.conclusion) {
    lines.push("  record ConclusionData");
    lines.push('    "Final conclusion and confidence"');
    lines.push(`    parameter String statement = "${escapeModelicaString(thought.conclusion.statement)}";`);
    if (thought.conclusion.confidence) {
      lines.push(`    parameter Real confidence = ${thought.conclusion.confidence.toFixed(3)};`);
    }
    lines.push("  end ConclusionData;");
    lines.push("");
  }
  if (includeMetrics && stages2.length > 0) {
    const currentStageIndex = stages2.length;
    lines.push("  // Progress metrics");
    lines.push(`  parameter Integer totalStages = ${stages2.length};`);
    lines.push(`  parameter Integer completedStages = ${currentStageIndex};`);
    lines.push(`  parameter Real progress = ${(currentStageIndex / stages2.length).toFixed(3)};`);
    lines.push("");
  }
  lines.push("  annotation(");
  lines.push('    Documentation(info="<html>');
  lines.push("      <p>Scientific Method Experiment Flow</p>");
  if (includeMetrics) {
    lines.push(`      <p>Stages: ${stages2.length}</p>`);
    if (thought.scientificHypotheses) {
      lines.push(`      <p>Hypotheses: ${thought.scientificHypotheses.length}</p>`);
    }
    if (thought.conclusion?.confidence) {
      lines.push(`      <p>Confidence: ${(thought.conclusion.confidence * 100).toFixed(0)}%</p>`);
    }
  }
  lines.push("      <p>Generated by DeepThinking MCP v7.1.0</p>");
  lines.push('    </html>"),');
  lines.push('    version="1.0.0"');
  lines.push("  );");
  lines.push("end ScientificMethodExperiment;");
  return lines.join("\n");
}
function scientificMethodToUML(thought, options) {
  const { includeLabels = true } = options;
  const activities = [];
  if (thought.researchQuestion) {
    const label = includeLabels ? `Research Question: ${thought.researchQuestion.question.substring(0, 40)}...` : "Research Question";
    activities.push(label);
  }
  if (thought.scientificHypotheses && thought.scientificHypotheses.length > 0) {
    const label = includeLabels ? `Hypotheses (${thought.scientificHypotheses.length})` : "Hypotheses";
    activities.push(label);
  }
  if (thought.experiment) {
    const label = includeLabels ? `Experiment: ${thought.experiment.design.substring(0, 40)}` : "Experiment";
    activities.push(label);
  }
  if (thought.data) {
    activities.push("Data Collection");
  }
  if (thought.analysis) {
    const label = includeLabels && thought.analysis.tests ? `Statistical Analysis (${thought.analysis.tests.length} tests)` : "Statistical Analysis";
    activities.push(label);
  }
  if (thought.conclusion) {
    const label = includeLabels ? `Conclusion: ${thought.conclusion.statement.substring(0, 40)}...` : "Conclusion";
    activities.push(label);
  }
  const currentActivity = thought.conclusion ? activities[activities.length - 1] : void 0;
  return generateActivityDiagram(activities, currentActivity, {
    title: "Scientific Method Experiment Flow",
    includeLabels
  });
}
function scientificMethodToJSON(thought, options) {
  const { includeMetrics = true } = options;
  const graph = createJsonGraph("Scientific Method Experiment", "scientific-method", options);
  if (graph.layout) {
    graph.layout.type = "linear";
    graph.layout.direction = "TB";
  }
  let yPosition = 0;
  const ySpacing = 100;
  let edgeId = 0;
  const nodeIds = [];
  if (thought.researchQuestion) {
    addNode(graph, {
      id: "research_question",
      label: thought.researchQuestion.question.substring(0, 60) + "...",
      type: "question",
      y: yPosition,
      x: 200,
      color: "#ffd699",
      shape: "ellipse",
      metadata: {
        question: thought.researchQuestion.question,
        background: thought.researchQuestion.background,
        significance: thought.researchQuestion.significance
      }
    });
    nodeIds.push("research_question");
    yPosition += ySpacing;
  }
  if (thought.scientificHypotheses && thought.scientificHypotheses.length > 0) {
    addNode(graph, {
      id: "hypotheses",
      label: `Hypotheses (${thought.scientificHypotheses.length})`,
      type: "hypothesis",
      y: yPosition,
      x: 200,
      color: "#a8d5ff",
      shape: "rectangle",
      metadata: {
        count: thought.scientificHypotheses.length,
        hypotheses: thought.scientificHypotheses.map((h) => ({
          id: h.id,
          statement: h.statement,
          type: h.type
        }))
      }
    });
    nodeIds.push("hypotheses");
    yPosition += ySpacing;
  }
  if (thought.experiment) {
    addNode(graph, {
      id: "experiment",
      label: `Experiment: ${thought.experiment.design.substring(0, 30)}...`,
      type: "experiment",
      y: yPosition,
      x: 200,
      color: "#e0e0e0",
      shape: "rectangle",
      metadata: {
        type: thought.experiment.type,
        design: thought.experiment.design,
        sampleSize: thought.experiment?.sampleSize
      }
    });
    nodeIds.push("experiment");
    yPosition += ySpacing;
  }
  if (thought.data) {
    addNode(graph, {
      id: "data_collection",
      label: "Data Collection",
      type: "data",
      y: yPosition,
      x: 200,
      color: "#e0e0e0",
      shape: "rectangle",
      metadata: {
        method: thought.data.method,
        dataQuality: thought.data.dataQuality
      }
    });
    nodeIds.push("data_collection");
    yPosition += ySpacing;
  }
  if (thought.analysis) {
    const testCount = thought.analysis.tests?.length || 0;
    addNode(graph, {
      id: "analysis",
      label: `Statistical Analysis (${testCount} tests)`,
      type: "analysis",
      y: yPosition,
      x: 200,
      color: "#e0e0e0",
      shape: "rectangle",
      metadata: {
        testCount,
        tests: thought.analysis.tests
      }
    });
    nodeIds.push("analysis");
    yPosition += ySpacing;
  }
  if (thought.conclusion) {
    addNode(graph, {
      id: "conclusion",
      label: `Conclusion: ${thought.conclusion.statement.substring(0, 40)}...`,
      type: "conclusion",
      y: yPosition,
      x: 200,
      color: "#a5d6a7",
      shape: "stadium",
      metadata: {
        statement: thought.conclusion.statement,
        confidence: thought.conclusion.confidence,
        supportedHypotheses: thought.conclusion.supportedHypotheses
      }
    });
    nodeIds.push("conclusion");
  }
  for (let i = 0; i < nodeIds.length - 1; i++) {
    addEdge(graph, {
      id: `edge_${edgeId++}`,
      source: nodeIds[i],
      target: nodeIds[i + 1],
      directed: true,
      style: "solid"
    });
  }
  if (includeMetrics && graph.metrics) {
    addMetric(graph, "totalStages", nodeIds.length);
    addMetric(graph, "completedStages", nodeIds.length);
    addMetric(graph, "progress", 1);
    addMetric(graph, "hypothesisCount", thought.scientificHypotheses?.length || 0);
    if (thought.conclusion?.confidence) {
      addMetric(graph, "confidence", thought.conclusion.confidence);
    }
    if (thought.analysis?.tests) {
      addMetric(graph, "testCount", thought.analysis.tests.length);
    }
  }
  return serializeGraph(graph, options);
}
function scientificMethodToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  if (thought.researchQuestion) {
    const questionContent = keyValueSection({
      "Question": thought.researchQuestion.question,
      "Background": thought.researchQuestion.background,
      "Significance": thought.researchQuestion.significance || "N/A"
    });
    parts.push(section("Research Question", questionContent));
  }
  if (includeMetrics) {
    const metricsContent = keyValueSection({
      "Hypotheses": thought.scientificHypotheses?.length || 0,
      "Tests": thought.analysis?.tests?.length || 0,
      "Confidence": thought.conclusion?.confidence?.toFixed(2) || "N/A"
    });
    parts.push(section("Metrics", metricsContent));
  }
  if (thought.scientificHypotheses && thought.scientificHypotheses.length > 0) {
    const hypothesisItems = thought.scientificHypotheses.map(
      (h) => `**${h.type === "null" ? "H\u2080" : "H\u2081"}**: ${h.statement}${h.prediction ? `
  - Prediction: ${h.prediction}` : ""}`
    );
    parts.push(section("Hypotheses", list(hypothesisItems)));
  }
  if (thought.experiment) {
    const experimentContent = keyValueSection({
      "Type": thought.experiment.type,
      "Design": thought.experiment.design,
      "Sample Size": thought.experiment?.sampleSize || "N/A"
    });
    parts.push(section("Experiment", experimentContent));
  }
  if (thought.data) {
    const dataContent = keyValueSection({
      "Method": thought.data.method.join(", "),
      "Completeness": thought.data.dataQuality ? `${(thought.data.dataQuality.completeness * 100).toFixed(0)}%` : "N/A",
      "Reliability": thought.data.dataQuality ? `${(thought.data.dataQuality.reliability * 100).toFixed(0)}%` : "N/A"
    });
    parts.push(section("Data Collection", dataContent));
  }
  if (thought.analysis && thought.analysis.tests) {
    const testRows = thought.analysis.tests.map((test) => [
      test.name,
      test.pValue.toFixed(4),
      test.alpha.toString(),
      test.result
    ]);
    const testsTable = table(
      ["Test", "p-value", "\u03B1", "Result"],
      testRows
    );
    parts.push(section("Statistical Analysis", testsTable));
  }
  if (thought.conclusion) {
    const conclusionContent = `${thought.conclusion.statement}

` + keyValueSection({
      "Confidence": thought.conclusion.confidence ? `${(thought.conclusion.confidence * 100).toFixed(0)}%` : "N/A",
      "Supported Hypotheses": thought.conclusion.supportedHypotheses?.join(", ") || "N/A"
    });
    parts.push(section("Conclusion", conclusionContent));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = scientificMethodToMermaid(thought, "default", true, true);
    parts.push(section("Experiment Flow Diagram", mermaidBlock(mermaidDiagram)));
  }
  return document("Scientific Method Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: { mode: "scientific-method" }
  });
}
var init_scientific_method = __esm({
  "src/export/visual/scientific-method.ts"() {
    init_esm_shims();
    init_utils();
    init_svg_utils();
    init_graphml_utils();
    init_tikz_utils();
    init_html_utils();
    init_modelica_utils();
    init_uml_utils();
    init_json_utils();
    init_markdown_utils();
  }
});

// src/export/visual/optimization.ts
function exportOptimizationSolution(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return optimizationToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return optimizationToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return optimizationToASCII(thought);
    case "svg":
      return optimizationToSVG(thought, options);
    case "graphml":
      return optimizationToGraphML(thought, options);
    case "tikz":
      return optimizationToTikZ(thought, options);
    case "html":
      return optimizationToHTML(thought, options);
    case "modelica":
      return optimizationToModelica(thought, options);
    case "uml":
      return optimizationToUML(thought, options);
    case "json":
      return optimizationToJSON(thought, options);
    case "markdown":
      return optimizationToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function optimizationToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TD\n";
  if (thought.problem) {
    const problemLabel = includeLabels ? `Problem: ${thought.problem.name}` : "Problem";
    mermaid += `  Problem["${problemLabel}"]

`;
  }
  if (thought.variables && thought.variables.length > 0) {
    mermaid += '  subgraph Variables["Decision Variables"]\n';
    for (const variable of thought.variables) {
      const varId = sanitizeId(variable.id);
      const label = includeLabels ? variable.name : varId;
      const domainLabel = includeMetrics && variable.domain ? ` [${variable.domain.lowerBound},${variable.domain.upperBound}]` : "";
      mermaid += `    ${varId}["${label}${domainLabel}"]
`;
    }
    mermaid += "  end\n\n";
  }
  if (thought.optimizationConstraints && thought.optimizationConstraints.length > 0) {
    mermaid += '  subgraph Constraints["Constraints"]\n';
    for (const constraint of thought.optimizationConstraints) {
      const constId = sanitizeId(constraint.id);
      const label = includeLabels ? constraint.name : constId;
      mermaid += `    ${constId}["${label}"]
`;
    }
    mermaid += "  end\n\n";
  }
  if (thought.objectives && thought.objectives.length > 0) {
    for (const objective of thought.objectives) {
      const objId = sanitizeId(objective.id);
      const label = includeLabels ? `${objective.type}: ${objective.name}` : objId;
      mermaid += `  ${objId}["${label}"]
`;
    }
    mermaid += "\n";
  }
  if (thought.solution) {
    const qualityLabel = includeMetrics && thought.solution.quality ? ` (quality: ${thought.solution.quality.toFixed(2)})` : "";
    mermaid += `  Solution["Solution${qualityLabel}"]
`;
    if (thought.objectives) {
      for (const objective of thought.objectives) {
        const objId = sanitizeId(objective.id);
        mermaid += `  ${objId} --> Solution
`;
      }
    }
  }
  if (colorScheme !== "monochrome") {
    mermaid += "\n";
    const solutionColor = colorScheme === "pastel" ? "#e8f5e9" : "#a5d6a7";
    if (thought.solution) {
      mermaid += `  style Solution fill:${solutionColor}
`;
    }
  }
  return mermaid;
}
function optimizationToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph Optimization {\n";
  dot += "  rankdir=TD;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  if (thought.problem) {
    const label = includeLabels ? thought.problem.name : "Problem";
    dot += `  Problem [label="Problem:\\n${label}", shape=ellipse];

`;
  }
  if (thought.variables && thought.variables.length > 0) {
    dot += "  subgraph cluster_variables {\n";
    dot += '    label="Decision Variables";\n';
    for (const variable of thought.variables) {
      const varId = sanitizeId(variable.id);
      const label = includeLabels ? variable.name : varId;
      const domainLabel = includeMetrics && variable.domain ? `\\n[${variable.domain.lowerBound}, ${variable.domain.upperBound}]` : "";
      dot += `    ${varId} [label="${label}${domainLabel}"];
`;
    }
    dot += "  }\n\n";
  }
  if (thought.optimizationConstraints && thought.optimizationConstraints.length > 0) {
    dot += "  subgraph cluster_constraints {\n";
    dot += '    label="Constraints";\n';
    for (const constraint of thought.optimizationConstraints) {
      const constId = sanitizeId(constraint.id);
      const label = includeLabels ? constraint.name : constId;
      dot += `    ${constId} [label="${label}", shape=diamond];
`;
    }
    dot += "  }\n\n";
  }
  if (thought.objectives) {
    for (const objective of thought.objectives) {
      const objId = sanitizeId(objective.id);
      const label = includeLabels ? `${objective.type}:\\n${objective.name}` : objId;
      dot += `  ${objId} [label="${label}"];
`;
    }
  }
  if (thought.solution) {
    const qualityLabel = includeMetrics && thought.solution.quality ? `\\nquality: ${thought.solution.quality.toFixed(2)}` : "";
    dot += `  Solution [label="Solution${qualityLabel}", shape=doubleoctagon, style=filled, fillcolor=lightgreen];
`;
    if (thought.objectives) {
      for (const objective of thought.objectives) {
        const objId = sanitizeId(objective.id);
        dot += `  ${objId} -> Solution;
`;
      }
    }
  }
  dot += "}\n";
  return dot;
}
function optimizationToASCII(thought) {
  let ascii = "Optimization Problem:\n";
  ascii += "====================\n\n";
  if (thought.problem) {
    ascii += `Problem: ${thought.problem.name}
`;
    ascii += `Type: ${thought.problem.type}
`;
    ascii += `${thought.problem.description}

`;
  }
  if (thought.variables && thought.variables.length > 0) {
    ascii += "Decision Variables:\n";
    for (const variable of thought.variables) {
      const varType = variable.type || "unknown";
      ascii += `  ${variable.name} (${varType})
`;
      if (variable.domain) {
        ascii += `    Domain: [${variable.domain.lowerBound}, ${variable.domain.upperBound}]
`;
      }
    }
    ascii += "\n";
  }
  if (thought.optimizationConstraints && thought.optimizationConstraints.length > 0) {
    ascii += "Constraints:\n";
    for (const constraint of thought.optimizationConstraints) {
      ascii += `  ${constraint.name} (${constraint.type})
`;
      ascii += `    ${constraint.formula}
`;
    }
    ascii += "\n";
  }
  if (thought.objectives && thought.objectives.length > 0) {
    ascii += "Objectives:\n";
    for (const objective of thought.objectives) {
      ascii += `  ${objective.type.toUpperCase()}: ${objective.name}
`;
      ascii += `    ${objective.formula}
`;
    }
    ascii += "\n";
  }
  if (thought.solution) {
    ascii += "Solution:\n";
    const solution = thought.solution;
    if (solution.status) {
      ascii += `  Status: ${solution.status}
`;
    }
    if (solution.optimalValue !== void 0) {
      ascii += `  Optimal Value: ${solution.optimalValue}
`;
    }
    if (solution.quality !== void 0) {
      ascii += `  Quality: ${solution.quality.toFixed(2)}
`;
    }
    if (solution.assignments) {
      ascii += "  Assignments:\n";
      for (const [varId, value] of Object.entries(solution.assignments)) {
        ascii += `    ${varId} = ${value}
`;
      }
    }
  }
  return ascii;
}
function optimizationToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width,
    svgHeight = DEFAULT_SVG_OPTIONS.height
  } = options;
  const positions = /* @__PURE__ */ new Map();
  const nodeWidth = 150;
  const nodeHeight = 40;
  if (thought.problem) {
    positions.set("Problem", {
      id: "Problem",
      label: includeLabels ? thought.problem.name : "Problem",
      x: svgWidth / 2,
      y: 80,
      width: nodeWidth,
      height: nodeHeight,
      type: "problem"
    });
  }
  if (thought.variables) {
    thought.variables.forEach((variable, index) => {
      positions.set(variable.id, {
        id: variable.id,
        label: includeLabels ? variable.name : variable.id,
        x: 150,
        y: 200 + index * 80,
        width: nodeWidth,
        height: nodeHeight,
        type: "variable"
      });
    });
  }
  if (thought.objectives) {
    thought.objectives.forEach((objective, index) => {
      positions.set(objective.id, {
        id: objective.id,
        label: includeLabels ? `${objective.type}: ${objective.name}` : objective.id,
        x: svgWidth - 150,
        y: 200 + index * 80,
        width: nodeWidth,
        height: nodeHeight,
        type: "objective"
      });
    });
  }
  if (thought.solution) {
    positions.set("Solution", {
      id: "Solution",
      label: "Solution",
      x: svgWidth / 2,
      y: svgHeight - 100,
      width: nodeWidth,
      height: nodeHeight,
      type: "solution"
    });
  }
  let svg = generateSVGHeader(svgWidth, svgHeight, "Optimization Problem");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  if (thought.objectives && thought.solution) {
    for (const objective of thought.objectives) {
      const objPos = positions.get(objective.id);
      const solPos = positions.get("Solution");
      if (objPos && solPos) {
        svg += renderEdge(objPos, solPos);
      }
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  const problemColors = getNodeColor("warning", colorScheme);
  const variableColors = getNodeColor("neutral", colorScheme);
  const objectiveColors = getNodeColor("primary", colorScheme);
  const solutionColors = getNodeColor("success", colorScheme);
  for (const [, pos] of positions) {
    if (pos.type === "problem") {
      svg += renderEllipseNode(pos, problemColors);
    } else if (pos.type === "variable") {
      svg += renderRectNode(pos, variableColors);
    } else if (pos.type === "objective") {
      svg += renderRectNode(pos, objectiveColors);
    } else if (pos.type === "solution") {
      svg += renderStadiumNode(pos, solutionColors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Variables", value: thought.variables?.length || 0 },
      { label: "Constraints", value: thought.optimizationConstraints?.length || 0 },
      { label: "Objectives", value: thought.objectives?.length || 0 },
      { label: "Quality", value: thought.solution?.quality?.toFixed(2) || "N/A" }
    ];
    svg += renderMetricsPanel(svgWidth - 180, svgHeight - 150, metrics);
  }
  const legendItems = [
    { label: "Problem", color: problemColors, shape: "ellipse" },
    { label: "Variable", color: variableColors },
    { label: "Objective", color: objectiveColors },
    { label: "Solution", color: solutionColors, shape: "stadium" }
  ];
  svg += renderLegend(20, svgHeight - 140, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function optimizationToGraphML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  let edgeCount = 0;
  if (thought.objectives && thought.objectives.length > 0) {
    for (const objective of thought.objectives) {
      nodes.push({
        id: sanitizeId(objective.id),
        label: includeLabels ? `${objective.type}: ${objective.name}` : objective.id,
        type: "objective",
        metadata: {
          description: objective.formula,
          objectiveType: objective.type
        }
      });
    }
  }
  if (thought.optimizationConstraints && thought.optimizationConstraints.length > 0) {
    for (const constraint of thought.optimizationConstraints) {
      nodes.push({
        id: sanitizeId(constraint.id),
        label: includeLabels ? constraint.name : constraint.id,
        type: "constraint",
        metadata: {
          description: constraint.formula,
          constraintType: constraint.type
        }
      });
      if (thought.objectives) {
        for (const objective of thought.objectives) {
          edges.push({
            id: `e${edgeCount++}`,
            source: sanitizeId(constraint.id),
            target: sanitizeId(objective.id),
            label: "constrains"
          });
        }
      }
    }
  }
  if (thought.solution) {
    nodes.push({
      id: "solution",
      label: includeMetrics && thought.solution.quality ? `Solution (quality: ${thought.solution.quality.toFixed(2)})` : "Solution",
      type: "solution",
      metadata: {
        status: thought.solution.status,
        optimalValue: thought.solution.optimalValue,
        quality: thought.solution.quality
      }
    });
    if (thought.objectives) {
      for (const objective of thought.objectives) {
        edges.push({
          id: `e${edgeCount++}`,
          source: sanitizeId(objective.id),
          target: "solution",
          label: "optimizes"
        });
      }
    }
  }
  return generateGraphML(nodes, edges, {
    graphName: "Optimization Solution",
    includeLabels,
    includeMetadata: includeMetrics
  });
}
function optimizationToTikZ(thought, options) {
  const { colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  let yOffset = 0;
  if (thought.objectives && thought.objectives.length > 0) {
    const startX = thought.objectives.length > 1 ? 0 : 4;
    const spacing = thought.objectives.length > 1 ? 8 / thought.objectives.length : 0;
    for (let i = 0; i < thought.objectives.length; i++) {
      const objective = thought.objectives[i];
      const x = thought.objectives.length === 1 ? startX : startX + i * spacing + spacing / 2;
      nodes.push({
        id: sanitizeId(objective.id),
        label: includeLabels ? `${objective.type}: ${objective.name}` : objective.id,
        x,
        y: yOffset,
        type: "primary",
        shape: "rectangle"
      });
    }
    yOffset -= 2;
  }
  if (thought.optimizationConstraints && thought.optimizationConstraints.length > 0) {
    const startX = thought.optimizationConstraints.length > 1 ? 0 : 4;
    const spacing = thought.optimizationConstraints.length > 1 ? 8 / thought.optimizationConstraints.length : 0;
    for (let i = 0; i < thought.optimizationConstraints.length; i++) {
      const constraint = thought.optimizationConstraints[i];
      const x = thought.optimizationConstraints.length === 1 ? startX : startX + i * spacing + spacing / 2;
      const constraintId = sanitizeId(constraint.id);
      nodes.push({
        id: constraintId,
        label: includeLabels ? constraint.name : constraint.id,
        x,
        y: yOffset,
        type: "warning",
        shape: "diamond"
      });
      if (thought.objectives) {
        for (const objective of thought.objectives) {
          edges.push({
            source: constraintId,
            target: sanitizeId(objective.id),
            directed: true
          });
        }
      }
    }
    yOffset -= 2;
  }
  if (thought.solution) {
    const solutionLabel = includeMetrics && thought.solution.quality ? `Solution (${thought.solution.quality.toFixed(2)})` : "Solution";
    nodes.push({
      id: "solution",
      label: solutionLabel,
      x: 4,
      y: yOffset,
      type: "success",
      shape: "ellipse"
    });
    if (thought.objectives) {
      for (const objective of thought.objectives) {
        edges.push({
          source: sanitizeId(objective.id),
          target: "solution",
          directed: true
        });
      }
    }
  }
  return generateTikZ(nodes, edges, {
    title: "Optimization Solution",
    colorScheme,
    includeLabels,
    includeMetrics
  });
}
function optimizationToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Optimization Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  if (thought.problem) {
    const problemContent = `
      <p><strong>Name:</strong> ${escapeHTML(thought.problem.name)}</p>
      <p><strong>Type:</strong> ${renderBadge(thought.problem.type.toUpperCase(), "info")}</p>
      <p>${escapeHTML(thought.problem.description)}</p>
    `;
    html += renderSection("Problem", problemContent, "\u{1F3AF}");
  }
  if (includeMetrics) {
    html += '<div class="metrics-grid">\n';
    html += renderMetricCard("Variables", thought.variables?.length || 0, "primary");
    html += renderMetricCard("Constraints", thought.optimizationConstraints?.length || 0, "warning");
    html += renderMetricCard("Objectives", thought.objectives?.length || 0, "info");
    html += renderMetricCard("Quality", thought.solution?.quality?.toFixed(2) || "N/A", "success");
    html += "</div>\n";
  }
  if (thought.variables && thought.variables.length > 0) {
    const variableRows = thought.variables.map((v) => {
      const varType = v.type || "unknown";
      const domain = v.domain ? `[${v.domain.lowerBound}, ${v.domain.upperBound}]` : "N/A";
      return [v.name, varType, domain, v.description];
    });
    const variablesTable = renderTable(
      ["Name", "Type", "Domain", "Description"],
      variableRows,
      { caption: "Decision Variables" }
    );
    html += renderSection("Decision Variables", variablesTable, "\u{1F522}");
  }
  if (thought.optimizationConstraints && thought.optimizationConstraints.length > 0) {
    let constraintsContent = "";
    for (const constraint of thought.optimizationConstraints) {
      const badge = renderBadge(constraint.type.toUpperCase(), "warning");
      constraintsContent += `
        <div class="card">
          <div class="card-header">${escapeHTML(constraint.name)} ${badge}</div>
          <p><strong>Formula:</strong> <code>${escapeHTML(constraint.formula)}</code></p>
        </div>
      `;
    }
    html += renderSection("Constraints", constraintsContent, "\u26A0\uFE0F");
  }
  if (thought.objectives && thought.objectives.length > 0) {
    let objectivesContent = "";
    for (const objective of thought.objectives) {
      const typeColor = objective.type === "maximize" ? "success" : "info";
      const badge = renderBadge(objective.type.toUpperCase(), typeColor);
      objectivesContent += `
        <div class="card">
          <div class="card-header">${badge} ${escapeHTML(objective.name)}</div>
          <p><strong>Formula:</strong> <code>${escapeHTML(objective.formula)}</code></p>
        </div>
      `;
    }
    html += renderSection("Objectives", objectivesContent, "\u{1F3AF}");
  }
  if (thought.solution) {
    const solution = thought.solution;
    let solutionContent = "";
    if (solution.status) {
      const statusBadge = solution.status === "optimal" ? renderBadge("OPTIMAL", "success") : solution.status === "feasible" ? renderBadge("FEASIBLE", "info") : renderBadge("INFEASIBLE", "danger");
      solutionContent += `<p><strong>Status:</strong> ${statusBadge}</p>`;
    }
    if (solution.optimalValue !== void 0) {
      solutionContent += `<p><strong>Optimal Value:</strong> ${solution.optimalValue}</p>`;
    }
    if (solution.quality !== void 0) {
      solutionContent += `<p><strong>Quality:</strong> ${(solution.quality * 100).toFixed(0)}%</p>`;
    }
    if (solution.assignments) {
      solutionContent += "<h4>Variable Assignments</h4><ul>";
      for (const [varId, value] of Object.entries(solution.assignments)) {
        solutionContent += `<li><strong>${escapeHTML(varId)}:</strong> ${value}</li>`;
      }
      solutionContent += "</ul>";
    }
    html += renderSection("Solution", solutionContent, "\u2705");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function optimizationToModelica(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  let modelica = "// Optimization Problem Model\n";
  const packageName = thought.problem ? sanitizeModelicaId(thought.problem.name) : "OptimizationProblem";
  modelica += `package ${packageName}
`;
  if (thought.problem) {
    modelica += `  annotation(Documentation(info="${escapeModelicaString(thought.problem.description)}"));

`;
  }
  if (thought.variables && thought.variables.length > 0) {
    modelica += "  // Decision Variables\n";
    for (const variable of thought.variables) {
      const varId = sanitizeModelicaId(variable.id);
      const varType = variable.type || "Real";
      const domain = variable.domain ? `(min=${variable.domain.lowerBound}, max=${variable.domain.upperBound})` : "";
      const comment = includeLabels && variable.description ? ` "${escapeModelicaString(variable.description)}"` : "";
      modelica += `  ${varType} ${varId}${domain}${comment};
`;
    }
    modelica += "\n";
  }
  if (thought.objectives && thought.objectives.length > 0) {
    modelica += "  // Objective Functions\n";
    for (const objective of thought.objectives) {
      const objId = sanitizeModelicaId(objective.id);
      const comment = includeLabels ? ` "${objective.type}: ${escapeModelicaString(objective.name)}"` : "";
      modelica += `  Real ${objId}${comment};
`;
      modelica += `  equation
`;
      modelica += `    ${objId} = ${escapeModelicaString(objective.formula)};
`;
    }
    modelica += "\n";
  }
  if (thought.optimizationConstraints && thought.optimizationConstraints.length > 0) {
    modelica += "  // Constraints\n";
    modelica += "  equation\n";
    for (const constraint of thought.optimizationConstraints) {
      const comment = includeLabels ? ` // ${constraint.name} (${constraint.type})` : "";
      modelica += `    ${escapeModelicaString(constraint.formula)};${comment}
`;
    }
    modelica += "\n";
  }
  if (thought.solution) {
    modelica += "  // Solution\n";
    modelica += "  record Solution\n";
    const solution = thought.solution;
    if (solution.status) {
      modelica += `    String status = "${escapeModelicaString(solution.status)}";
`;
    }
    if (solution.optimalValue !== void 0) {
      modelica += `    Real optimalValue = ${solution.optimalValue};
`;
    }
    if (includeMetrics && solution.quality !== void 0) {
      modelica += `    Real quality = ${solution.quality.toFixed(4)};
`;
    }
    if (solution.assignments) {
      modelica += "    // Variable Assignments\n";
      for (const [varId, value] of Object.entries(solution.assignments)) {
        const safeVarId = sanitizeModelicaId(varId);
        modelica += `    Real ${safeVarId}_value = ${value};
`;
      }
    }
    modelica += "  end Solution;\n";
  }
  modelica += `end ${packageName};
`;
  return modelica;
}
function optimizationToUML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  if (thought.problem) {
    nodes.push({
      id: "Problem",
      label: includeLabels ? thought.problem.name : "Problem",
      shape: "package",
      attributes: [
        `type: ${thought.problem.type}`,
        `description: ${thought.problem.description}`
      ]
    });
  }
  if (thought.variables && thought.variables.length > 0) {
    const attributes = thought.variables.map((v) => {
      const varType = v.type || "Real";
      const domain = v.domain ? ` [${v.domain.lowerBound}..${v.domain.upperBound}]` : "";
      return `${v.name}: ${varType}${domain}`;
    });
    nodes.push({
      id: "Variables",
      label: "Decision Variables",
      shape: "class",
      attributes
    });
    if (thought.problem) {
      edges.push({
        source: "Problem",
        target: "Variables",
        type: "composition",
        label: "contains"
      });
    }
  }
  if (thought.optimizationConstraints && thought.optimizationConstraints.length > 0) {
    const methods = thought.optimizationConstraints.map(
      (c) => `${c.name}(): ${c.type} = ${c.formula}`
    );
    nodes.push({
      id: "Constraints",
      label: "Constraints",
      shape: "class",
      stereotype: "constraint",
      methods
    });
    if (thought.problem) {
      edges.push({
        source: "Problem",
        target: "Constraints",
        type: "composition",
        label: "enforces"
      });
    }
    if (thought.variables) {
      edges.push({
        source: "Constraints",
        target: "Variables",
        type: "dependency",
        label: "constrains"
      });
    }
  }
  if (thought.objectives && thought.objectives.length > 0) {
    const methods = thought.objectives.map(
      (o) => `${o.name}(): ${o.type} = ${o.formula}`
    );
    nodes.push({
      id: "Objectives",
      label: "Objective Functions",
      shape: "interface",
      stereotype: "interface",
      methods
    });
    if (thought.problem) {
      edges.push({
        source: "Problem",
        target: "Objectives",
        type: "composition",
        label: "optimizes"
      });
    }
    if (thought.variables) {
      edges.push({
        source: "Objectives",
        target: "Variables",
        type: "dependency",
        label: "uses"
      });
    }
  }
  if (thought.solution) {
    const solution = thought.solution;
    const attributes = [];
    if (solution.status) {
      attributes.push(`status: ${solution.status}`);
    }
    if (solution.optimalValue !== void 0) {
      attributes.push(`optimalValue: ${solution.optimalValue}`);
    }
    if (includeMetrics && solution.quality !== void 0) {
      attributes.push(`quality: ${solution.quality.toFixed(2)}`);
    }
    if (solution.assignments) {
      for (const [varId, value] of Object.entries(solution.assignments)) {
        attributes.push(`${varId} = ${value}`);
      }
    }
    nodes.push({
      id: "Solution",
      label: "Solution",
      shape: "class",
      stereotype: "result",
      attributes
    });
    if (thought.objectives) {
      edges.push({
        source: "Solution",
        target: "Objectives",
        type: "implementation",
        label: "satisfies"
      });
    }
  }
  return generateUmlDiagram(nodes, edges, {
    title: "Optimization Problem Structure"});
}
function optimizationToJSON(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const graph = createJsonGraph("Optimization Problem Graph", "optimization");
  let edgeIdCounter = 0;
  if (thought.problem) {
    addNode(graph, {
      id: "problem",
      label: includeLabels ? thought.problem.name : "Problem",
      type: "problem",
      metadata: {
        problemType: thought.problem.type,
        description: thought.problem.description
      }
    });
  }
  if (thought.variables && thought.variables.length > 0) {
    for (const variable of thought.variables) {
      addNode(graph, {
        id: variable.id,
        label: includeLabels ? variable.name : variable.id,
        type: "variable",
        metadata: {
          variableType: variable.type || "Real",
          domain: variable.domain,
          description: variable.description
        }
      });
      if (thought.problem) {
        addEdge(graph, {
          id: `e${edgeIdCounter++}`,
          source: "problem",
          target: variable.id,
          label: "has_variable"
        });
      }
    }
  }
  if (thought.optimizationConstraints && thought.optimizationConstraints.length > 0) {
    for (const constraint of thought.optimizationConstraints) {
      addNode(graph, {
        id: constraint.id,
        label: includeLabels ? constraint.name : constraint.id,
        type: "constraint",
        metadata: {
          constraintType: constraint.type,
          formula: constraint.formula
        }
      });
      if (thought.problem) {
        addEdge(graph, {
          id: `e${edgeIdCounter++}`,
          source: "problem",
          target: constraint.id,
          label: "enforces"
        });
      }
    }
  }
  if (thought.objectives && thought.objectives.length > 0) {
    for (const objective of thought.objectives) {
      addNode(graph, {
        id: objective.id,
        label: includeLabels ? objective.name : objective.id,
        type: "objective",
        metadata: {
          objectiveType: objective.type,
          formula: objective.formula
        }
      });
      if (thought.problem) {
        addEdge(graph, {
          id: `e${edgeIdCounter++}`,
          source: "problem",
          target: objective.id,
          label: "optimizes"
        });
      }
      if (thought.solution) {
        addEdge(graph, {
          id: `e${edgeIdCounter++}`,
          source: objective.id,
          target: "solution",
          label: "achieved_by"
        });
      }
    }
  }
  if (thought.solution) {
    const solution = thought.solution;
    addNode(graph, {
      id: "solution",
      label: "Solution",
      type: "solution",
      metadata: {
        status: solution.status,
        optimalValue: solution.optimalValue,
        quality: solution.quality,
        assignments: solution.assignments
      }
    });
  }
  if (includeMetrics) {
    addMetric(graph, "variable_count", thought.variables?.length || 0);
    addMetric(graph, "constraint_count", thought.optimizationConstraints?.length || 0);
    addMetric(graph, "objective_count", thought.objectives?.length || 0);
    if (thought.solution?.quality !== void 0) {
      addMetric(graph, "solution_quality", thought.solution.quality);
    }
  }
  return serializeGraph(graph);
}
function optimizationToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  if (thought.problem) {
    const problemContent = keyValueSection({
      "Name": thought.problem.name,
      "Type": thought.problem.type,
      "Description": thought.problem.description
    });
    parts.push(section("Problem", problemContent));
  }
  if (includeMetrics) {
    const metricsContent = keyValueSection({
      "Variables": thought.variables?.length || 0,
      "Constraints": thought.optimizationConstraints?.length || 0,
      "Objectives": thought.objectives?.length || 0,
      "Quality": thought.solution?.quality?.toFixed(2) || "N/A"
    });
    parts.push(section("Metrics", metricsContent));
  }
  if (thought.variables && thought.variables.length > 0) {
    const variableRows = thought.variables.map((v) => {
      const varType = v.type || "unknown";
      const domain = v.domain ? `[${v.domain.lowerBound}, ${v.domain.upperBound}]` : "N/A";
      return [v.name, varType, domain, v.description];
    });
    const variablesTable = table(
      ["Name", "Type", "Domain", "Description"],
      variableRows
    );
    parts.push(section("Decision Variables", variablesTable));
  }
  if (thought.optimizationConstraints && thought.optimizationConstraints.length > 0) {
    const constraintItems = thought.optimizationConstraints.map(
      (c) => `**${c.name}** (${c.type})
  - Formula: \`${c.formula}\``
    );
    parts.push(section("Constraints", list(constraintItems)));
  }
  if (thought.objectives && thought.objectives.length > 0) {
    const objectiveItems = thought.objectives.map(
      (o) => `**${o.type.toUpperCase()}: ${o.name}**
  - Formula: \`${o.formula}\``
    );
    parts.push(section("Objectives", list(objectiveItems)));
  }
  if (thought.solution) {
    const solution = thought.solution;
    let solutionContent = "";
    if (solution.status) {
      solutionContent += `**Status:** ${solution.status}

`;
    }
    const solutionMetrics = {};
    if (solution.optimalValue !== void 0) {
      solutionMetrics["Optimal Value"] = solution.optimalValue;
    }
    if (solution.quality !== void 0) {
      solutionMetrics["Quality"] = `${(solution.quality * 100).toFixed(0)}%`;
    }
    if (Object.keys(solutionMetrics).length > 0) {
      solutionContent += keyValueSection(solutionMetrics);
    }
    if (solution.assignments) {
      solutionContent += "\n**Variable Assignments:**\n\n";
      solutionContent += keyValueSection(solution.assignments);
    }
    parts.push(section("Solution", solutionContent));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = optimizationToMermaid(thought, "default", true, true);
    parts.push(section("Optimization Diagram", mermaidBlock(mermaidDiagram)));
  }
  return document("Optimization Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: { mode: "optimization" }
  });
}
var init_optimization = __esm({
  "src/export/visual/optimization.ts"() {
    init_esm_shims();
    init_utils();
    init_svg_utils();
    init_graphml_utils();
    init_tikz_utils();
    init_html_utils();
    init_modelica_utils();
    init_uml_utils();
    init_json_utils();
    init_markdown_utils();
  }
});

// src/export/visual/formal-logic.ts
function exportFormalLogicProof(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return formalLogicToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return formalLogicToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return formalLogicToASCII(thought);
    case "svg":
      return formalLogicToSVG(thought, options);
    case "graphml":
      return formalLogicToGraphML(thought, options);
    case "tikz":
      return formalLogicToTikZ(thought, options);
    case "html":
      return formalLogicToHTML(thought, options);
    case "modelica":
      return formalLogicToModelica(thought, options);
    case "uml":
      return formalLogicToUML(thought, options);
    case "json":
      return formalLogicToJSON(thought, options);
    case "markdown":
      return formalLogicToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function formalLogicToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TD\n";
  if (thought.propositions && thought.propositions.length > 0) {
    mermaid += '  subgraph Propositions["Propositions"]\n';
    for (const proposition of thought.propositions) {
      const propId = sanitizeId(proposition.id);
      const label = includeLabels ? `${proposition.symbol}: ${proposition.statement.substring(0, 40)}...` : proposition.symbol;
      const shape = proposition.type === "atomic" ? ["[", "]"] : ["[[", "]]"];
      mermaid += `    ${propId}${shape[0]}${label}${shape[1]}
`;
    }
    mermaid += "  end\n\n";
  }
  if (thought.proof && thought.proof.steps && thought.proof.steps.length > 0) {
    mermaid += '  Theorem["Theorem"]\n';
    for (const step of thought.proof.steps) {
      const stepId = `Step${step.stepNumber}`;
      const label = includeLabels ? `${step.stepNumber}. ${step.statement.substring(0, 40)}...` : `Step ${step.stepNumber}`;
      mermaid += `  ${stepId}["${label}"]
`;
      if (step.referencesSteps && step.referencesSteps.length > 0) {
        for (const refStep of step.referencesSteps) {
          mermaid += `  Step${refStep} --> ${stepId}
`;
        }
      }
    }
    const lastStep = thought.proof.steps[thought.proof.steps.length - 1];
    mermaid += `  Step${lastStep.stepNumber} --> Theorem
`;
    if (includeMetrics) {
      const completeness = (thought.proof.completeness * 100).toFixed(0);
      mermaid += `
  Completeness["Completeness: ${completeness}%"]
`;
      mermaid += `  Completeness -.-> Theorem
`;
    }
  }
  if (thought.logicalInferences && thought.logicalInferences.length > 0) {
    mermaid += "\n";
    for (const inference of thought.logicalInferences) {
      const infId = sanitizeId(inference.id);
      const label = includeLabels ? inference.rule : infId;
      mermaid += `  ${infId}{{"${label}"}}
`;
      if (inference.premises) {
        for (const premiseId of inference.premises) {
          const propId = sanitizeId(premiseId);
          mermaid += `  ${propId} --> ${infId}
`;
        }
      }
      const conclusionId = sanitizeId(inference.conclusion);
      mermaid += `  ${infId} --> ${conclusionId}
`;
    }
  }
  if (colorScheme !== "monochrome") {
    mermaid += "\n";
    const atomicColor = colorScheme === "pastel" ? "#e1f5ff" : "#a8d5ff";
    const compoundColor = colorScheme === "pastel" ? "#fff3e0" : "#ffd699";
    if (thought.propositions) {
      for (const proposition of thought.propositions) {
        const propId = sanitizeId(proposition.id);
        const color = proposition.type === "atomic" ? atomicColor : compoundColor;
        mermaid += `  style ${propId} fill:${color}
`;
      }
    }
  }
  return mermaid;
}
function formalLogicToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph FormalLogic {\n";
  dot += "  rankdir=TD;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  if (thought.propositions && thought.propositions.length > 0) {
    dot += "  subgraph cluster_propositions {\n";
    dot += '    label="Propositions";\n';
    for (const proposition of thought.propositions) {
      const propId = sanitizeId(proposition.id);
      const label = includeLabels ? `${proposition.symbol}:\\n${proposition.statement.substring(0, 40)}...` : proposition.symbol;
      const shape = proposition.type === "atomic" ? "ellipse" : "box";
      dot += `    ${propId} [label="${label}", shape=${shape}];
`;
    }
    dot += "  }\n\n";
  }
  if (thought.proof && thought.proof.steps && thought.proof.steps.length > 0) {
    dot += `  Theorem [label="Theorem:\\n${thought.proof.theorem.substring(0, 50)}...", shape=doubleoctagon, style=bold];

`;
    for (const step of thought.proof.steps) {
      const stepId = `Step${step.stepNumber}`;
      const label = includeLabels ? `${step.stepNumber}. ${step.statement.substring(0, 40)}...` : `Step ${step.stepNumber}`;
      const ruleLabel = step.rule ? `\\n(${step.rule})` : "";
      dot += `  ${stepId} [label="${label}${ruleLabel}"];
`;
      if (step.referencesSteps) {
        for (const refStep of step.referencesSteps) {
          dot += `  Step${refStep} -> ${stepId};
`;
        }
      }
    }
    const lastStep = thought.proof.steps[thought.proof.steps.length - 1];
    dot += `  Step${lastStep.stepNumber} -> Theorem;
`;
    if (includeMetrics) {
      const completeness = (thought.proof.completeness * 100).toFixed(0);
      dot += `
  Completeness [label="Completeness: ${completeness}%", shape=note];
`;
    }
  }
  if (thought.logicalInferences && thought.logicalInferences.length > 0) {
    dot += "\n";
    for (const inference of thought.logicalInferences) {
      const infId = sanitizeId(inference.id);
      const label = includeLabels ? inference.rule : infId;
      dot += `  ${infId} [label="${label}", shape=diamond];
`;
      if (inference.premises) {
        for (const premiseId of inference.premises) {
          const propId = sanitizeId(premiseId);
          dot += `  ${propId} -> ${infId};
`;
        }
      }
      const conclusionId = sanitizeId(inference.conclusion);
      dot += `  ${infId} -> ${conclusionId};
`;
    }
  }
  dot += "}\n";
  return dot;
}
function formalLogicToASCII(thought) {
  let ascii = "Formal Logic Proof:\n";
  ascii += "==================\n\n";
  if (thought.propositions && thought.propositions.length > 0) {
    ascii += "Propositions:\n";
    for (const proposition of thought.propositions) {
      const typeMarker = proposition.type === "atomic" ? "\u25CF" : "\u25C6";
      ascii += `  ${typeMarker} ${proposition.symbol}: ${proposition.statement}
`;
    }
    ascii += "\n";
  }
  if (thought.logicalInferences && thought.logicalInferences.length > 0) {
    ascii += "Inferences:\n";
    for (const inference of thought.logicalInferences) {
      ascii += `  [${inference.rule}]
`;
      ascii += `    Premises: ${inference.premises.join(", ")}
`;
      ascii += `    Conclusion: ${inference.conclusion}
`;
      ascii += `    Valid: ${inference.valid ? "\u2713" : "\u2717"}
`;
    }
    ascii += "\n";
  }
  if (thought.proof) {
    ascii += `Proof: ${thought.proof.theorem}
`;
    ascii += `Technique: ${thought.proof.technique}
`;
    ascii += `Completeness: ${(thought.proof.completeness * 100).toFixed(0)}%

`;
    if (thought.proof.steps && thought.proof.steps.length > 0) {
      ascii += "Proof Steps:\n";
      for (const step of thought.proof.steps) {
        ascii += `  ${step.stepNumber}. ${step.statement}
`;
        ascii += `     Justification: ${step.justification}
`;
      }
      ascii += "\n";
    }
    ascii += `Conclusion: ${thought.proof.conclusion}
`;
    ascii += `Valid: ${thought.proof.valid ? "\u2713" : "\u2717"}
`;
  }
  if (thought.truthTable) {
    ascii += "\nTruth Table:\n";
    ascii += `  Tautology: ${thought.truthTable.isTautology ? "\u2713" : "\u2717"}
`;
    ascii += `  Contradiction: ${thought.truthTable.isContradiction ? "\u2713" : "\u2717"}
`;
    ascii += `  Contingent: ${thought.truthTable.isContingent ? "\u2713" : "\u2717"}
`;
  }
  return ascii;
}
function formalLogicToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width,
    svgHeight = DEFAULT_SVG_OPTIONS.height
  } = options;
  const positions = /* @__PURE__ */ new Map();
  const nodeWidth = 150;
  const nodeHeight = 40;
  if (thought.propositions) {
    const propSpacing = Math.min(180, svgWidth / (thought.propositions.length + 1));
    const propStartX = (svgWidth - (thought.propositions.length - 1) * propSpacing) / 2;
    thought.propositions.forEach((prop, index) => {
      positions.set(prop.id, {
        id: prop.id,
        label: includeLabels ? `${prop.symbol}: ${prop.statement.substring(0, 20)}...` : prop.symbol,
        x: propStartX + index * propSpacing,
        y: 80,
        width: nodeWidth,
        height: nodeHeight,
        type: prop.type
      });
    });
  }
  if (thought.proof && thought.proof.steps) {
    thought.proof.steps.forEach((step, index) => {
      const stepId = `Step${step.stepNumber}`;
      positions.set(stepId, {
        id: stepId,
        label: includeLabels ? `${step.stepNumber}. ${step.statement.substring(0, 25)}...` : `Step ${step.stepNumber}`,
        x: 150 + index * 180,
        y: 250,
        width: nodeWidth,
        height: nodeHeight,
        type: "step"
      });
    });
  }
  if (thought.proof) {
    positions.set("Theorem", {
      id: "Theorem",
      label: "Theorem",
      x: svgWidth / 2,
      y: 420,
      width: nodeWidth,
      height: nodeHeight,
      type: "theorem"
    });
  }
  let svg = generateSVGHeader(svgWidth, svgHeight, "Formal Logic Proof");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  if (thought.proof && thought.proof.steps) {
    const theoremPos = positions.get("Theorem");
    for (const step of thought.proof.steps) {
      const stepPos = positions.get(`Step${step.stepNumber}`);
      if (stepPos && theoremPos) {
        svg += renderEdge(stepPos, theoremPos);
      }
      if (step.referencesSteps) {
        for (const refStepNum of step.referencesSteps) {
          const refStepPos = positions.get(`Step${refStepNum}`);
          if (refStepPos && stepPos) {
            svg += renderEdge(refStepPos, stepPos, { style: "dashed" });
          }
        }
      }
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  const atomicColors = getNodeColor("primary", colorScheme);
  const compoundColors = getNodeColor("secondary", colorScheme);
  const stepColors = getNodeColor("neutral", colorScheme);
  const theoremColors = getNodeColor("success", colorScheme);
  for (const [, pos] of positions) {
    if (pos.type === "theorem") {
      svg += renderStadiumNode(pos, theoremColors);
    } else if (pos.type === "step") {
      svg += renderRectNode(pos, stepColors);
    } else if (pos.type === "atomic") {
      svg += renderEllipseNode(pos, atomicColors);
    } else {
      svg += renderRectNode(pos, compoundColors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Propositions", value: thought.propositions?.length || 0 },
      { label: "Proof Steps", value: thought.proof?.steps?.length || 0 },
      { label: "Completeness", value: thought.proof ? `${(thought.proof.completeness * 100).toFixed(0)}%` : "N/A" }
    ];
    svg += renderMetricsPanel(svgWidth - 180, svgHeight - 110, metrics);
  }
  const legendItems = [
    { label: "Atomic", color: atomicColors, shape: "ellipse" },
    { label: "Compound", color: compoundColors },
    { label: "Proof Step", color: stepColors },
    { label: "Theorem", color: theoremColors, shape: "stadium" }
  ];
  svg += renderLegend(20, svgHeight - 130, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function formalLogicToGraphML(thought, options) {
  const { includeLabels = true } = options;
  const nodes = [];
  const edges = [];
  let edgeCount = 0;
  if (thought.propositions && thought.propositions.length > 0) {
    for (const proposition of thought.propositions) {
      nodes.push({
        id: sanitizeId(proposition.id),
        label: includeLabels ? `${proposition.symbol}: ${proposition.statement}` : proposition.symbol,
        type: "premise",
        metadata: {
          propositionType: proposition.type,
          description: proposition.statement
        }
      });
    }
  }
  if (thought.logicalInferences && thought.logicalInferences.length > 0) {
    for (const inference of thought.logicalInferences) {
      const infId = sanitizeId(inference.id);
      nodes.push({
        id: infId,
        label: includeLabels ? inference.rule : infId,
        type: "inference",
        metadata: {
          rule: inference.rule,
          valid: inference.valid
        }
      });
      if (inference.premises) {
        for (const premiseId of inference.premises) {
          edges.push({
            id: `e${edgeCount++}`,
            source: sanitizeId(premiseId),
            target: infId,
            directed: true,
            metadata: { type: "premise-to-inference" }
          });
        }
      }
      edges.push({
        id: `e${edgeCount++}`,
        source: infId,
        target: sanitizeId(inference.conclusion),
        directed: true,
        metadata: { type: "inference-to-conclusion" }
      });
    }
  }
  if (thought.proof && thought.proof.steps && thought.proof.steps.length > 0) {
    for (const step of thought.proof.steps) {
      const stepId = `Step${step.stepNumber}`;
      nodes.push({
        id: stepId,
        label: includeLabels ? `${step.stepNumber}. ${step.statement}` : `Step ${step.stepNumber}`,
        type: "proof-step",
        metadata: {
          stepNumber: step.stepNumber,
          justification: step.justification,
          rule: step.rule
        }
      });
      if (step.referencesSteps && step.referencesSteps.length > 0) {
        for (const refStep of step.referencesSteps) {
          edges.push({
            id: `e${edgeCount++}`,
            source: `Step${refStep}`,
            target: stepId,
            directed: true,
            metadata: { type: "step-reference" }
          });
        }
      }
    }
    nodes.push({
      id: "Theorem",
      label: includeLabels ? thought.proof.theorem : "Theorem",
      type: "conclusion",
      metadata: {
        theorem: thought.proof.theorem,
        valid: thought.proof.valid,
        completeness: thought.proof.completeness
      }
    });
    const lastStep = thought.proof.steps[thought.proof.steps.length - 1];
    edges.push({
      id: `e${edgeCount++}`,
      source: `Step${lastStep.stepNumber}`,
      target: "Theorem",
      directed: true,
      metadata: { type: "step-to-theorem" }
    });
  }
  return generateGraphML(nodes, edges, {
    graphName: "Formal Logic Proof",
    directed: true,
    includeLabels
  });
}
function formalLogicToTikZ(thought, options) {
  const { includeLabels = true, colorScheme = "default" } = options;
  const nodes = [];
  const edges = [];
  let currentY = 0;
  if (thought.propositions && thought.propositions.length > 0) {
    thought.propositions.forEach((proposition, index) => {
      nodes.push({
        id: sanitizeId(proposition.id),
        label: includeLabels ? `${proposition.symbol}: ${proposition.statement.substring(0, 30)}...` : proposition.symbol,
        x: index * 3,
        y: currentY,
        type: "premise",
        shape: "stadium"
      });
    });
    currentY -= 2.5;
  }
  if (thought.logicalInferences && thought.logicalInferences.length > 0) {
    thought.logicalInferences.forEach((inference, index) => {
      const infId = sanitizeId(inference.id);
      nodes.push({
        id: infId,
        label: includeLabels ? inference.rule : infId,
        x: index * 3,
        y: currentY,
        type: "inference",
        shape: "rectangle"
      });
      if (inference.premises) {
        for (const premiseId of inference.premises) {
          edges.push({
            source: sanitizeId(premiseId),
            target: infId,
            directed: true
          });
        }
      }
      edges.push({
        source: infId,
        target: sanitizeId(inference.conclusion),
        directed: true
      });
    });
    currentY -= 2.5;
  }
  if (thought.proof && thought.proof.steps && thought.proof.steps.length > 0) {
    thought.proof.steps.forEach((step, index) => {
      const stepId = `Step${step.stepNumber}`;
      nodes.push({
        id: stepId,
        label: includeLabels ? `${step.stepNumber}. ${step.statement.substring(0, 20)}...` : `Step ${step.stepNumber}`,
        x: index * 3,
        y: currentY,
        type: "neutral",
        shape: "rectangle"
      });
      if (step.referencesSteps && step.referencesSteps.length > 0) {
        for (const refStep of step.referencesSteps) {
          edges.push({
            source: `Step${refStep}`,
            target: stepId,
            directed: true,
            style: "dashed"
          });
        }
      }
    });
    currentY -= 2.5;
    nodes.push({
      id: "Theorem",
      label: includeLabels ? "Theorem" : "T",
      x: (thought.proof.steps.length - 1) * 1.5,
      y: currentY,
      type: "conclusion",
      shape: "ellipse"
    });
    const lastStep = thought.proof.steps[thought.proof.steps.length - 1];
    edges.push({
      source: `Step${lastStep.stepNumber}`,
      target: "Theorem",
      directed: true
    });
  }
  return generateTikZ(nodes, edges, {
    title: "Formal Logic Proof",
    colorScheme,
    includeLabels
  });
}
function formalLogicToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Formal Logic Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  if (thought.proof) {
    const validBadge = thought.proof.valid ? renderBadge("VALID", "success") : renderBadge("INVALID", "danger");
    const proofContent = `
      <p><strong>Theorem:</strong> ${escapeHTML(thought.proof.theorem)}</p>
      <p><strong>Technique:</strong> ${escapeHTML(thought.proof.technique)}</p>
      <p><strong>Validity:</strong> ${validBadge}</p>
      <p><strong>Completeness:</strong> ${(thought.proof.completeness * 100).toFixed(0)}%</p>
      ${renderProgressBar(thought.proof.completeness * 100, "primary")}
    `;
    html += renderSection("Proof", proofContent, "\u{1F4CB}");
  }
  if (includeMetrics) {
    html += '<div class="metrics-grid">\n';
    html += renderMetricCard("Propositions", thought.propositions?.length || 0, "primary");
    html += renderMetricCard("Inferences", thought.logicalInferences?.length || 0, "info");
    html += renderMetricCard("Proof Steps", thought.proof?.steps?.length || 0, "secondary");
    html += renderMetricCard("Completeness", thought.proof ? `${(thought.proof.completeness * 100).toFixed(0)}%` : "N/A", "success");
    html += "</div>\n";
  }
  if (thought.propositions && thought.propositions.length > 0) {
    const propositionRows = thought.propositions.map((p) => [
      p.symbol,
      p.type,
      p.statement,
      p.truthValue !== void 0 ? String(p.truthValue) : "N/A"
    ]);
    const propositionsTable = renderTable(
      ["Symbol", "Type", "Statement", "Truth Value"],
      propositionRows,
      { caption: "Propositions" }
    );
    html += renderSection("Propositions", propositionsTable, "\u{1F4AD}");
  }
  if (thought.logicalInferences && thought.logicalInferences.length > 0) {
    let inferencesContent = "";
    for (const inference of thought.logicalInferences) {
      const validBadge = inference.valid ? renderBadge("VALID", "success") : renderBadge("INVALID", "danger");
      inferencesContent += `
        <div class="card">
          <div class="card-header">${escapeHTML(inference.rule)} ${validBadge}</div>
          <p><strong>Premises:</strong> ${inference.premises.map((p) => escapeHTML(p)).join(", ")}</p>
          <p><strong>Conclusion:</strong> ${escapeHTML(inference.conclusion)}</p>
        </div>
      `;
    }
    html += renderSection("Logical Inferences", inferencesContent, "\u{1F517}");
  }
  if (thought.proof && thought.proof.steps && thought.proof.steps.length > 0) {
    let stepsContent = "<ol>";
    for (const step of thought.proof.steps) {
      stepsContent += `
        <li>
          <strong>${escapeHTML(step.statement)}</strong>
          <p><em>Justification:</em> ${escapeHTML(step.justification)}</p>
          ${step.rule ? `<p><em>Rule:</em> ${renderBadge(step.rule, "info")}</p>` : ""}
          ${step.referencesSteps && step.referencesSteps.length > 0 ? `<p><em>References steps:</em> ${step.referencesSteps.join(", ")}</p>` : ""}
        </li>
      `;
    }
    stepsContent += "</ol>";
    html += renderSection("Proof Steps", stepsContent, "\u{1F4DD}");
  }
  if (thought.proof) {
    const conclusionBadge = thought.proof.valid ? renderBadge("PROVEN", "success") : renderBadge("NOT PROVEN", "danger");
    const conclusionContent = `
      <p>${conclusionBadge}</p>
      <p>${escapeHTML(thought.proof.conclusion)}</p>
    `;
    html += renderSection("Conclusion", conclusionContent, "\u2705");
  }
  if (thought.truthTable) {
    const truthTableContent = `
      <p><strong>Tautology:</strong> ${thought.truthTable.isTautology ? "\u2713" : "\u2717"}</p>
      <p><strong>Contradiction:</strong> ${thought.truthTable.isContradiction ? "\u2713" : "\u2717"}</p>
      <p><strong>Contingent:</strong> ${thought.truthTable.isContingent ? "\u2713" : "\u2717"}</p>
    `;
    html += renderSection("Truth Table", truthTableContent, "\u{1F4CA}");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function formalLogicToModelica(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  let modelica = "package FormalLogicProof\n";
  modelica += '  "Formal logic proof representation"\n\n';
  if (thought.propositions && thought.propositions.length > 0) {
    modelica += "  // Logical Propositions\n";
    for (const proposition of thought.propositions) {
      const propId = sanitizeModelicaId(proposition.id);
      const comment = includeLabels ? ` "${escapeModelicaString(proposition.symbol)}: ${escapeModelicaString(proposition.statement)}"` : "";
      const truthValue = proposition.truthValue !== void 0 ? String(proposition.truthValue) : "false";
      modelica += `  parameter Boolean ${propId} = ${truthValue}${comment};
`;
    }
    modelica += "\n";
  }
  if (thought.logicalInferences && thought.logicalInferences.length > 0) {
    modelica += "  // Inference Rules\n";
    for (const inference of thought.logicalInferences) {
      const ruleName = sanitizeModelicaId(inference.rule.replace(/[^a-zA-Z0-9]/g, "_"));
      modelica += `  function ${ruleName}
`;
      modelica += `    "${escapeModelicaString(inference.rule)}"
`;
      if (inference.premises && inference.premises.length > 0) {
        for (let i = 0; i < inference.premises.length; i++) {
          const premiseId = sanitizeModelicaId(inference.premises[i]);
          modelica += `    input Boolean premise${i + 1} "${escapeModelicaString(premiseId)}";
`;
        }
      }
      modelica += `    output Boolean conclusion "${escapeModelicaString(inference.conclusion)}";
`;
      modelica += `  algorithm
`;
      if (inference.premises && inference.premises.length > 0) {
        const conditions = inference.premises.map((_, i) => `premise${i + 1}`).join(" and ");
        modelica += `    conclusion := ${conditions};
`;
      } else {
        modelica += `    conclusion := false;
`;
      }
      modelica += `  end ${ruleName};

`;
    }
  }
  if (thought.proof && thought.proof.steps && thought.proof.steps.length > 0) {
    modelica += "  // Proof Steps\n";
    modelica += `  model ProofSequence
`;
    modelica += `    "${escapeModelicaString(thought.proof.theorem)}"

`;
    for (const step of thought.proof.steps) {
      const stepId = sanitizeModelicaId(`Step${step.stepNumber}`);
      const comment = includeLabels ? ` "${escapeModelicaString(step.statement)}"` : "";
      modelica += `    parameter Boolean ${stepId} = true${comment};
`;
      if (step.rule) {
        modelica += `    // Rule: ${escapeModelicaString(step.rule)}
`;
      }
      if (step.justification) {
        modelica += `    // Justification: ${escapeModelicaString(step.justification)}
`;
      }
    }
    modelica += "\n";
    const validStr = thought.proof.valid ? "true" : "false";
    modelica += `    parameter Boolean theoremProven = ${validStr} "Theorem is proven";
`;
    if (includeMetrics) {
      const completeness = thought.proof.completeness.toFixed(4);
      modelica += `    parameter Real completeness = ${completeness} "Proof completeness (0-1)";
`;
    }
    modelica += `  end ProofSequence;

`;
  }
  if (includeMetrics) {
    modelica += "  // Proof Metrics\n";
    modelica += `  constant Integer propositionCount = ${thought.propositions?.length || 0};
`;
    modelica += `  constant Integer inferenceCount = ${thought.logicalInferences?.length || 0};
`;
    modelica += `  constant Integer proofStepCount = ${thought.proof?.steps?.length || 0};
`;
    if (thought.truthTable) {
      modelica += `  constant Boolean isTautology = ${thought.truthTable.isTautology};
`;
      modelica += `  constant Boolean isContradiction = ${thought.truthTable.isContradiction};
`;
      modelica += `  constant Boolean isContingent = ${thought.truthTable.isContingent};
`;
    }
  }
  modelica += "end FormalLogicProof;\n";
  return modelica;
}
function formalLogicToUML(thought, options) {
  const { includeLabels = true } = options;
  const nodes = [];
  const edges = [];
  if (thought.propositions && thought.propositions.length > 0) {
    for (const proposition of thought.propositions) {
      const propId = sanitizeId(proposition.id);
      const attributes = [];
      if (includeLabels) {
        attributes.push(`symbol: ${proposition.symbol}`);
        attributes.push(`type: ${proposition.type}`);
        if (proposition.truthValue !== void 0) {
          attributes.push(`truth: ${proposition.truthValue}`);
        }
      }
      nodes.push({
        id: propId,
        label: includeLabels ? proposition.symbol : propId,
        shape: "class",
        stereotype: "premise",
        attributes
      });
    }
  }
  if (thought.logicalInferences && thought.logicalInferences.length > 0) {
    for (const inference of thought.logicalInferences) {
      const infId = sanitizeId(inference.id);
      const operations = [];
      if (includeLabels) {
        operations.push(`apply(): Boolean`);
      }
      nodes.push({
        id: infId,
        label: includeLabels ? inference.rule : infId,
        shape: "class",
        stereotype: "inference",
        attributes: [`valid: ${inference.valid}`],
        methods: operations
      });
      if (inference.premises) {
        for (const premiseId of inference.premises) {
          const propId = sanitizeId(premiseId);
          edges.push({
            source: propId,
            target: infId,
            type: "dependency",
            label: "premise"
          });
        }
      }
      const conclusionId = sanitizeId(inference.conclusion);
      edges.push({
        source: infId,
        target: conclusionId,
        type: "implementation",
        label: "derives"
      });
    }
  }
  if (thought.proof && thought.proof.steps && thought.proof.steps.length > 0) {
    for (const step of thought.proof.steps) {
      const stepId = `Step${step.stepNumber}`;
      const attributes = [];
      if (includeLabels) {
        attributes.push(`number: ${step.stepNumber}`);
        if (step.rule) {
          attributes.push(`rule: ${step.rule}`);
        }
      }
      nodes.push({
        id: stepId,
        label: includeLabels ? `Step ${step.stepNumber}` : stepId,
        shape: "class",
        stereotype: "proof-step",
        attributes
      });
      if (step.referencesSteps && step.referencesSteps.length > 0) {
        for (const refStep of step.referencesSteps) {
          edges.push({
            source: `Step${refStep}`,
            target: stepId,
            type: "dependency",
            label: "uses"
          });
        }
      }
    }
    nodes.push({
      id: "Theorem",
      label: includeLabels ? "Theorem" : "T",
      shape: "class",
      stereotype: "conclusion",
      attributes: [
        `valid: ${thought.proof.valid}`,
        `completeness: ${(thought.proof.completeness * 100).toFixed(0)}%`
      ]
    });
    const lastStep = thought.proof.steps[thought.proof.steps.length - 1];
    edges.push({
      source: `Step${lastStep.stepNumber}`,
      target: "Theorem",
      type: "implementation",
      label: "proves"
    });
  }
  return generateUmlDiagram(nodes, edges, {
    title: "Formal Logic Proof"});
}
function formalLogicToJSON(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const graph = createJsonGraph("Formal Logic Proof", "formal-logic", { includeMetrics });
  if (thought.propositions && thought.propositions.length > 0) {
    for (const proposition of thought.propositions) {
      addNode(graph, {
        id: proposition.id,
        label: includeLabels ? `${proposition.symbol}: ${proposition.statement}` : proposition.symbol,
        type: "premise",
        metadata: {
          symbol: proposition.symbol,
          propositionType: proposition.type,
          statement: proposition.statement,
          truthValue: proposition.truthValue
        }
      });
    }
  }
  let edgeId = 0;
  if (thought.logicalInferences && thought.logicalInferences.length > 0) {
    for (const inference of thought.logicalInferences) {
      const infId = inference.id;
      addNode(graph, {
        id: infId,
        label: includeLabels ? inference.rule : infId,
        type: "inference",
        metadata: {
          rule: inference.rule,
          valid: inference.valid,
          premises: inference.premises,
          conclusion: inference.conclusion
        }
      });
      if (inference.premises) {
        for (const premiseId of inference.premises) {
          addEdge(graph, {
            id: `edge_${edgeId++}`,
            source: premiseId,
            target: infId,
            label: "premise",
            metadata: { type: "premise-to-inference" }
          });
        }
      }
      addEdge(graph, {
        id: `edge_${edgeId++}`,
        source: infId,
        target: inference.conclusion,
        label: "derives",
        metadata: { type: "inference-to-conclusion" }
      });
    }
  }
  if (thought.proof && thought.proof.steps && thought.proof.steps.length > 0) {
    for (const step of thought.proof.steps) {
      const stepId = `Step${step.stepNumber}`;
      addNode(graph, {
        id: stepId,
        label: includeLabels ? `${step.stepNumber}. ${step.statement}` : `Step ${step.stepNumber}`,
        type: "proof-step",
        metadata: {
          stepNumber: step.stepNumber,
          statement: step.statement,
          justification: step.justification,
          rule: step.rule,
          referencesSteps: step.referencesSteps
        }
      });
      if (step.referencesSteps && step.referencesSteps.length > 0) {
        for (const refStep of step.referencesSteps) {
          addEdge(graph, {
            id: `edge_${edgeId++}`,
            source: `Step${refStep}`,
            target: stepId,
            label: "uses",
            metadata: { type: "step-reference" }
          });
        }
      }
    }
    addNode(graph, {
      id: "Theorem",
      label: includeLabels ? thought.proof.theorem : "Theorem",
      type: "conclusion",
      metadata: {
        theorem: thought.proof.theorem,
        technique: thought.proof.technique,
        valid: thought.proof.valid,
        completeness: thought.proof.completeness,
        conclusion: thought.proof.conclusion
      }
    });
    const lastStep = thought.proof.steps[thought.proof.steps.length - 1];
    addEdge(graph, {
      id: `edge_${edgeId++}`,
      source: `Step${lastStep.stepNumber}`,
      target: "Theorem",
      label: "proves",
      metadata: { type: "step-to-theorem" }
    });
  }
  if (includeMetrics) {
    addMetric(graph, "propositionCount", thought.propositions?.length || 0);
    addMetric(graph, "inferenceCount", thought.logicalInferences?.length || 0);
    addMetric(graph, "proofStepCount", thought.proof?.steps?.length || 0);
    if (thought.proof) {
      addMetric(graph, "proofValid", thought.proof.valid);
      addMetric(graph, "proofCompleteness", thought.proof.completeness);
    }
    if (thought.truthTable) {
      addMetric(graph, "isTautology", thought.truthTable.isTautology);
      addMetric(graph, "isContradiction", thought.truthTable.isContradiction);
      addMetric(graph, "isContingent", thought.truthTable.isContingent);
    }
  }
  return serializeGraph(graph);
}
function formalLogicToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  if (thought.proof) {
    const proofContent = keyValueSection({
      "Theorem": thought.proof.theorem,
      "Technique": thought.proof.technique,
      "Valid": thought.proof.valid ? "Yes" : "No",
      "Completeness": `${(thought.proof.completeness * 100).toFixed(0)}%`
    });
    parts.push(section("Proof", proofContent));
  }
  if (includeMetrics) {
    const metricsContent = keyValueSection({
      "Propositions": thought.propositions?.length || 0,
      "Inferences": thought.logicalInferences?.length || 0,
      "Proof Steps": thought.proof?.steps?.length || 0,
      "Completeness": thought.proof ? `${(thought.proof.completeness * 100).toFixed(0)}%` : "N/A"
    });
    parts.push(section("Metrics", metricsContent));
  }
  if (thought.propositions && thought.propositions.length > 0) {
    const propositionRows = thought.propositions.map((p) => [
      p.symbol,
      p.type,
      p.statement,
      p.truthValue !== void 0 ? String(p.truthValue) : "N/A"
    ]);
    const propositionsTable = table(
      ["Symbol", "Type", "Statement", "Truth Value"],
      propositionRows
    );
    parts.push(section("Propositions", propositionsTable));
  }
  if (thought.logicalInferences && thought.logicalInferences.length > 0) {
    const inferenceItems = thought.logicalInferences.map(
      (inf) => `**${inf.rule}** (${inf.valid ? "Valid" : "Invalid"})
  - Premises: ${inf.premises.join(", ")}
  - Conclusion: ${inf.conclusion}`
    );
    parts.push(section("Logical Inferences", list(inferenceItems)));
  }
  if (thought.proof && thought.proof.steps && thought.proof.steps.length > 0) {
    const stepItems = thought.proof.steps.map(
      (step) => `**${step.stepNumber}. ${step.statement}**
  - Justification: ${step.justification}${step.rule ? `
  - Rule: ${step.rule}` : ""}${step.referencesSteps && step.referencesSteps.length > 0 ? `
  - References steps: ${step.referencesSteps.join(", ")}` : ""}`
    );
    parts.push(section("Proof Steps", list(stepItems)));
  }
  if (thought.proof) {
    const conclusionContent = `${thought.proof.conclusion}

**Status:** ${thought.proof.valid ? "PROVEN" : "NOT PROVEN"}`;
    parts.push(section("Conclusion", conclusionContent));
  }
  if (thought.truthTable) {
    const truthTableContent = keyValueSection({
      "Tautology": thought.truthTable.isTautology ? "Yes" : "No",
      "Contradiction": thought.truthTable.isContradiction ? "Yes" : "No",
      "Contingent": thought.truthTable.isContingent ? "Yes" : "No"
    });
    parts.push(section("Truth Table", truthTableContent));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = formalLogicToMermaid(thought, "default", true, true);
    parts.push(section("Proof Tree Diagram", mermaidBlock(mermaidDiagram)));
  }
  return document("Formal Logic Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: { mode: "formal-logic" }
  });
}
var init_formal_logic = __esm({
  "src/export/visual/formal-logic.ts"() {
    init_esm_shims();
    init_utils();
    init_svg_utils();
    init_graphml_utils();
    init_tikz_utils();
    init_html_utils();
    init_modelica_utils();
    init_uml_utils();
    init_json_utils();
    init_markdown_utils();
  }
});

// src/export/visual/mathematics.ts
function exportMathematicsDerivation(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return mathematicsToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return mathematicsToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return mathematicsToASCII(thought);
    case "svg":
      return mathematicsToSVG(thought, options);
    case "graphml":
      return mathematicsToGraphML(thought, options);
    case "tikz":
      return mathematicsToTikZ(thought, options);
    case "html":
      return mathematicsToHTML(thought, options);
    case "modelica":
      return mathematicsToModelica(thought, options);
    case "uml":
      return mathematicsToUML(thought, options);
    case "json":
      return mathematicsToJSON(thought, options);
    case "markdown":
      return mathematicsToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function mathematicsToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TB\n";
  const typeId = sanitizeId(`type_${thought.thoughtType || "proof"}`);
  const typeLabel = includeLabels ? (thought.thoughtType || "Proof").replace(/_/g, " ") : typeId;
  mermaid += `  ${typeId}[["${typeLabel}"]]
`;
  if (thought.proofStrategy) {
    const strategyId = sanitizeId("strategy");
    const strategyLabel = thought.proofStrategy.type;
    mermaid += `  ${strategyId}(["${strategyLabel}"])
`;
    mermaid += `  ${typeId} --> ${strategyId}
`;
    let prevStepId = strategyId;
    thought.proofStrategy.steps.forEach((step, index) => {
      const stepId = sanitizeId(`step_${index}`);
      const stepLabel = includeLabels ? step.slice(0, 40) + (step.length > 40 ? "..." : "") : `Step ${index + 1}`;
      mermaid += `  ${stepId}["${stepLabel}"]
`;
      mermaid += `  ${prevStepId} --> ${stepId}
`;
      prevStepId = stepId;
    });
    if (includeMetrics) {
      const completenessId = sanitizeId("completeness");
      const completenessLabel = `Completeness: ${(thought.proofStrategy.completeness * 100).toFixed(0)}%`;
      mermaid += `  ${completenessId}{{${completenessLabel}}}
`;
      mermaid += `  ${prevStepId} --> ${completenessId}
`;
    }
  }
  if (thought.mathematicalModel) {
    const modelId = sanitizeId("model");
    const modelLabel = thought.mathematicalModel.symbolic || "Mathematical Model";
    mermaid += `  ${modelId}["${modelLabel}"]
`;
    mermaid += `  ${typeId} --> ${modelId}
`;
  }
  if (thought.theorems && thought.theorems.length > 0) {
    thought.theorems.forEach((theorem, index) => {
      const theoremId = sanitizeId(`theorem_${index}`);
      const theoremLabel = theorem.name || `Theorem ${index + 1}`;
      mermaid += `  ${theoremId}[/"${theoremLabel}"/]
`;
      mermaid += `  ${typeId} --> ${theoremId}
`;
    });
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    const assumptionsId = sanitizeId("assumptions");
    mermaid += `  ${assumptionsId}>"Assumptions: ${thought.assumptions.length}"]
`;
  }
  if (colorScheme !== "monochrome") {
    const colors = colorScheme === "pastel" ? { type: "#e8f4e8", strategy: "#fff3e0"} : { type: "#90EE90", strategy: "#FFD700"};
    mermaid += `
  style ${typeId} fill:${colors.type}
`;
    if (thought.proofStrategy) {
      mermaid += `  style ${sanitizeId("strategy")} fill:${colors.strategy}
`;
    }
  }
  return mermaid;
}
function mathematicsToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph MathematicsDerivation {\n";
  dot += "  rankdir=TB;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  const typeId = sanitizeId(`type_${thought.thoughtType || "proof"}`);
  const typeLabel = includeLabels ? (thought.thoughtType || "Proof").replace(/_/g, " ") : typeId;
  dot += `  ${typeId} [label="${typeLabel}", shape=doubleoctagon];
`;
  if (thought.proofStrategy) {
    const strategyId = sanitizeId("strategy");
    dot += `  ${strategyId} [label="${thought.proofStrategy.type}", shape=ellipse];
`;
    dot += `  ${typeId} -> ${strategyId};
`;
    let prevStepId = strategyId;
    thought.proofStrategy.steps.forEach((step, index) => {
      const stepId = sanitizeId(`step_${index}`);
      const stepLabel = includeLabels ? step.slice(0, 30).replace(/"/g, '\\"') : `Step ${index + 1}`;
      dot += `  ${stepId} [label="${stepLabel}"];
`;
      dot += `  ${prevStepId} -> ${stepId};
`;
      prevStepId = stepId;
    });
    if (includeMetrics) {
      const completenessId = sanitizeId("completeness");
      dot += `  ${completenessId} [label="${(thought.proofStrategy.completeness * 100).toFixed(0)}%", shape=diamond];
`;
      dot += `  ${prevStepId} -> ${completenessId};
`;
    }
  }
  if (thought.theorems) {
    thought.theorems.forEach((theorem, index) => {
      const theoremId = sanitizeId(`theorem_${index}`);
      dot += `  ${theoremId} [label="${theorem.name || `Theorem ${index + 1}`}", shape=parallelogram];
`;
      dot += `  ${typeId} -> ${theoremId};
`;
    });
  }
  dot += "}\n";
  return dot;
}
function mathematicsToASCII(thought) {
  let ascii = "Mathematics Derivation:\n";
  ascii += "=======================\n\n";
  ascii += `Type: ${(thought.thoughtType || "proof").replace(/_/g, " ")}
`;
  ascii += `Uncertainty: ${(thought.uncertainty * 100).toFixed(1)}%

`;
  if (thought.mathematicalModel) {
    ascii += "Mathematical Model:\n";
    ascii += `  LaTeX: ${thought.mathematicalModel.latex}
`;
    ascii += `  Symbolic: ${thought.mathematicalModel.symbolic}
`;
    if (thought.mathematicalModel.ascii) {
      ascii += `  ASCII: ${thought.mathematicalModel.ascii}
`;
    }
    ascii += "\n";
  }
  if (thought.proofStrategy) {
    ascii += `Proof Strategy: ${thought.proofStrategy.type}
`;
    ascii += `Completeness: ${(thought.proofStrategy.completeness * 100).toFixed(0)}%
`;
    ascii += "Steps:\n";
    thought.proofStrategy.steps.forEach((step, index) => {
      ascii += `  ${index + 1}. ${step}
`;
    });
    if (thought.proofStrategy.baseCase) {
      ascii += `Base Case: ${thought.proofStrategy.baseCase}
`;
    }
    if (thought.proofStrategy.inductiveStep) {
      ascii += `Inductive Step: ${thought.proofStrategy.inductiveStep}
`;
    }
    ascii += "\n";
  }
  if (thought.theorems && thought.theorems.length > 0) {
    ascii += "Theorems:\n";
    thought.theorems.forEach((theorem, index) => {
      ascii += `  [${index + 1}] ${theorem.name}: ${theorem.statement}
`;
      if (theorem.hypotheses.length > 0) {
        ascii += `      Hypotheses: ${theorem.hypotheses.join(", ")}
`;
      }
      ascii += `      Conclusion: ${theorem.conclusion}
`;
    });
    ascii += "\n";
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    ascii += "Assumptions:\n";
    thought.assumptions.forEach((assumption, index) => {
      ascii += `  ${index + 1}. ${assumption}
`;
    });
    ascii += "\n";
  }
  if (thought.dependencies && thought.dependencies.length > 0) {
    ascii += "Dependencies:\n";
    thought.dependencies.forEach((dep, index) => {
      ascii += `  ${index + 1}. ${dep}
`;
    });
  }
  return ascii;
}
function mathematicsToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width
  } = options;
  const positions = /* @__PURE__ */ new Map();
  const nodeWidth = 150;
  const nodeHeight = 40;
  let currentY = 80;
  const typeId = "type";
  positions.set(typeId, {
    id: typeId,
    label: includeLabels ? (thought.thoughtType || "Proof").replace(/_/g, " ") : typeId,
    x: svgWidth / 2,
    y: currentY,
    width: nodeWidth,
    height: nodeHeight,
    type: "type"
  });
  currentY += 120;
  if (thought.proofStrategy) {
    positions.set("strategy", {
      id: "strategy",
      label: thought.proofStrategy.type,
      x: svgWidth / 2,
      y: currentY,
      width: nodeWidth,
      height: nodeHeight,
      type: "strategy"
    });
    currentY += 100;
    thought.proofStrategy.steps.forEach((step, index) => {
      const stepId = `step_${index}`;
      positions.set(stepId, {
        id: stepId,
        label: includeLabels ? `${index + 1}. ${step.substring(0, 25)}...` : `Step ${index + 1}`,
        x: 150 + index % 3 * 200,
        y: currentY + Math.floor(index / 3) * 80,
        width: nodeWidth,
        height: nodeHeight,
        type: "step"
      });
    });
    currentY += Math.ceil(thought.proofStrategy.steps.length / 3) * 80 + 40;
  }
  if (thought.theorems && thought.theorems.length > 0) {
    thought.theorems.forEach((theorem, index) => {
      const theoremId = `theorem_${index}`;
      positions.set(theoremId, {
        id: theoremId,
        label: theorem.name || `Theorem ${index + 1}`,
        x: svgWidth / 2,
        y: currentY,
        width: nodeWidth,
        height: nodeHeight,
        type: "theorem"
      });
      currentY += 80;
    });
  }
  const actualHeight = Math.max(DEFAULT_SVG_OPTIONS.height, currentY + 100);
  let svg = generateSVGHeader(svgWidth, actualHeight, "Mathematics Derivation");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  if (thought.proofStrategy) {
    const typePos = positions.get("type");
    const strategyPos = positions.get("strategy");
    if (typePos && strategyPos) {
      svg += renderEdge(typePos, strategyPos);
    }
    const stratPos = positions.get("strategy");
    thought.proofStrategy.steps.forEach((_, index) => {
      const stepPos = positions.get(`step_${index}`);
      if (stratPos && stepPos) {
        svg += renderEdge(stratPos, stepPos);
      }
    });
  }
  if (thought.theorems) {
    const typePos = positions.get("type");
    thought.theorems.forEach((_, index) => {
      const theoremPos = positions.get(`theorem_${index}`);
      if (typePos && theoremPos) {
        svg += renderEdge(typePos, theoremPos);
      }
    });
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  const typeColors = getNodeColor("primary", colorScheme);
  const strategyColors = getNodeColor("secondary", colorScheme);
  const stepColors = getNodeColor("neutral", colorScheme);
  const theoremColors = getNodeColor("tertiary", colorScheme);
  for (const [, pos] of positions) {
    if (pos.type === "type") {
      svg += renderStadiumNode(pos, typeColors);
    } else if (pos.type === "strategy") {
      svg += renderEllipseNode(pos, strategyColors);
    } else if (pos.type === "step") {
      svg += renderRectNode(pos, stepColors);
    } else if (pos.type === "theorem") {
      svg += renderRectNode(pos, theoremColors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Uncertainty", value: `${(thought.uncertainty * 100).toFixed(1)}%` },
      { label: "Theorems", value: thought.theorems?.length || 0 },
      { label: "Assumptions", value: thought.assumptions?.length || 0 }
    ];
    svg += renderMetricsPanel(svgWidth - 180, actualHeight - 110, metrics);
  }
  const legendItems = [
    { label: "Type", color: typeColors, shape: "stadium" },
    { label: "Strategy", color: strategyColors, shape: "ellipse" },
    { label: "Step", color: stepColors },
    { label: "Theorem", color: theoremColors }
  ];
  svg += renderLegend(20, actualHeight - 130, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function mathematicsToGraphML(thought, options) {
  const { includeLabels = true } = options;
  const nodes = [];
  const edges = [];
  let edgeCount = 0;
  const typeId = sanitizeId(`type_${thought.thoughtType || "proof"}`);
  nodes.push({
    id: typeId,
    label: includeLabels ? (thought.thoughtType || "Proof").replace(/_/g, " ") : typeId,
    type: "type"
  });
  if (thought.theorems && thought.theorems.length > 0) {
    thought.theorems.forEach((theorem, index) => {
      const theoremId = sanitizeId(`theorem_${index}`);
      nodes.push({
        id: theoremId,
        label: theorem.name || `Theorem ${index + 1}`,
        type: "axiom",
        metadata: {
          description: theorem.statement
        }
      });
      edges.push({
        id: `e${edgeCount++}`,
        source: typeId,
        target: theoremId,
        directed: true
      });
    });
  }
  if (thought.proofStrategy) {
    const strategyId = sanitizeId("strategy");
    nodes.push({
      id: strategyId,
      label: thought.proofStrategy.type,
      type: "strategy"
    });
    edges.push({
      id: `e${edgeCount++}`,
      source: typeId,
      target: strategyId,
      directed: true
    });
    let prevStepId = strategyId;
    thought.proofStrategy.steps.forEach((step, index) => {
      const stepId = sanitizeId(`step_${index}`);
      nodes.push({
        id: stepId,
        label: includeLabels ? step.slice(0, 40) + (step.length > 40 ? "..." : "") : `Step ${index + 1}`,
        type: "step",
        metadata: {
          description: step
        }
      });
      edges.push({
        id: `e${edgeCount++}`,
        source: prevStepId,
        target: stepId,
        directed: true
      });
      prevStepId = stepId;
    });
  }
  if (thought.mathematicalModel) {
    const modelId = sanitizeId("model");
    nodes.push({
      id: modelId,
      label: thought.mathematicalModel.symbolic || "Mathematical Model",
      type: "model",
      metadata: {
        description: thought.mathematicalModel.latex
      }
    });
    edges.push({
      id: `e${edgeCount++}`,
      source: typeId,
      target: modelId,
      directed: true
    });
  }
  return generateGraphML(nodes, edges, {
    graphName: "Mathematics Derivation",
    directed: true,
    includeLabels
  });
}
function mathematicsToTikZ(thought, options) {
  const { includeLabels = true, colorScheme = "default" } = options;
  const nodes = [];
  const edges = [];
  let yPos = 0;
  const typeId = sanitizeId(`type_${thought.thoughtType || "proof"}`);
  nodes.push({
    id: typeId,
    label: includeLabels ? (thought.thoughtType || "Proof").replace(/_/g, " ") : typeId,
    x: 4,
    y: yPos,
    type: "primary",
    shape: "stadium"
  });
  yPos -= 2;
  if (thought.theorems && thought.theorems.length > 0) {
    thought.theorems.forEach((theorem, index) => {
      const theoremId = sanitizeId(`theorem_${index}`);
      const xPos = 1 + index * 3;
      nodes.push({
        id: theoremId,
        label: theorem.name || `Theorem ${index + 1}`,
        x: xPos,
        y: yPos,
        type: "secondary",
        shape: "stadium"
      });
      edges.push({
        source: typeId,
        target: theoremId,
        directed: true
      });
    });
    yPos -= 2;
  }
  if (thought.proofStrategy) {
    const strategyId = sanitizeId("strategy");
    nodes.push({
      id: strategyId,
      label: thought.proofStrategy.type,
      x: 4,
      y: yPos,
      type: "secondary",
      shape: "ellipse"
    });
    edges.push({
      source: typeId,
      target: strategyId,
      directed: true
    });
    yPos -= 2;
    let prevStepId = strategyId;
    thought.proofStrategy.steps.forEach((step, index) => {
      const stepId = sanitizeId(`step_${index}`);
      const xPos = 1 + index % 3 * 2.5;
      const stepYPos = yPos - Math.floor(index / 3) * 1.5;
      nodes.push({
        id: stepId,
        label: includeLabels ? `${index + 1}. ${step.substring(0, 20)}...` : `Step ${index + 1}`,
        x: xPos,
        y: stepYPos,
        type: "neutral",
        shape: "rectangle"
      });
      edges.push({
        source: prevStepId,
        target: stepId,
        directed: true
      });
      prevStepId = stepId;
    });
  }
  return generateTikZ(nodes, edges, {
    title: "Mathematics Derivation",
    colorScheme,
    includeLabels
  });
}
function mathematicsToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Mathematics Derivation Analysis",
    htmlTheme = "light"
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  html += '<div class="metrics-grid">';
  html += renderMetricCard("Uncertainty", `${(thought.uncertainty * 100).toFixed(1)}%`, "warning");
  if (thought.theorems) {
    html += renderMetricCard("Theorems", thought.theorems.length, "primary");
  }
  if (thought.assumptions) {
    html += renderMetricCard("Assumptions", thought.assumptions.length, "info");
  }
  if (thought.proofStrategy) {
    html += renderMetricCard("Completeness", `${(thought.proofStrategy.completeness * 100).toFixed(0)}%`, "success");
  }
  html += "</div>\n";
  const badges = [];
  if (thought.thoughtType) {
    badges.push(renderBadge(thought.thoughtType.replace(/_/g, " "), "primary"));
  }
  if (badges.length > 0) {
    html += `<div class="flex gap-1" style="margin: 1rem 0">${badges.join(" ")}</div>
`;
  }
  if (thought.mathematicalModel) {
    const modelContent = `
      <p><strong>LaTeX:</strong> <code>${escapeHTML(thought.mathematicalModel.latex)}</code></p>
      <p><strong>Symbolic:</strong> <code>${escapeHTML(thought.mathematicalModel.symbolic)}</code></p>
      ${thought.mathematicalModel.ascii ? `<p><strong>ASCII:</strong> <code>${escapeHTML(thought.mathematicalModel.ascii)}</code></p>` : ""}
    `;
    html += renderSection("Mathematical Model", modelContent, "\u{1F4D0}");
  }
  if (thought.proofStrategy) {
    const proofContent = `
      <p><strong>Type:</strong> ${renderBadge(thought.proofStrategy.type, "info")}</p>
      <p><strong>Completeness:</strong></p>
      ${renderProgressBar(thought.proofStrategy.completeness * 100, "success")}
      <p style="margin-top: 1rem"><strong>Steps:</strong></p>
      <ol class="list-styled">
        ${thought.proofStrategy.steps.map((step) => `<li>${escapeHTML(step)}</li>`).join("")}
      </ol>
      ${thought.proofStrategy.baseCase ? `<p><strong>Base Case:</strong> ${escapeHTML(thought.proofStrategy.baseCase)}</p>` : ""}
      ${thought.proofStrategy.inductiveStep ? `<p><strong>Inductive Step:</strong> ${escapeHTML(thought.proofStrategy.inductiveStep)}</p>` : ""}
    `;
    html += renderSection("Proof Strategy", proofContent, "\u{1F50D}");
  }
  if (thought.theorems && thought.theorems.length > 0) {
    const theoremsContent = thought.theorems.map((theorem, index) => `
      <div class="card">
        <div class="card-header">${escapeHTML(theorem.name || `Theorem ${index + 1}`)}</div>
        <p><strong>Statement:</strong> ${escapeHTML(theorem.statement)}</p>
        ${theorem.hypotheses.length > 0 ? `<p><strong>Hypotheses:</strong> ${escapeHTML(theorem.hypotheses.join(", "))}</p>` : ""}
        <p><strong>Conclusion:</strong> ${escapeHTML(theorem.conclusion)}</p>
      </div>
    `).join("");
    html += renderSection("Theorems", theoremsContent, "\u{1F4DC}");
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    const assumptionsList = thought.assumptions.map((a) => escapeHTML(a));
    html += renderSection("Assumptions", `
      <ul class="list-styled">
        ${assumptionsList.map((a) => `<li>${a}</li>`).join("")}
      </ul>
    `, "\u26A0\uFE0F");
  }
  if (thought.dependencies && thought.dependencies.length > 0) {
    const depsList = thought.dependencies.map((d) => escapeHTML(d));
    html += renderSection("Dependencies", `
      <ul class="list-styled">
        ${depsList.map((d) => `<li>${d}</li>`).join("")}
      </ul>
    `, "\u{1F517}");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function mathematicsToModelica(thought, options) {
  const { includeLabels = true } = options;
  let modelica = "// Mathematics Derivation Model\n";
  modelica += `package MathematicsDerivation "${thought.thoughtType || "Proof"}"
`;
  modelica += '  "Mathematical derivation and proof structure"\n\n';
  modelica += "  // Mathematical Model\n";
  if (thought.mathematicalModel) {
    const modelName = sanitizeModelicaId("MathModel");
    modelica += `  model ${modelName} "Mathematical Expression"
`;
    modelica += `    parameter String latex = "${escapeModelicaString(thought.mathematicalModel.latex)}";
`;
    modelica += `    parameter String symbolic = "${escapeModelicaString(thought.mathematicalModel.symbolic)}";
`;
    if (thought.mathematicalModel.ascii) {
      modelica += `    parameter String ascii = "${escapeModelicaString(thought.mathematicalModel.ascii)}";
`;
    }
    modelica += `  end ${modelName};

`;
  }
  if (thought.theorems && thought.theorems.length > 0) {
    modelica += "  // Theorems\n";
    thought.theorems.forEach((theorem, index) => {
      const theoremName = sanitizeModelicaId(theorem.name || `Theorem${index + 1}`);
      modelica += `  model ${theoremName} "Theorem ${index + 1}"
`;
      modelica += `    parameter String statement = "${escapeModelicaString(theorem.statement)}";
`;
      if (theorem.hypotheses.length > 0) {
        theorem.hypotheses.forEach((hyp, hypIndex) => {
          modelica += `    parameter String hypothesis${hypIndex + 1} = "${escapeModelicaString(hyp)}";
`;
        });
      }
      modelica += `    parameter String conclusion = "${escapeModelicaString(theorem.conclusion)}";
`;
      modelica += `  end ${theoremName};

`;
    });
  }
  if (thought.proofStrategy) {
    const strategyName = sanitizeModelicaId(thought.proofStrategy.type.replace(/\s+/g, "_"));
    modelica += "  // Proof Strategy\n";
    modelica += `  model ${strategyName} "Proof Strategy"
`;
    modelica += `    parameter String proofType = "${escapeModelicaString(thought.proofStrategy.type)}";
`;
    modelica += `    parameter Real completeness = ${thought.proofStrategy.completeness};
`;
    thought.proofStrategy.steps.forEach((step, index) => {
      if (includeLabels) {
        modelica += `    parameter String step${index + 1} = "${escapeModelicaString(step)}";
`;
      }
    });
    if (thought.proofStrategy.baseCase) {
      modelica += `    parameter String baseCase = "${escapeModelicaString(thought.proofStrategy.baseCase)}";
`;
    }
    if (thought.proofStrategy.inductiveStep) {
      modelica += `    parameter String inductiveStep = "${escapeModelicaString(thought.proofStrategy.inductiveStep)}";
`;
    }
    modelica += `  end ${strategyName};

`;
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    modelica += "  // Assumptions\n";
    modelica += '  model Assumptions "Proof Assumptions"\n';
    thought.assumptions.forEach((assumption, index) => {
      modelica += `    parameter String assumption${index + 1} = "${escapeModelicaString(assumption)}";
`;
    });
    modelica += "  end Assumptions;\n\n";
  }
  modelica += "  // Metadata\n";
  modelica += '  model Metadata "Derivation Metadata"\n';
  modelica += `    parameter Real uncertainty = ${thought.uncertainty};
`;
  modelica += `    parameter Integer theoremCount = ${thought.theorems?.length || 0};
`;
  modelica += `    parameter Integer assumptionCount = ${thought.assumptions?.length || 0};
`;
  modelica += "  end Metadata;\n\n";
  modelica += "end MathematicsDerivation;\n";
  return modelica;
}
function mathematicsToUML(thought, options) {
  const { includeLabels = true } = options;
  const nodes = [];
  const edges = [];
  const typeId = sanitizeId(`type_${thought.thoughtType || "proof"}`);
  nodes.push({
    id: typeId,
    label: includeLabels ? (thought.thoughtType || "Proof").replace(/_/g, " ") : typeId,
    shape: "class",
    stereotype: "mathematical",
    attributes: [
      `uncertainty: ${(thought.uncertainty * 100).toFixed(1)}%`
    ]
  });
  if (thought.mathematicalModel) {
    const modelId = sanitizeId("model");
    nodes.push({
      id: modelId,
      label: "Mathematical Model",
      shape: "class",
      stereotype: "model",
      attributes: [
        `latex: ${thought.mathematicalModel.latex.substring(0, 40)}...`,
        `symbolic: ${thought.mathematicalModel.symbolic}`
      ]
    });
    edges.push({
      source: typeId,
      target: modelId,
      type: "composition",
      label: "contains"
    });
  }
  if (thought.theorems && thought.theorems.length > 0) {
    thought.theorems.forEach((theorem, index) => {
      const theoremId = sanitizeId(`theorem_${index}`);
      const attributes = [
        `statement: ${theorem.statement.substring(0, 40)}...`,
        `hypotheses: ${theorem.hypotheses.length}`,
        `conclusion: ${theorem.conclusion.substring(0, 40)}...`
      ];
      nodes.push({
        id: theoremId,
        label: theorem.name || `Theorem ${index + 1}`,
        shape: "class",
        stereotype: "theorem",
        attributes
      });
      edges.push({
        source: typeId,
        target: theoremId,
        type: "association",
        label: "uses"
      });
    });
  }
  if (thought.proofStrategy) {
    const strategyId = sanitizeId("strategy");
    const methods = thought.proofStrategy.steps.map((step, index) => {
      return includeLabels ? `step${index + 1}(): ${step.substring(0, 30)}...` : `step${index + 1}()`;
    });
    nodes.push({
      id: strategyId,
      label: thought.proofStrategy.type,
      shape: "class",
      stereotype: "strategy",
      attributes: [
        `completeness: ${(thought.proofStrategy.completeness * 100).toFixed(0)}%`
      ],
      methods
    });
    edges.push({
      source: typeId,
      target: strategyId,
      type: "dependency",
      label: "applies"
    });
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    const assumptionsId = sanitizeId("assumptions");
    nodes.push({
      id: assumptionsId,
      label: "Assumptions",
      shape: "interface",
      attributes: thought.assumptions.slice(0, 5).map((a, i) => `${i + 1}. ${a.substring(0, 30)}...`)
    });
    edges.push({
      source: typeId,
      target: assumptionsId,
      type: "implementation",
      label: "assumes"
    });
  }
  return generateUmlDiagram(nodes, edges, {
    title: "Mathematics Derivation Structure"});
}
function mathematicsToJSON(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const graph = createJsonGraph("Mathematics Derivation", "mathematics");
  const typeId = sanitizeId(`type_${thought.thoughtType || "proof"}`);
  addNode(graph, {
    id: typeId,
    label: includeLabels ? (thought.thoughtType || "Proof").replace(/_/g, " ") : typeId,
    type: "type",
    metadata: {
      thoughtType: thought.thoughtType || "proof",
      uncertainty: thought.uncertainty
    }
  });
  if (thought.mathematicalModel) {
    const modelId = sanitizeId("model");
    addNode(graph, {
      id: modelId,
      label: thought.mathematicalModel.symbolic || "Mathematical Model",
      type: "model",
      metadata: {
        latex: thought.mathematicalModel.latex,
        symbolic: thought.mathematicalModel.symbolic,
        ascii: thought.mathematicalModel.ascii
      }
    });
    addEdge(graph, {
      id: `edge_${typeId}_${modelId}`,
      source: typeId,
      target: modelId,
      label: "contains",
      type: "composition"
    });
  }
  if (thought.theorems && thought.theorems.length > 0) {
    thought.theorems.forEach((theorem, index) => {
      const theoremId = sanitizeId(`theorem_${index}`);
      addNode(graph, {
        id: theoremId,
        label: theorem.name || `Theorem ${index + 1}`,
        type: "theorem",
        metadata: {
          statement: theorem.statement,
          hypotheses: theorem.hypotheses,
          conclusion: theorem.conclusion
        }
      });
      addEdge(graph, {
        id: `edge_${typeId}_${theoremId}`,
        source: typeId,
        target: theoremId,
        label: "uses",
        type: "association"
      });
    });
  }
  if (thought.proofStrategy) {
    const strategyId = sanitizeId("strategy");
    addNode(graph, {
      id: strategyId,
      label: thought.proofStrategy.type,
      type: "strategy",
      metadata: {
        proofType: thought.proofStrategy.type,
        completeness: thought.proofStrategy.completeness,
        baseCase: thought.proofStrategy.baseCase,
        inductiveStep: thought.proofStrategy.inductiveStep
      }
    });
    addEdge(graph, {
      id: `edge_${typeId}_${strategyId}`,
      source: typeId,
      target: strategyId,
      label: "applies",
      type: "dependency"
    });
    let prevStepId = strategyId;
    thought.proofStrategy.steps.forEach((step, index) => {
      const stepId = sanitizeId(`step_${index}`);
      addNode(graph, {
        id: stepId,
        label: includeLabels ? `Step ${index + 1}` : stepId,
        type: "step",
        metadata: {
          stepNumber: index + 1,
          description: step
        }
      });
      addEdge(graph, {
        id: `edge_${prevStepId}_${stepId}`,
        source: prevStepId,
        target: stepId,
        label: "leads_to",
        type: "sequence"
      });
      prevStepId = stepId;
    });
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    thought.assumptions.forEach((assumption, index) => {
      const assumptionId = sanitizeId(`assumption_${index}`);
      addNode(graph, {
        id: assumptionId,
        label: includeLabels ? `Assumption ${index + 1}` : assumptionId,
        type: "assumption",
        metadata: {
          description: assumption
        }
      });
      addEdge(graph, {
        id: `edge_${typeId}_${assumptionId}`,
        source: typeId,
        target: assumptionId,
        label: "assumes",
        type: "dependency"
      });
    });
  }
  if (includeMetrics) {
    addMetric(graph, "uncertainty", thought.uncertainty);
    addMetric(graph, "theorem_count", thought.theorems?.length || 0);
    addMetric(graph, "assumption_count", thought.assumptions?.length || 0);
    addMetric(graph, "dependency_count", thought.dependencies?.length || 0);
    if (thought.proofStrategy) {
      addMetric(graph, "proof_completeness", thought.proofStrategy.completeness);
      addMetric(graph, "proof_step_count", thought.proofStrategy.steps.length);
    }
  }
  return serializeGraph(graph);
}
function mathematicsToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  const typeContent = keyValueSection({
    "Type": (thought.thoughtType || "proof").replace(/_/g, " "),
    "Uncertainty": `${(thought.uncertainty * 100).toFixed(1)}%`
  });
  parts.push(section("Overview", typeContent));
  if (thought.mathematicalModel) {
    const modelContent = keyValueSection({
      "LaTeX": `\`${thought.mathematicalModel.latex}\``,
      "Symbolic": `\`${thought.mathematicalModel.symbolic}\``,
      "ASCII": thought.mathematicalModel.ascii ? `\`${thought.mathematicalModel.ascii}\`` : "N/A"
    });
    parts.push(section("Mathematical Model", modelContent));
  }
  if (includeMetrics) {
    const metricsContent = keyValueSection({
      "Uncertainty": `${(thought.uncertainty * 100).toFixed(1)}%`,
      "Theorems": thought.theorems?.length || 0,
      "Assumptions": thought.assumptions?.length || 0,
      "Proof Completeness": thought.proofStrategy ? `${(thought.proofStrategy.completeness * 100).toFixed(0)}%` : "N/A"
    });
    parts.push(section("Metrics", metricsContent));
  }
  if (thought.proofStrategy) {
    let proofContent = `**Type:** ${thought.proofStrategy.type}

`;
    proofContent += `**Completeness:** ${(thought.proofStrategy.completeness * 100).toFixed(0)}%

`;
    proofContent += "**Steps:**\n\n";
    const stepItems = thought.proofStrategy.steps.map(
      (step, index) => `${index + 1}. ${step}`
    );
    proofContent += list(stepItems, "numbered");
    if (thought.proofStrategy.baseCase) {
      proofContent += `
**Base Case:** ${thought.proofStrategy.baseCase}
`;
    }
    if (thought.proofStrategy.inductiveStep) {
      proofContent += `
**Inductive Step:** ${thought.proofStrategy.inductiveStep}
`;
    }
    parts.push(section("Proof Strategy", proofContent));
  }
  if (thought.theorems && thought.theorems.length > 0) {
    const theoremItems = thought.theorems.map(
      (theorem) => `**${theorem.name}**: ${theorem.statement}
  - Hypotheses: ${theorem.hypotheses.join(", ")}
  - Conclusion: ${theorem.conclusion}`
    );
    parts.push(section("Theorems", list(theoremItems)));
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    parts.push(section("Assumptions", list(thought.assumptions)));
  }
  if (thought.dependencies && thought.dependencies.length > 0) {
    parts.push(section("Dependencies", list(thought.dependencies)));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = mathematicsToMermaid(thought, "default", true, true);
    parts.push(section("Derivation Diagram", mermaidBlock(mermaidDiagram)));
  }
  return document("Mathematics Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: { mode: "mathematics" }
  });
}
var init_mathematics = __esm({
  "src/export/visual/mathematics.ts"() {
    init_esm_shims();
    init_utils();
    init_svg_utils();
    init_graphml_utils();
    init_tikz_utils();
    init_html_utils();
    init_modelica_utils();
    init_uml_utils();
    init_json_utils();
    init_markdown_utils();
  }
});

// src/export/visual/physics.ts
function exportPhysicsVisualization(thought, options) {
  const { format, colorScheme = "default" } = options;
  switch (format) {
    case "mermaid":
      return physicsToMermaid(thought, colorScheme, options.includeLabels ?? true, options.includeMetrics ?? true);
    case "dot":
      return physicsToDOT(thought, options.includeLabels ?? true, options.includeMetrics ?? true);
    case "ascii":
      return physicsToASCII(thought);
    case "svg":
      return physicsToSVG(thought, options);
    case "graphml":
      return physicsToGraphML(thought, options);
    case "tikz":
      return physicsToTikZ(thought, options);
    case "html":
      return physicsToHTML(thought, options);
    case "modelica":
      return physicsToModelica(thought, options);
    case "uml":
      return physicsToUML(thought, options);
    case "json":
      return physicsToJSON(thought, options);
    case "markdown":
      return physicsToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function physicsToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TB\n";
  const typeId = sanitizeId(`type_${thought.thoughtType || "physics"}`);
  const typeLabel = includeLabels ? (thought.thoughtType || "Physics").replace(/_/g, " ") : typeId;
  mermaid += `  ${typeId}[["${typeLabel}"]]
`;
  if (thought.tensorProperties) {
    const tensorId = sanitizeId("tensor");
    const rankLabel = `Rank (${thought.tensorProperties.rank[0]},${thought.tensorProperties.rank[1]})`;
    mermaid += `  ${tensorId}(["${rankLabel}"])
`;
    mermaid += `  ${typeId} --> ${tensorId}
`;
    const compId = sanitizeId("components");
    const compLabel = includeLabels ? thought.tensorProperties.components.slice(0, 30) + (thought.tensorProperties.components.length > 30 ? "..." : "") : "Components";
    mermaid += `  ${compId}["${compLabel}"]
`;
    mermaid += `  ${tensorId} --> ${compId}
`;
    if (thought.tensorProperties.symmetries.length > 0) {
      const symId = sanitizeId("symmetries");
      mermaid += `  ${symId}{{"Symmetries: ${thought.tensorProperties.symmetries.length}"}}
`;
      mermaid += `  ${tensorId} --> ${symId}
`;
    }
    if (thought.tensorProperties.invariants.length > 0) {
      const invId = sanitizeId("invariants");
      mermaid += `  ${invId}{{"Invariants: ${thought.tensorProperties.invariants.length}"}}
`;
      mermaid += `  ${tensorId} --> ${invId}
`;
    }
  }
  if (thought.physicalInterpretation) {
    const interpId = sanitizeId("interpretation");
    const interpLabel = thought.physicalInterpretation.quantity;
    mermaid += `  ${interpId}[/"${interpLabel}"/]
`;
    mermaid += `  ${typeId} --> ${interpId}
`;
    const unitsId = sanitizeId("units");
    mermaid += `  ${unitsId}(["${thought.physicalInterpretation.units}"])
`;
    mermaid += `  ${interpId} --> ${unitsId}
`;
    if (thought.physicalInterpretation.conservationLaws.length > 0) {
      thought.physicalInterpretation.conservationLaws.forEach((law, index) => {
        const lawId = sanitizeId(`conservation_${index}`);
        const lawLabel = includeLabels ? law.slice(0, 25) + (law.length > 25 ? "..." : "") : `Law ${index + 1}`;
        mermaid += `  ${lawId}>"${lawLabel}"]
`;
        mermaid += `  ${interpId} --> ${lawId}
`;
      });
    }
  }
  if (thought.fieldTheoryContext) {
    const fieldId = sanitizeId("field_theory");
    mermaid += `  ${fieldId}[("Field Theory")]
`;
    mermaid += `  ${typeId} --> ${fieldId}
`;
    thought.fieldTheoryContext.fields.forEach((field, index) => {
      const fId = sanitizeId(`field_${index}`);
      mermaid += `  ${fId}["${field}"]
`;
      mermaid += `  ${fieldId} --> ${fId}
`;
    });
    const symGroupId = sanitizeId("symmetry_group");
    mermaid += `  ${symGroupId}{{"${thought.fieldTheoryContext.symmetryGroup}"}}
`;
    mermaid += `  ${fieldId} --> ${symGroupId}
`;
  }
  if (includeMetrics) {
    const uncertId = sanitizeId("uncertainty");
    const uncertLabel = `Uncertainty: ${(thought.uncertainty * 100).toFixed(1)}%`;
    mermaid += `  ${uncertId}{{${uncertLabel}}}
`;
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    const assumptionsId = sanitizeId("assumptions");
    mermaid += `  ${assumptionsId}>"Assumptions: ${thought.assumptions.length}"]
`;
  }
  if (colorScheme !== "monochrome") {
    const colors = colorScheme === "pastel" ? { type: "#e3f2fd", tensor: "#fff3e0", interp: "#e8f5e9" } : { type: "#87CEEB", tensor: "#FFD700", interp: "#90EE90" };
    mermaid += `
  style ${typeId} fill:${colors.type}
`;
    if (thought.tensorProperties) {
      mermaid += `  style ${sanitizeId("tensor")} fill:${colors.tensor}
`;
    }
    if (thought.physicalInterpretation) {
      mermaid += `  style ${sanitizeId("interpretation")} fill:${colors.interp}
`;
    }
  }
  return mermaid;
}
function physicsToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph PhysicsVisualization {\n";
  dot += "  rankdir=TB;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  const typeId = sanitizeId(`type_${thought.thoughtType || "physics"}`);
  const typeLabel = includeLabels ? (thought.thoughtType || "Physics").replace(/_/g, " ") : typeId;
  dot += `  ${typeId} [label="${typeLabel}", shape=doubleoctagon];
`;
  if (thought.tensorProperties) {
    const tensorId = sanitizeId("tensor");
    const rankLabel = `Rank (${thought.tensorProperties.rank[0]},${thought.tensorProperties.rank[1]})`;
    dot += `  ${tensorId} [label="${rankLabel}", shape=ellipse];
`;
    dot += `  ${typeId} -> ${tensorId};
`;
    const compId = sanitizeId("components");
    const compLabel = includeLabels ? thought.tensorProperties.components.slice(0, 25).replace(/"/g, '\\"') : "Components";
    dot += `  ${compId} [label="${compLabel}"];
`;
    dot += `  ${tensorId} -> ${compId};
`;
    const transId = sanitizeId("transformation");
    dot += `  ${transId} [label="${thought.tensorProperties.transformation}", shape=diamond];
`;
    dot += `  ${tensorId} -> ${transId};
`;
  }
  if (thought.physicalInterpretation) {
    const interpId = sanitizeId("interpretation");
    dot += `  ${interpId} [label="${thought.physicalInterpretation.quantity}", shape=parallelogram];
`;
    dot += `  ${typeId} -> ${interpId};
`;
    const unitsId = sanitizeId("units");
    dot += `  ${unitsId} [label="${thought.physicalInterpretation.units}", shape=ellipse];
`;
    dot += `  ${interpId} -> ${unitsId};
`;
    thought.physicalInterpretation.conservationLaws.forEach((law, index) => {
      const lawId = sanitizeId(`conservation_${index}`);
      const lawLabel = includeLabels ? law.slice(0, 20).replace(/"/g, '\\"') : `Law ${index + 1}`;
      dot += `  ${lawId} [label="${lawLabel}", shape=hexagon];
`;
      dot += `  ${interpId} -> ${lawId};
`;
    });
  }
  if (thought.fieldTheoryContext) {
    const fieldId = sanitizeId("field_theory");
    dot += `  ${fieldId} [label="Field Theory", shape=cylinder];
`;
    dot += `  ${typeId} -> ${fieldId};
`;
    thought.fieldTheoryContext.fields.forEach((field, index) => {
      const fId = sanitizeId(`field_${index}`);
      dot += `  ${fId} [label="${field}"];
`;
      dot += `  ${fieldId} -> ${fId};
`;
    });
    const symGroupId = sanitizeId("symmetry_group");
    dot += `  ${symGroupId} [label="${thought.fieldTheoryContext.symmetryGroup}", shape=diamond];
`;
    dot += `  ${fieldId} -> ${symGroupId};
`;
  }
  if (includeMetrics) {
    const uncertId = sanitizeId("uncertainty");
    dot += `  ${uncertId} [label="${(thought.uncertainty * 100).toFixed(1)}%", shape=diamond];
`;
  }
  dot += "}\n";
  return dot;
}
function physicsToASCII(thought) {
  let ascii = "Physics Analysis:\n";
  ascii += "=================\n\n";
  ascii += `Type: ${(thought.thoughtType || "physics").replace(/_/g, " ")}
`;
  ascii += `Uncertainty: ${(thought.uncertainty * 100).toFixed(1)}%

`;
  if (thought.tensorProperties) {
    ascii += "Tensor Properties:\n";
    ascii += `  Rank: (${thought.tensorProperties.rank[0]}, ${thought.tensorProperties.rank[1]})
`;
    ascii += `  Components: ${thought.tensorProperties.components}
`;
    ascii += `  LaTeX: ${thought.tensorProperties.latex}
`;
    ascii += `  Transformation: ${thought.tensorProperties.transformation}
`;
    if (thought.tensorProperties.indexStructure) {
      ascii += `  Index Structure: ${thought.tensorProperties.indexStructure}
`;
    }
    if (thought.tensorProperties.coordinateSystem) {
      ascii += `  Coordinate System: ${thought.tensorProperties.coordinateSystem}
`;
    }
    if (thought.tensorProperties.symmetries.length > 0) {
      ascii += "  Symmetries:\n";
      thought.tensorProperties.symmetries.forEach((sym, index) => {
        ascii += `    ${index + 1}. ${sym}
`;
      });
    }
    if (thought.tensorProperties.invariants.length > 0) {
      ascii += "  Invariants:\n";
      thought.tensorProperties.invariants.forEach((inv, index) => {
        ascii += `    ${index + 1}. ${inv}
`;
      });
    }
    ascii += "\n";
  }
  if (thought.physicalInterpretation) {
    ascii += "Physical Interpretation:\n";
    ascii += `  Quantity: ${thought.physicalInterpretation.quantity}
`;
    ascii += `  Units: ${thought.physicalInterpretation.units}
`;
    if (thought.physicalInterpretation.conservationLaws.length > 0) {
      ascii += "  Conservation Laws:\n";
      thought.physicalInterpretation.conservationLaws.forEach((law, index) => {
        ascii += `    ${index + 1}. ${law}
`;
      });
    }
    if (thought.physicalInterpretation.constraints && thought.physicalInterpretation.constraints.length > 0) {
      ascii += "  Constraints:\n";
      thought.physicalInterpretation.constraints.forEach((constraint, index) => {
        ascii += `    ${index + 1}. ${constraint}
`;
      });
    }
    if (thought.physicalInterpretation.observables && thought.physicalInterpretation.observables.length > 0) {
      ascii += "  Observables:\n";
      thought.physicalInterpretation.observables.forEach((obs, index) => {
        ascii += `    ${index + 1}. ${obs}
`;
      });
    }
    ascii += "\n";
  }
  if (thought.fieldTheoryContext) {
    ascii += "Field Theory Context:\n";
    ascii += `  Symmetry Group: ${thought.fieldTheoryContext.symmetryGroup}
`;
    if (thought.fieldTheoryContext.fields.length > 0) {
      ascii += "  Fields:\n";
      thought.fieldTheoryContext.fields.forEach((field, index) => {
        ascii += `    ${index + 1}. ${field}
`;
      });
    }
    if (thought.fieldTheoryContext.interactions.length > 0) {
      ascii += "  Interactions:\n";
      thought.fieldTheoryContext.interactions.forEach((interaction, index) => {
        ascii += `    ${index + 1}. ${interaction}
`;
      });
    }
    if (thought.fieldTheoryContext.gaugeSymmetries && thought.fieldTheoryContext.gaugeSymmetries.length > 0) {
      ascii += "  Gauge Symmetries:\n";
      thought.fieldTheoryContext.gaugeSymmetries.forEach((gauge, index) => {
        ascii += `    ${index + 1}. ${gauge}
`;
      });
    }
    ascii += "\n";
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    ascii += "Assumptions:\n";
    thought.assumptions.forEach((assumption, index) => {
      ascii += `  ${index + 1}. ${assumption}
`;
    });
    ascii += "\n";
  }
  if (thought.dependencies && thought.dependencies.length > 0) {
    ascii += "Dependencies:\n";
    thought.dependencies.forEach((dep, index) => {
      ascii += `  ${index + 1}. ${dep}
`;
    });
  }
  return ascii;
}
function physicsToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width,
    svgHeight = DEFAULT_SVG_OPTIONS.height
  } = options;
  const positions = /* @__PURE__ */ new Map();
  const nodeWidth = 150;
  const nodeHeight = 40;
  positions.set("type", {
    id: "type",
    label: includeLabels ? (thought.thoughtType || "Physics").replace(/_/g, " ") : "Physics",
    x: svgWidth / 2,
    y: 80,
    width: nodeWidth,
    height: nodeHeight,
    type: "type"
  });
  if (thought.tensorProperties) {
    positions.set("tensor", {
      id: "tensor",
      label: `Tensor (${thought.tensorProperties.rank[0]},${thought.tensorProperties.rank[1]})`,
      x: 150,
      y: 220,
      width: nodeWidth,
      height: nodeHeight,
      type: "tensor"
    });
  }
  if (thought.physicalInterpretation) {
    positions.set("interpretation", {
      id: "interpretation",
      label: thought.physicalInterpretation.quantity,
      x: svgWidth - 150,
      y: 220,
      width: nodeWidth,
      height: nodeHeight,
      type: "interpretation"
    });
  }
  if (thought.fieldTheoryContext) {
    positions.set("field", {
      id: "field",
      label: "Field Theory",
      x: svgWidth / 2,
      y: 360,
      width: nodeWidth,
      height: nodeHeight,
      type: "field"
    });
  }
  let svg = generateSVGHeader(svgWidth, svgHeight, "Physics Analysis");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  const typePos = positions.get("type");
  const tensorPos = positions.get("tensor");
  const interpPos = positions.get("interpretation");
  const fieldPos = positions.get("field");
  if (typePos && tensorPos) {
    svg += renderEdge(typePos, tensorPos);
  }
  if (typePos && interpPos) {
    svg += renderEdge(typePos, interpPos);
  }
  if (typePos && fieldPos) {
    svg += renderEdge(typePos, fieldPos);
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  const typeColors = getNodeColor("primary", colorScheme);
  const tensorColors = getNodeColor("secondary", colorScheme);
  const interpColors = getNodeColor("tertiary", colorScheme);
  const fieldColors = getNodeColor("neutral", colorScheme);
  for (const [, pos] of positions) {
    if (pos.type === "type") {
      svg += renderStadiumNode(pos, typeColors);
    } else if (pos.type === "tensor") {
      svg += renderEllipseNode(pos, tensorColors);
    } else if (pos.type === "interpretation") {
      svg += renderRectNode(pos, interpColors);
    } else if (pos.type === "field") {
      svg += renderRectNode(pos, fieldColors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Uncertainty", value: `${(thought.uncertainty * 100).toFixed(1)}%` },
      { label: "Assumptions", value: thought.assumptions?.length || 0 }
    ];
    svg += renderMetricsPanel(svgWidth - 180, svgHeight - 110, metrics);
  }
  const legendItems = [
    { label: "Type", color: typeColors, shape: "stadium" },
    { label: "Tensor", color: tensorColors, shape: "ellipse" },
    { label: "Interpretation", color: interpColors },
    { label: "Field Theory", color: fieldColors }
  ];
  svg += renderLegend(20, svgHeight - 130, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function physicsToGraphML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  let edgeCount = 0;
  const typeId = "type";
  nodes.push({
    id: typeId,
    label: includeLabels ? (thought.thoughtType || "Physics").replace(/_/g, " ") : "Physics",
    type: "primary"
  });
  if (thought.tensorProperties) {
    const tensorId = "tensor";
    nodes.push({
      id: tensorId,
      label: `Tensor Rank (${thought.tensorProperties.rank[0]},${thought.tensorProperties.rank[1]})`,
      type: "tensor",
      metadata: {
        description: `Components: ${thought.tensorProperties.components}`
      }
    });
    edges.push({
      id: `e${edgeCount++}`,
      source: typeId,
      target: tensorId,
      label: "has tensor"
    });
    const componentsId = "components";
    nodes.push({
      id: componentsId,
      label: "Components",
      type: "property",
      metadata: {
        description: thought.tensorProperties.components
      }
    });
    edges.push({
      id: `e${edgeCount++}`,
      source: tensorId,
      target: componentsId
    });
    if (thought.tensorProperties.symmetries.length > 0) {
      thought.tensorProperties.symmetries.forEach((sym, index) => {
        const symId = `symmetry_${index}`;
        nodes.push({
          id: symId,
          label: includeLabels ? sym : `Symmetry ${index + 1}`,
          type: "symmetry"
        });
        edges.push({
          id: `e${edgeCount++}`,
          source: tensorId,
          target: symId,
          label: "symmetry"
        });
      });
    }
    if (thought.tensorProperties.invariants.length > 0) {
      thought.tensorProperties.invariants.forEach((inv, index) => {
        const invId = `invariant_${index}`;
        nodes.push({
          id: invId,
          label: includeLabels ? inv : `Invariant ${index + 1}`,
          type: "invariant"
        });
        edges.push({
          id: `e${edgeCount++}`,
          source: tensorId,
          target: invId,
          label: "invariant"
        });
      });
    }
  }
  if (thought.physicalInterpretation) {
    const interpId = "interpretation";
    nodes.push({
      id: interpId,
      label: thought.physicalInterpretation.quantity,
      type: "interpretation",
      metadata: {
        description: `Units: ${thought.physicalInterpretation.units}`
      }
    });
    edges.push({
      id: `e${edgeCount++}`,
      source: typeId,
      target: interpId,
      label: "physical meaning"
    });
    const unitsId = "units";
    nodes.push({
      id: unitsId,
      label: thought.physicalInterpretation.units,
      type: "units"
    });
    edges.push({
      id: `e${edgeCount++}`,
      source: interpId,
      target: unitsId,
      label: "measured in"
    });
    if (thought.physicalInterpretation.conservationLaws.length > 0) {
      thought.physicalInterpretation.conservationLaws.forEach((law, index) => {
        const lawId = `conservation_${index}`;
        nodes.push({
          id: lawId,
          label: includeLabels ? law : `Law ${index + 1}`,
          type: "conservation_law"
        });
        edges.push({
          id: `e${edgeCount++}`,
          source: interpId,
          target: lawId,
          label: "conserves"
        });
      });
    }
  }
  if (thought.fieldTheoryContext) {
    const fieldId = "field_theory";
    nodes.push({
      id: fieldId,
      label: "Field Theory",
      type: "field_theory",
      metadata: {
        description: `Symmetry Group: ${thought.fieldTheoryContext.symmetryGroup}`
      }
    });
    edges.push({
      id: `e${edgeCount++}`,
      source: typeId,
      target: fieldId,
      label: "context"
    });
    thought.fieldTheoryContext.fields.forEach((field, index) => {
      const fId = `field_${index}`;
      nodes.push({
        id: fId,
        label: field,
        type: "field"
      });
      edges.push({
        id: `e${edgeCount++}`,
        source: fieldId,
        target: fId,
        label: "includes field"
      });
    });
    const symGroupId = "symmetry_group";
    nodes.push({
      id: symGroupId,
      label: thought.fieldTheoryContext.symmetryGroup,
      type: "symmetry_group"
    });
    edges.push({
      id: `e${edgeCount++}`,
      source: fieldId,
      target: symGroupId,
      label: "has symmetry"
    });
  }
  if (includeMetrics) {
    const metricsId = "metrics";
    nodes.push({
      id: metricsId,
      label: `Uncertainty: ${(thought.uncertainty * 100).toFixed(1)}%`,
      type: "metric",
      metadata: {
        description: `Assumptions: ${thought.assumptions?.length || 0}`
      }
    });
  }
  const graphmlOptions = {
    graphName: "Physics Visualization"
  };
  return generateGraphML(nodes, edges, graphmlOptions);
}
function physicsToTikZ(thought, options) {
  const { includeLabels = true, includeMetrics = true, colorScheme = "default" } = options;
  const nodes = [];
  const edges = [];
  const typeId = "type";
  nodes.push({
    id: typeId,
    x: 0,
    y: 0,
    label: includeLabels ? (thought.thoughtType || "Physics").replace(/_/g, " ") : "Physics",
    shape: "stadium",
    type: "primary"
  });
  let leftColumn = -4;
  let rightColumn = 4;
  let currentRow = -2;
  if (thought.tensorProperties) {
    const tensorId = "tensor";
    nodes.push({
      id: tensorId,
      x: leftColumn,
      y: currentRow,
      label: `Tensor (${thought.tensorProperties.rank[0]},${thought.tensorProperties.rank[1]})`,
      shape: "ellipse",
      type: "tensor"
    });
    edges.push({
      source: typeId,
      target: tensorId
    });
    const componentsId = "components";
    nodes.push({
      id: componentsId,
      x: leftColumn,
      y: currentRow - 1.5,
      label: "Components",
      shape: "rectangle",
      type: "property"
    });
    edges.push({
      source: tensorId,
      target: componentsId,
      style: "dashed"
    });
    if (thought.tensorProperties.symmetries.length > 0) {
      const symId = "symmetries";
      nodes.push({
        id: symId,
        x: leftColumn - 2,
        y: currentRow - 3,
        label: `Symmetries (${thought.tensorProperties.symmetries.length})`,
        shape: "diamond",
        type: "symmetry"
      });
      edges.push({
        source: tensorId,
        target: symId
      });
    }
    if (thought.tensorProperties.invariants.length > 0) {
      const invId = "invariants";
      nodes.push({
        id: invId,
        x: leftColumn + 2,
        y: currentRow - 3,
        label: `Invariants (${thought.tensorProperties.invariants.length})`,
        shape: "diamond",
        type: "invariant"
      });
      edges.push({
        source: tensorId,
        target: invId
      });
    }
  }
  if (thought.physicalInterpretation) {
    const interpId = "interpretation";
    nodes.push({
      id: interpId,
      x: rightColumn,
      y: currentRow,
      label: thought.physicalInterpretation.quantity,
      shape: "rounded",
      type: "interpretation"
    });
    edges.push({
      source: typeId,
      target: interpId
    });
    const unitsId = "units";
    nodes.push({
      id: unitsId,
      x: rightColumn,
      y: currentRow - 1.5,
      label: thought.physicalInterpretation.units,
      shape: "ellipse",
      type: "units"
    });
    edges.push({
      source: interpId,
      target: unitsId,
      style: "dashed"
    });
    if (thought.physicalInterpretation.conservationLaws.length > 0) {
      thought.physicalInterpretation.conservationLaws.forEach((law, index) => {
        const lawId = `conservation_${index}`;
        const offset = (index - (thought.physicalInterpretation.conservationLaws.length - 1) / 2) * 2;
        nodes.push({
          id: lawId,
          x: rightColumn + offset,
          y: currentRow - 3,
          label: includeLabels ? law.substring(0, 20) : `Law ${index + 1}`,
          shape: "rectangle",
          type: "conservation_law"
        });
        edges.push({
          source: interpId,
          target: lawId
        });
      });
    }
  }
  if (thought.fieldTheoryContext) {
    const fieldId = "field_theory";
    nodes.push({
      id: fieldId,
      x: 0,
      y: currentRow - 5,
      label: "Field Theory",
      shape: "stadium",
      type: "field_theory"
    });
    edges.push({
      source: typeId,
      target: fieldId
    });
    thought.fieldTheoryContext.fields.forEach((field, index) => {
      const fId = `field_${index}`;
      const offset = (index - (thought.fieldTheoryContext.fields.length - 1) / 2) * 2.5;
      nodes.push({
        id: fId,
        x: offset,
        y: currentRow - 6.5,
        label: field,
        shape: "rectangle",
        type: "field"
      });
      edges.push({
        source: fieldId,
        target: fId
      });
    });
    const symGroupId = "symmetry_group";
    nodes.push({
      id: symGroupId,
      x: 0,
      y: currentRow - 8,
      label: thought.fieldTheoryContext.symmetryGroup,
      shape: "diamond",
      type: "symmetry_group"
    });
    edges.push({
      source: fieldId,
      target: symGroupId,
      style: "dashed"
    });
  }
  const tikzOptions = {
    title: "Physics Visualization",
    colorScheme
  };
  let tikz = generateTikZ(nodes, edges, tikzOptions);
  if (includeMetrics) {
    const metrics = [
      { label: "Uncertainty", value: `${(thought.uncertainty * 100).toFixed(1)}%` },
      { label: "Assumptions", value: thought.assumptions?.length || 0 }
    ];
    tikz = tikz.replace("\\end{tikzpicture}", renderTikZMetrics(8, -8, metrics) + "\n\\end{tikzpicture}");
  }
  return tikz;
}
function physicsToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Physics Analysis",
    htmlTheme = "light"
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  html += '<div class="metrics-grid">';
  html += renderMetricCard("Uncertainty", `${(thought.uncertainty * 100).toFixed(1)}%`, "warning");
  if (thought.assumptions) {
    html += renderMetricCard("Assumptions", thought.assumptions.length, "info");
  }
  if (thought.tensorProperties) {
    html += renderMetricCard("Tensor Rank", `(${thought.tensorProperties.rank[0]},${thought.tensorProperties.rank[1]})`, "primary");
  }
  if (thought.physicalInterpretation?.conservationLaws) {
    html += renderMetricCard("Conservation Laws", thought.physicalInterpretation.conservationLaws.length, "success");
  }
  html += "</div>\n";
  const badges = [];
  if (thought.thoughtType) {
    badges.push(renderBadge(thought.thoughtType.replace(/_/g, " "), "primary"));
  }
  if (badges.length > 0) {
    html += `<div class="flex gap-1" style="margin: 1rem 0">${badges.join(" ")}</div>
`;
  }
  if (thought.tensorProperties) {
    const tensorRows = [
      ["Rank", `(${thought.tensorProperties.rank[0]}, ${thought.tensorProperties.rank[1]})`],
      ["Components", thought.tensorProperties.components],
      ["LaTeX", thought.tensorProperties.latex],
      ["Transformation", thought.tensorProperties.transformation]
    ];
    if (thought.tensorProperties.indexStructure) {
      tensorRows.push(["Index Structure", thought.tensorProperties.indexStructure]);
    }
    if (thought.tensorProperties.coordinateSystem) {
      tensorRows.push(["Coordinate System", thought.tensorProperties.coordinateSystem]);
    }
    let tensorContent = renderTable(["Property", "Value"], tensorRows);
    if (thought.tensorProperties.symmetries.length > 0) {
      tensorContent += '<p style="margin-top: 1rem"><strong>Symmetries:</strong></p>';
      tensorContent += '<ul class="list-styled">';
      thought.tensorProperties.symmetries.forEach((sym) => {
        tensorContent += `<li>${escapeHTML(sym)}</li>`;
      });
      tensorContent += "</ul>";
    }
    if (thought.tensorProperties.invariants.length > 0) {
      tensorContent += '<p style="margin-top: 1rem"><strong>Invariants:</strong></p>';
      tensorContent += '<ul class="list-styled">';
      thought.tensorProperties.invariants.forEach((inv) => {
        tensorContent += `<li>${escapeHTML(inv)}</li>`;
      });
      tensorContent += "</ul>";
    }
    html += renderSection("Tensor Properties", tensorContent, "\u{1F522}");
  }
  if (thought.physicalInterpretation) {
    const interpRows = [
      ["Quantity", thought.physicalInterpretation.quantity],
      ["Units", thought.physicalInterpretation.units]
    ];
    let interpContent = renderTable(["Property", "Value"], interpRows);
    if (thought.physicalInterpretation.conservationLaws.length > 0) {
      interpContent += '<p style="margin-top: 1rem"><strong>Conservation Laws:</strong></p>';
      interpContent += '<ul class="list-styled">';
      thought.physicalInterpretation.conservationLaws.forEach((law) => {
        interpContent += `<li>${escapeHTML(law)}</li>`;
      });
      interpContent += "</ul>";
    }
    if (thought.physicalInterpretation.constraints && thought.physicalInterpretation.constraints.length > 0) {
      interpContent += '<p style="margin-top: 1rem"><strong>Constraints:</strong></p>';
      interpContent += '<ul class="list-styled">';
      thought.physicalInterpretation.constraints.forEach((constraint) => {
        interpContent += `<li>${escapeHTML(constraint)}</li>`;
      });
      interpContent += "</ul>";
    }
    if (thought.physicalInterpretation.observables && thought.physicalInterpretation.observables.length > 0) {
      interpContent += '<p style="margin-top: 1rem"><strong>Observables:</strong></p>';
      interpContent += '<ul class="list-styled">';
      thought.physicalInterpretation.observables.forEach((obs) => {
        interpContent += `<li>${escapeHTML(obs)}</li>`;
      });
      interpContent += "</ul>";
    }
    html += renderSection("Physical Interpretation", interpContent, "\u269B\uFE0F");
  }
  if (thought.fieldTheoryContext) {
    let fieldContent = `<p><strong>Symmetry Group:</strong> ${renderBadge(thought.fieldTheoryContext.symmetryGroup, "info")}</p>`;
    if (thought.fieldTheoryContext.fields.length > 0) {
      fieldContent += '<p style="margin-top: 1rem"><strong>Fields:</strong></p>';
      fieldContent += '<ul class="list-styled">';
      thought.fieldTheoryContext.fields.forEach((field) => {
        fieldContent += `<li>${escapeHTML(field)}</li>`;
      });
      fieldContent += "</ul>";
    }
    if (thought.fieldTheoryContext.interactions.length > 0) {
      fieldContent += '<p style="margin-top: 1rem"><strong>Interactions:</strong></p>';
      fieldContent += '<ul class="list-styled">';
      thought.fieldTheoryContext.interactions.forEach((interaction) => {
        fieldContent += `<li>${escapeHTML(interaction)}</li>`;
      });
      fieldContent += "</ul>";
    }
    if (thought.fieldTheoryContext.gaugeSymmetries && thought.fieldTheoryContext.gaugeSymmetries.length > 0) {
      fieldContent += '<p style="margin-top: 1rem"><strong>Gauge Symmetries:</strong></p>';
      fieldContent += '<ul class="list-styled">';
      thought.fieldTheoryContext.gaugeSymmetries.forEach((gauge) => {
        fieldContent += `<li>${escapeHTML(gauge)}</li>`;
      });
      fieldContent += "</ul>";
    }
    html += renderSection("Field Theory Context", fieldContent, "\u{1F30C}");
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    const assumptionsList = thought.assumptions.map((a) => escapeHTML(a));
    html += renderSection("Assumptions", `
      <ul class="list-styled">
        ${assumptionsList.map((a) => `<li>${a}</li>`).join("")}
      </ul>
    `, "\u26A0\uFE0F");
  }
  if (thought.dependencies && thought.dependencies.length > 0) {
    const depsList = thought.dependencies.map((d) => escapeHTML(d));
    html += renderSection("Dependencies", `
      <ul class="list-styled">
        ${depsList.map((d) => `<li>${d}</li>`).join("")}
      </ul>
    `, "\u{1F517}");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function physicsToModelica(thought, options) {
  const { includeMetrics = true } = options;
  const packageName = sanitizeModelicaId(thought.thoughtType || "PhysicsModel");
  let modelica = `package ${packageName}
`;
  modelica += `  "${escapeModelicaString("Physics model for " + (thought.thoughtType || "physical system"))}"

`;
  modelica += `  model PhysicalSystem
`;
  modelica += `    "${escapeModelicaString("Physical system representation")}"

`;
  if (thought.tensorProperties) {
    modelica += `    // Tensor Properties
`;
    modelica += `    parameter Integer tensorRank[2] = {${thought.tensorProperties.rank[0]}, ${thought.tensorProperties.rank[1]}};
`;
    modelica += `    parameter String tensorComponents = "${escapeModelicaString(thought.tensorProperties.components)}";
`;
    modelica += `    parameter String tensorTransformation = "${escapeModelicaString(thought.tensorProperties.transformation)}";
`;
    if (thought.tensorProperties.indexStructure) {
      modelica += `    parameter String indexStructure = "${escapeModelicaString(thought.tensorProperties.indexStructure)}";
`;
    }
    if (thought.tensorProperties.coordinateSystem) {
      modelica += `    parameter String coordinateSystem = "${escapeModelicaString(thought.tensorProperties.coordinateSystem)}";
`;
    }
    modelica += "\n";
  }
  if (thought.physicalInterpretation) {
    modelica += `    // Physical Interpretation
`;
    const quantity = sanitizeModelicaId(thought.physicalInterpretation.quantity);
    const units = thought.physicalInterpretation.units;
    modelica += `    Real ${quantity}(unit="${escapeModelicaString(units)}");
`;
    modelica += `    parameter String physicalQuantity = "${escapeModelicaString(thought.physicalInterpretation.quantity)}";
`;
    if (thought.physicalInterpretation.conservationLaws.length > 0) {
      modelica += `
    // Conservation Laws
`;
      thought.physicalInterpretation.conservationLaws.forEach((law, index) => {
        const lawVar = sanitizeModelicaId(`conservationLaw_${index + 1}`);
        modelica += `    parameter String ${lawVar} = "${escapeModelicaString(law)}";
`;
      });
    }
    if (thought.physicalInterpretation.constraints && thought.physicalInterpretation.constraints.length > 0) {
      modelica += `
    // Constraints
`;
      thought.physicalInterpretation.constraints.forEach((constraint, index) => {
        const constraintVar = sanitizeModelicaId(`constraint_${index + 1}`);
        modelica += `    parameter String ${constraintVar} = "${escapeModelicaString(constraint)}";
`;
      });
    }
    if (thought.physicalInterpretation.observables && thought.physicalInterpretation.observables.length > 0) {
      modelica += `
    // Observables
`;
      thought.physicalInterpretation.observables.forEach((obs, index) => {
        const obsVar = sanitizeModelicaId(`observable_${index + 1}`);
        modelica += `    Real ${obsVar} "${escapeModelicaString(obs)}";
`;
      });
    }
    modelica += "\n";
  }
  if (thought.fieldTheoryContext) {
    modelica += `    // Field Theory Context
`;
    modelica += `    parameter String symmetryGroup = "${escapeModelicaString(thought.fieldTheoryContext.symmetryGroup)}";
`;
    if (thought.fieldTheoryContext.fields.length > 0) {
      modelica += `
    // Fields
`;
      thought.fieldTheoryContext.fields.forEach((field, index) => {
        const fieldVar = sanitizeModelicaId(`field_${index + 1}`);
        modelica += `    Real ${fieldVar} "${escapeModelicaString(field)}";
`;
      });
    }
    if (thought.fieldTheoryContext.interactions.length > 0) {
      modelica += `
    // Interactions
`;
      thought.fieldTheoryContext.interactions.forEach((interaction, index) => {
        const intVar = sanitizeModelicaId(`interaction_${index + 1}`);
        modelica += `    parameter String ${intVar} = "${escapeModelicaString(interaction)}";
`;
      });
    }
    if (thought.fieldTheoryContext.gaugeSymmetries && thought.fieldTheoryContext.gaugeSymmetries.length > 0) {
      modelica += `
    // Gauge Symmetries
`;
      thought.fieldTheoryContext.gaugeSymmetries.forEach((gauge, index) => {
        const gaugeVar = sanitizeModelicaId(`gaugeSymmetry_${index + 1}`);
        modelica += `    parameter String ${gaugeVar} = "${escapeModelicaString(gauge)}";
`;
      });
    }
    modelica += "\n";
  }
  if (includeMetrics) {
    modelica += `    // Metrics
`;
    modelica += `    parameter Real uncertainty = ${thought.uncertainty};
`;
    if (thought.assumptions && thought.assumptions.length > 0) {
      modelica += `    parameter Integer assumptionCount = ${thought.assumptions.length};
`;
    }
    modelica += "\n";
  }
  modelica += `  equation
`;
  if (thought.physicalInterpretation) {
    const quantity = sanitizeModelicaId(thought.physicalInterpretation.quantity);
    modelica += `    // Physical evolution (placeholder)
`;
    modelica += `    der(${quantity}) = 0; // Steady state or define custom dynamics
`;
  }
  modelica += `  end PhysicalSystem;

`;
  modelica += `  annotation(
`;
  modelica += `    Documentation(info="<html>
`;
  modelica += `      <p>Physics model generated from reasoning thought</p>
`;
  modelica += `      <p>Uncertainty: ${(thought.uncertainty * 100).toFixed(1)}%</p>
`;
  if (thought.assumptions && thought.assumptions.length > 0) {
    modelica += `      <p>Assumptions: ${thought.assumptions.length}</p>
`;
  }
  modelica += `    </html>")
`;
  modelica += `  );
`;
  modelica += `end ${packageName};
`;
  return modelica;
}
function physicsToUML(thought, options) {
  const { includeLabels = true } = options;
  const nodes = [];
  const edges = [];
  const mainId = "PhysicsSystem";
  nodes.push({
    id: mainId,
    label: includeLabels ? (thought.thoughtType || "Physics").replace(/_/g, " ") : "PhysicsSystem",
    shape: "class",
    attributes: [
      `uncertainty: Real = ${thought.uncertainty.toFixed(3)}`,
      ...thought.assumptions ? [`assumptions: Integer = ${thought.assumptions.length}`] : []
    ],
    methods: []
  });
  if (thought.tensorProperties) {
    const tensorId = "TensorProperties";
    nodes.push({
      id: tensorId,
      label: "TensorProperties",
      shape: "class",
      attributes: [
        `rank: Integer[2] = [${thought.tensorProperties.rank[0]}, ${thought.tensorProperties.rank[1]}]`,
        `components: String = "${thought.tensorProperties.components.substring(0, 30)}..."`,
        `transformation: String = "${thought.tensorProperties.transformation}"`,
        ...thought.tensorProperties.symmetries.length > 0 ? [`symmetries: Integer = ${thought.tensorProperties.symmetries.length}`] : [],
        ...thought.tensorProperties.invariants.length > 0 ? [`invariants: Integer = ${thought.tensorProperties.invariants.length}`] : []
      ],
      methods: []
    });
    edges.push({
      source: mainId,
      target: tensorId,
      type: "composition",
      label: "has"
    });
  }
  if (thought.physicalInterpretation) {
    const interpId = "PhysicalInterpretation";
    nodes.push({
      id: interpId,
      label: "PhysicalInterpretation",
      shape: "class",
      attributes: [
        `quantity: String = "${thought.physicalInterpretation.quantity}"`,
        `units: String = "${thought.physicalInterpretation.units}"`,
        `conservationLaws: Integer = ${thought.physicalInterpretation.conservationLaws.length}`,
        ...thought.physicalInterpretation.constraints ? [`constraints: Integer = ${thought.physicalInterpretation.constraints.length}`] : [],
        ...thought.physicalInterpretation.observables ? [`observables: Integer = ${thought.physicalInterpretation.observables.length}`] : []
      ],
      methods: [
        "measure(): Real",
        "validate(): Boolean"
      ]
    });
    edges.push({
      source: mainId,
      target: interpId,
      type: "composition",
      label: "interprets as"
    });
    if (thought.physicalInterpretation.conservationLaws.length > 0) {
      const lawsId = "ConservationLaws";
      nodes.push({
        id: lawsId,
        label: "ConservationLaws",
        shape: "class",
        attributes: thought.physicalInterpretation.conservationLaws.map(
          (law, i) => `law${i + 1}: String = "${law.substring(0, 30)}..."`
        ),
        methods: ["verify(): Boolean"]
      });
      edges.push({
        source: interpId,
        target: lawsId,
        type: "association",
        label: "enforces"
      });
    }
  }
  if (thought.fieldTheoryContext) {
    const fieldId = "FieldTheory";
    nodes.push({
      id: fieldId,
      label: "FieldTheory",
      shape: "class",
      attributes: [
        `symmetryGroup: String = "${thought.fieldTheoryContext.symmetryGroup}"`,
        `fields: Integer = ${thought.fieldTheoryContext.fields.length}`,
        `interactions: Integer = ${thought.fieldTheoryContext.interactions.length}`,
        ...thought.fieldTheoryContext.gaugeSymmetries ? [`gaugeSymmetries: Integer = ${thought.fieldTheoryContext.gaugeSymmetries.length}`] : []
      ],
      methods: [
        "computeField(x: Real): Real",
        "applySymmetry(g: Group): Field"
      ]
    });
    edges.push({
      source: mainId,
      target: fieldId,
      type: "composition",
      label: "described by"
    });
    if (thought.fieldTheoryContext.fields.length > 0 && thought.fieldTheoryContext.fields.length <= 3) {
      thought.fieldTheoryContext.fields.forEach((field, index) => {
        const fId = `Field${index + 1}`;
        nodes.push({
          id: fId,
          label: field,
          shape: "class",
          attributes: ["value: Real", "gradient: Real"],
          methods: ["evaluate(x: Real): Real"]
        });
        edges.push({
          source: fieldId,
          target: fId,
          type: "aggregation",
          label: "contains"
        });
      });
    }
  }
  return generateUmlDiagram(nodes, edges, {
    title: "Physics System UML"});
}
function physicsToJSON(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const graph = createJsonGraph("physics_system", "Physics System Model");
  const typeId = "type";
  addNode(graph, {
    id: typeId,
    label: includeLabels ? (thought.thoughtType || "Physics").replace(/_/g, " ") : "Physics",
    type: "thought_type",
    metadata: {
      thoughtType: thought.thoughtType || "physics"
    }
  });
  if (thought.tensorProperties) {
    const tensorId = "tensor";
    addNode(graph, {
      id: tensorId,
      label: `Tensor (${thought.tensorProperties.rank[0]},${thought.tensorProperties.rank[1]})`,
      type: "tensor",
      metadata: {
        rank: thought.tensorProperties.rank,
        components: thought.tensorProperties.components,
        transformation: thought.tensorProperties.transformation,
        indexStructure: thought.tensorProperties.indexStructure,
        coordinateSystem: thought.tensorProperties.coordinateSystem
      }
    });
    addEdge(graph, {
      id: "edge_type_tensor",
      source: typeId,
      target: tensorId,
      label: "has_tensor",
      directed: true
    });
    if (thought.tensorProperties.symmetries.length > 0) {
      thought.tensorProperties.symmetries.forEach((sym, index) => {
        const symId = `symmetry_${index}`;
        addNode(graph, {
          id: symId,
          label: sym,
          type: "symmetry",
          metadata: { description: sym }
        });
        addEdge(graph, {
          id: `edge_tensor_sym_${index}`,
          source: tensorId,
          target: symId,
          label: "has_symmetry",
          directed: true
        });
      });
    }
    if (thought.tensorProperties.invariants.length > 0) {
      thought.tensorProperties.invariants.forEach((inv, index) => {
        const invId = `invariant_${index}`;
        addNode(graph, {
          id: invId,
          label: inv,
          type: "invariant",
          metadata: { description: inv }
        });
        addEdge(graph, {
          id: `edge_tensor_inv_${index}`,
          source: tensorId,
          target: invId,
          label: "has_invariant",
          directed: true
        });
      });
    }
  }
  if (thought.physicalInterpretation) {
    const interpId = "interpretation";
    addNode(graph, {
      id: interpId,
      label: thought.physicalInterpretation.quantity,
      type: "physical_interpretation",
      metadata: {
        quantity: thought.physicalInterpretation.quantity,
        units: thought.physicalInterpretation.units,
        conservationLaws: thought.physicalInterpretation.conservationLaws,
        constraints: thought.physicalInterpretation.constraints,
        observables: thought.physicalInterpretation.observables
      }
    });
    addEdge(graph, {
      id: "edge_type_interp",
      source: typeId,
      target: interpId,
      label: "interprets_as",
      directed: true
    });
    const unitsId = "units";
    addNode(graph, {
      id: unitsId,
      label: thought.physicalInterpretation.units,
      type: "units",
      metadata: { units: thought.physicalInterpretation.units }
    });
    addEdge(graph, {
      id: "edge_interp_units",
      source: interpId,
      target: unitsId,
      label: "measured_in",
      directed: true
    });
    if (thought.physicalInterpretation.conservationLaws.length > 0) {
      thought.physicalInterpretation.conservationLaws.forEach((law, index) => {
        const lawId = `conservation_${index}`;
        addNode(graph, {
          id: lawId,
          label: includeLabels ? law : `Law ${index + 1}`,
          type: "conservation_law",
          metadata: { law }
        });
        addEdge(graph, {
          id: `edge_interp_law_${index}`,
          source: interpId,
          target: lawId,
          label: "conserves",
          directed: true
        });
      });
    }
    if (thought.physicalInterpretation.observables && thought.physicalInterpretation.observables.length > 0) {
      thought.physicalInterpretation.observables.forEach((obs, index) => {
        const obsId = `observable_${index}`;
        addNode(graph, {
          id: obsId,
          label: obs,
          type: "observable",
          metadata: { observable: obs }
        });
        addEdge(graph, {
          id: `edge_interp_obs_${index}`,
          source: interpId,
          target: obsId,
          label: "has_observable",
          directed: true
        });
      });
    }
  }
  if (thought.fieldTheoryContext) {
    const fieldId = "field_theory";
    addNode(graph, {
      id: fieldId,
      label: "Field Theory",
      type: "field_theory",
      metadata: {
        symmetryGroup: thought.fieldTheoryContext.symmetryGroup,
        fields: thought.fieldTheoryContext.fields,
        interactions: thought.fieldTheoryContext.interactions,
        gaugeSymmetries: thought.fieldTheoryContext.gaugeSymmetries
      }
    });
    addEdge(graph, {
      id: "edge_type_field",
      source: typeId,
      target: fieldId,
      label: "has_context",
      directed: true
    });
    thought.fieldTheoryContext.fields.forEach((field, index) => {
      const fId = `field_${index}`;
      addNode(graph, {
        id: fId,
        label: field,
        type: "field",
        metadata: { field }
      });
      addEdge(graph, {
        id: `edge_field_f_${index}`,
        source: fieldId,
        target: fId,
        label: "includes_field",
        directed: true
      });
    });
    const symGroupId = "symmetry_group";
    addNode(graph, {
      id: symGroupId,
      label: thought.fieldTheoryContext.symmetryGroup,
      type: "symmetry_group",
      metadata: { group: thought.fieldTheoryContext.symmetryGroup }
    });
    addEdge(graph, {
      id: "edge_field_symgroup",
      source: fieldId,
      target: symGroupId,
      label: "has_symmetry_group",
      directed: true
    });
  }
  if (includeMetrics) {
    addMetric(graph, "uncertainty", thought.uncertainty);
    if (thought.assumptions) {
      addMetric(graph, "assumption_count", thought.assumptions.length);
    }
    if (thought.dependencies) {
      addMetric(graph, "dependency_count", thought.dependencies.length);
    }
  }
  return serializeGraph(graph);
}
function physicsToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  const typeContent = `**Type:** ${(thought.thoughtType || "physics").replace(/_/g, " ")}`;
  parts.push(section("Overview", typeContent));
  if (thought.tensorProperties) {
    const tensorContent = keyValueSection({
      "Rank": `(${thought.tensorProperties.rank[0]}, ${thought.tensorProperties.rank[1]})`,
      "Components": thought.tensorProperties.components,
      "LaTeX": thought.tensorProperties.latex,
      "Transformation": thought.tensorProperties.transformation,
      ...thought.tensorProperties.indexStructure ? { "Index Structure": thought.tensorProperties.indexStructure } : {},
      ...thought.tensorProperties.coordinateSystem ? { "Coordinate System": thought.tensorProperties.coordinateSystem } : {}
    });
    let tensorFull = tensorContent;
    if (thought.tensorProperties.symmetries.length > 0) {
      tensorFull += "\n\n**Symmetries:**\n\n" + list(thought.tensorProperties.symmetries);
    }
    if (thought.tensorProperties.invariants.length > 0) {
      tensorFull += "\n\n**Invariants:**\n\n" + list(thought.tensorProperties.invariants);
    }
    parts.push(section("Tensor Properties", tensorFull));
  }
  if (thought.physicalInterpretation) {
    const interpContent = keyValueSection({
      "Quantity": thought.physicalInterpretation.quantity,
      "Units": thought.physicalInterpretation.units
    });
    let interpFull = interpContent;
    if (thought.physicalInterpretation.conservationLaws.length > 0) {
      interpFull += "\n\n**Conservation Laws:**\n\n" + list(thought.physicalInterpretation.conservationLaws);
    }
    if (thought.physicalInterpretation.constraints && thought.physicalInterpretation.constraints.length > 0) {
      interpFull += "\n\n**Constraints:**\n\n" + list(thought.physicalInterpretation.constraints);
    }
    if (thought.physicalInterpretation.observables && thought.physicalInterpretation.observables.length > 0) {
      interpFull += "\n\n**Observables:**\n\n" + list(thought.physicalInterpretation.observables);
    }
    parts.push(section("Physical Interpretation", interpFull));
  }
  if (thought.fieldTheoryContext) {
    const fieldContent = keyValueSection({
      "Symmetry Group": thought.fieldTheoryContext.symmetryGroup
    });
    let fieldFull = fieldContent;
    if (thought.fieldTheoryContext.fields.length > 0) {
      fieldFull += "\n\n**Fields:**\n\n" + list(thought.fieldTheoryContext.fields);
    }
    if (thought.fieldTheoryContext.interactions.length > 0) {
      fieldFull += "\n\n**Interactions:**\n\n" + list(thought.fieldTheoryContext.interactions);
    }
    if (thought.fieldTheoryContext.gaugeSymmetries && thought.fieldTheoryContext.gaugeSymmetries.length > 0) {
      fieldFull += "\n\n**Gauge Symmetries:**\n\n" + list(thought.fieldTheoryContext.gaugeSymmetries);
    }
    parts.push(section("Field Theory Context", fieldFull));
  }
  if (includeMetrics) {
    const metricsContent = keyValueSection({
      "Uncertainty": `${(thought.uncertainty * 100).toFixed(1)}%`,
      ...thought.assumptions ? { "Assumptions": thought.assumptions.length } : {},
      ...thought.dependencies ? { "Dependencies": thought.dependencies.length } : {}
    });
    parts.push(section("Metrics", metricsContent + "\n\n" + progressBar(thought.uncertainty * 100)));
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    parts.push(section("Assumptions", list(thought.assumptions)));
  }
  if (thought.dependencies && thought.dependencies.length > 0) {
    parts.push(section("Dependencies", list(thought.dependencies)));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = physicsToMermaid(thought, "default", true, true);
    parts.push(section("Visualization", mermaidBlock(mermaidDiagram)));
  }
  return document("Physics Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "physics",
      thoughtType: thought.thoughtType || "physics",
      uncertainty: thought.uncertainty
    }
  });
}
var init_physics = __esm({
  "src/export/visual/physics.ts"() {
    init_esm_shims();
    init_utils();
    init_svg_utils();
    init_graphml_utils();
    init_tikz_utils();
    init_html_utils();
    init_modelica_utils();
    init_uml_utils();
    init_json_utils();
    init_markdown_utils();
  }
});

// src/export/visual/hybrid.ts
function exportHybridOrchestration(thought, options) {
  const { format, colorScheme = "default", includeMetrics = true } = options;
  const includeLabels = options.includeLabels !== false;
  switch (format) {
    case "mermaid":
      return hybridToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return hybridToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return hybridToASCII(thought);
    case "svg":
      return hybridToSVG(thought, options);
    case "graphml":
      return hybridToGraphML(thought, options);
    case "tikz":
      return hybridToTikZ(thought, options);
    case "html":
      return hybridToHTML(thought, options);
    case "modelica":
      return hybridToModelica(thought, options);
    case "uml":
      return hybridToUML(thought, options);
    case "json":
      return hybridToJSON(thought, options);
    case "markdown":
      return hybridToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function hybridToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TB\n";
  const hybridId = sanitizeId("hybrid_mode");
  mermaid += `  ${hybridId}(("Hybrid Mode"))
`;
  const primaryId = sanitizeId(`primary_${thought.primaryMode}`);
  const primaryLabel = includeLabels ? thought.primaryMode.charAt(0).toUpperCase() + thought.primaryMode.slice(1) : primaryId;
  mermaid += `  ${primaryId}[["${primaryLabel}"]]
`;
  mermaid += `  ${hybridId} ==> ${primaryId}
`;
  if (thought.secondaryFeatures && thought.secondaryFeatures.length > 0) {
    const secondaryId = sanitizeId("secondary_features");
    mermaid += `  ${secondaryId}(["Secondary Features"])
`;
    mermaid += `  ${hybridId} --> ${secondaryId}
`;
    thought.secondaryFeatures.forEach((feature, index) => {
      const featureId = sanitizeId(`feature_${index}`);
      const featureLabel = includeLabels ? feature.slice(0, 30) + (feature.length > 30 ? "..." : "") : `Feature ${index + 1}`;
      mermaid += `  ${featureId}["${featureLabel}"]
`;
      mermaid += `  ${secondaryId} --> ${featureId}
`;
    });
  }
  if (thought.switchReason) {
    const switchId = sanitizeId("switch_reason");
    const switchLabel = includeLabels ? thought.switchReason.slice(0, 40) + (thought.switchReason.length > 40 ? "..." : "") : "Switch Reason";
    mermaid += `  ${switchId}>"${switchLabel}"]
`;
    mermaid += `  ${hybridId} -.-> ${switchId}
`;
  }
  if (thought.stage) {
    const stageId = sanitizeId(`stage_${thought.stage}`);
    const stageLabel = thought.stage.replace(/_/g, " ");
    mermaid += `  ${stageId}{{"Stage: ${stageLabel}"}}
`;
    mermaid += `  ${primaryId} --> ${stageId}
`;
  }
  if (thought.mathematicalModel) {
    const modelId = sanitizeId("math_model");
    const modelLabel = thought.mathematicalModel.symbolic || "Mathematical Model";
    mermaid += `  ${modelId}["${modelLabel}"]
`;
    mermaid += `  ${primaryId} --> ${modelId}
`;
  }
  if (thought.tensorProperties) {
    const tensorId = sanitizeId("tensor");
    const tensorLabel = `Tensor (${thought.tensorProperties.rank[0]},${thought.tensorProperties.rank[1]})`;
    mermaid += `  ${tensorId}[/"${tensorLabel}"/]
`;
    mermaid += `  ${primaryId} --> ${tensorId}
`;
  }
  if (thought.physicalInterpretation) {
    const physId = sanitizeId("physical");
    mermaid += `  ${physId}[/"${thought.physicalInterpretation.quantity}"/]
`;
    mermaid += `  ${primaryId} --> ${physId}
`;
  }
  if (includeMetrics && thought.uncertainty !== void 0) {
    const uncertId = sanitizeId("uncertainty");
    const uncertLabel = `Uncertainty: ${(thought.uncertainty * 100).toFixed(1)}%`;
    mermaid += `  ${uncertId}{{${uncertLabel}}}
`;
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    const assumptionsId = sanitizeId("assumptions");
    mermaid += `  ${assumptionsId}>"Assumptions: ${thought.assumptions.length}"]
`;
  }
  if (thought.dependencies && thought.dependencies.length > 0) {
    const depsId = sanitizeId("dependencies");
    mermaid += `  ${depsId}>"Dependencies: ${thought.dependencies.length}"]
`;
  }
  if (colorScheme !== "monochrome") {
    const colors = colorScheme === "pastel" ? { hybrid: "#e8f4e8", primary: "#e3f2fd", secondary: "#fff3e0" } : { hybrid: "#90EE90", primary: "#87CEEB", secondary: "#FFD700" };
    mermaid += `
  style ${hybridId} fill:${colors.hybrid}
`;
    mermaid += `  style ${primaryId} fill:${colors.primary}
`;
    if (thought.secondaryFeatures && thought.secondaryFeatures.length > 0) {
      mermaid += `  style ${sanitizeId("secondary_features")} fill:${colors.secondary}
`;
    }
  }
  return mermaid;
}
function hybridToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph HybridOrchestration {\n";
  dot += "  rankdir=TB;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  const hybridId = sanitizeId("hybrid_mode");
  dot += `  ${hybridId} [label="Hybrid Mode", shape=doubleoctagon];
`;
  const primaryId = sanitizeId(`primary_${thought.primaryMode}`);
  const primaryLabel = thought.primaryMode.charAt(0).toUpperCase() + thought.primaryMode.slice(1);
  dot += `  ${primaryId} [label="${primaryLabel}", shape=box, style="filled,rounded", fillcolor=lightblue];
`;
  dot += `  ${hybridId} -> ${primaryId} [style=bold, penwidth=2];
`;
  if (thought.secondaryFeatures && thought.secondaryFeatures.length > 0) {
    const secondaryId = sanitizeId("secondary_features");
    dot += `  ${secondaryId} [label="Secondary Features", shape=ellipse];
`;
    dot += `  ${hybridId} -> ${secondaryId};
`;
    thought.secondaryFeatures.forEach((feature, index) => {
      const featureId = sanitizeId(`feature_${index}`);
      const featureLabel = includeLabels ? feature.slice(0, 25).replace(/"/g, '\\"') : `Feature ${index + 1}`;
      dot += `  ${featureId} [label="${featureLabel}"];
`;
      dot += `  ${secondaryId} -> ${featureId};
`;
    });
  }
  if (thought.switchReason) {
    const switchId = sanitizeId("switch_reason");
    const switchLabel = includeLabels ? thought.switchReason.slice(0, 30).replace(/"/g, '\\"') : "Switch Reason";
    dot += `  ${switchId} [label="${switchLabel}", shape=note];
`;
    dot += `  ${hybridId} -> ${switchId} [style=dashed];
`;
  }
  if (thought.stage) {
    const stageId = sanitizeId(`stage_${thought.stage}`);
    dot += `  ${stageId} [label="${thought.stage.replace(/_/g, " ")}", shape=diamond];
`;
    dot += `  ${primaryId} -> ${stageId};
`;
  }
  if (thought.mathematicalModel) {
    const modelId = sanitizeId("math_model");
    const modelLabel = thought.mathematicalModel.symbolic ? thought.mathematicalModel.symbolic.slice(0, 25).replace(/"/g, '\\"') : "Math Model";
    dot += `  ${modelId} [label="${modelLabel}", shape=parallelogram];
`;
    dot += `  ${primaryId} -> ${modelId};
`;
  }
  if (thought.tensorProperties) {
    const tensorId = sanitizeId("tensor");
    dot += `  ${tensorId} [label="Tensor (${thought.tensorProperties.rank[0]},${thought.tensorProperties.rank[1]})", shape=parallelogram];
`;
    dot += `  ${primaryId} -> ${tensorId};
`;
  }
  if (thought.physicalInterpretation) {
    const physId = sanitizeId("physical");
    dot += `  ${physId} [label="${thought.physicalInterpretation.quantity}", shape=parallelogram];
`;
    dot += `  ${primaryId} -> ${physId};
`;
  }
  if (includeMetrics && thought.uncertainty !== void 0) {
    const uncertId = sanitizeId("uncertainty");
    dot += `  ${uncertId} [label="${(thought.uncertainty * 100).toFixed(1)}%", shape=diamond];
`;
  }
  dot += "}\n";
  return dot;
}
function hybridToASCII(thought) {
  let ascii = "Hybrid Mode Orchestration:\n";
  ascii += "==========================\n\n";
  ascii += `Primary Mode: ${thought.primaryMode.charAt(0).toUpperCase() + thought.primaryMode.slice(1)}
`;
  if (thought.stage) {
    ascii += `Current Stage: ${thought.stage.replace(/_/g, " ")}
`;
  }
  if (thought.uncertainty !== void 0) {
    ascii += `Uncertainty: ${(thought.uncertainty * 100).toFixed(1)}%
`;
  }
  ascii += "\n";
  if (thought.switchReason) {
    ascii += `Switch Reason: ${thought.switchReason}

`;
  }
  if (thought.secondaryFeatures && thought.secondaryFeatures.length > 0) {
    ascii += "Secondary Features:\n";
    thought.secondaryFeatures.forEach((feature, index) => {
      ascii += `  ${index + 1}. ${feature}
`;
    });
    ascii += "\n";
  }
  if (thought.mathematicalModel) {
    ascii += "Mathematical Model:\n";
    ascii += `  LaTeX: ${thought.mathematicalModel.latex}
`;
    ascii += `  Symbolic: ${thought.mathematicalModel.symbolic}
`;
    if (thought.mathematicalModel.ascii) {
      ascii += `  ASCII: ${thought.mathematicalModel.ascii}
`;
    }
    ascii += "\n";
  }
  if (thought.tensorProperties) {
    ascii += "Tensor Properties:\n";
    ascii += `  Rank: (${thought.tensorProperties.rank[0]}, ${thought.tensorProperties.rank[1]})
`;
    ascii += `  Components: ${thought.tensorProperties.components}
`;
    ascii += `  Transformation: ${thought.tensorProperties.transformation}
`;
    if (thought.tensorProperties.symmetries.length > 0) {
      ascii += "  Symmetries:\n";
      thought.tensorProperties.symmetries.forEach((sym, index) => {
        ascii += `    ${index + 1}. ${sym}
`;
      });
    }
    ascii += "\n";
  }
  if (thought.physicalInterpretation) {
    ascii += "Physical Interpretation:\n";
    ascii += `  Quantity: ${thought.physicalInterpretation.quantity}
`;
    ascii += `  Units: ${thought.physicalInterpretation.units}
`;
    if (thought.physicalInterpretation.conservationLaws.length > 0) {
      ascii += "  Conservation Laws:\n";
      thought.physicalInterpretation.conservationLaws.forEach((law, index) => {
        ascii += `    ${index + 1}. ${law}
`;
      });
    }
    ascii += "\n";
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    ascii += "Assumptions:\n";
    thought.assumptions.forEach((assumption, index) => {
      ascii += `  ${index + 1}. ${assumption}
`;
    });
    ascii += "\n";
  }
  if (thought.dependencies && thought.dependencies.length > 0) {
    ascii += "Dependencies:\n";
    thought.dependencies.forEach((dep, index) => {
      ascii += `  ${index + 1}. ${dep}
`;
    });
    ascii += "\n";
  }
  if (thought.revisionReason) {
    ascii += `Revision Reason: ${thought.revisionReason}
`;
  }
  return ascii;
}
function hybridToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width,
    svgHeight = DEFAULT_SVG_OPTIONS.height
  } = options;
  const positions = /* @__PURE__ */ new Map();
  const nodeWidth = 150;
  const nodeHeight = 40;
  positions.set("hybrid", {
    id: "hybrid",
    label: "Hybrid Mode",
    x: svgWidth / 2,
    y: 100,
    width: nodeWidth,
    height: nodeHeight,
    type: "hybrid"
  });
  positions.set("primary", {
    id: "primary",
    label: thought.primaryMode.charAt(0).toUpperCase() + thought.primaryMode.slice(1),
    x: svgWidth / 2,
    y: 240,
    width: nodeWidth,
    height: nodeHeight,
    type: "primary"
  });
  if (thought.secondaryFeatures && thought.secondaryFeatures.length > 0) {
    thought.secondaryFeatures.forEach((feature, index) => {
      positions.set(`feature_${index}`, {
        id: `feature_${index}`,
        label: includeLabels ? feature.substring(0, 30) + (feature.length > 30 ? "..." : "") : `Feature ${index + 1}`,
        x: 150 + index * 180,
        y: 380,
        width: nodeWidth,
        height: nodeHeight,
        type: "feature"
      });
    });
  }
  let svg = generateSVGHeader(svgWidth, svgHeight, "Hybrid Mode Orchestration");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  const hybridPos = positions.get("hybrid");
  const primaryPos = positions.get("primary");
  if (hybridPos && primaryPos) {
    svg += renderEdge(hybridPos, primaryPos, { style: "solid" });
  }
  if (thought.secondaryFeatures) {
    thought.secondaryFeatures.forEach((_, index) => {
      const featurePos = positions.get(`feature_${index}`);
      if (hybridPos && featurePos) {
        svg += renderEdge(hybridPos, featurePos);
      }
    });
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  const hybridColors = getNodeColor("success", colorScheme);
  const primaryColors = getNodeColor("primary", colorScheme);
  const featureColors = getNodeColor("secondary", colorScheme);
  for (const [, pos] of positions) {
    if (pos.type === "hybrid") {
      svg += renderEllipseNode(pos, hybridColors);
    } else if (pos.type === "primary") {
      svg += renderStadiumNode(pos, primaryColors);
    } else if (pos.type === "feature") {
      svg += renderRectNode(pos, featureColors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Primary Mode", value: thought.primaryMode },
      { label: "Secondary Features", value: thought.secondaryFeatures?.length || 0 },
      { label: "Uncertainty", value: thought.uncertainty !== void 0 ? `${(thought.uncertainty * 100).toFixed(1)}%` : "N/A" }
    ];
    svg += renderMetricsPanel(svgWidth - 200, svgHeight - 120, metrics);
  }
  const legendItems = [
    { label: "Hybrid Mode", color: hybridColors, shape: "ellipse" },
    { label: "Primary Mode", color: primaryColors, shape: "stadium" },
    { label: "Secondary Feature", color: featureColors }
  ];
  svg += renderLegend(20, svgHeight - 110, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function hybridToGraphML(thought, options) {
  const { includeLabels = true } = options;
  const nodes = [];
  const edges = [];
  nodes.push({
    id: sanitizeId("hybrid_mode"),
    label: includeLabels ? "Hybrid Mode" : "hybrid",
    type: "hybrid"
  });
  const primaryId = sanitizeId(`primary_${thought.primaryMode}`);
  nodes.push({
    id: primaryId,
    label: includeLabels ? thought.primaryMode.charAt(0).toUpperCase() + thought.primaryMode.slice(1) : thought.primaryMode,
    type: "primary"
  });
  edges.push({
    id: "e_hybrid_primary",
    source: sanitizeId("hybrid_mode"),
    target: primaryId,
    directed: true
  });
  if (thought.secondaryFeatures && thought.secondaryFeatures.length > 0) {
    thought.secondaryFeatures.forEach((feature, index) => {
      const featureId = sanitizeId(`feature_${index}`);
      nodes.push({
        id: featureId,
        label: includeLabels ? feature.substring(0, 50) + (feature.length > 50 ? "..." : "") : `Feature ${index + 1}`,
        type: "secondary"
      });
      edges.push({
        id: `e_hybrid_feature_${index}`,
        source: sanitizeId("hybrid_mode"),
        target: featureId,
        directed: true
      });
    });
  }
  if (thought.stage) {
    const stageId = sanitizeId(`stage_${thought.stage}`);
    nodes.push({
      id: stageId,
      label: includeLabels ? thought.stage.replace(/_/g, " ") : "stage",
      type: "stage"
    });
    edges.push({
      id: "e_primary_stage",
      source: primaryId,
      target: stageId,
      directed: true
    });
  }
  return generateGraphML(nodes, edges, {
    graphName: "Hybrid Orchestration",
    directed: true,
    includeLabels
  });
}
function hybridToTikZ(thought, options) {
  const { includeLabels = true, colorScheme = "default" } = options;
  const nodes = [];
  const edges = [];
  nodes.push({
    id: sanitizeId("hybrid_mode"),
    label: includeLabels ? "Hybrid Mode" : "hybrid",
    x: 4,
    y: 0,
    type: "success",
    shape: "ellipse"
  });
  const primaryId = sanitizeId(`primary_${thought.primaryMode}`);
  nodes.push({
    id: primaryId,
    label: includeLabels ? thought.primaryMode.charAt(0).toUpperCase() + thought.primaryMode.slice(1) : thought.primaryMode,
    x: 4,
    y: -2,
    type: "primary",
    shape: "stadium"
  });
  edges.push({
    source: sanitizeId("hybrid_mode"),
    target: primaryId,
    directed: true
  });
  if (thought.secondaryFeatures && thought.secondaryFeatures.length > 0) {
    const featureCount = thought.secondaryFeatures.length;
    const spacing = 3;
    const totalWidth = (featureCount - 1) * spacing;
    const startX = 4 - totalWidth / 2;
    thought.secondaryFeatures.forEach((feature, index) => {
      const featureId = sanitizeId(`feature_${index}`);
      nodes.push({
        id: featureId,
        label: includeLabels ? feature.length > 20 ? feature.substring(0, 20) + "..." : feature : `F${index + 1}`,
        x: startX + index * spacing,
        y: -4,
        type: "secondary",
        shape: "rectangle"
      });
      edges.push({
        source: primaryId,
        target: featureId,
        directed: true
      });
    });
  }
  if (thought.stage) {
    const stageId = sanitizeId(`stage_${thought.stage}`);
    nodes.push({
      id: stageId,
      label: includeLabels ? thought.stage.replace(/_/g, " ") : "stage",
      x: 7,
      y: -2,
      type: "info",
      shape: "diamond"
    });
    edges.push({
      source: primaryId,
      target: stageId,
      directed: true,
      style: "dashed"
    });
  }
  return generateTikZ(nodes, edges, {
    title: "Hybrid Orchestration",
    colorScheme,
    includeLabels
  });
}
function hybridToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Hybrid Mode Orchestration",
    htmlTheme = "light"
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  html += '<div class="metrics-grid">';
  html += renderMetricCard("Primary Mode", thought.primaryMode, "primary");
  if (thought.secondaryFeatures) {
    html += renderMetricCard("Secondary Features", thought.secondaryFeatures.length, "info");
  }
  if (thought.uncertainty !== void 0) {
    html += renderMetricCard("Uncertainty", `${(thought.uncertainty * 100).toFixed(1)}%`, "warning");
  }
  if (thought.stage) {
    html += renderMetricCard("Stage", thought.stage.replace(/_/g, " "), "secondary");
  }
  html += "</div>\n";
  const badges = [];
  badges.push(renderBadge(`Primary: ${thought.primaryMode}`, "primary"));
  if (thought.stage) {
    badges.push(renderBadge(thought.stage.replace(/_/g, " "), "info"));
  }
  html += `<div class="flex gap-1 flex-wrap" style="margin: 1rem 0">${badges.join(" ")}</div>
`;
  if (thought.switchReason) {
    html += renderSection("Mode Switch Reason", `
      <p>${escapeHTML(thought.switchReason)}</p>
    `, "\u{1F504}");
  }
  if (thought.secondaryFeatures && thought.secondaryFeatures.length > 0) {
    const featuresContent = `
      <ul class="list-styled">
        ${thought.secondaryFeatures.map((f) => `<li>${escapeHTML(f)}</li>`).join("")}
      </ul>
    `;
    html += renderSection("Secondary Features", featuresContent, "\u2699\uFE0F");
  }
  if (thought.mathematicalModel) {
    const modelContent = `
      <p><strong>LaTeX:</strong> <code>${escapeHTML(thought.mathematicalModel.latex)}</code></p>
      <p><strong>Symbolic:</strong> <code>${escapeHTML(thought.mathematicalModel.symbolic)}</code></p>
      ${thought.mathematicalModel.ascii ? `<p><strong>ASCII:</strong> <code>${escapeHTML(thought.mathematicalModel.ascii)}</code></p>` : ""}
    `;
    html += renderSection("Mathematical Model", modelContent, "\u{1F4D0}");
  }
  if (thought.tensorProperties) {
    const tensorRows = [
      ["Rank", `(${thought.tensorProperties.rank[0]}, ${thought.tensorProperties.rank[1]})`],
      ["Components", thought.tensorProperties.components],
      ["Transformation", thought.tensorProperties.transformation]
    ];
    let tensorContent = renderTable(["Property", "Value"], tensorRows);
    if (thought.tensorProperties.symmetries.length > 0) {
      tensorContent += '<p style="margin-top: 1rem"><strong>Symmetries:</strong></p>';
      tensorContent += '<ul class="list-styled">';
      thought.tensorProperties.symmetries.forEach((sym) => {
        tensorContent += `<li>${escapeHTML(sym)}</li>`;
      });
      tensorContent += "</ul>";
    }
    html += renderSection("Tensor Properties", tensorContent, "\u{1F522}");
  }
  if (thought.physicalInterpretation) {
    const interpRows = [
      ["Quantity", thought.physicalInterpretation.quantity],
      ["Units", thought.physicalInterpretation.units]
    ];
    let interpContent = renderTable(["Property", "Value"], interpRows);
    if (thought.physicalInterpretation.conservationLaws.length > 0) {
      interpContent += '<p style="margin-top: 1rem"><strong>Conservation Laws:</strong></p>';
      interpContent += '<ul class="list-styled">';
      thought.physicalInterpretation.conservationLaws.forEach((law) => {
        interpContent += `<li>${escapeHTML(law)}</li>`;
      });
      interpContent += "</ul>";
    }
    html += renderSection("Physical Interpretation", interpContent, "\u269B\uFE0F");
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    const assumptionsList = thought.assumptions.map((a) => escapeHTML(a));
    html += renderSection("Assumptions", `
      <ul class="list-styled">
        ${assumptionsList.map((a) => `<li>${a}</li>`).join("")}
      </ul>
    `, "\u26A0\uFE0F");
  }
  if (thought.dependencies && thought.dependencies.length > 0) {
    const depsList = thought.dependencies.map((d) => escapeHTML(d));
    html += renderSection("Dependencies", `
      <ul class="list-styled">
        ${depsList.map((d) => `<li>${d}</li>`).join("")}
      </ul>
    `, "\u{1F517}");
  }
  if (thought.revisionReason) {
    html += renderSection("Revision Reason", `
      <p>${escapeHTML(thought.revisionReason)}</p>
    `, "\u270F\uFE0F");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function hybridToModelica(thought, options) {
  const { includeMetrics = true } = options;
  let modelica = "// Hybrid Mode Orchestration\n";
  modelica += "// Multi-mode reasoning orchestration package\n\n";
  const packageName = sanitizeModelicaId("HybridOrchestration");
  modelica += `package ${packageName}
`;
  modelica += '  "Hybrid mode reasoning orchestration with primary and secondary features"\n\n';
  modelica += "  record ModeConfiguration\n";
  modelica += '    "Configuration for a reasoning mode"\n';
  modelica += '    String modeName "Name of the reasoning mode";\n';
  modelica += '    Real weight "Weight/importance in orchestration (0-1)";\n';
  modelica += '    Boolean isPrimary "Whether this is the primary mode";\n';
  modelica += "  end ModeConfiguration;\n\n";
  modelica += "  model Orchestrator\n";
  modelica += '    "Hybrid mode orchestration controller"\n\n';
  modelica += "    // Mode configuration\n";
  const primaryMode = escapeModelicaString(thought.primaryMode);
  modelica += `    parameter String primaryMode = "${primaryMode}" "Primary reasoning mode";
`;
  if (thought.stage) {
    const stage = escapeModelicaString(thought.stage.replace(/_/g, " "));
    modelica += `    parameter String currentStage = "${stage}" "Current orchestration stage";
`;
  }
  if (includeMetrics && thought.uncertainty !== void 0) {
    modelica += `    parameter Real uncertainty = ${thought.uncertainty.toFixed(4)} "Orchestration uncertainty (0-1)";
`;
  }
  const featureCount = thought.secondaryFeatures?.length || 0;
  modelica += `    parameter Integer secondaryCount = ${featureCount} "Number of secondary features";
`;
  modelica += "\n    // Mode weights\n";
  modelica += '    parameter Real primaryWeight = 0.7 "Primary mode weight";\n';
  modelica += '    parameter Real secondaryWeight = 0.3 "Secondary features weight";\n\n';
  modelica += "    // State variables\n";
  modelica += '    Real orchestrationEfficiency(start=1.0) "Overall orchestration efficiency";\n';
  modelica += '    Real modeBalance "Balance between primary and secondary modes";\n';
  modelica += '    Boolean isActive(start=true) "Whether orchestration is active";\n\n';
  modelica += "  equation\n";
  modelica += "    // Orchestration efficiency decreases with uncertainty\n";
  if (thought.uncertainty !== void 0) {
    modelica += `    orchestrationEfficiency = 1.0 - ${thought.uncertainty.toFixed(4)};
`;
  } else {
    modelica += "    orchestrationEfficiency = 1.0;\n";
  }
  modelica += "    \n";
  modelica += "    // Mode balance based on weights\n";
  modelica += "    modeBalance = primaryWeight / (primaryWeight + secondaryWeight);\n";
  modelica += "    \n";
  modelica += "    // Orchestration is active when efficiency is above threshold\n";
  modelica += "    isActive = orchestrationEfficiency > 0.5;\n\n";
  modelica += "  annotation(\n";
  modelica += '    Documentation(info="<html>\n';
  modelica += `      <p>Hybrid mode orchestration combining ${primaryMode}`;
  if (featureCount > 0) {
    modelica += ` with ${featureCount} secondary features`;
  }
  modelica += ".</p>\n";
  if (thought.switchReason) {
    const switchReason = escapeModelicaString(thought.switchReason);
    modelica += `      <p><b>Switch Reason:</b> ${switchReason}</p>
`;
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    modelica += "      <p><b>Assumptions:</b></p>\n";
    modelica += "      <ul>\n";
    thought.assumptions.forEach((assumption) => {
      const escapedAssumption = escapeModelicaString(assumption);
      modelica += `        <li>${escapedAssumption}</li>
`;
    });
    modelica += "      </ul>\n";
  }
  modelica += '    </html>")\n';
  modelica += "  );\n";
  modelica += "  end Orchestrator;\n\n";
  if (thought.secondaryFeatures && thought.secondaryFeatures.length > 0) {
    modelica += "  // Secondary feature models\n";
    thought.secondaryFeatures.forEach((feature, index) => {
      const featureId = sanitizeModelicaId(`Feature${index + 1}`);
      const featureDesc = escapeModelicaString(feature.substring(0, 60));
      modelica += `  model ${featureId}
`;
      modelica += `    "Secondary feature: ${featureDesc}"
`;
      modelica += '    parameter Real contribution = 0.1 "Contribution to orchestration";\n';
      modelica += '    Real effectiveness "Feature effectiveness";\n';
      modelica += "  equation\n";
      modelica += "    effectiveness = contribution;\n";
      modelica += `  end ${featureId};

`;
    });
  }
  if (thought.mathematicalModel) {
    modelica += "  model MathematicalModel\n";
    modelica += '    "Mathematical model integration"\n';
    const symbolicModel = escapeModelicaString(thought.mathematicalModel.symbolic || "Unknown");
    modelica += `    parameter String symbolic = "${symbolicModel}" "Symbolic representation";
`;
    if (thought.mathematicalModel.ascii) {
      const asciiModel = escapeModelicaString(thought.mathematicalModel.ascii);
      modelica += `    parameter String ascii = "${asciiModel}" "ASCII representation";
`;
    }
    modelica += "  end MathematicalModel;\n\n";
  }
  if (thought.tensorProperties) {
    modelica += "  model TensorProperties\n";
    modelica += '    "Tensor analysis integration"\n';
    modelica += `    parameter Integer rank[2] = {${thought.tensorProperties.rank[0]}, ${thought.tensorProperties.rank[1]}} "Tensor rank";
`;
    const components = escapeModelicaString(thought.tensorProperties.components);
    modelica += `    parameter String components = "${components}" "Tensor components";
`;
    const transformation = escapeModelicaString(thought.tensorProperties.transformation);
    modelica += `    parameter String transformation = "${transformation}" "Transformation rule";
`;
    modelica += "  end TensorProperties;\n\n";
  }
  if (thought.physicalInterpretation) {
    modelica += "  model PhysicalInterpretation\n";
    modelica += '    "Physical meaning of reasoning"\n';
    const quantity = escapeModelicaString(thought.physicalInterpretation.quantity);
    modelica += `    parameter String quantity = "${quantity}" "Physical quantity";
`;
    const units = escapeModelicaString(thought.physicalInterpretation.units);
    modelica += `    parameter String units = "${units}" "Measurement units";
`;
    modelica += "  end PhysicalInterpretation;\n\n";
  }
  modelica += `end ${packageName};
`;
  return modelica;
}
function hybridToUML(thought, options) {
  const { includeLabels = true } = options;
  const nodes = [];
  const edges = [];
  nodes.push({
    id: "hybrid",
    label: includeLabels ? "Hybrid Orchestrator" : "Hybrid",
    shape: "component",
    stereotype: "<<orchestrator>>",
    attributes: [
      `primaryMode: ${thought.primaryMode}`,
      thought.stage ? `stage: ${thought.stage.replace(/_/g, " ")}` : null,
      thought.uncertainty !== void 0 ? `uncertainty: ${(thought.uncertainty * 100).toFixed(1)}%` : null
    ].filter(Boolean)
  });
  const primaryId = sanitizeId(`primary_${thought.primaryMode}`);
  nodes.push({
    id: primaryId,
    label: includeLabels ? thought.primaryMode.charAt(0).toUpperCase() + thought.primaryMode.slice(1) : thought.primaryMode,
    shape: "class",
    stereotype: "<<primary>>",
    attributes: ["weight: 0.7"]
  });
  edges.push({
    source: "hybrid",
    target: primaryId,
    type: "composition",
    label: "orchestrates"
  });
  if (thought.secondaryFeatures && thought.secondaryFeatures.length > 0) {
    thought.secondaryFeatures.forEach((feature, index) => {
      const featureId = sanitizeId(`feature_${index}`);
      nodes.push({
        id: featureId,
        label: includeLabels ? feature.length > 30 ? feature.substring(0, 30) + "..." : feature : `Feature${index + 1}`,
        shape: "class",
        stereotype: "<<secondary>>",
        attributes: ["weight: 0.3"]
      });
      edges.push({
        source: "hybrid",
        target: featureId,
        type: "association",
        label: "uses"
      });
    });
  }
  if (thought.mathematicalModel) {
    nodes.push({
      id: "math_model",
      label: "Mathematical Model",
      shape: "package",
      attributes: [
        `symbolic: ${thought.mathematicalModel.symbolic}`,
        thought.mathematicalModel.ascii ? `ascii: ${thought.mathematicalModel.ascii.substring(0, 30)}` : null
      ].filter(Boolean)
    });
    edges.push({
      source: primaryId,
      target: "math_model",
      type: "dependency",
      label: "applies"
    });
  }
  if (thought.tensorProperties) {
    nodes.push({
      id: "tensor",
      label: "Tensor Properties",
      shape: "interface",
      attributes: [
        `rank: (${thought.tensorProperties.rank[0]}, ${thought.tensorProperties.rank[1]})`,
        `components: ${thought.tensorProperties.components}`
      ]
    });
    edges.push({
      source: primaryId,
      target: "tensor",
      type: "implementation",
      label: "implements"
    });
  }
  if (thought.physicalInterpretation) {
    nodes.push({
      id: "physical",
      label: "Physical Interpretation",
      shape: "component",
      attributes: [
        `quantity: ${thought.physicalInterpretation.quantity}`,
        `units: ${thought.physicalInterpretation.units}`
      ]
    });
    edges.push({
      source: primaryId,
      target: "physical",
      type: "dependency",
      label: "interprets"
    });
  }
  if (thought.switchReason && includeLabels) {
    nodes.push({
      id: "switch_note",
      label: "Switch Reason",
      shape: "rectangle",
      stereotype: "<<note>>",
      attributes: [thought.switchReason.substring(0, 50) + (thought.switchReason.length > 50 ? "..." : "")]
    });
    edges.push({
      source: "hybrid",
      target: "switch_note",
      type: "dependency"
    });
  }
  return generateUmlDiagram(nodes, edges, {
    title: "Hybrid Mode Orchestration"});
}
function hybridToJSON(thought, options) {
  const { includeMetrics = true } = options;
  const graph = createJsonGraph("Hybrid Mode Orchestration", "hybrid_orchestration", {
    includeMetrics,
    includeLegend: true,
    includeLayout: true
  });
  addNode(graph, {
    id: "hybrid",
    label: "Hybrid Mode",
    type: "orchestrator",
    metadata: {
      primaryMode: thought.primaryMode,
      stage: thought.stage || null,
      uncertainty: thought.uncertainty,
      secondaryFeaturesCount: thought.secondaryFeatures?.length || 0
    }
  });
  const primaryId = sanitizeId(`primary_${thought.primaryMode}`);
  addNode(graph, {
    id: primaryId,
    label: thought.primaryMode.charAt(0).toUpperCase() + thought.primaryMode.slice(1),
    type: "primary_mode",
    metadata: {
      name: thought.primaryMode,
      weight: 0.7
    }
  });
  addEdge(graph, {
    id: "e_hybrid_primary",
    source: "hybrid",
    target: primaryId,
    label: "orchestrates",
    type: "primary",
    metadata: {
      strength: 1
    }
  });
  if (thought.secondaryFeatures && thought.secondaryFeatures.length > 0) {
    thought.secondaryFeatures.forEach((feature, index) => {
      const featureId = sanitizeId(`feature_${index}`);
      addNode(graph, {
        id: featureId,
        label: `Feature ${index + 1}`,
        type: "secondary_feature",
        metadata: {
          description: feature,
          index,
          weight: 0.3 / thought.secondaryFeatures.length
        }
      });
      addEdge(graph, {
        id: `e_hybrid_feature_${index}`,
        source: "hybrid",
        target: featureId,
        label: "uses",
        type: "secondary",
        metadata: {
          strength: 0.5
        }
      });
    });
  }
  if (thought.stage) {
    const stageId = sanitizeId(`stage_${thought.stage}`);
    addNode(graph, {
      id: stageId,
      label: thought.stage.replace(/_/g, " "),
      type: "stage",
      metadata: {
        name: thought.stage
      }
    });
    addEdge(graph, {
      id: "e_primary_stage",
      source: primaryId,
      target: stageId,
      label: "in_stage",
      type: "stage_flow"
    });
  }
  if (thought.mathematicalModel) {
    addNode(graph, {
      id: "math_model",
      label: "Mathematical Model",
      type: "mathematical",
      metadata: {
        latex: thought.mathematicalModel.latex,
        symbolic: thought.mathematicalModel.symbolic,
        ascii: thought.mathematicalModel.ascii || null
      }
    });
    addEdge(graph, {
      id: "e_primary_math",
      source: primaryId,
      target: "math_model",
      label: "applies",
      type: "transformation"
    });
  }
  if (thought.tensorProperties) {
    addNode(graph, {
      id: "tensor",
      label: "Tensor Properties",
      type: "tensor",
      metadata: {
        rank: thought.tensorProperties.rank,
        components: thought.tensorProperties.components,
        transformation: thought.tensorProperties.transformation,
        symmetries: thought.tensorProperties.symmetries
      }
    });
    addEdge(graph, {
      id: "e_primary_tensor",
      source: primaryId,
      target: "tensor",
      label: "analyzes",
      type: "analysis"
    });
  }
  if (thought.physicalInterpretation) {
    addNode(graph, {
      id: "physical",
      label: "Physical Interpretation",
      type: "physical",
      metadata: {
        quantity: thought.physicalInterpretation.quantity,
        units: thought.physicalInterpretation.units,
        conservationLaws: thought.physicalInterpretation.conservationLaws
      }
    });
    addEdge(graph, {
      id: "e_primary_physical",
      source: primaryId,
      target: "physical",
      label: "interprets",
      type: "interpretation"
    });
  }
  if (includeMetrics) {
    addMetric(graph, "primary_mode", thought.primaryMode);
    addMetric(graph, "secondary_features_count", thought.secondaryFeatures?.length || 0);
    if (thought.uncertainty !== void 0) {
      addMetric(graph, "uncertainty", thought.uncertainty);
    }
    if (thought.stage) {
      addMetric(graph, "stage", thought.stage);
    }
    if (thought.assumptions) {
      addMetric(graph, "assumptions_count", thought.assumptions.length);
    }
    if (thought.dependencies) {
      addMetric(graph, "dependencies_count", thought.dependencies.length);
    }
  }
  addLegendItem(graph, "Hybrid Orchestrator", "#90EE90");
  addLegendItem(graph, "Primary Mode", "#87CEEB");
  addLegendItem(graph, "Secondary Feature", "#FFD700");
  if (thought.mathematicalModel) {
    addLegendItem(graph, "Mathematical Model", "#DDA0DD");
  }
  if (thought.tensorProperties) {
    addLegendItem(graph, "Tensor Properties", "#F0E68C");
  }
  if (thought.physicalInterpretation) {
    addLegendItem(graph, "Physical Interpretation", "#98FB98");
  }
  return serializeGraph(graph);
}
function hybridToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  const overviewContent = keyValueSection({
    "Primary Mode": thought.primaryMode.charAt(0).toUpperCase() + thought.primaryMode.slice(1),
    ...thought.stage ? { "Stage": thought.stage.replace(/_/g, " ") } : {},
    ...thought.uncertainty !== void 0 ? { "Uncertainty": `${(thought.uncertainty * 100).toFixed(1)}%` } : {}
  });
  parts.push(section("Overview", overviewContent));
  if (thought.switchReason) {
    parts.push(section("Mode Switch Reason", thought.switchReason));
  }
  if (thought.secondaryFeatures && thought.secondaryFeatures.length > 0) {
    parts.push(section("Secondary Features", list(thought.secondaryFeatures)));
  }
  if (thought.mathematicalModel) {
    const mathContent = keyValueSection({
      "LaTeX": thought.mathematicalModel.latex,
      "Symbolic": thought.mathematicalModel.symbolic,
      ...thought.mathematicalModel.ascii ? { "ASCII": thought.mathematicalModel.ascii } : {}
    });
    parts.push(section("Mathematical Model", mathContent));
  }
  if (thought.tensorProperties) {
    const tensorRows = [
      ["Rank", `(${thought.tensorProperties.rank[0]}, ${thought.tensorProperties.rank[1]})`],
      ["Components", thought.tensorProperties.components],
      ["Transformation", thought.tensorProperties.transformation]
    ];
    let tensorContent = table(["Property", "Value"], tensorRows);
    if (thought.tensorProperties.symmetries.length > 0) {
      tensorContent += "\n\n**Symmetries:**\n\n" + list(thought.tensorProperties.symmetries);
    }
    parts.push(section("Tensor Properties", tensorContent));
  }
  if (thought.physicalInterpretation) {
    const interpContent = keyValueSection({
      "Quantity": thought.physicalInterpretation.quantity,
      "Units": thought.physicalInterpretation.units
    });
    let interpFull = interpContent;
    if (thought.physicalInterpretation.conservationLaws.length > 0) {
      interpFull += "\n\n**Conservation Laws:**\n\n" + list(thought.physicalInterpretation.conservationLaws);
    }
    parts.push(section("Physical Interpretation", interpFull));
  }
  if (includeMetrics) {
    const metricsItems = {
      "Primary Mode": thought.primaryMode,
      "Secondary Features": thought.secondaryFeatures?.length || 0
    };
    if (thought.uncertainty !== void 0) {
      metricsItems["Uncertainty"] = `${(thought.uncertainty * 100).toFixed(1)}%`;
    }
    if (thought.assumptions) {
      metricsItems["Assumptions"] = thought.assumptions.length;
    }
    if (thought.dependencies) {
      metricsItems["Dependencies"] = thought.dependencies.length;
    }
    parts.push(section("Metrics", keyValueSection(metricsItems)));
  }
  if (thought.assumptions && thought.assumptions.length > 0) {
    parts.push(section("Assumptions", list(thought.assumptions)));
  }
  if (thought.dependencies && thought.dependencies.length > 0) {
    parts.push(section("Dependencies", list(thought.dependencies)));
  }
  if (thought.revisionReason) {
    parts.push(section("Revision Reason", thought.revisionReason));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = hybridToMermaid(thought, "default", true, true);
    parts.push(section("Visualization", mermaidBlock(mermaidDiagram)));
  }
  return document("Hybrid Mode Orchestration", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "hybrid",
      primaryMode: thought.primaryMode,
      secondaryFeatures: thought.secondaryFeatures?.length || 0
    }
  });
}
var init_hybrid = __esm({
  "src/export/visual/hybrid.ts"() {
    init_esm_shims();
    init_utils();
    init_svg_utils();
    init_graphml_utils();
    init_tikz_utils();
    init_html_utils();
    init_modelica_utils();
    init_uml_utils();
    init_json_utils();
    init_markdown_utils();
  }
});

// src/export/visual/metareasoning.ts
function exportMetaReasoningVisualization(thought, options) {
  const { format, colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  switch (format) {
    case "mermaid":
      return metaReasoningToMermaid(thought, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return metaReasoningToDOT(thought, includeLabels, includeMetrics);
    case "ascii":
      return metaReasoningToASCII(thought);
    case "svg":
      return metaReasoningToSVG(thought, options);
    case "graphml":
      return metaReasoningToGraphML(thought, options);
    case "tikz":
      return metaReasoningToTikZ(thought, options);
    case "html":
      return metaReasoningToHTML(thought, options);
    case "modelica":
      return metaReasoningToModelica(thought, options);
    case "uml":
      return metaReasoningToUML(thought, options);
    case "json":
      return metaReasoningToJSON(thought, options);
    case "markdown":
      return metaReasoningToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function metaReasoningToMermaid(thought, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TB\n";
  const metaId = sanitizeId("meta_reasoning");
  mermaid += `  ${metaId}(("Meta-Reasoning"))
`;
  const currentId = sanitizeId("current_strategy");
  const currentLabel = includeLabels ? thought.currentStrategy.approach : "Current Strategy";
  mermaid += `  ${currentId}[["${currentLabel}"]]
`;
  mermaid += `  ${metaId} ==> ${currentId}
`;
  const modeId = sanitizeId("current_mode");
  mermaid += `  ${modeId}(["Mode: ${thought.currentStrategy.mode}"])
`;
  mermaid += `  ${currentId} --> ${modeId}
`;
  const evalId = sanitizeId("evaluation");
  mermaid += `  ${evalId}{{"Effectiveness: ${(thought.strategyEvaluation.effectiveness * 100).toFixed(0)}%"}}
`;
  mermaid += `  ${currentId} --> ${evalId}
`;
  if (thought.strategyEvaluation.issues.length > 0) {
    const issuesId = sanitizeId("issues");
    mermaid += `  ${issuesId}>"Issues: ${thought.strategyEvaluation.issues.length}"]
`;
    mermaid += `  ${evalId} --> ${issuesId}
`;
  }
  if (thought.strategyEvaluation.strengths.length > 0) {
    const strengthsId = sanitizeId("strengths");
    mermaid += `  ${strengthsId}>"Strengths: ${thought.strategyEvaluation.strengths.length}"]
`;
    mermaid += `  ${evalId} --> ${strengthsId}
`;
  }
  if (thought.alternativeStrategies.length > 0) {
    const altsId = sanitizeId("alternatives");
    mermaid += `  ${altsId}(["Alternative Strategies"])
`;
    mermaid += `  ${metaId} --> ${altsId}
`;
    thought.alternativeStrategies.forEach((alt, index) => {
      const altId = sanitizeId(`alt_${index}`);
      const altLabel = includeLabels ? `${alt.mode}: ${(alt.recommendationScore * 100).toFixed(0)}%` : `Alt ${index + 1}`;
      mermaid += `  ${altId}["${altLabel}"]
`;
      mermaid += `  ${altsId} --> ${altId}
`;
    });
  }
  const recId = sanitizeId("recommendation");
  const recLabel = `${thought.recommendation.action}${thought.recommendation.targetMode ? ` \u2192 ${thought.recommendation.targetMode}` : ""}`;
  mermaid += `  ${recId}[/"${recLabel}"/]
`;
  mermaid += `  ${metaId} ==> ${recId}
`;
  if (includeMetrics) {
    const confId = sanitizeId("rec_confidence");
    mermaid += `  ${confId}{{"Confidence: ${(thought.recommendation.confidence * 100).toFixed(0)}%"}}
`;
    mermaid += `  ${recId} --> ${confId}
`;
  }
  if (includeMetrics) {
    const qualityId = sanitizeId("quality");
    const qualityLabel = `Quality: ${(thought.qualityMetrics.overallQuality * 100).toFixed(0)}%`;
    mermaid += `  ${qualityId}{{"${qualityLabel}"}}
`;
    mermaid += `  ${metaId} -.-> ${qualityId}
`;
  }
  const resourceId = sanitizeId("resources");
  mermaid += `  ${resourceId}[("Complexity: ${thought.resourceAllocation.complexityLevel}")]
`;
  mermaid += `  ${metaId} -.-> ${resourceId}
`;
  const sessionId = sanitizeId("session");
  mermaid += `  ${sessionId}>"Thoughts: ${thought.sessionContext.totalThoughts}"]
`;
  mermaid += `  ${metaId} -.-> ${sessionId}
`;
  if (colorScheme !== "monochrome") {
    const colors = colorScheme === "pastel" ? { meta: "#f3e5f5", current: "#e3f2fd", rec: "#e8f5e9", alt: "#fff3e0" } : { meta: "#DDA0DD", current: "#87CEEB", rec: "#90EE90", alt: "#FFD700" };
    mermaid += `
  style ${metaId} fill:${colors.meta}
`;
    mermaid += `  style ${currentId} fill:${colors.current}
`;
    mermaid += `  style ${recId} fill:${colors.rec}
`;
    if (thought.alternativeStrategies.length > 0) {
      mermaid += `  style ${sanitizeId("alternatives")} fill:${colors.alt}
`;
    }
  }
  return mermaid;
}
function metaReasoningToDOT(thought, includeLabels, includeMetrics) {
  let dot = "digraph MetaReasoning {\n";
  dot += "  rankdir=TB;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  dot += "  subgraph cluster_current {\n";
  dot += '    label="Current Strategy";\n';
  dot += "    style=filled;\n";
  dot += "    fillcolor=lightblue;\n";
  const currentId = sanitizeId("current_strategy");
  const currentLabel = includeLabels ? thought.currentStrategy.approach.slice(0, 30).replace(/"/g, '\\"') : "Current Strategy";
  dot += `    ${currentId} [label="${currentLabel}"];
`;
  const modeId = sanitizeId("current_mode");
  dot += `    ${modeId} [label="${thought.currentStrategy.mode}", shape=ellipse];
`;
  dot += `    ${currentId} -> ${modeId};
`;
  if (includeMetrics) {
    const evalId = sanitizeId("evaluation");
    dot += `    ${evalId} [label="Eff: ${(thought.strategyEvaluation.effectiveness * 100).toFixed(0)}%", shape=diamond];
`;
    dot += `    ${currentId} -> ${evalId};
`;
  }
  dot += "  }\n\n";
  if (thought.alternativeStrategies.length > 0) {
    dot += "  subgraph cluster_alternatives {\n";
    dot += '    label="Alternatives";\n';
    dot += "    style=filled;\n";
    dot += "    fillcolor=lightyellow;\n";
    thought.alternativeStrategies.forEach((alt, index) => {
      const altId = sanitizeId(`alt_${index}`);
      const altLabel = `${alt.mode}\\n${(alt.recommendationScore * 100).toFixed(0)}%`;
      dot += `    ${altId} [label="${altLabel}"];
`;
    });
    dot += "  }\n\n";
  }
  const recId = sanitizeId("recommendation");
  const recLabel = `${thought.recommendation.action}${thought.recommendation.targetMode ? `\\n\u2192 ${thought.recommendation.targetMode}` : ""}`;
  dot += `  ${recId} [label="${recLabel}", shape=hexagon, style="filled", fillcolor=lightgreen];
`;
  if (includeMetrics) {
    const qualityId = sanitizeId("quality");
    const qualityLabel = `Quality: ${(thought.qualityMetrics.overallQuality * 100).toFixed(0)}%`;
    dot += `  ${qualityId} [label="${qualityLabel}", shape=diamond];
`;
  }
  dot += `  ${currentId} -> ${recId} [style=bold, penwidth=2];
`;
  thought.alternativeStrategies.forEach((_, index) => {
    const altId = sanitizeId(`alt_${index}`);
    dot += `  ${altId} -> ${recId} [style=dashed];
`;
  });
  dot += "}\n";
  return dot;
}
function metaReasoningToASCII(thought) {
  let ascii = "Meta-Reasoning Analysis:\n";
  ascii += "========================\n\n";
  ascii += "CURRENT STRATEGY\n";
  ascii += "----------------\n";
  ascii += `Mode: ${thought.currentStrategy.mode}
`;
  ascii += `Approach: ${thought.currentStrategy.approach}
`;
  ascii += `Thoughts Spent: ${thought.currentStrategy.thoughtsSpent}
`;
  if (thought.currentStrategy.progressIndicators.length > 0) {
    ascii += "Progress Indicators:\n";
    thought.currentStrategy.progressIndicators.forEach((ind, index) => {
      ascii += `  ${index + 1}. ${ind}
`;
    });
  }
  ascii += "\n";
  ascii += "STRATEGY EVALUATION\n";
  ascii += "-------------------\n";
  ascii += `Effectiveness: ${(thought.strategyEvaluation.effectiveness * 100).toFixed(1)}%
`;
  ascii += `Efficiency: ${(thought.strategyEvaluation.efficiency * 100).toFixed(1)}%
`;
  ascii += `Confidence: ${(thought.strategyEvaluation.confidence * 100).toFixed(1)}%
`;
  ascii += `Progress Rate: ${thought.strategyEvaluation.progressRate.toFixed(2)} insights/thought
`;
  ascii += `Quality Score: ${(thought.strategyEvaluation.qualityScore * 100).toFixed(1)}%
`;
  if (thought.strategyEvaluation.strengths.length > 0) {
    ascii += "Strengths:\n";
    thought.strategyEvaluation.strengths.forEach((s, index) => {
      ascii += `  + ${index + 1}. ${s}
`;
    });
  }
  if (thought.strategyEvaluation.issues.length > 0) {
    ascii += "Issues:\n";
    thought.strategyEvaluation.issues.forEach((issue, index) => {
      ascii += `  - ${index + 1}. ${issue}
`;
    });
  }
  ascii += "\n";
  if (thought.alternativeStrategies.length > 0) {
    ascii += "ALTERNATIVE STRATEGIES\n";
    ascii += "----------------------\n";
    thought.alternativeStrategies.forEach((alt, index) => {
      ascii += `[${index + 1}] ${alt.mode}
`;
      ascii += `    Reasoning: ${alt.reasoning}
`;
      ascii += `    Expected Benefit: ${alt.expectedBenefit}
`;
      ascii += `    Switching Cost: ${(alt.switchingCost * 100).toFixed(0)}%
`;
      ascii += `    Recommendation Score: ${(alt.recommendationScore * 100).toFixed(0)}%
`;
    });
    ascii += "\n";
  }
  ascii += "RECOMMENDATION\n";
  ascii += "--------------\n";
  ascii += `Action: ${thought.recommendation.action}
`;
  if (thought.recommendation.targetMode) {
    ascii += `Target Mode: ${thought.recommendation.targetMode}
`;
  }
  ascii += `Justification: ${thought.recommendation.justification}
`;
  ascii += `Confidence: ${(thought.recommendation.confidence * 100).toFixed(1)}%
`;
  ascii += `Expected Improvement: ${thought.recommendation.expectedImprovement}
`;
  ascii += "\n";
  ascii += "RESOURCE ALLOCATION\n";
  ascii += "-------------------\n";
  ascii += `Time Spent: ${thought.resourceAllocation.timeSpent}ms
`;
  ascii += `Thoughts Remaining: ${thought.resourceAllocation.thoughtsRemaining}
`;
  ascii += `Complexity: ${thought.resourceAllocation.complexityLevel}
`;
  ascii += `Urgency: ${thought.resourceAllocation.urgency}
`;
  ascii += `Recommendation: ${thought.resourceAllocation.recommendation}
`;
  ascii += "\n";
  ascii += "QUALITY METRICS\n";
  ascii += "---------------\n";
  ascii += `Logical Consistency: ${(thought.qualityMetrics.logicalConsistency * 100).toFixed(1)}%
`;
  ascii += `Evidence Quality: ${(thought.qualityMetrics.evidenceQuality * 100).toFixed(1)}%
`;
  ascii += `Completeness: ${(thought.qualityMetrics.completeness * 100).toFixed(1)}%
`;
  ascii += `Originality: ${(thought.qualityMetrics.originality * 100).toFixed(1)}%
`;
  ascii += `Clarity: ${(thought.qualityMetrics.clarity * 100).toFixed(1)}%
`;
  ascii += `Overall Quality: ${(thought.qualityMetrics.overallQuality * 100).toFixed(1)}%
`;
  ascii += "\n";
  ascii += "SESSION CONTEXT\n";
  ascii += "---------------\n";
  ascii += `Session ID: ${thought.sessionContext.sessionId}
`;
  ascii += `Total Thoughts: ${thought.sessionContext.totalThoughts}
`;
  ascii += `Mode Switches: ${thought.sessionContext.modeSwitches}
`;
  ascii += `Problem Type: ${thought.sessionContext.problemType}
`;
  ascii += `Modes Used: ${thought.sessionContext.modesUsed.join(", ")}
`;
  if (thought.sessionContext.historicalEffectiveness !== void 0) {
    ascii += `Historical Effectiveness: ${(thought.sessionContext.historicalEffectiveness * 100).toFixed(1)}%
`;
  }
  return ascii;
}
function metaReasoningToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width,
    svgHeight = DEFAULT_SVG_OPTIONS.height
  } = options;
  const positions = /* @__PURE__ */ new Map();
  const nodeWidth = 150;
  const nodeHeight = 40;
  positions.set("meta", {
    id: "meta",
    label: "Meta-Reasoning",
    x: svgWidth / 2,
    y: 80,
    width: nodeWidth,
    height: nodeHeight,
    type: "meta"
  });
  positions.set("current", {
    id: "current",
    label: includeLabels ? thought.currentStrategy.approach : "Current Strategy",
    x: 200,
    y: 220,
    width: nodeWidth,
    height: nodeHeight,
    type: "current"
  });
  positions.set("recommendation", {
    id: "recommendation",
    label: thought.recommendation.action,
    x: svgWidth - 200,
    y: 220,
    width: nodeWidth,
    height: nodeHeight,
    type: "recommendation"
  });
  if (thought.alternativeStrategies && thought.alternativeStrategies.length > 0) {
    thought.alternativeStrategies.forEach((alt, index) => {
      positions.set(`alt_${index}`, {
        id: `alt_${index}`,
        label: includeLabels ? `${alt.mode}: ${(alt.recommendationScore * 100).toFixed(0)}%` : `Alt ${index + 1}`,
        x: 150 + index * 180,
        y: 380,
        width: nodeWidth,
        height: nodeHeight,
        type: "alternative"
      });
    });
  }
  let svg = generateSVGHeader(svgWidth, svgHeight, "Meta-Reasoning Analysis");
  svg += '\n  <!-- Edges -->\n  <g class="edges">';
  const metaPos = positions.get("meta");
  const currentPos = positions.get("current");
  const recPos = positions.get("recommendation");
  if (metaPos && currentPos) {
    svg += renderEdge(metaPos, currentPos, { style: "solid" });
  }
  if (metaPos && recPos) {
    svg += renderEdge(metaPos, recPos, { style: "solid" });
  }
  if (thought.alternativeStrategies) {
    thought.alternativeStrategies.forEach((_, index) => {
      const altPos = positions.get(`alt_${index}`);
      if (metaPos && altPos) {
        svg += renderEdge(metaPos, altPos, { style: "dashed" });
      }
    });
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- Nodes -->\n  <g class="nodes">';
  const metaColors = getNodeColor("warning", colorScheme);
  const currentColors = getNodeColor("primary", colorScheme);
  const recColors = getNodeColor("success", colorScheme);
  const altColors = getNodeColor("secondary", colorScheme);
  for (const [, pos] of positions) {
    if (pos.type === "meta") {
      svg += renderEllipseNode(pos, metaColors);
    } else if (pos.type === "current") {
      svg += renderStadiumNode(pos, currentColors);
    } else if (pos.type === "recommendation") {
      svg += renderStadiumNode(pos, recColors);
    } else if (pos.type === "alternative") {
      svg += renderRectNode(pos, altColors);
    }
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Effectiveness", value: `${(thought.strategyEvaluation.effectiveness * 100).toFixed(0)}%` },
      { label: "Quality", value: `${(thought.qualityMetrics.overallQuality * 100).toFixed(0)}%` },
      { label: "Alternatives", value: thought.alternativeStrategies.length },
      { label: "Rec Confidence", value: `${(thought.recommendation.confidence * 100).toFixed(0)}%` }
    ];
    svg += renderMetricsPanel(svgWidth - 190, svgHeight - 140, metrics);
  }
  const legendItems = [
    { label: "Meta-Reasoning", color: metaColors, shape: "ellipse" },
    { label: "Current Strategy", color: currentColors, shape: "stadium" },
    { label: "Recommendation", color: recColors, shape: "stadium" },
    { label: "Alternative", color: altColors }
  ];
  svg += renderLegend(20, svgHeight - 140, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function metaReasoningToGraphML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  nodes.push({
    id: "meta",
    label: "Meta-Reasoning",
    type: "meta"
  });
  const currentLabel = includeLabels ? thought.currentStrategy.approach : "Current Strategy";
  nodes.push({
    id: "current_strategy",
    label: currentLabel,
    type: "current",
    metadata: {
      mode: thought.currentStrategy.mode,
      thoughtsSpent: thought.currentStrategy.thoughtsSpent
    }
  });
  edges.push({
    id: "e_meta_current",
    source: "meta",
    target: "current_strategy",
    directed: true
  });
  if (includeMetrics) {
    nodes.push({
      id: "evaluation",
      label: `Effectiveness: ${(thought.strategyEvaluation.effectiveness * 100).toFixed(0)}%`,
      type: "evaluation",
      metadata: {
        effectiveness: thought.strategyEvaluation.effectiveness,
        efficiency: thought.strategyEvaluation.efficiency,
        confidence: thought.strategyEvaluation.confidence,
        progressRate: thought.strategyEvaluation.progressRate,
        qualityScore: thought.strategyEvaluation.qualityScore
      }
    });
    edges.push({
      id: "e_current_eval",
      source: "current_strategy",
      target: "evaluation",
      directed: true
    });
    if (thought.strategyEvaluation.issues.length > 0) {
      nodes.push({
        id: "issues",
        label: `Issues: ${thought.strategyEvaluation.issues.length}`,
        type: "issue",
        metadata: {
          issues: thought.strategyEvaluation.issues
        }
      });
      edges.push({
        id: "e_eval_issues",
        source: "evaluation",
        target: "issues",
        directed: true
      });
    }
    if (thought.strategyEvaluation.strengths.length > 0) {
      nodes.push({
        id: "strengths",
        label: `Strengths: ${thought.strategyEvaluation.strengths.length}`,
        type: "strength",
        metadata: {
          strengths: thought.strategyEvaluation.strengths
        }
      });
      edges.push({
        id: "e_eval_strengths",
        source: "evaluation",
        target: "strengths",
        directed: true
      });
    }
  }
  if (thought.alternativeStrategies.length > 0) {
    thought.alternativeStrategies.forEach((alt, index) => {
      const altLabel = includeLabels ? `${alt.mode}: ${(alt.recommendationScore * 100).toFixed(0)}%` : `Alternative ${index + 1}`;
      nodes.push({
        id: `alt_${index}`,
        label: altLabel,
        type: "alternative",
        metadata: {
          mode: alt.mode,
          reasoning: alt.reasoning,
          expectedBenefit: alt.expectedBenefit,
          switchingCost: alt.switchingCost,
          recommendationScore: alt.recommendationScore
        }
      });
      edges.push({
        id: `e_meta_alt_${index}`,
        source: "meta",
        target: `alt_${index}`,
        directed: true
      });
    });
  }
  const recLabel = `${thought.recommendation.action}${thought.recommendation.targetMode ? ` \u2192 ${thought.recommendation.targetMode}` : ""}`;
  nodes.push({
    id: "recommendation",
    label: recLabel,
    type: "recommendation",
    metadata: {
      action: thought.recommendation.action,
      targetMode: thought.recommendation.targetMode,
      justification: thought.recommendation.justification,
      confidence: thought.recommendation.confidence,
      expectedImprovement: thought.recommendation.expectedImprovement
    }
  });
  edges.push({
    id: "e_meta_rec",
    source: "meta",
    target: "recommendation",
    directed: true
  });
  if (includeMetrics) {
    nodes.push({
      id: "quality",
      label: `Quality: ${(thought.qualityMetrics.overallQuality * 100).toFixed(0)}%`,
      type: "quality",
      metadata: {
        logicalConsistency: thought.qualityMetrics.logicalConsistency,
        evidenceQuality: thought.qualityMetrics.evidenceQuality,
        completeness: thought.qualityMetrics.completeness,
        originality: thought.qualityMetrics.originality,
        clarity: thought.qualityMetrics.clarity,
        overallQuality: thought.qualityMetrics.overallQuality
      }
    });
    edges.push({
      id: "e_meta_quality",
      source: "meta",
      target: "quality",
      directed: true
    });
  }
  const graphmlOptions = {
    graphName: "MetaReasoning Visualization",
    directed: true,
    includeLabels
  };
  return generateGraphML(nodes, edges, graphmlOptions);
}
function metaReasoningToTikZ(thought, options) {
  const { includeLabels = true, includeMetrics = true, colorScheme = "default" } = options;
  const nodes = [];
  const edges = [];
  nodes.push({
    id: "meta",
    label: "Meta-Reasoning",
    x: 0,
    y: 0,
    shape: "ellipse",
    type: "meta"
  });
  const currentLabel = includeLabels ? thought.currentStrategy.approach : "Current Strategy";
  nodes.push({
    id: "current_strategy",
    label: currentLabel.substring(0, 30),
    // Truncate for readability
    x: -4,
    y: -2,
    shape: "stadium",
    type: "current"
  });
  edges.push({
    source: "meta",
    target: "current_strategy",
    directed: true
  });
  const recLabel = `${thought.recommendation.action}${thought.recommendation.targetMode ? ` \u2192 ${thought.recommendation.targetMode}` : ""}`;
  nodes.push({
    id: "recommendation",
    label: recLabel.substring(0, 30),
    x: 4,
    y: -2,
    shape: "stadium",
    type: "recommendation"
  });
  edges.push({
    source: "meta",
    target: "recommendation",
    directed: true
  });
  if (includeMetrics) {
    nodes.push({
      id: "evaluation",
      label: `Eff: ${(thought.strategyEvaluation.effectiveness * 100).toFixed(0)}%`,
      x: -4,
      y: -4,
      shape: "diamond",
      type: "evaluation"
    });
    edges.push({
      source: "current_strategy",
      target: "evaluation",
      directed: true
    });
  }
  if (thought.alternativeStrategies.length > 0) {
    const altCount = thought.alternativeStrategies.length;
    const spacing = 2.5;
    const totalWidth = (altCount - 1) * spacing;
    const offset = totalWidth / 2;
    thought.alternativeStrategies.forEach((alt, index) => {
      const altLabel = includeLabels ? `${alt.mode}: ${(alt.recommendationScore * 100).toFixed(0)}%` : `Alt ${index + 1}`;
      nodes.push({
        id: `alt_${index}`,
        label: altLabel,
        x: index * spacing - offset,
        y: -5,
        shape: "rectangle",
        type: "alternative"
      });
      edges.push({
        source: "meta",
        target: `alt_${index}`,
        directed: true,
        style: "dashed"
      });
    });
  }
  if (includeMetrics) {
    nodes.push({
      id: "quality",
      label: `Quality: ${(thought.qualityMetrics.overallQuality * 100).toFixed(0)}%`,
      x: 4,
      y: -4,
      shape: "diamond",
      type: "quality"
    });
    edges.push({
      source: "meta",
      target: "quality",
      directed: true,
      style: "dashed"
    });
  }
  const tikzOptions = {
    title: "MetaReasoning Visualization",
    colorScheme,
    includeLabels
  };
  return generateTikZ(nodes, edges, tikzOptions);
}
function metaReasoningToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Meta-Reasoning Analysis",
    htmlTheme = "light"
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  html += '<div class="metrics-grid">';
  html += renderMetricCard("Effectiveness", `${(thought.strategyEvaluation.effectiveness * 100).toFixed(0)}%`, "primary");
  html += renderMetricCard("Quality", `${(thought.qualityMetrics.overallQuality * 100).toFixed(0)}%`, "success");
  html += renderMetricCard("Alternatives", thought.alternativeStrategies.length, "info");
  html += renderMetricCard("Confidence", `${(thought.recommendation.confidence * 100).toFixed(0)}%`, "warning");
  html += "</div>\n";
  const strategyContent = `
    <p><strong>Mode:</strong> ${renderBadge(thought.currentStrategy.mode, "primary")}</p>
    <p><strong>Approach:</strong> ${escapeHTML(thought.currentStrategy.approach)}</p>
    <p><strong>Thoughts Spent:</strong> ${thought.currentStrategy.thoughtsSpent}</p>
    ${thought.currentStrategy.progressIndicators.length > 0 ? `
      <p style="margin-top: 1rem"><strong>Progress Indicators:</strong></p>
      <ul class="list-styled">
        ${thought.currentStrategy.progressIndicators.map((ind) => `<li>${escapeHTML(ind)}</li>`).join("")}
      </ul>
    ` : ""}
  `;
  html += renderSection("Current Strategy", strategyContent, "\u{1F3AF}");
  const evalRows = [
    ["Effectiveness", `${(thought.strategyEvaluation.effectiveness * 100).toFixed(1)}%`],
    ["Efficiency", `${(thought.strategyEvaluation.efficiency * 100).toFixed(1)}%`],
    ["Confidence", `${(thought.strategyEvaluation.confidence * 100).toFixed(1)}%`],
    ["Progress Rate", `${thought.strategyEvaluation.progressRate.toFixed(2)} insights/thought`],
    ["Quality Score", `${(thought.strategyEvaluation.qualityScore * 100).toFixed(1)}%`]
  ];
  let evalContent = renderTable(["Metric", "Value"], evalRows);
  evalContent += '<p style="margin-top: 1rem"><strong>Effectiveness:</strong></p>';
  evalContent += renderProgressBar(thought.strategyEvaluation.effectiveness * 100, "primary");
  if (thought.strategyEvaluation.strengths.length > 0) {
    evalContent += '<p style="margin-top: 1rem"><strong>Strengths:</strong></p>';
    evalContent += '<ul class="list-styled">';
    thought.strategyEvaluation.strengths.forEach((s) => {
      evalContent += `<li class="text-success">\u2713 ${escapeHTML(s)}</li>`;
    });
    evalContent += "</ul>";
  }
  if (thought.strategyEvaluation.issues.length > 0) {
    evalContent += '<p style="margin-top: 1rem"><strong>Issues:</strong></p>';
    evalContent += '<ul class="list-styled">';
    thought.strategyEvaluation.issues.forEach((issue) => {
      evalContent += `<li class="text-danger">\u2717 ${escapeHTML(issue)}</li>`;
    });
    evalContent += "</ul>";
  }
  html += renderSection("Strategy Evaluation", evalContent, "\u{1F4CA}");
  if (thought.alternativeStrategies.length > 0) {
    const altsContent = thought.alternativeStrategies.map((alt) => `
      <div class="card">
        <div class="card-header">
          ${renderBadge(alt.mode, "info")}
          ${renderBadge(`Score: ${(alt.recommendationScore * 100).toFixed(0)}%`, "secondary")}
        </div>
        <p><strong>Reasoning:</strong> ${escapeHTML(alt.reasoning)}</p>
        <p><strong>Expected Benefit:</strong> ${escapeHTML(alt.expectedBenefit)}</p>
        <p><strong>Switching Cost:</strong></p>
        ${renderProgressBar(alt.switchingCost * 100, "warning")}
        <p style="margin-top: 0.5rem"><strong>Recommendation Score:</strong></p>
        ${renderProgressBar(alt.recommendationScore * 100, "success")}
      </div>
    `).join("");
    html += renderSection("Alternative Strategies", altsContent, "\u{1F500}");
  }
  const recContent = `
    <p><strong>Action:</strong> ${renderBadge(thought.recommendation.action, "warning")}</p>
    ${thought.recommendation.targetMode ? `<p><strong>Target Mode:</strong> ${renderBadge(thought.recommendation.targetMode, "primary")}</p>` : ""}
    <p><strong>Justification:</strong> ${escapeHTML(thought.recommendation.justification)}</p>
    <p><strong>Expected Improvement:</strong> ${escapeHTML(thought.recommendation.expectedImprovement)}</p>
    <p style="margin-top: 1rem"><strong>Confidence:</strong></p>
    ${renderProgressBar(thought.recommendation.confidence * 100, "success")}
  `;
  html += renderSection("Recommendation", recContent, "\u{1F4A1}");
  const resourceRows = [
    ["Time Spent", `${thought.resourceAllocation.timeSpent}ms`],
    ["Thoughts Remaining", thought.resourceAllocation.thoughtsRemaining],
    ["Complexity Level", thought.resourceAllocation.complexityLevel],
    ["Urgency", thought.resourceAllocation.urgency]
  ];
  let resourceContent = renderTable(["Resource", "Value"], resourceRows);
  resourceContent += `<p style="margin-top: 1rem"><strong>Recommendation:</strong> ${escapeHTML(thought.resourceAllocation.recommendation)}</p>`;
  html += renderSection("Resource Allocation", resourceContent, "\u26A1");
  const qualityRows = [
    ["Logical Consistency", `${(thought.qualityMetrics.logicalConsistency * 100).toFixed(1)}%`],
    ["Evidence Quality", `${(thought.qualityMetrics.evidenceQuality * 100).toFixed(1)}%`],
    ["Completeness", `${(thought.qualityMetrics.completeness * 100).toFixed(1)}%`],
    ["Originality", `${(thought.qualityMetrics.originality * 100).toFixed(1)}%`],
    ["Clarity", `${(thought.qualityMetrics.clarity * 100).toFixed(1)}%`],
    ["Overall Quality", `${(thought.qualityMetrics.overallQuality * 100).toFixed(1)}%`]
  ];
  let qualityContent = renderTable(["Metric", "Value"], qualityRows);
  qualityContent += '<p style="margin-top: 1rem"><strong>Overall Quality:</strong></p>';
  qualityContent += renderProgressBar(thought.qualityMetrics.overallQuality * 100, "success");
  html += renderSection("Quality Metrics", qualityContent, "\u2B50");
  const sessionRows = [
    ["Session ID", thought.sessionContext.sessionId],
    ["Total Thoughts", thought.sessionContext.totalThoughts],
    ["Mode Switches", thought.sessionContext.modeSwitches],
    ["Problem Type", thought.sessionContext.problemType]
  ];
  if (thought.sessionContext.historicalEffectiveness !== void 0) {
    sessionRows.push(["Historical Effectiveness", `${(thought.sessionContext.historicalEffectiveness * 100).toFixed(1)}%`]);
  }
  let sessionContent = renderTable(["Property", "Value"], sessionRows);
  if (thought.sessionContext.modesUsed.length > 0) {
    sessionContent += '<p style="margin-top: 1rem"><strong>Modes Used:</strong></p>';
    sessionContent += '<div class="flex gap-1 flex-wrap">';
    thought.sessionContext.modesUsed.forEach((mode) => {
      sessionContent += renderBadge(mode, "info");
      sessionContent += " ";
    });
    sessionContent += "</div>";
  }
  html += renderSection("Session Context", sessionContent, "\u{1F4CB}");
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function metaReasoningToModelica(thought, options) {
  const { includeMetrics = true } = options;
  let modelica = "package MetaReasoning\n";
  modelica += '  "Meta-reasoning analysis model for strategy evaluation and recommendation"\n\n';
  modelica += "  record CurrentStrategy\n";
  modelica += '    "Current reasoning strategy being employed"\n';
  const modeId = sanitizeModelicaId(thought.currentStrategy.mode);
  modelica += `    parameter String mode = "${escapeModelicaString(modeId)}";
`;
  modelica += `    parameter String approach = "${escapeModelicaString(thought.currentStrategy.approach)}";
`;
  modelica += `    parameter Integer thoughtsSpent = ${thought.currentStrategy.thoughtsSpent};
`;
  if (thought.currentStrategy.progressIndicators.length > 0) {
    modelica += `    parameter Integer progressIndicatorCount = ${thought.currentStrategy.progressIndicators.length};
`;
  }
  modelica += "  end CurrentStrategy;\n\n";
  modelica += "  record StrategyEvaluation\n";
  modelica += '    "Evaluation metrics for current strategy"\n';
  modelica += `    parameter Real effectiveness(min=0.0, max=1.0) = ${thought.strategyEvaluation.effectiveness.toFixed(4)};
`;
  modelica += `    parameter Real efficiency(min=0.0, max=1.0) = ${thought.strategyEvaluation.efficiency.toFixed(4)};
`;
  modelica += `    parameter Real confidence(min=0.0, max=1.0) = ${thought.strategyEvaluation.confidence.toFixed(4)};
`;
  modelica += `    parameter Real progressRate = ${thought.strategyEvaluation.progressRate.toFixed(4)};
`;
  modelica += `    parameter Real qualityScore(min=0.0, max=1.0) = ${thought.strategyEvaluation.qualityScore.toFixed(4)};
`;
  modelica += `    parameter Integer issueCount = ${thought.strategyEvaluation.issues.length};
`;
  modelica += `    parameter Integer strengthCount = ${thought.strategyEvaluation.strengths.length};
`;
  modelica += "  end StrategyEvaluation;\n\n";
  if (thought.alternativeStrategies.length > 0) {
    thought.alternativeStrategies.forEach((alt, index) => {
      modelica += `  record AlternativeStrategy${index + 1}
`;
      modelica += `    "Alternative reasoning strategy option ${index + 1}"
`;
      const altModeId = sanitizeModelicaId(alt.mode);
      modelica += `    parameter String mode = "${escapeModelicaString(altModeId)}";
`;
      modelica += `    parameter String reasoning = "${escapeModelicaString(alt.reasoning)}";
`;
      modelica += `    parameter String expectedBenefit = "${escapeModelicaString(alt.expectedBenefit)}";
`;
      modelica += `    parameter Real switchingCost(min=0.0, max=1.0) = ${alt.switchingCost.toFixed(4)};
`;
      modelica += `    parameter Real recommendationScore(min=0.0, max=1.0) = ${alt.recommendationScore.toFixed(4)};
`;
      modelica += `  end AlternativeStrategy${index + 1};

`;
    });
  }
  modelica += "  record Recommendation\n";
  modelica += '    "Strategic recommendation from meta-reasoning"\n';
  modelica += `    parameter String action = "${escapeModelicaString(thought.recommendation.action)}";
`;
  if (thought.recommendation.targetMode) {
    const targetModeId = sanitizeModelicaId(thought.recommendation.targetMode);
    modelica += `    parameter String targetMode = "${escapeModelicaString(targetModeId)}";
`;
  }
  modelica += `    parameter String justification = "${escapeModelicaString(thought.recommendation.justification)}";
`;
  modelica += `    parameter Real confidence(min=0.0, max=1.0) = ${thought.recommendation.confidence.toFixed(4)};
`;
  modelica += `    parameter String expectedImprovement = "${escapeModelicaString(thought.recommendation.expectedImprovement)}";
`;
  modelica += "  end Recommendation;\n\n";
  if (includeMetrics) {
    modelica += "  record QualityMetrics\n";
    modelica += '    "Quality assessment metrics for reasoning session"\n';
    modelica += `    parameter Real logicalConsistency(min=0.0, max=1.0) = ${thought.qualityMetrics.logicalConsistency.toFixed(4)};
`;
    modelica += `    parameter Real evidenceQuality(min=0.0, max=1.0) = ${thought.qualityMetrics.evidenceQuality.toFixed(4)};
`;
    modelica += `    parameter Real completeness(min=0.0, max=1.0) = ${thought.qualityMetrics.completeness.toFixed(4)};
`;
    modelica += `    parameter Real originality(min=0.0, max=1.0) = ${thought.qualityMetrics.originality.toFixed(4)};
`;
    modelica += `    parameter Real clarity(min=0.0, max=1.0) = ${thought.qualityMetrics.clarity.toFixed(4)};
`;
    modelica += `    parameter Real overallQuality(min=0.0, max=1.0) = ${thought.qualityMetrics.overallQuality.toFixed(4)};
`;
    modelica += "  end QualityMetrics;\n\n";
  }
  modelica += "  record ResourceAllocation\n";
  modelica += '    "Resource allocation and complexity assessment"\n';
  modelica += `    parameter Real timeSpent = ${thought.resourceAllocation.timeSpent};
`;
  modelica += `    parameter Integer thoughtsRemaining = ${thought.resourceAllocation.thoughtsRemaining};
`;
  modelica += `    parameter String complexityLevel = "${escapeModelicaString(thought.resourceAllocation.complexityLevel)}";
`;
  modelica += `    parameter String urgency = "${escapeModelicaString(thought.resourceAllocation.urgency)}";
`;
  modelica += `    parameter String recommendation = "${escapeModelicaString(thought.resourceAllocation.recommendation)}";
`;
  modelica += "  end ResourceAllocation;\n\n";
  modelica += "  record SessionContext\n";
  modelica += '    "Session context and historical information"\n';
  modelica += `    parameter String sessionId = "${escapeModelicaString(thought.sessionContext.sessionId)}";
`;
  modelica += `    parameter Integer totalThoughts = ${thought.sessionContext.totalThoughts};
`;
  modelica += `    parameter Integer modeSwitches = ${thought.sessionContext.modeSwitches};
`;
  modelica += `    parameter String problemType = "${escapeModelicaString(thought.sessionContext.problemType)}";
`;
  modelica += `    parameter Integer modesUsedCount = ${thought.sessionContext.modesUsed.length};
`;
  if (thought.sessionContext.historicalEffectiveness !== void 0) {
    modelica += `    parameter Real historicalEffectiveness(min=0.0, max=1.0) = ${thought.sessionContext.historicalEffectiveness.toFixed(4)};
`;
  }
  modelica += "  end SessionContext;\n\n";
  modelica += "  model MetaReasoningAnalysis\n";
  modelica += '    "Complete meta-reasoning analysis model"\n';
  modelica += "    CurrentStrategy currentStrategy;\n";
  modelica += "    StrategyEvaluation strategyEvaluation;\n";
  modelica += "    Recommendation recommendation;\n";
  if (includeMetrics) {
    modelica += "    QualityMetrics qualityMetrics;\n";
  }
  modelica += "    ResourceAllocation resourceAllocation;\n";
  modelica += "    SessionContext sessionContext;\n";
  if (thought.alternativeStrategies.length > 0) {
    thought.alternativeStrategies.forEach((_, index) => {
      modelica += `    AlternativeStrategy${index + 1} alternativeStrategy${index + 1};
`;
    });
  }
  modelica += "  end MetaReasoningAnalysis;\n\n";
  modelica += "end MetaReasoning;\n";
  return modelica;
}
function metaReasoningToUML(thought, options) {
  const { includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  nodes.push({
    id: "MetaReasoning",
    label: "MetaReasoning",
    shape: "class",
    attributes: [
      `mode: ${thought.currentStrategy.mode}`,
      `sessionId: ${thought.sessionContext.sessionId}`,
      `totalThoughts: ${thought.sessionContext.totalThoughts}`
    ],
    methods: [
      "evaluateStrategy()",
      "generateRecommendation()",
      "allocateResources()"
    ]
  });
  nodes.push({
    id: "CurrentStrategy",
    label: "CurrentStrategy",
    shape: "class",
    attributes: [
      `mode: ${thought.currentStrategy.mode}`,
      `approach: ${thought.currentStrategy.approach.substring(0, 30)}...`,
      `thoughtsSpent: ${thought.currentStrategy.thoughtsSpent}`,
      `progressIndicators: ${thought.currentStrategy.progressIndicators.length}`
    ]
  });
  edges.push({
    source: "MetaReasoning",
    target: "CurrentStrategy",
    label: "employs",
    type: "composition"
  });
  nodes.push({
    id: "StrategyEvaluation",
    label: "StrategyEvaluation",
    shape: "class",
    attributes: [
      `effectiveness: ${(thought.strategyEvaluation.effectiveness * 100).toFixed(1)}%`,
      `efficiency: ${(thought.strategyEvaluation.efficiency * 100).toFixed(1)}%`,
      `confidence: ${(thought.strategyEvaluation.confidence * 100).toFixed(1)}%`,
      `progressRate: ${thought.strategyEvaluation.progressRate.toFixed(2)}`,
      `qualityScore: ${(thought.strategyEvaluation.qualityScore * 100).toFixed(1)}%`,
      `issues: ${thought.strategyEvaluation.issues.length}`,
      `strengths: ${thought.strategyEvaluation.strengths.length}`
    ]
  });
  edges.push({
    source: "MetaReasoning",
    target: "StrategyEvaluation",
    label: "evaluates",
    type: "association"
  });
  nodes.push({
    id: "Recommendation",
    label: "Recommendation",
    shape: "class",
    attributes: [
      `action: ${thought.recommendation.action}`,
      thought.recommendation.targetMode ? `targetMode: ${thought.recommendation.targetMode}` : void 0,
      `confidence: ${(thought.recommendation.confidence * 100).toFixed(1)}%`,
      `justification: ${thought.recommendation.justification.substring(0, 40)}...`
    ].filter(Boolean)
  });
  edges.push({
    source: "MetaReasoning",
    target: "Recommendation",
    label: "produces",
    type: "association"
  });
  if (thought.alternativeStrategies.length > 0) {
    nodes.push({
      id: "AlternativeStrategy",
      label: "<<interface>>\\nAlternativeStrategy",
      shape: "interface",
      attributes: [
        "mode: ThinkingMode",
        "reasoning: string",
        "expectedBenefit: string",
        "switchingCost: number",
        "recommendationScore: number"
      ]
    });
    edges.push({
      source: "MetaReasoning",
      target: "AlternativeStrategy",
      label: `considers (${thought.alternativeStrategies.length})`,
      type: "association"
    });
    thought.alternativeStrategies.slice(0, 3).forEach((alt, index) => {
      nodes.push({
        id: `Alt${index + 1}`,
        label: `${alt.mode}Strategy`,
        shape: "class",
        attributes: [
          `score: ${(alt.recommendationScore * 100).toFixed(0)}%`,
          `cost: ${(alt.switchingCost * 100).toFixed(0)}%`
        ]
      });
      edges.push({
        source: `Alt${index + 1}`,
        target: "AlternativeStrategy",
        type: "implementation"
      });
    });
  }
  if (includeMetrics) {
    nodes.push({
      id: "QualityMetrics",
      label: "QualityMetrics",
      shape: "class",
      attributes: [
        `logicalConsistency: ${(thought.qualityMetrics.logicalConsistency * 100).toFixed(1)}%`,
        `evidenceQuality: ${(thought.qualityMetrics.evidenceQuality * 100).toFixed(1)}%`,
        `completeness: ${(thought.qualityMetrics.completeness * 100).toFixed(1)}%`,
        `originality: ${(thought.qualityMetrics.originality * 100).toFixed(1)}%`,
        `clarity: ${(thought.qualityMetrics.clarity * 100).toFixed(1)}%`,
        `overallQuality: ${(thought.qualityMetrics.overallQuality * 100).toFixed(1)}%`
      ]
    });
    edges.push({
      source: "MetaReasoning",
      target: "QualityMetrics",
      label: "monitors",
      type: "association"
    });
  }
  nodes.push({
    id: "ResourceAllocation",
    label: "ResourceAllocation",
    shape: "class",
    attributes: [
      `timeSpent: ${thought.resourceAllocation.timeSpent}ms`,
      `thoughtsRemaining: ${thought.resourceAllocation.thoughtsRemaining}`,
      `complexity: ${thought.resourceAllocation.complexityLevel}`,
      `urgency: ${thought.resourceAllocation.urgency}`
    ]
  });
  edges.push({
    source: "MetaReasoning",
    target: "ResourceAllocation",
    label: "manages",
    type: "composition"
  });
  return generateUmlDiagram(nodes, edges, {
    title: "MetaReasoning Structure",
    direction: "top to bottom"
  });
}
function metaReasoningToJSON(thought, options) {
  const { includeMetrics = true } = options;
  const graph = createJsonGraph(
    "MetaReasoning",
    "Meta-reasoning analysis graph showing strategy evaluation and recommendations",
    { includeMetrics, includeLayout: true }
  );
  addNode(graph, {
    id: "meta",
    label: "Meta-Reasoning",
    type: "meta",
    metadata: {
      mode: thought.currentStrategy.mode,
      sessionId: thought.sessionContext.sessionId
    }
  });
  addNode(graph, {
    id: "current_strategy",
    label: "Current Strategy",
    type: "strategy",
    metadata: {
      mode: thought.currentStrategy.mode,
      approach: thought.currentStrategy.approach,
      thoughtsSpent: thought.currentStrategy.thoughtsSpent,
      progressIndicatorCount: thought.currentStrategy.progressIndicators.length,
      progressIndicators: thought.currentStrategy.progressIndicators
    }
  });
  addEdge(graph, {
    id: "e_meta_current",
    source: "meta",
    target: "current_strategy",
    label: "employs",
    metadata: {
      relationship: "current"
    }
  });
  addNode(graph, {
    id: "evaluation",
    label: "Strategy Evaluation",
    type: "evaluation",
    metadata: {
      effectiveness: thought.strategyEvaluation.effectiveness,
      efficiency: thought.strategyEvaluation.efficiency,
      confidence: thought.strategyEvaluation.confidence,
      progressRate: thought.strategyEvaluation.progressRate,
      qualityScore: thought.strategyEvaluation.qualityScore,
      issueCount: thought.strategyEvaluation.issues.length,
      strengthCount: thought.strategyEvaluation.strengths.length,
      issues: thought.strategyEvaluation.issues,
      strengths: thought.strategyEvaluation.strengths
    }
  });
  addEdge(graph, {
    id: "e_current_eval",
    source: "current_strategy",
    target: "evaluation",
    label: "evaluated_by"
  });
  thought.alternativeStrategies.forEach((alt, index) => {
    addNode(graph, {
      id: `alt_${index}`,
      label: `Alternative: ${alt.mode}`,
      type: "alternative",
      metadata: {
        mode: alt.mode,
        reasoning: alt.reasoning,
        expectedBenefit: alt.expectedBenefit,
        switchingCost: alt.switchingCost,
        recommendationScore: alt.recommendationScore
      }
    });
    addEdge(graph, {
      id: `e_meta_alt_${index}`,
      source: "meta",
      target: `alt_${index}`,
      label: "considers",
      metadata: {
        score: alt.recommendationScore
      }
    });
  });
  addNode(graph, {
    id: "recommendation",
    label: "Recommendation",
    type: "recommendation",
    metadata: {
      action: thought.recommendation.action,
      targetMode: thought.recommendation.targetMode,
      justification: thought.recommendation.justification,
      confidence: thought.recommendation.confidence,
      expectedImprovement: thought.recommendation.expectedImprovement
    }
  });
  addEdge(graph, {
    id: "e_eval_rec",
    source: "evaluation",
    target: "recommendation",
    label: "produces",
    metadata: {
      confidence: thought.recommendation.confidence
    }
  });
  if (includeMetrics) {
    addNode(graph, {
      id: "quality",
      label: "Quality Metrics",
      type: "metrics",
      metadata: {
        logicalConsistency: thought.qualityMetrics.logicalConsistency,
        evidenceQuality: thought.qualityMetrics.evidenceQuality,
        completeness: thought.qualityMetrics.completeness,
        originality: thought.qualityMetrics.originality,
        clarity: thought.qualityMetrics.clarity,
        overallQuality: thought.qualityMetrics.overallQuality
      }
    });
    addEdge(graph, {
      id: "e_meta_quality",
      source: "meta",
      target: "quality",
      label: "monitors"
    });
    addMetric(graph, "effectiveness", thought.strategyEvaluation.effectiveness);
    addMetric(graph, "overallQuality", thought.qualityMetrics.overallQuality);
    addMetric(graph, "recommendationConfidence", thought.recommendation.confidence);
  }
  addNode(graph, {
    id: "resources",
    label: "Resource Allocation",
    type: "resources",
    metadata: {
      timeSpent: thought.resourceAllocation.timeSpent,
      thoughtsRemaining: thought.resourceAllocation.thoughtsRemaining,
      complexityLevel: thought.resourceAllocation.complexityLevel,
      urgency: thought.resourceAllocation.urgency,
      recommendation: thought.resourceAllocation.recommendation
    }
  });
  addEdge(graph, {
    id: "e_meta_resources",
    source: "meta",
    target: "resources",
    label: "manages"
  });
  graph.metadata = {
    ...graph.metadata,
    sessionContext: {
      sessionId: thought.sessionContext.sessionId,
      totalThoughts: thought.sessionContext.totalThoughts,
      modeSwitches: thought.sessionContext.modeSwitches,
      problemType: thought.sessionContext.problemType,
      modesUsed: thought.sessionContext.modesUsed,
      historicalEffectiveness: thought.sessionContext.historicalEffectiveness
    }
  };
  return serializeGraph(graph);
}
function metaReasoningToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  const strategyContent = keyValueSection({
    "Mode": thought.currentStrategy.mode,
    "Approach": thought.currentStrategy.approach,
    "Thoughts Spent": thought.currentStrategy.thoughtsSpent
  });
  let strategyFull = strategyContent;
  if (thought.currentStrategy.progressIndicators.length > 0) {
    strategyFull += "\n\n**Progress Indicators:**\n\n" + list(thought.currentStrategy.progressIndicators);
  }
  parts.push(section("Current Strategy", strategyFull));
  if (includeMetrics) {
    const evalRows = [
      ["Effectiveness", `${(thought.strategyEvaluation.effectiveness * 100).toFixed(1)}%`],
      ["Efficiency", `${(thought.strategyEvaluation.efficiency * 100).toFixed(1)}%`],
      ["Confidence", `${(thought.strategyEvaluation.confidence * 100).toFixed(1)}%`],
      ["Progress Rate", `${thought.strategyEvaluation.progressRate.toFixed(2)} insights/thought`],
      ["Quality Score", `${(thought.strategyEvaluation.qualityScore * 100).toFixed(1)}%`]
    ];
    let evalContent = table(["Metric", "Value"], evalRows);
    evalContent += "\n\n**Effectiveness:**\n\n" + progressBar(thought.strategyEvaluation.effectiveness * 100);
    if (thought.strategyEvaluation.strengths.length > 0) {
      evalContent += "\n\n**Strengths:**\n\n" + list(thought.strategyEvaluation.strengths.map((s) => `\u2713 ${s}`));
    }
    if (thought.strategyEvaluation.issues.length > 0) {
      evalContent += "\n\n**Issues:**\n\n" + list(thought.strategyEvaluation.issues.map((i) => `\u2717 ${i}`));
    }
    parts.push(section("Strategy Evaluation", evalContent));
  }
  if (thought.alternativeStrategies.length > 0) {
    const altRows = thought.alternativeStrategies.map((alt) => [
      alt.mode,
      alt.reasoning.substring(0, 50) + (alt.reasoning.length > 50 ? "..." : ""),
      alt.expectedBenefit.substring(0, 40) + (alt.expectedBenefit.length > 40 ? "..." : ""),
      `${(alt.switchingCost * 100).toFixed(0)}%`,
      `${(alt.recommendationScore * 100).toFixed(0)}%`
    ]);
    parts.push(section("Alternative Strategies", table(
      ["Mode", "Reasoning", "Expected Benefit", "Switching Cost", "Score"],
      altRows
    )));
  }
  const recContent = keyValueSection({
    "Action": thought.recommendation.action,
    ...thought.recommendation.targetMode ? { "Target Mode": thought.recommendation.targetMode } : {},
    "Confidence": `${(thought.recommendation.confidence * 100).toFixed(1)}%`,
    "Expected Improvement": thought.recommendation.expectedImprovement
  });
  let recFull = recContent;
  recFull += "\n\n**Justification:**\n\n" + thought.recommendation.justification;
  recFull += "\n\n**Confidence Level:**\n\n" + progressBar(thought.recommendation.confidence * 100);
  parts.push(section("Recommendation", recFull));
  const resourceContent = keyValueSection({
    "Time Spent": `${thought.resourceAllocation.timeSpent}ms`,
    "Thoughts Remaining": thought.resourceAllocation.thoughtsRemaining,
    "Complexity Level": thought.resourceAllocation.complexityLevel,
    "Urgency": thought.resourceAllocation.urgency,
    "Recommendation": thought.resourceAllocation.recommendation
  });
  parts.push(section("Resource Allocation", resourceContent));
  if (includeMetrics) {
    const qualityRows = [
      ["Logical Consistency", `${(thought.qualityMetrics.logicalConsistency * 100).toFixed(1)}%`],
      ["Evidence Quality", `${(thought.qualityMetrics.evidenceQuality * 100).toFixed(1)}%`],
      ["Completeness", `${(thought.qualityMetrics.completeness * 100).toFixed(1)}%`],
      ["Originality", `${(thought.qualityMetrics.originality * 100).toFixed(1)}%`],
      ["Clarity", `${(thought.qualityMetrics.clarity * 100).toFixed(1)}%`],
      ["Overall Quality", `${(thought.qualityMetrics.overallQuality * 100).toFixed(1)}%`]
    ];
    let qualityContent = table(["Metric", "Value"], qualityRows);
    qualityContent += "\n\n**Overall Quality:**\n\n" + progressBar(thought.qualityMetrics.overallQuality * 100);
    parts.push(section("Quality Metrics", qualityContent));
  }
  const sessionContent = keyValueSection({
    "Session ID": thought.sessionContext.sessionId,
    "Total Thoughts": thought.sessionContext.totalThoughts,
    "Mode Switches": thought.sessionContext.modeSwitches,
    "Problem Type": thought.sessionContext.problemType,
    "Modes Used": thought.sessionContext.modesUsed.join(", "),
    ...thought.sessionContext.historicalEffectiveness !== void 0 ? { "Historical Effectiveness": `${(thought.sessionContext.historicalEffectiveness * 100).toFixed(1)}%` } : {}
  });
  parts.push(section("Session Context", sessionContent));
  if (markdownIncludeMermaid) {
    const mermaidDiagram = metaReasoningToMermaid(thought, "default", true, true);
    parts.push(section("Visualization", mermaidBlock(mermaidDiagram)));
  }
  return document("Meta-Reasoning Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "metareasoning",
      currentMode: thought.currentStrategy.mode,
      recommendedAction: thought.recommendation.action,
      overallQuality: thought.qualityMetrics.overallQuality
    }
  });
}
var init_metareasoning = __esm({
  "src/export/visual/metareasoning.ts"() {
    init_esm_shims();
    init_utils();
    init_svg_utils();
    init_graphml_utils();
    init_tikz_utils();
    init_html_utils();
    init_modelica_utils();
    init_uml_utils();
    init_json_utils();
    init_markdown_utils();
  }
});

// src/export/visual/proof-decomposition.ts
function exportProofDecomposition(decomposition, options) {
  const {
    format,
    colorScheme = "default",
    includeLabels = true,
    includeMetrics = true,
    svgWidth = 800,
    svgHeight = 600,
    nodeSpacing = 120
  } = options;
  switch (format) {
    case "mermaid":
      return proofDecompositionToMermaid(decomposition, colorScheme, includeLabels, includeMetrics);
    case "dot":
      return proofDecompositionToDOT(decomposition, includeLabels, includeMetrics);
    case "ascii":
      return proofDecompositionToASCII(decomposition);
    case "svg":
      return proofDecompositionToSVG(decomposition, colorScheme, includeLabels, includeMetrics, svgWidth, svgHeight, nodeSpacing);
    case "html":
      return proofDecompositionToHTML(decomposition, options);
    case "modelica":
      return proofDecompositionToModelica(decomposition, options);
    case "uml":
      return proofDecompositionToUML(decomposition, options);
    case "json":
      return proofDecompositionToJSON(decomposition, options);
    case "markdown":
      return proofDecompositionToMarkdown(decomposition, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function getMermaidShape(type) {
  switch (type) {
    case "axiom":
      return ["([", "])"];
    // Stadium/rounded
    case "definition":
      return ["[[", "]]"];
    // Subroutine
    case "hypothesis":
      return ["[", "]"];
    // Rectangle
    case "lemma":
      return ["{{", "}}"];
    // Hexagon
    case "derived":
      return ["(", ")"];
    // Default rounded
    case "conclusion":
      return ["{", "}"];
    // Diamond shape via styling
    default:
      return ["(", ")"];
  }
}
function getNodeColor2(type, colorScheme) {
  if (colorScheme === "monochrome") return "#ffffff";
  const colors = colorScheme === "pastel" ? {
    axiom: "#c8e6c9",
    // Light green
    definition: "#e1bee7",
    // Light purple
    hypothesis: "#bbdefb",
    // Light blue
    lemma: "#fff9c4",
    // Light yellow
    derived: "#e0e0e0",
    // Light gray
    conclusion: "#d1c4e9"
    // Light purple
  } : {
    axiom: "#81c784",
    // Green
    definition: "#ba68c8",
    // Purple
    hypothesis: "#64b5f6",
    // Blue
    lemma: "#ffd54f",
    // Yellow
    derived: "#bdbdbd",
    // Gray
    conclusion: "#9575cd"
    // Purple
  };
  return colors[type] || colors.derived;
}
function proofDecompositionToMermaid(decomposition, colorScheme, includeLabels, includeMetrics) {
  let mermaid = "graph TD\n";
  if (decomposition.theorem) {
    mermaid += `  title["Proof: ${decomposition.theorem.substring(0, 50)}..."]
`;
    mermaid += "  style title fill:#f5f5f5,stroke:#333\n\n";
  }
  const axioms = decomposition.atoms.filter((a) => a.type === "axiom");
  const hypotheses = decomposition.atoms.filter((a) => a.type === "hypothesis");
  const derived = decomposition.atoms.filter((a) => a.type === "derived" || a.type === "lemma");
  const conclusions = decomposition.atoms.filter((a) => a.type === "conclusion");
  if (axioms.length > 0) {
    mermaid += '  subgraph Axioms["Axioms"]\n';
    for (const atom of axioms) {
      const nodeId = sanitizeId(atom.id);
      const label = includeLabels ? atom.statement.substring(0, 40) + (atom.statement.length > 40 ? "..." : "") : atom.id;
      const [open, close] = getMermaidShape(atom.type);
      mermaid += `    ${nodeId}${open}"${label}"${close}
`;
    }
    mermaid += "  end\n\n";
  }
  if (hypotheses.length > 0) {
    mermaid += '  subgraph Hypotheses["Hypotheses"]\n';
    for (const atom of hypotheses) {
      const nodeId = sanitizeId(atom.id);
      const label = includeLabels ? atom.statement.substring(0, 40) + (atom.statement.length > 40 ? "..." : "") : atom.id;
      const [open, close] = getMermaidShape(atom.type);
      mermaid += `    ${nodeId}${open}"${label}"${close}
`;
    }
    mermaid += "  end\n\n";
  }
  for (const atom of derived) {
    const nodeId = sanitizeId(atom.id);
    const label = includeLabels ? atom.statement.substring(0, 40) + (atom.statement.length > 40 ? "..." : "") : atom.id;
    const [open, close] = getMermaidShape(atom.type);
    mermaid += `  ${nodeId}${open}"${label}"${close}
`;
  }
  if (conclusions.length > 0) {
    mermaid += '\n  subgraph Conclusions["Conclusions"]\n';
    for (const atom of conclusions) {
      const nodeId = sanitizeId(atom.id);
      const label = includeLabels ? atom.statement.substring(0, 40) + (atom.statement.length > 40 ? "..." : "") : atom.id;
      mermaid += `    ${nodeId}{"${label}"}
`;
    }
    mermaid += "  end\n\n";
  }
  if (decomposition.dependencies && decomposition.dependencies.edges) {
    for (const edge of decomposition.dependencies.edges) {
      const fromId = sanitizeId(edge.from);
      const toId = sanitizeId(edge.to);
      const edgeLabel = edge.inferenceRule ? ` -->|${edge.inferenceRule}| ` : " --> ";
      mermaid += `  ${fromId}${edgeLabel}${toId}
`;
    }
  }
  if (decomposition.gaps && decomposition.gaps.length > 0) {
    mermaid += '\n  subgraph Gaps["Identified Gaps"]\n';
    for (const gap of decomposition.gaps) {
      const gapId = sanitizeId(gap.id);
      const label = gap.description.substring(0, 30) + "...";
      mermaid += `    ${gapId}["${label}"]
`;
      mermaid += `    ${sanitizeId(gap.location.from)} -.->|gap| ${gapId}
`;
      mermaid += `    ${gapId} -.-> ${sanitizeId(gap.location.to)}
`;
    }
    mermaid += "  end\n";
  }
  if (includeMetrics) {
    mermaid += '\n  subgraph Metrics["Metrics"]\n';
    mermaid += `    m1["Completeness: ${(decomposition.completeness * 100).toFixed(0)}%"]
`;
    mermaid += `    m2["Rigor: ${decomposition.rigorLevel}"]
`;
    mermaid += `    m3["Atoms: ${decomposition.atomCount}"]
`;
    mermaid += `    m4["Depth: ${decomposition.maxDependencyDepth}"]
`;
    mermaid += "  end\n";
  }
  if (colorScheme !== "monochrome") {
    mermaid += "\n";
    for (const atom of decomposition.atoms) {
      const nodeId = sanitizeId(atom.id);
      const color = getNodeColor2(atom.type, colorScheme);
      mermaid += `  style ${nodeId} fill:${color}
`;
    }
    if (decomposition.gaps) {
      for (const gap of decomposition.gaps) {
        const gapId = sanitizeId(gap.id);
        mermaid += `  style ${gapId} fill:#ffcdd2,stroke:#e53935,stroke-dasharray: 5 5
`;
      }
    }
  }
  return mermaid;
}
function getDOTShape(type) {
  switch (type) {
    case "axiom":
      return "ellipse";
    case "definition":
      return "box3d";
    case "hypothesis":
      return "box";
    case "lemma":
      return "hexagon";
    case "derived":
      return "box";
    case "conclusion":
      return "diamond";
    default:
      return "box";
  }
}
function proofDecompositionToDOT(decomposition, includeLabels, includeMetrics) {
  let dot = "digraph ProofDecomposition {\n";
  dot += "  rankdir=TB;\n";
  dot += "  compound=true;\n";
  dot += '  node [style="rounded,filled", fontname="Arial"];\n';
  dot += '  edge [fontname="Arial", fontsize=10];\n\n';
  if (decomposition.theorem) {
    dot += `  label="Proof: ${decomposition.theorem.substring(0, 60)}...";
`;
    dot += "  labelloc=t;\n";
    dot += "  fontsize=14;\n\n";
  }
  const axioms = decomposition.atoms.filter((a) => a.type === "axiom");
  const hypotheses = decomposition.atoms.filter((a) => a.type === "hypothesis");
  const conclusions = decomposition.atoms.filter((a) => a.type === "conclusion");
  if (axioms.length > 0) {
    dot += "  subgraph cluster_axioms {\n";
    dot += '    label="Axioms";\n';
    dot += "    style=filled;\n";
    dot += '    color="#e8f5e9";\n';
    for (const atom of axioms) {
      const nodeId = sanitizeId(atom.id);
      const label = includeLabels ? atom.statement.substring(0, 40).replace(/"/g, '\\"') : atom.id;
      dot += `    ${nodeId} [label="${label}", shape=${getDOTShape(atom.type)}, fillcolor="#81c784"];
`;
    }
    dot += "  }\n\n";
  }
  if (hypotheses.length > 0) {
    dot += "  subgraph cluster_hypotheses {\n";
    dot += '    label="Hypotheses";\n';
    dot += "    style=filled;\n";
    dot += '    color="#e3f2fd";\n';
    for (const atom of hypotheses) {
      const nodeId = sanitizeId(atom.id);
      const label = includeLabels ? atom.statement.substring(0, 40).replace(/"/g, '\\"') : atom.id;
      dot += `    ${nodeId} [label="${label}", shape=${getDOTShape(atom.type)}, fillcolor="#64b5f6"];
`;
    }
    dot += "  }\n\n";
  }
  const derived = decomposition.atoms.filter((a) => a.type === "derived" || a.type === "lemma");
  for (const atom of derived) {
    const nodeId = sanitizeId(atom.id);
    const label = includeLabels ? atom.statement.substring(0, 40).replace(/"/g, '\\"') : atom.id;
    const color = atom.type === "lemma" ? "#ffd54f" : "#bdbdbd";
    dot += `  ${nodeId} [label="${label}", shape=${getDOTShape(atom.type)}, fillcolor="${color}"];
`;
  }
  dot += "\n";
  if (conclusions.length > 0) {
    dot += "  subgraph cluster_conclusions {\n";
    dot += '    label="Conclusions";\n';
    dot += "    style=filled;\n";
    dot += '    color="#ede7f6";\n';
    for (const atom of conclusions) {
      const nodeId = sanitizeId(atom.id);
      const label = includeLabels ? atom.statement.substring(0, 40).replace(/"/g, '\\"') : atom.id;
      dot += `    ${nodeId} [label="${label}", shape=${getDOTShape(atom.type)}, fillcolor="#9575cd"];
`;
    }
    dot += "  }\n\n";
  }
  if (decomposition.dependencies && decomposition.dependencies.edges) {
    for (const edge of decomposition.dependencies.edges) {
      const fromId = sanitizeId(edge.from);
      const toId = sanitizeId(edge.to);
      const edgeLabel = edge.inferenceRule ? ` [label="${edge.inferenceRule}"]` : "";
      dot += `  ${fromId} -> ${toId}${edgeLabel};
`;
    }
  }
  if (decomposition.gaps && decomposition.gaps.length > 0) {
    dot += "\n  // Gaps (dashed red)\n";
    for (const gap of decomposition.gaps) {
      const gapId = sanitizeId(gap.id);
      const label = gap.description.substring(0, 30).replace(/"/g, '\\"');
      dot += `  ${gapId} [label="${label}", shape=note, fillcolor="#ffcdd2", style="dashed,filled"];
`;
      dot += `  ${sanitizeId(gap.location.from)} -> ${gapId} [style=dashed, color=red];
`;
      dot += `  ${gapId} -> ${sanitizeId(gap.location.to)} [style=dashed, color=red];
`;
    }
  }
  if (includeMetrics) {
    dot += "\n  // Metrics\n";
    dot += "  subgraph cluster_metrics {\n";
    dot += '    label="Metrics";\n';
    dot += "    style=filled;\n";
    dot += '    color="#f5f5f5";\n';
    dot += `    metrics [label="Completeness: ${(decomposition.completeness * 100).toFixed(0)}%\\nRigor: ${decomposition.rigorLevel}\\nAtoms: ${decomposition.atomCount}\\nDepth: ${decomposition.maxDependencyDepth}", shape=note];
`;
    dot += "  }\n";
  }
  dot += "}\n";
  return dot;
}
function proofDecompositionToASCII(decomposition) {
  let ascii = "";
  ascii += "\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n";
  ascii += "\u2551                    PROOF DECOMPOSITION                         \u2551\n";
  ascii += "\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D\n\n";
  if (decomposition.theorem) {
    ascii += `Theorem: ${decomposition.theorem}

`;
  }
  ascii += "\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n";
  ascii += "\u2502 METRICS                                                         \u2502\n";
  ascii += "\u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n";
  ascii += `\u2502 Completeness: ${(decomposition.completeness * 100).toFixed(0)}%`.padEnd(66) + "\u2502\n";
  ascii += `\u2502 Rigor Level:  ${decomposition.rigorLevel}`.padEnd(66) + "\u2502\n";
  ascii += `\u2502 Atom Count:   ${decomposition.atomCount}`.padEnd(66) + "\u2502\n";
  ascii += `\u2502 Max Depth:    ${decomposition.maxDependencyDepth}`.padEnd(66) + "\u2502\n";
  ascii += "\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n";
  const axioms = decomposition.atoms.filter((a) => a.type === "axiom");
  if (axioms.length > 0) {
    ascii += "\u250C\u2500 AXIOMS \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n";
    for (const atom of axioms) {
      const marker = "\u25C9";
      const line = `\u2502 ${marker} [${atom.id}] ${atom.statement}`;
      ascii += line.substring(0, 65).padEnd(66) + "\u2502\n";
    }
    ascii += "\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n";
  }
  const hypotheses = decomposition.atoms.filter((a) => a.type === "hypothesis");
  if (hypotheses.length > 0) {
    ascii += "\u250C\u2500 HYPOTHESES \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n";
    for (const atom of hypotheses) {
      const marker = "\u25C6";
      const line = `\u2502 ${marker} [${atom.id}] ${atom.statement}`;
      ascii += line.substring(0, 65).padEnd(66) + "\u2502\n";
    }
    ascii += "\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n";
  }
  const derived = decomposition.atoms.filter((a) => a.type === "derived" || a.type === "lemma");
  if (derived.length > 0) {
    ascii += "\u250C\u2500 DERIVATION CHAIN \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n";
    for (const atom of derived) {
      const marker = atom.type === "lemma" ? "\u25C7" : "\u25CB";
      const deps = atom.derivedFrom && atom.derivedFrom.length > 0 ? ` \u2190 [${atom.derivedFrom.join(", ")}]` : "";
      const line = `\u2502 ${marker} [${atom.id}] ${atom.statement}${deps}`;
      ascii += line.substring(0, 65).padEnd(66) + "\u2502\n";
      if (atom.usedInferenceRule) {
        ascii += `\u2502   \u2514\u2500 Rule: ${atom.usedInferenceRule}`.padEnd(66) + "\u2502\n";
      }
    }
    ascii += "\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n";
  }
  const conclusions = decomposition.atoms.filter((a) => a.type === "conclusion");
  if (conclusions.length > 0) {
    ascii += "\u250C\u2500 CONCLUSIONS \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n";
    for (const atom of conclusions) {
      const marker = "\u2605";
      const deps = atom.derivedFrom && atom.derivedFrom.length > 0 ? ` \u2190 [${atom.derivedFrom.join(", ")}]` : "";
      const line = `\u2502 ${marker} [${atom.id}] ${atom.statement}${deps}`;
      ascii += line.substring(0, 65).padEnd(66) + "\u2502\n";
    }
    ascii += "\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n";
  }
  if (decomposition.gaps && decomposition.gaps.length > 0) {
    ascii += "\u250C\u2500 GAPS (Missing Steps) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n";
    for (const gap of decomposition.gaps) {
      const severityIcon = gap.severity === "critical" ? "\u26A0" : gap.severity === "significant" ? "!" : "?";
      ascii += `\u2502 ${severityIcon} [${gap.type}] ${gap.description}`.substring(0, 65).padEnd(66) + "\u2502\n";
      ascii += `\u2502   Between: ${gap.location.from} \u2192 ${gap.location.to}`.padEnd(66) + "\u2502\n";
      if (gap.suggestedFix) {
        ascii += `\u2502   Fix: ${gap.suggestedFix}`.substring(0, 65).padEnd(66) + "\u2502\n";
      }
    }
    ascii += "\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n";
  }
  if (decomposition.implicitAssumptions && decomposition.implicitAssumptions.length > 0) {
    ascii += "\u250C\u2500 IMPLICIT ASSUMPTIONS \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n";
    for (const assumption of decomposition.implicitAssumptions) {
      ascii += `\u2502 \u2022 [${assumption.type}]`.padEnd(66) + "\u2502\n";
      ascii += `\u2502   ${assumption.statement}`.substring(0, 65).padEnd(66) + "\u2502\n";
      if (assumption.shouldBeExplicit) {
        ascii += `\u2502   \u26A0 Should be explicit`.padEnd(66) + "\u2502\n";
      }
    }
    ascii += "\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n";
  }
  if (decomposition.dependencies && decomposition.dependencies.edges.length > 0) {
    ascii += "\u250C\u2500 DEPENDENCY TREE \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n";
    ascii += "\u2502                                                                    \u2502\n";
    const roots = decomposition.dependencies.roots || [];
    for (const rootId of roots) {
      ascii += buildASCIITree(rootId, decomposition, 0, /* @__PURE__ */ new Set());
    }
    ascii += "\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n";
  }
  return ascii;
}
function buildASCIITree(nodeId, decomposition, depth, visited) {
  if (visited.has(nodeId) || depth > 10) {
    return "";
  }
  visited.add(nodeId);
  const indent = "\u2502   ".repeat(depth);
  const atom = decomposition.atoms.find((a) => a.id === nodeId);
  if (!atom) return "";
  const typeMarker = {
    axiom: "\u25C9",
    hypothesis: "\u25C6",
    definition: "\u25A3",
    lemma: "\u25C7",
    derived: "\u25CB",
    conclusion: "\u2605"
  }[atom.type] || "?";
  let result = `\u2502 ${indent}${typeMarker} ${atom.id}
`;
  const children = decomposition.dependencies.edges.filter((e) => e.from === nodeId).map((e) => e.to);
  for (const childId of children) {
    result += buildASCIITree(childId, decomposition, depth + 1, visited);
  }
  return result;
}
function getSVGColors(type, colorScheme) {
  if (colorScheme === "monochrome") {
    return { fill: "#ffffff", stroke: "#333333" };
  }
  const colors = colorScheme === "pastel" ? {
    axiom: { fill: "#c8e6c9", stroke: "#4caf50" },
    definition: { fill: "#e1bee7", stroke: "#9c27b0" },
    hypothesis: { fill: "#bbdefb", stroke: "#2196f3" },
    lemma: { fill: "#fff9c4", stroke: "#ffc107" },
    derived: { fill: "#e0e0e0", stroke: "#757575" },
    conclusion: { fill: "#d1c4e9", stroke: "#673ab7" }
  } : {
    axiom: { fill: "#81c784", stroke: "#388e3c" },
    definition: { fill: "#ba68c8", stroke: "#7b1fa2" },
    hypothesis: { fill: "#64b5f6", stroke: "#1976d2" },
    lemma: { fill: "#ffd54f", stroke: "#ffa000" },
    derived: { fill: "#bdbdbd", stroke: "#616161" },
    conclusion: { fill: "#9575cd", stroke: "#512da8" }
  };
  return colors[type] || colors.derived;
}
function escapeSVGText2(text) {
  return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
}
function truncateText2(text, maxChars) {
  if (text.length <= maxChars) return text;
  return text.substring(0, maxChars - 3) + "...";
}
function renderSVGNode(pos, colorScheme) {
  const colors = getSVGColors(pos.type, colorScheme);
  const escapedLabel = escapeSVGText2(truncateText2(pos.label, 30));
  switch (pos.type) {
    case "axiom":
      return `
    <g class="node node-axiom" data-id="${sanitizeId(pos.id)}">
      <rect x="${pos.x}" y="${pos.y}" width="${pos.width}" height="${pos.height}"
            rx="20" ry="20" fill="${colors.fill}" stroke="${colors.stroke}" stroke-width="2"/>
      <text x="${pos.x + pos.width / 2}" y="${pos.y + pos.height / 2 + 5}"
            text-anchor="middle" font-family="Arial, sans-serif" font-size="12">${escapedLabel}</text>
    </g>`;
    case "hypothesis":
      return `
    <g class="node node-hypothesis" data-id="${sanitizeId(pos.id)}">
      <rect x="${pos.x}" y="${pos.y}" width="${pos.width}" height="${pos.height}"
            rx="4" ry="4" fill="${colors.fill}" stroke="${colors.stroke}" stroke-width="2"/>
      <text x="${pos.x + pos.width / 2}" y="${pos.y + pos.height / 2 + 5}"
            text-anchor="middle" font-family="Arial, sans-serif" font-size="12">${escapedLabel}</text>
    </g>`;
    case "conclusion": {
      const cx = pos.x + pos.width / 2;
      const cy = pos.y + pos.height / 2;
      return `
    <g class="node node-conclusion" data-id="${sanitizeId(pos.id)}">
      <polygon points="${cx},${pos.y} ${pos.x + pos.width},${cy} ${cx},${pos.y + pos.height} ${pos.x},${cy}"
               fill="${colors.fill}" stroke="${colors.stroke}" stroke-width="2"/>
      <text x="${cx}" y="${cy + 5}"
            text-anchor="middle" font-family="Arial, sans-serif" font-size="12">${escapedLabel}</text>
    </g>`;
    }
    case "lemma": {
      const hx = pos.x + pos.width / 2;
      const hy = pos.y + pos.height / 2;
      const w = pos.width;
      const h = pos.height;
      return `
    <g class="node node-lemma" data-id="${sanitizeId(pos.id)}">
      <polygon points="${pos.x + w * 0.25},${pos.y} ${pos.x + w * 0.75},${pos.y} ${pos.x + w},${hy} ${pos.x + w * 0.75},${pos.y + h} ${pos.x + w * 0.25},${pos.y + h} ${pos.x},${hy}"
               fill="${colors.fill}" stroke="${colors.stroke}" stroke-width="2"/>
      <text x="${hx}" y="${hy + 5}"
            text-anchor="middle" font-family="Arial, sans-serif" font-size="12">${escapedLabel}</text>
    </g>`;
    }
    case "definition":
      return `
    <g class="node node-definition" data-id="${sanitizeId(pos.id)}">
      <rect x="${pos.x}" y="${pos.y}" width="${pos.width}" height="${pos.height}"
            rx="4" ry="4" fill="${colors.fill}" stroke="${colors.stroke}" stroke-width="2"/>
      <rect x="${pos.x + 4}" y="${pos.y + 4}" width="${pos.width - 8}" height="${pos.height - 8}"
            rx="2" ry="2" fill="none" stroke="${colors.stroke}" stroke-width="1"/>
      <text x="${pos.x + pos.width / 2}" y="${pos.y + pos.height / 2 + 5}"
            text-anchor="middle" font-family="Arial, sans-serif" font-size="12">${escapedLabel}</text>
    </g>`;
    default:
      return `
    <g class="node node-derived" data-id="${sanitizeId(pos.id)}">
      <rect x="${pos.x}" y="${pos.y}" width="${pos.width}" height="${pos.height}"
            rx="8" ry="8" fill="${colors.fill}" stroke="${colors.stroke}" stroke-width="2"/>
      <text x="${pos.x + pos.width / 2}" y="${pos.y + pos.height / 2 + 5}"
            text-anchor="middle" font-family="Arial, sans-serif" font-size="12">${escapedLabel}</text>
    </g>`;
  }
}
function renderSVGEdge(fromPos, toPos, label, isDashed = false, color = "#333333") {
  const fromX = fromPos.x + fromPos.width / 2;
  const fromY = fromPos.y + fromPos.height;
  const toX = toPos.x + toPos.width / 2;
  const toY = toPos.y;
  const midY = (fromY + toY) / 2;
  const path4 = `M ${fromX} ${fromY} C ${fromX} ${midY}, ${toX} ${midY}, ${toX} ${toY - 8}`;
  const dashStyle = isDashed ? 'stroke-dasharray="5,5"' : "";
  const labelElement = label ? `<text x="${(fromX + toX) / 2}" y="${midY - 5}" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" fill="#666">${escapeSVGText2(label)}</text>` : "";
  return `
    <g class="edge">
      <path d="${path4}" fill="none" stroke="${color}" stroke-width="2" ${dashStyle} marker-end="url(#arrowhead)"/>
      ${labelElement}
    </g>`;
}
function proofDecompositionToSVG(decomposition, colorScheme, includeLabels, includeMetrics, width, height, nodeSpacing) {
  const nodeWidth = 150;
  const nodeHeight = 40;
  const padding = 40;
  const layerSpacing = nodeSpacing;
  const axioms = decomposition.atoms.filter((a) => a.type === "axiom");
  const hypotheses = decomposition.atoms.filter((a) => a.type === "hypothesis");
  const derived = decomposition.atoms.filter((a) => a.type === "derived" || a.type === "lemma");
  const conclusions = decomposition.atoms.filter((a) => a.type === "conclusion");
  const nodePositions = /* @__PURE__ */ new Map();
  let currentY = padding;
  const layer1 = [...axioms, ...hypotheses];
  const layer1Width = layer1.length * (nodeWidth + 20) - 20;
  let startX = (width - layer1Width) / 2;
  for (const atom of layer1) {
    const label = includeLabels ? atom.statement : atom.id;
    nodePositions.set(atom.id, {
      id: atom.id,
      x: startX,
      y: currentY,
      width: nodeWidth,
      height: nodeHeight,
      type: atom.type,
      label
    });
    startX += nodeWidth + 20;
  }
  currentY += nodeHeight + layerSpacing;
  const derivedWidth = derived.length * (nodeWidth + 20) - 20;
  startX = (width - derivedWidth) / 2;
  for (const atom of derived) {
    const label = includeLabels ? atom.statement : atom.id;
    nodePositions.set(atom.id, {
      id: atom.id,
      x: startX,
      y: currentY,
      width: nodeWidth,
      height: nodeHeight,
      type: atom.type,
      label
    });
    startX += nodeWidth + 20;
  }
  currentY += nodeHeight + layerSpacing;
  const conclusionsWidth = conclusions.length * (nodeWidth + 20) - 20;
  startX = (width - conclusionsWidth) / 2;
  for (const atom of conclusions) {
    const label = includeLabels ? atom.statement : atom.id;
    nodePositions.set(atom.id, {
      id: atom.id,
      x: startX,
      y: currentY,
      width: nodeWidth,
      height: nodeHeight,
      type: atom.type,
      label
    });
    startX += nodeWidth + 20;
  }
  currentY += nodeHeight + padding;
  const actualHeight = Math.max(height, currentY);
  let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${width} ${actualHeight}" width="${width}" height="${actualHeight}">
  <defs>
    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" fill="#333"/>
    </marker>
    <marker id="arrowhead-red" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" fill="#e53935"/>
    </marker>
  </defs>

  <style>
    .title { font-family: Arial, sans-serif; font-size: 16px; font-weight: bold; }
    .section-label { font-family: Arial, sans-serif; font-size: 12px; fill: #666; font-style: italic; }
    .metrics { font-family: Arial, sans-serif; font-size: 11px; fill: #444; }
  </style>

  <!-- Background -->
  <rect width="100%" height="100%" fill="#fafafa"/>
`;
  if (decomposition.theorem) {
    svg += `
  <!-- Title -->
  <text x="${width / 2}" y="25" text-anchor="middle" class="title">Proof: ${escapeSVGText2(truncateText2(decomposition.theorem, 60))}</text>
`;
  }
  if (decomposition.dependencies && decomposition.dependencies.edges) {
    svg += '\n  <!-- Edges -->\n  <g class="edges">';
    for (const edge of decomposition.dependencies.edges) {
      const fromPos = nodePositions.get(edge.from);
      const toPos = nodePositions.get(edge.to);
      if (fromPos && toPos) {
        svg += renderSVGEdge(fromPos, toPos, edge.inferenceRule);
      }
    }
    svg += "\n  </g>\n";
  }
  if (decomposition.gaps && decomposition.gaps.length > 0) {
    svg += '\n  <!-- Gap Edges -->\n  <g class="gap-edges">';
    for (const gap of decomposition.gaps) {
      const fromPos = nodePositions.get(gap.location.from);
      const toPos = nodePositions.get(gap.location.to);
      if (fromPos && toPos) {
        svg += renderSVGEdge(fromPos, toPos, "GAP: " + truncateText2(gap.description, 20), true, "#e53935");
      }
    }
    svg += "\n  </g>\n";
  }
  svg += '\n  <!-- Nodes -->\n  <g class="nodes">';
  for (const [, pos] of nodePositions) {
    svg += renderSVGNode(pos, colorScheme);
  }
  svg += "\n  </g>\n";
  if (includeMetrics) {
    const metricsX = width - 180;
    const metricsY = actualHeight - 100;
    svg += `
  <!-- Metrics -->
  <g class="metrics-panel">
    <rect x="${metricsX}" y="${metricsY}" width="160" height="90" rx="8" fill="#f5f5f5" stroke="#ddd" stroke-width="1"/>
    <text x="${metricsX + 10}" y="${metricsY + 20}" class="metrics" font-weight="bold">Metrics</text>
    <text x="${metricsX + 10}" y="${metricsY + 38}" class="metrics">Completeness: ${(decomposition.completeness * 100).toFixed(0)}%</text>
    <text x="${metricsX + 10}" y="${metricsY + 54}" class="metrics">Rigor: ${decomposition.rigorLevel}</text>
    <text x="${metricsX + 10}" y="${metricsY + 70}" class="metrics">Atoms: ${decomposition.atomCount}</text>
    <text x="${metricsX + 10}" y="${metricsY + 86}" class="metrics">Depth: ${decomposition.maxDependencyDepth}</text>
  </g>
`;
  }
  svg += `
  <!-- Legend -->
  <g class="legend" transform="translate(20, ${actualHeight - 100})">
    <text x="0" y="0" font-family="Arial, sans-serif" font-size="11" font-weight="bold">Legend</text>
    <rect x="0" y="10" width="20" height="12" rx="6" fill="${getSVGColors("axiom", colorScheme).fill}" stroke="${getSVGColors("axiom", colorScheme).stroke}"/>
    <text x="25" y="20" font-family="Arial, sans-serif" font-size="10">Axiom</text>
    <rect x="0" y="28" width="20" height="12" rx="2" fill="${getSVGColors("hypothesis", colorScheme).fill}" stroke="${getSVGColors("hypothesis", colorScheme).stroke}"/>
    <text x="25" y="38" font-family="Arial, sans-serif" font-size="10">Hypothesis</text>
    <rect x="0" y="46" width="20" height="12" rx="4" fill="${getSVGColors("derived", colorScheme).fill}" stroke="${getSVGColors("derived", colorScheme).stroke}"/>
    <text x="25" y="56" font-family="Arial, sans-serif" font-size="10">Derived</text>
    <polygon points="10,64 20,70 10,76 0,70" fill="${getSVGColors("conclusion", colorScheme).fill}" stroke="${getSVGColors("conclusion", colorScheme).stroke}"/>
    <text x="25" y="74" font-family="Arial, sans-serif" font-size="10">Conclusion</text>
  </g>
`;
  svg += "</svg>";
  return svg;
}
function proofDecompositionToHTML(decomposition, options) {
  const { colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  const theme = colorScheme === "monochrome" ? "light" : "light";
  let html = generateHTMLHeader("Proof Decomposition", { standalone: true, theme });
  if (decomposition.theorem) {
    html += renderSection(
      "Theorem",
      `<p class="theorem-statement">${escapeHTML(decomposition.theorem)}</p>`,
      "info"
    );
  }
  if (includeMetrics) {
    const metricsHTML = `
      <div class="metrics-grid">
        ${renderMetricCard("Completeness", `${(decomposition.completeness * 100).toFixed(0)}%`, renderProgressBar(decomposition.completeness * 100))}
        ${renderMetricCard("Rigor Level", decomposition.rigorLevel)}
        ${renderMetricCard("Atom Count", decomposition.atomCount.toString())}
        ${renderMetricCard("Max Depth", decomposition.maxDependencyDepth.toString())}
      </div>
    `;
    html += renderSection("Metrics", metricsHTML);
  }
  const axioms = decomposition.atoms.filter((a) => a.type === "axiom");
  if (axioms.length > 0) {
    const axiomsRows = axioms.map((atom) => [
      atom.id,
      includeLabels ? atom.statement : atom.id,
      atom.type
    ]);
    html += renderSection("Axioms", renderTable(["ID", "Statement", "Type"], axiomsRows), "success");
  }
  const hypotheses = decomposition.atoms.filter((a) => a.type === "hypothesis");
  if (hypotheses.length > 0) {
    const hypothesesRows = hypotheses.map((atom) => [
      atom.id,
      includeLabels ? atom.statement : atom.id,
      atom.type
    ]);
    html += renderSection("Hypotheses", renderTable(["ID", "Statement", "Type"], hypothesesRows), "info");
  }
  const derived = decomposition.atoms.filter((a) => a.type === "derived" || a.type === "lemma");
  if (derived.length > 0) {
    const derivedRows = derived.map((atom) => {
      const deps = atom.derivedFrom && atom.derivedFrom.length > 0 ? atom.derivedFrom.join(", ") : "None";
      const rule = atom.usedInferenceRule ? atom.usedInferenceRule : "N/A";
      return [
        atom.id,
        includeLabels ? atom.statement : atom.id,
        atom.type,
        deps,
        rule
      ];
    });
    html += renderSection(
      "Derivation Chain",
      renderTable(["ID", "Statement", "Type", "Derived From", "Inference Rule"], derivedRows)
    );
  }
  const conclusions = decomposition.atoms.filter((a) => a.type === "conclusion");
  if (conclusions.length > 0) {
    const conclusionsRows = conclusions.map((atom) => {
      const deps = atom.derivedFrom && atom.derivedFrom.length > 0 ? atom.derivedFrom.join(", ") : "None";
      return [
        atom.id,
        includeLabels ? atom.statement : atom.id,
        atom.type,
        deps
      ];
    });
    html += renderSection("Conclusions", renderTable(["ID", "Statement", "Type", "Derived From"], conclusionsRows), "primary");
  }
  if (decomposition.dependencies && decomposition.dependencies.edges && decomposition.dependencies.edges.length > 0) {
    const depsRows = decomposition.dependencies.edges.map((edge) => [
      edge.from,
      edge.to,
      edge.inferenceRule ? edge.inferenceRule : "Direct"
    ]);
    html += renderSection("Dependencies", renderTable(["From", "To", "Inference Rule"], depsRows));
  }
  if (decomposition.gaps && decomposition.gaps.length > 0) {
    const gapsRows = decomposition.gaps.map((gap) => [
      gap.id,
      gap.type,
      gap.severity,
      gap.description,
      `${gap.location.from} \u2192 ${gap.location.to}`,
      gap.suggestedFix ? gap.suggestedFix : "N/A"
    ]);
    html += renderSection("Gaps (Missing Steps)", renderTable(["ID", "Type", "Severity", "Description", "Location", "Suggested Fix"], gapsRows), "danger");
  }
  if (decomposition.implicitAssumptions && decomposition.implicitAssumptions.length > 0) {
    const assumptionsRows = decomposition.implicitAssumptions.map((assumption) => [
      assumption.type,
      assumption.statement,
      assumption.shouldBeExplicit ? "Yes" : "No",
      assumption.suggestedFormulation
    ]);
    html += renderSection("Implicit Assumptions", renderTable(["Type", "Statement", "Should Be Explicit", "Suggested Formulation"], assumptionsRows), "warning");
  }
  html += generateHTMLFooter(true);
  return html;
}
function proofDecompositionToModelica(decomposition, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const packageName = "ProofDecomposition";
  let modelica = `package ${packageName}
`;
  modelica += `  "Proof decomposition structure for: ${escapeModelicaString(decomposition.theorem || "theorem")}"

`;
  if (decomposition.theorem) {
    modelica += `  record Theorem "Main theorem being proved"
`;
    modelica += `    String statement = "${escapeModelicaString(decomposition.theorem)}";
`;
    modelica += `    Real completeness = ${decomposition.completeness};
`;
    modelica += `    String rigorLevel = "${escapeModelicaString(decomposition.rigorLevel)}";
`;
    modelica += `    Integer atomCount = ${decomposition.atomCount};
`;
    modelica += `    Integer maxDepth = ${decomposition.maxDependencyDepth};
`;
    modelica += `  end Theorem;

`;
  }
  modelica += `  record AtomicStatement "Individual statement in the proof"
`;
  modelica += `    String id "Unique identifier";
`;
  modelica += `    String statementType "Type: axiom, hypothesis, derived, lemma, conclusion, definition";
`;
  modelica += `    String statement "The mathematical statement";
`;
  modelica += `  end AtomicStatement;

`;
  const axioms = decomposition.atoms.filter((a) => a.type === "axiom");
  const hypotheses = decomposition.atoms.filter((a) => a.type === "hypothesis");
  const lemmas = decomposition.atoms.filter((a) => a.type === "lemma");
  const derived = decomposition.atoms.filter((a) => a.type === "derived");
  const conclusions = decomposition.atoms.filter((a) => a.type === "conclusion");
  if (axioms.length > 0) {
    modelica += `  // Axioms (${axioms.length})
`;
    for (const atom of axioms) {
      const atomId = sanitizeModelicaId(atom.id);
      const statement = includeLabels ? escapeModelicaString(atom.statement) : atom.id;
      modelica += `  AtomicStatement ${atomId}(
`;
      modelica += `    id="${escapeModelicaString(atom.id)}",
`;
      modelica += `    statementType="${atom.type}",
`;
      modelica += `    statement="${statement}"
`;
      modelica += `  );
`;
    }
    modelica += "\n";
  }
  if (hypotheses.length > 0) {
    modelica += `  // Hypotheses (${hypotheses.length})
`;
    for (const atom of hypotheses) {
      const atomId = sanitizeModelicaId(atom.id);
      const statement = includeLabels ? escapeModelicaString(atom.statement) : atom.id;
      modelica += `  AtomicStatement ${atomId}(
`;
      modelica += `    id="${escapeModelicaString(atom.id)}",
`;
      modelica += `    statementType="${atom.type}",
`;
      modelica += `    statement="${statement}"
`;
      modelica += `  );
`;
    }
    modelica += "\n";
  }
  if (lemmas.length > 0) {
    modelica += `  // Lemmas (${lemmas.length})
`;
    for (const atom of lemmas) {
      const atomId = sanitizeModelicaId(atom.id);
      const statement = includeLabels ? escapeModelicaString(atom.statement) : atom.id;
      modelica += `  AtomicStatement ${atomId}(
`;
      modelica += `    id="${escapeModelicaString(atom.id)}",
`;
      modelica += `    statementType="${atom.type}",
`;
      modelica += `    statement="${statement}"
`;
      modelica += `  );
`;
    }
    modelica += "\n";
  }
  if (derived.length > 0) {
    modelica += `  // Derived Statements (${derived.length})
`;
    for (const atom of derived) {
      const atomId = sanitizeModelicaId(atom.id);
      const statement = includeLabels ? escapeModelicaString(atom.statement) : atom.id;
      modelica += `  AtomicStatement ${atomId}(
`;
      modelica += `    id="${escapeModelicaString(atom.id)}",
`;
      modelica += `    statementType="${atom.type}",
`;
      modelica += `    statement="${statement}"
`;
      modelica += `  );
`;
    }
    modelica += "\n";
  }
  if (conclusions.length > 0) {
    modelica += `  // Conclusions (${conclusions.length})
`;
    for (const atom of conclusions) {
      const atomId = sanitizeModelicaId(atom.id);
      const statement = includeLabels ? escapeModelicaString(atom.statement) : atom.id;
      modelica += `  AtomicStatement ${atomId}(
`;
      modelica += `    id="${escapeModelicaString(atom.id)}",
`;
      modelica += `    statementType="${atom.type}",
`;
      modelica += `    statement="${statement}"
`;
      modelica += `  );
`;
    }
    modelica += "\n";
  }
  if (decomposition.dependencies && decomposition.dependencies.edges && decomposition.dependencies.edges.length > 0) {
    modelica += `  // Dependencies (${decomposition.dependencies.edges.length} edges)
`;
    modelica += `  /* Proof structure:
`;
    for (const edge of decomposition.dependencies.edges) {
      const rule = edge.inferenceRule ? ` [${edge.inferenceRule}]` : "";
      modelica += `   * ${edge.from} -> ${edge.to}${rule}
`;
    }
    modelica += `   */

`;
  }
  if (decomposition.gaps && decomposition.gaps.length > 0) {
    modelica += `  // Identified Gaps (${decomposition.gaps.length})
`;
    modelica += `  /* Gaps in proof:
`;
    for (const gap of decomposition.gaps) {
      modelica += `   * [${gap.severity}] ${gap.type}: ${gap.description}
`;
      modelica += `   *   Location: ${gap.location.from} -> ${gap.location.to}
`;
      if (gap.suggestedFix) {
        modelica += `   *   Fix: ${gap.suggestedFix}
`;
      }
    }
    modelica += `   */

`;
  }
  if (includeMetrics) {
    modelica += `  annotation(
`;
    modelica += `    Documentation(info="<html>
`;
    modelica += `      <h3>Proof Metrics</h3>
`;
    modelica += `      <ul>
`;
    modelica += `        <li>Completeness: ${(decomposition.completeness * 100).toFixed(0)}%</li>
`;
    modelica += `        <li>Rigor Level: ${decomposition.rigorLevel}</li>
`;
    modelica += `        <li>Atom Count: ${decomposition.atomCount}</li>
`;
    modelica += `        <li>Max Dependency Depth: ${decomposition.maxDependencyDepth}</li>
`;
    modelica += `      </ul>
`;
    modelica += `    </html>")
`;
    modelica += `  );
`;
  }
  modelica += `end ${packageName};
`;
  return modelica;
}
function proofDecompositionToUML(decomposition, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  for (const atom of decomposition.atoms) {
    const label = includeLabels ? atom.statement.substring(0, 40) + (atom.statement.length > 40 ? "..." : "") : atom.id;
    let stereotype = "";
    switch (atom.type) {
      case "axiom":
        stereotype = "\xABaxiom\xBB";
        break;
      case "hypothesis":
        stereotype = "\xABhypothesis\xBB";
        break;
      case "lemma":
        stereotype = "\xABlemma\xBB";
        break;
      case "conclusion":
        stereotype = "\xABconclusion\xBB";
        break;
      case "definition":
        stereotype = "\xABdefinition\xBB";
        break;
      default:
        stereotype = "\xABderived\xBB";
    }
    nodes.push({
      id: atom.id,
      label: `${stereotype}\\n${label}`,
      shape: "class",
      // Use class notation
      stereotype: atom.type
    });
  }
  if (decomposition.dependencies && decomposition.dependencies.edges) {
    for (const edge of decomposition.dependencies.edges) {
      edges.push({
        source: edge.from,
        target: edge.to,
        label: edge.inferenceRule || "derives",
        type: "dependency"
        // UML dependency arrow
      });
    }
  }
  if (decomposition.gaps && decomposition.gaps.length > 0) {
    for (const gap of decomposition.gaps) {
      edges.push({
        source: gap.location.from,
        target: gap.location.to,
        label: `GAP: ${gap.description.substring(0, 20)}`,
        type: "dashed"
      });
    }
  }
  let uml = generateUmlDiagram(nodes, edges, {
    title: `Proof Structure: ${decomposition.theorem?.substring(0, 50) || "Proof Decomposition"}`,
    direction: "top to bottom"
  });
  if (includeMetrics) {
    uml += "\n\nnote right of diagram\n";
    uml += "  **Proof Metrics**\n";
    uml += `  Completeness: ${(decomposition.completeness * 100).toFixed(0)}%
`;
    uml += `  Rigor: ${decomposition.rigorLevel}
`;
    uml += `  Atoms: ${decomposition.atomCount}
`;
    uml += `  Depth: ${decomposition.maxDependencyDepth}
`;
    uml += "end note\n";
  }
  uml += "\nlegend right\n";
  uml += "  |= Type |= Symbol |\n";
  uml += "  | Axiom | \xABaxiom\xBB |\n";
  uml += "  | Hypothesis | \xABhypothesis\xBB |\n";
  uml += "  | Lemma | \xABlemma\xBB |\n";
  uml += "  | Derived | \xABderived\xBB |\n";
  uml += "  | Conclusion | \xABconclusion\xBB |\n";
  uml += "endlegend\n";
  return uml;
}
function proofDecompositionToJSON(decomposition, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const graph = createJsonGraph(
    decomposition.theorem?.substring(0, 50) || "Proof Decomposition",
    "mathematics",
    { includeMetrics, includeLayout: true }
  );
  if (decomposition.theorem) {
    graph.metadata.theorem = decomposition.theorem;
    graph.metadata.completeness = decomposition.completeness;
    graph.metadata.rigorLevel = decomposition.rigorLevel;
    graph.metadata.atomCount = decomposition.atomCount;
    graph.metadata.maxDependencyDepth = decomposition.maxDependencyDepth;
  }
  for (const atom of decomposition.atoms) {
    const label = includeLabels ? atom.statement : atom.id;
    addNode(graph, {
      id: atom.id,
      label,
      type: atom.type,
      shape: atom.type === "conclusion" ? "diamond" : atom.type === "axiom" ? "stadium" : "rectangle",
      metadata: {
        statement: atom.statement,
        derivedFrom: atom.derivedFrom || [],
        usedInferenceRule: atom.usedInferenceRule || null
      }
    });
  }
  if (decomposition.dependencies && decomposition.dependencies.edges) {
    let edgeId = 0;
    for (const edge of decomposition.dependencies.edges) {
      addEdge(graph, {
        id: `edge_${edgeId++}`,
        source: edge.from,
        target: edge.to,
        label: edge.inferenceRule,
        type: "inference",
        directed: true,
        style: "solid"
      });
    }
  }
  if (decomposition.gaps && decomposition.gaps.length > 0) {
    let gapId = 0;
    for (const gap of decomposition.gaps) {
      addEdge(graph, {
        id: `gap_${gapId++}`,
        source: gap.location.from,
        target: gap.location.to,
        label: `GAP: ${gap.description.substring(0, 30)}`,
        type: "gap",
        directed: true,
        style: "dashed",
        metadata: {
          gapType: gap.type,
          severity: gap.severity,
          description: gap.description,
          suggestedFix: gap.suggestedFix || null
        }
      });
    }
  }
  if (includeMetrics) {
    addMetric(graph, "completeness", decomposition.completeness);
    addMetric(graph, "rigorLevel", decomposition.rigorLevel);
    addMetric(graph, "atomCount", decomposition.atomCount);
    addMetric(graph, "maxDependencyDepth", decomposition.maxDependencyDepth);
  }
  if (decomposition.implicitAssumptions && decomposition.implicitAssumptions.length > 0) {
    graph.metadata.implicitAssumptions = decomposition.implicitAssumptions.map((assumption) => ({
      type: assumption.type,
      statement: assumption.statement,
      shouldBeExplicit: assumption.shouldBeExplicit || false,
      suggestedFormulation: assumption.suggestedFormulation || null
    }));
  }
  if (decomposition.gaps && decomposition.gaps.length > 0) {
    graph.metadata.gaps = decomposition.gaps.map((gap) => ({
      id: gap.id,
      type: gap.type,
      severity: gap.severity,
      description: gap.description,
      location: gap.location,
      suggestedFix: gap.suggestedFix || null
    }));
  }
  return serializeGraph(graph, { prettyPrint: true });
}
function proofDecompositionToMarkdown(decomposition, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  if (decomposition.theorem) {
    parts.push(section("Theorem", decomposition.theorem));
  }
  if (includeMetrics) {
    const metricsContent = keyValueSection({
      "Completeness": `${(decomposition.completeness * 100).toFixed(0)}%`,
      "Rigor Level": decomposition.rigorLevel,
      "Atom Count": decomposition.atomCount,
      "Max Dependency Depth": decomposition.maxDependencyDepth
    });
    let metricsFull = metricsContent;
    metricsFull += "\n\n**Completeness:**\n\n" + progressBar(decomposition.completeness * 100);
    parts.push(section("Metrics", metricsFull));
  }
  const axioms = decomposition.atoms.filter((a) => a.type === "axiom");
  if (axioms.length > 0) {
    const axiomRows = axioms.map((atom) => [
      atom.id,
      atom.statement.substring(0, 100) + (atom.statement.length > 100 ? "..." : "")
    ]);
    parts.push(section("Axioms", table(["ID", "Statement"], axiomRows)));
  }
  const hypotheses = decomposition.atoms.filter((a) => a.type === "hypothesis");
  if (hypotheses.length > 0) {
    const hypothesesRows = hypotheses.map((atom) => [
      atom.id,
      atom.statement.substring(0, 100) + (atom.statement.length > 100 ? "..." : "")
    ]);
    parts.push(section("Hypotheses", table(["ID", "Statement"], hypothesesRows)));
  }
  const definitions = decomposition.atoms.filter((a) => a.type === "definition");
  if (definitions.length > 0) {
    const definitionsRows = definitions.map((atom) => [
      atom.id,
      atom.statement.substring(0, 100) + (atom.statement.length > 100 ? "..." : "")
    ]);
    parts.push(section("Definitions", table(["ID", "Statement"], definitionsRows)));
  }
  const lemmas = decomposition.atoms.filter((a) => a.type === "lemma");
  if (lemmas.length > 0) {
    const lemmasRows = lemmas.map((atom) => [
      atom.id,
      atom.statement.substring(0, 80) + (atom.statement.length > 80 ? "..." : ""),
      atom.derivedFrom ? atom.derivedFrom.join(", ") : "-",
      atom.usedInferenceRule || "-"
    ]);
    parts.push(section("Lemmas", table(["ID", "Statement", "Derived From", "Rule"], lemmasRows)));
  }
  const derived = decomposition.atoms.filter((a) => a.type === "derived");
  if (derived.length > 0) {
    const derivedRows = derived.map((atom) => [
      atom.id,
      atom.statement.substring(0, 80) + (atom.statement.length > 80 ? "..." : ""),
      atom.derivedFrom ? atom.derivedFrom.join(", ") : "-",
      atom.usedInferenceRule || "-"
    ]);
    parts.push(section("Derived Statements", table(["ID", "Statement", "Derived From", "Rule"], derivedRows)));
  }
  const conclusions = decomposition.atoms.filter((a) => a.type === "conclusion");
  if (conclusions.length > 0) {
    const conclusionsRows = conclusions.map((atom) => [
      atom.id,
      atom.statement.substring(0, 100) + (atom.statement.length > 100 ? "..." : ""),
      atom.derivedFrom ? atom.derivedFrom.join(", ") : "-"
    ]);
    parts.push(section("Conclusions", table(["ID", "Statement", "Derived From"], conclusionsRows)));
  }
  if (decomposition.dependencies && decomposition.dependencies.edges && decomposition.dependencies.edges.length > 0) {
    const depsRows = decomposition.dependencies.edges.map((edge) => [
      edge.from,
      edge.to,
      edge.inferenceRule || "Direct"
    ]);
    parts.push(section("Dependencies", table(["From", "To", "Inference Rule"], depsRows)));
  }
  if (decomposition.gaps && decomposition.gaps.length > 0) {
    const gapsRows = decomposition.gaps.map((gap) => [
      gap.id,
      gap.type,
      gap.severity,
      gap.description.substring(0, 60) + (gap.description.length > 60 ? "..." : ""),
      `${gap.location.from} \u2192 ${gap.location.to}`,
      gap.suggestedFix ? gap.suggestedFix.substring(0, 40) : "-"
    ]);
    parts.push(section("Identified Gaps", table(
      ["ID", "Type", "Severity", "Description", "Location", "Suggested Fix"],
      gapsRows
    )));
  }
  if (decomposition.implicitAssumptions && decomposition.implicitAssumptions.length > 0) {
    const assumptionsRows = decomposition.implicitAssumptions.map((assumption) => [
      assumption.type,
      assumption.statement.substring(0, 80) + (assumption.statement.length > 80 ? "..." : ""),
      assumption.shouldBeExplicit ? "Yes" : "No",
      assumption.suggestedFormulation ? assumption.suggestedFormulation.substring(0, 50) : "-"
    ]);
    parts.push(section("Implicit Assumptions", table(
      ["Type", "Statement", "Should Be Explicit", "Suggested Formulation"],
      assumptionsRows
    )));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = proofDecompositionToMermaid(decomposition, "default", true, true);
    parts.push(section("Proof Structure Diagram", mermaidBlock(mermaidDiagram)));
  }
  return document("Proof Decomposition Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "proof-decomposition",
      completeness: decomposition.completeness,
      rigorLevel: decomposition.rigorLevel,
      atomCount: decomposition.atomCount
    }
  });
}
var init_proof_decomposition = __esm({
  "src/export/visual/proof-decomposition.ts"() {
    init_esm_shims();
    init_utils();
    init_html_utils();
    init_modelica_utils();
    init_uml_utils();
    init_json_utils();
    init_markdown_utils();
  }
});

// src/export/visual/engineering.ts
function exportEngineeringAnalysis(thought, options) {
  const { format } = options;
  switch (format) {
    case "mermaid":
      return engineeringToMermaid(thought, options);
    case "dot":
      return engineeringToDOT(thought, options);
    case "ascii":
      return engineeringToASCII(thought);
    case "svg":
      return engineeringToSVG(thought, options);
    case "graphml":
      return engineeringToGraphML(thought, options);
    case "tikz":
      return engineeringToTikZ(thought, options);
    case "modelica":
      return engineeringToModelica(thought, options);
    case "html":
      return engineeringToHTML(thought, options);
    case "uml":
      return engineeringToUML(thought, options);
    case "json":
      return engineeringToJSON(thought, options);
    case "markdown":
      return engineeringToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function engineeringToMermaid(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const lines = ["flowchart TB"];
  lines.push(`  title["\u{1F527} ${thought.analysisType.toUpperCase()} Analysis"]`);
  lines.push(`  title --> challenge["${thought.designChallenge.slice(0, 50)}${thought.designChallenge.length > 50 ? "..." : ""}"]`);
  if (thought.requirements && thought.requirements.requirements.length > 0) {
    lines.push("");
    lines.push('  subgraph Requirements ["\u{1F4CB} Requirements"]');
    for (const req of thought.requirements.requirements.slice(0, 5)) {
      const label = includeLabels ? req.title.slice(0, 30) : req.id;
      const status = req.status === "verified" ? "\u2713" : req.status === "implemented" ? "\u2699" : "\u25CB";
      lines.push(`    ${sanitizeId(req.id)}["${status} ${label}"]`);
    }
    if (thought.requirements.requirements.length > 5) {
      lines.push(`    reqMore["... +${thought.requirements.requirements.length - 5} more"]`);
    }
    lines.push("  end");
    lines.push("  challenge --> Requirements");
  }
  if (thought.tradeStudy) {
    lines.push("");
    lines.push('  subgraph TradeStudy ["\u2696\uFE0F Trade Study"]');
    for (const alt of thought.tradeStudy.alternatives.slice(0, 4)) {
      const isRecommended = alt.id === thought.tradeStudy.recommendation;
      const icon = isRecommended ? "\u2605" : "\u25CB";
      const label = includeLabels ? alt.name.slice(0, 25) : alt.id;
      lines.push(`    ${sanitizeId(alt.id)}["${icon} ${label}"]`);
    }
    if (thought.tradeStudy.alternatives.length > 4) {
      lines.push(`    altMore["... +${thought.tradeStudy.alternatives.length - 4} more"]`);
    }
    lines.push("  end");
    lines.push("  challenge --> TradeStudy");
  }
  if (thought.fmea && thought.fmea.failureModes.length > 0) {
    lines.push("");
    lines.push('  subgraph FMEA ["\u26A0\uFE0F Failure Modes"]');
    const sortedModes = [...thought.fmea.failureModes].sort((a, b) => b.rpn - a.rpn);
    for (const fm of sortedModes.slice(0, 4)) {
      const risk = fm.rpn >= thought.fmea.rpnThreshold ? "\u{1F534}" : fm.rpn >= 100 ? "\u{1F7E1}" : "\u{1F7E2}";
      const label = includeMetrics ? `${fm.failureMode.slice(0, 20)} (RPN:${fm.rpn})` : fm.failureMode.slice(0, 25);
      lines.push(`    ${sanitizeId(fm.id)}{{"${risk} ${label}"}}`);
    }
    if (thought.fmea.failureModes.length > 4) {
      lines.push(`    fmMore["... +${thought.fmea.failureModes.length - 4} more"]`);
    }
    lines.push("  end");
    lines.push("  challenge --> FMEA");
  }
  if (thought.designDecisions && thought.designDecisions.decisions.length > 0) {
    lines.push("");
    lines.push('  subgraph Decisions ["\u{1F4DD} Design Decisions"]');
    for (const dec of thought.designDecisions.decisions.slice(0, 4)) {
      const status = dec.status === "accepted" ? "\u2713" : dec.status === "proposed" ? "?" : "\u2717";
      const label = includeLabels ? dec.title.slice(0, 25) : dec.id;
      lines.push(`    ${sanitizeId(dec.id)}(["${status} ${label}"])`);
    }
    if (thought.designDecisions.decisions.length > 4) {
      lines.push(`    decMore["... +${thought.designDecisions.decisions.length - 4} more"]`);
    }
    lines.push("  end");
    lines.push("  challenge --> Decisions");
  }
  if (includeMetrics && thought.assessment) {
    lines.push("");
    lines.push(`  metrics["\u{1F4CA} Confidence: ${(thought.assessment.confidence * 100).toFixed(0)}%"]`);
    lines.push("  challenge --> metrics");
  }
  return lines.join("\n");
}
function engineeringToDOT(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const lines = [
    "digraph EngineeringAnalysis {",
    "  rankdir=TB;",
    '  node [fontname="Arial", fontsize=10];',
    '  edge [fontname="Arial", fontsize=9];',
    ""
  ];
  lines.push(`  challenge [label="${thought.designChallenge.slice(0, 40)}", shape=box, style=filled, fillcolor=lightblue];`);
  if (thought.requirements && thought.requirements.requirements.length > 0) {
    lines.push("");
    lines.push("  subgraph cluster_requirements {");
    lines.push('    label="Requirements";');
    lines.push("    style=filled;");
    lines.push("    fillcolor=lightyellow;");
    for (const req of thought.requirements.requirements) {
      const label = includeLabels ? `${req.id}\\n${req.title.slice(0, 20)}` : req.id;
      const color = req.status === "verified" ? "green" : req.status === "implemented" ? "blue" : "gray";
      lines.push(`    ${sanitizeId(req.id)} [label="${label}", color=${color}];`);
    }
    lines.push("  }");
    lines.push("  challenge -> " + sanitizeId(thought.requirements.requirements[0]?.id || "req") + ";");
  }
  if (thought.tradeStudy) {
    lines.push("");
    lines.push("  subgraph cluster_trade {");
    lines.push('    label="Trade Study";');
    lines.push("    style=filled;");
    lines.push("    fillcolor=lightgreen;");
    for (const alt of thought.tradeStudy.alternatives) {
      const label = includeLabels ? `${alt.id}\\n${alt.name.slice(0, 20)}` : alt.id;
      const style = alt.id === thought.tradeStudy.recommendation ? "bold" : "solid";
      const color = alt.id === thought.tradeStudy.recommendation ? "gold" : "white";
      lines.push(`    ${sanitizeId(alt.id)} [label="${label}", style="${style},filled", fillcolor=${color}];`);
    }
    lines.push("  }");
    lines.push("  challenge -> " + sanitizeId(thought.tradeStudy.alternatives[0]?.id || "alt") + ";");
  }
  if (thought.fmea && thought.fmea.failureModes.length > 0) {
    lines.push("");
    lines.push("  subgraph cluster_fmea {");
    lines.push('    label="FMEA";');
    lines.push("    style=filled;");
    lines.push("    fillcolor=mistyrose;");
    for (const fm of thought.fmea.failureModes) {
      const label = includeMetrics ? `${fm.id}\\n${fm.failureMode.slice(0, 15)}\\nRPN:${fm.rpn}` : `${fm.id}\\n${fm.failureMode.slice(0, 20)}`;
      const color = fm.rpn >= thought.fmea.rpnThreshold ? "red" : fm.rpn >= 100 ? "orange" : "green";
      lines.push(`    ${sanitizeId(fm.id)} [label="${label}", shape=diamond, color=${color}];`);
    }
    lines.push("  }");
    lines.push("  challenge -> " + sanitizeId(thought.fmea.failureModes[0]?.id || "fm") + ";");
  }
  if (thought.designDecisions && thought.designDecisions.decisions.length > 0) {
    lines.push("");
    lines.push("  subgraph cluster_decisions {");
    lines.push('    label="Design Decisions";');
    lines.push("    style=filled;");
    lines.push("    fillcolor=lavender;");
    for (const dec of thought.designDecisions.decisions) {
      const label = includeLabels ? `${dec.id}\\n${dec.title.slice(0, 20)}` : dec.id;
      const shape = dec.status === "accepted" ? "box" : "ellipse";
      lines.push(`    ${sanitizeId(dec.id)} [label="${label}", shape=${shape}];`);
    }
    lines.push("  }");
    lines.push("  challenge -> " + sanitizeId(thought.designDecisions.decisions[0]?.id || "dec") + ";");
  }
  lines.push("}");
  return lines.join("\n");
}
function engineeringToASCII(thought) {
  const lines = [];
  const width = 60;
  lines.push("\u2554" + "\u2550".repeat(width - 2) + "\u2557");
  lines.push("\u2551" + ` \u{1F527} ENGINEERING: ${thought.analysisType.toUpperCase()} `.padEnd(width - 2) + "\u2551");
  lines.push("\u2560" + "\u2550".repeat(width - 2) + "\u2563");
  lines.push("\u2551" + ` Challenge: ${thought.designChallenge.slice(0, width - 14)}`.padEnd(width - 2) + "\u2551");
  lines.push("\u2560" + "\u2500".repeat(width - 2) + "\u2563");
  if (thought.requirements && thought.requirements.requirements.length > 0) {
    lines.push("\u2551" + " \u{1F4CB} REQUIREMENTS".padEnd(width - 2) + "\u2551");
    lines.push("\u2551" + "\u2500".repeat(width - 2) + "\u2551");
    for (const req of thought.requirements.requirements.slice(0, 5)) {
      const status = req.status === "verified" ? "[\u2713]" : req.status === "implemented" ? "[\u2699]" : "[ ]";
      const line = ` ${status} ${req.id}: ${req.title.slice(0, width - 20)}`;
      lines.push("\u2551" + line.padEnd(width - 2) + "\u2551");
    }
    if (thought.requirements.requirements.length > 5) {
      lines.push("\u2551" + `   ... +${thought.requirements.requirements.length - 5} more`.padEnd(width - 2) + "\u2551");
    }
    lines.push("\u2551" + `   Coverage: ${thought.requirements.coverage.verified}/${thought.requirements.coverage.total} verified`.padEnd(width - 2) + "\u2551");
    lines.push("\u2560" + "\u2500".repeat(width - 2) + "\u2563");
  }
  if (thought.tradeStudy) {
    lines.push("\u2551" + " \u2696\uFE0F TRADE STUDY".padEnd(width - 2) + "\u2551");
    lines.push("\u2551" + "\u2500".repeat(width - 2) + "\u2551");
    for (const alt of thought.tradeStudy.alternatives) {
      const isRec = alt.id === thought.tradeStudy.recommendation;
      const marker = isRec ? "\u2605" : "\u25CB";
      const line = ` ${marker} ${alt.name.slice(0, width - 8)}`;
      lines.push("\u2551" + line.padEnd(width - 2) + "\u2551");
    }
    lines.push("\u2551" + `   Recommended: ${thought.tradeStudy.recommendation}`.padEnd(width - 2) + "\u2551");
    lines.push("\u2560" + "\u2500".repeat(width - 2) + "\u2563");
  }
  if (thought.fmea && thought.fmea.failureModes.length > 0) {
    lines.push("\u2551" + " \u26A0\uFE0F FAILURE MODES (FMEA)".padEnd(width - 2) + "\u2551");
    lines.push("\u2551" + "\u2500".repeat(width - 2) + "\u2551");
    const sortedModes = [...thought.fmea.failureModes].sort((a, b) => b.rpn - a.rpn);
    for (const fm of sortedModes.slice(0, 5)) {
      const risk = fm.rpn >= thought.fmea.rpnThreshold ? "\u{1F534}" : fm.rpn >= 100 ? "\u{1F7E1}" : "\u{1F7E2}";
      const line = ` ${risk} ${fm.failureMode.slice(0, width - 25)} RPN:${fm.rpn}`;
      lines.push("\u2551" + line.padEnd(width - 2) + "\u2551");
    }
    if (thought.fmea.failureModes.length > 5) {
      lines.push("\u2551" + `   ... +${thought.fmea.failureModes.length - 5} more`.padEnd(width - 2) + "\u2551");
    }
    lines.push("\u2551" + `   Critical: ${thought.fmea.summary.criticalModes} modes above threshold`.padEnd(width - 2) + "\u2551");
    lines.push("\u2560" + "\u2500".repeat(width - 2) + "\u2563");
  }
  if (thought.designDecisions && thought.designDecisions.decisions.length > 0) {
    lines.push("\u2551" + " \u{1F4DD} DESIGN DECISIONS".padEnd(width - 2) + "\u2551");
    lines.push("\u2551" + "\u2500".repeat(width - 2) + "\u2551");
    for (const dec of thought.designDecisions.decisions.slice(0, 5)) {
      const status = dec.status === "accepted" ? "[\u2713]" : dec.status === "proposed" ? "[?]" : "[\u2717]";
      const line = ` ${status} ${dec.id}: ${dec.title.slice(0, width - 20)}`;
      lines.push("\u2551" + line.padEnd(width - 2) + "\u2551");
    }
    if (thought.designDecisions.decisions.length > 5) {
      lines.push("\u2551" + `   ... +${thought.designDecisions.decisions.length - 5} more`.padEnd(width - 2) + "\u2551");
    }
    lines.push("\u2560" + "\u2500".repeat(width - 2) + "\u2563");
  }
  if (thought.assessment) {
    lines.push("\u2551" + " \u{1F4CA} ASSESSMENT".padEnd(width - 2) + "\u2551");
    lines.push("\u2551" + `   Confidence: ${(thought.assessment.confidence * 100).toFixed(0)}%`.padEnd(width - 2) + "\u2551");
    if (thought.assessment.keyRisks.length > 0) {
      lines.push("\u2551" + `   Key Risks: ${thought.assessment.keyRisks.length}`.padEnd(width - 2) + "\u2551");
    }
    if (thought.assessment.openIssues.length > 0) {
      lines.push("\u2551" + `   Open Issues: ${thought.assessment.openIssues.length}`.padEnd(width - 2) + "\u2551");
    }
  }
  lines.push("\u255A" + "\u2550".repeat(width - 2) + "\u255D");
  return lines.join("\n");
}
function engineeringToSVG(thought, options) {
  const { colorScheme = "default", includeLabels = true, includeMetrics = true } = options;
  const svgOptions = { ...DEFAULT_SVG_OPTIONS, ...options };
  const nodePositions = /* @__PURE__ */ new Map();
  let currentY = 60;
  const centerX = (svgOptions.svgWidth || 800) / 2;
  const challengePos = {
    id: "challenge",
    label: thought.designChallenge.slice(0, 40),
    x: centerX - 100,
    y: currentY,
    width: 200,
    height: 40,
    type: "primary"
  };
  nodePositions.set("challenge", challengePos);
  currentY += 80;
  const sections = [];
  if (thought.requirements && thought.requirements.requirements.length > 0) {
    const label = includeLabels ? `Requirements (${thought.requirements.requirements.length})` : "Reqs";
    sections.push({ id: "requirements", label, type: "info" });
  }
  if (thought.tradeStudy) {
    const label = includeLabels ? `Trade Study (${thought.tradeStudy.alternatives.length} alts)` : "Trade";
    sections.push({ id: "tradeStudy", label, type: "secondary" });
  }
  if (thought.fmea && thought.fmea.failureModes.length > 0) {
    const label = includeLabels ? `FMEA (${thought.fmea.failureModes.length} modes)` : "FMEA";
    sections.push({ id: "fmea", label, type: "danger" });
  }
  if (thought.designDecisions && thought.designDecisions.decisions.length > 0) {
    const label = includeLabels ? `Decisions (${thought.designDecisions.decisions.length})` : "Decisions";
    sections.push({ id: "decisions", label, type: "tertiary" });
  }
  const sectionWidth = 150;
  const totalWidth = sections.length * (sectionWidth + 20);
  let startX = centerX - totalWidth / 2;
  for (const section2 of sections) {
    const pos = {
      id: section2.id,
      label: section2.label,
      x: startX,
      y: currentY,
      width: sectionWidth,
      height: 40,
      type: section2.type
    };
    nodePositions.set(section2.id, pos);
    startX += sectionWidth + 20;
  }
  const svgHeight = currentY + 120;
  let svg = generateSVGHeader(svgOptions.svgWidth || 800, svgHeight, `Engineering: ${thought.analysisType}`);
  const challengeColors = getNodeColor("primary", colorScheme);
  svg += renderStadiumNode(challengePos, challengeColors);
  for (const section2 of sections) {
    const pos = nodePositions.get(section2.id);
    const colors = getNodeColor(section2.type, colorScheme);
    svg += renderRectNode(pos, colors, 5);
    svg += renderEdge(challengePos, pos, { color: "#666666" });
  }
  if (includeMetrics && thought.assessment) {
    const metrics = [
      { label: "Confidence", value: `${(thought.assessment.confidence * 100).toFixed(0)}%` },
      { label: "Key Risks", value: thought.assessment.keyRisks.length },
      { label: "Open Issues", value: thought.assessment.openIssues.length }
    ];
    svg += renderMetricsPanel((svgOptions.svgWidth || 800) - 150, 20, metrics);
  }
  svg += generateSVGFooter();
  return svg;
}
function engineeringToGraphML(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  let edgeId = 0;
  nodes.push({
    id: "challenge",
    label: includeLabels ? thought.designChallenge : "Challenge",
    type: "challenge",
    metadata: { analysisType: thought.analysisType }
  });
  if (thought.requirements) {
    for (const req of thought.requirements.requirements) {
      nodes.push({
        id: sanitizeId(req.id),
        label: includeLabels ? req.title : req.id,
        type: "requirement",
        metadata: {
          priority: req.priority,
          status: req.status,
          source: req.source
        }
      });
      edges.push({
        id: `e${edgeId++}`,
        source: "challenge",
        target: sanitizeId(req.id),
        label: "requires"
      });
      if (req.tracesTo) {
        for (const parentId of req.tracesTo) {
          edges.push({
            id: `e${edgeId++}`,
            source: sanitizeId(req.id),
            target: sanitizeId(parentId),
            label: "traces to"
          });
        }
      }
    }
  }
  if (thought.tradeStudy) {
    nodes.push({
      id: "tradeStudy",
      label: thought.tradeStudy.title,
      type: "trade-study"
    });
    edges.push({
      id: `e${edgeId++}`,
      source: "challenge",
      target: "tradeStudy"
    });
    for (const alt of thought.tradeStudy.alternatives) {
      const isRecommended = alt.id === thought.tradeStudy.recommendation;
      nodes.push({
        id: sanitizeId(alt.id),
        label: includeLabels ? alt.name : alt.id,
        type: isRecommended ? "recommended" : "alternative",
        metadata: {
          riskLevel: alt.riskLevel,
          estimatedCost: alt.estimatedCost
        }
      });
      edges.push({
        id: `e${edgeId++}`,
        source: "tradeStudy",
        target: sanitizeId(alt.id),
        label: isRecommended ? "recommended" : "alternative"
      });
    }
  }
  if (thought.fmea) {
    for (const fm of thought.fmea.failureModes) {
      nodes.push({
        id: sanitizeId(fm.id),
        label: includeLabels ? fm.failureMode : fm.id,
        type: fm.rpn >= thought.fmea.rpnThreshold ? "critical-failure" : "failure-mode",
        metadata: includeMetrics ? {
          severity: fm.severity,
          occurrence: fm.occurrence,
          detection: fm.detection,
          rpn: fm.rpn,
          component: fm.component
        } : void 0
      });
      edges.push({
        id: `e${edgeId++}`,
        source: "challenge",
        target: sanitizeId(fm.id),
        label: "failure mode",
        metadata: includeMetrics ? { weight: fm.rpn } : void 0
      });
    }
  }
  if (thought.designDecisions) {
    for (const dec of thought.designDecisions.decisions) {
      nodes.push({
        id: sanitizeId(dec.id),
        label: includeLabels ? dec.title : dec.id,
        type: `decision-${dec.status}`,
        metadata: {
          status: dec.status,
          context: dec.context
        }
      });
      edges.push({
        id: `e${edgeId++}`,
        source: "challenge",
        target: sanitizeId(dec.id),
        label: "decision"
      });
      if (dec.relatedDecisions) {
        for (const relId of dec.relatedDecisions) {
          edges.push({
            id: `e${edgeId++}`,
            source: sanitizeId(dec.id),
            target: sanitizeId(relId),
            label: "related to"
          });
        }
      }
    }
  }
  return generateGraphML(nodes, edges, { graphName: "Engineering Analysis", directed: true });
}
function engineeringToTikZ(thought, options) {
  const { includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  nodes.push({
    id: "challenge",
    label: thought.designChallenge.slice(0, 30),
    x: 4,
    y: 0,
    type: "primary",
    shape: "stadium"
  });
  let sectionX = 0;
  const sectionY = -2;
  if (thought.requirements && thought.requirements.requirements.length > 0) {
    nodes.push({
      id: "reqs",
      label: includeLabels ? `Reqs (${thought.requirements.requirements.length})` : "Requirements",
      x: sectionX,
      y: sectionY,
      type: "info",
      shape: "rectangle"
    });
    edges.push({ source: "challenge", target: "reqs", directed: true });
    sectionX += 2.5;
  }
  if (thought.tradeStudy) {
    nodes.push({
      id: "trade",
      label: includeLabels ? `Trade (${thought.tradeStudy.alternatives.length})` : "Trade Study",
      x: sectionX,
      y: sectionY,
      type: "secondary",
      shape: "rectangle"
    });
    edges.push({ source: "challenge", target: "trade", directed: true });
    sectionX += 2.5;
  }
  if (thought.fmea && thought.fmea.failureModes.length > 0) {
    const criticalCount = thought.fmea.summary.criticalModes;
    nodes.push({
      id: "fmea",
      label: includeMetrics ? `FMEA (${criticalCount} crit)` : "FMEA",
      x: sectionX,
      y: sectionY,
      type: "danger",
      shape: "diamond"
    });
    edges.push({ source: "challenge", target: "fmea", directed: true });
    sectionX += 2.5;
  }
  if (thought.designDecisions && thought.designDecisions.decisions.length > 0) {
    nodes.push({
      id: "decisions",
      label: includeLabels ? `Decisions (${thought.designDecisions.decisions.length})` : "Decisions",
      x: sectionX,
      y: sectionY,
      type: "tertiary",
      shape: "ellipse"
    });
    edges.push({ source: "challenge", target: "decisions", directed: true });
  }
  if (thought.assessment && includeMetrics) {
    nodes.push({
      id: "assessment",
      label: `${(thought.assessment.confidence * 100).toFixed(0)}% conf`,
      x: 4,
      y: -4,
      type: "success",
      shape: "ellipse"
    });
    edges.push({ source: "challenge", target: "assessment", style: "dashed", directed: true });
  }
  return generateTikZ(nodes, edges, { title: `Engineering: ${thought.analysisType}` });
}
function sanitizeModelicaId2(id) {
  let sanitized = id.replace(/[-\s]/g, "_");
  sanitized = sanitized.replace(/[^a-zA-Z0-9_]/g, "");
  if (!/^[a-zA-Z]/.test(sanitized)) {
    sanitized = "id_" + sanitized;
  }
  return sanitized;
}
function escapeModelicaString2(str) {
  return str.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
}
function engineeringToModelica(thought, options) {
  const { includeMetrics = true, modelicaPackageName, modelicaIncludeAnnotations = true } = options;
  const packageName = modelicaPackageName || sanitizeModelicaId2(thought.designChallenge.slice(0, 30)) || "EngineeringAnalysis";
  const lines = [];
  lines.push(`package ${packageName}`);
  lines.push(`  "Engineering Analysis: ${escapeModelicaString2(thought.designChallenge)}"`);
  lines.push("");
  if (thought.requirements && thought.requirements.requirements.length > 0) {
    lines.push("  // ==========================================================================");
    lines.push("  // Requirements Traceability");
    lines.push("  // ==========================================================================");
    lines.push("");
    lines.push("  record Requirements");
    lines.push(`    "Requirements traceability for ${escapeModelicaString2(thought.designChallenge)}"`);
    lines.push("");
    for (const req of thought.requirements.requirements) {
      const reqId = sanitizeModelicaId2(req.id);
      const priority = req.priority.toUpperCase();
      const status = req.status;
      lines.push(`    // ${req.id}: ${escapeModelicaString2(req.title)}`);
      lines.push(`    parameter Boolean ${reqId}_satisfied = ${status === "verified" || status === "implemented" ? "true" : "false"}`);
      if (modelicaIncludeAnnotations) {
        lines.push(`      annotation(Dialog(group="${priority}", tab="Requirements"),`);
        lines.push(`               Documentation(info="<html><p>${escapeModelicaString2(req.description)}</p></html>"));`);
      } else {
        lines.push("      ;");
      }
      lines.push("");
    }
    if (includeMetrics) {
      const cov = thought.requirements.coverage;
      lines.push(`    // Coverage Metrics`);
      lines.push(`    final parameter Integer totalRequirements = ${cov.total};`);
      lines.push(`    final parameter Integer verifiedRequirements = ${cov.verified};`);
      lines.push(`    final parameter Real coverageRatio = ${(cov.verified / Math.max(cov.total, 1)).toFixed(3)};`);
      lines.push("");
    }
    lines.push("  end Requirements;");
    lines.push("");
  }
  if (thought.tradeStudy) {
    lines.push("  // ==========================================================================");
    lines.push("  // Trade Study");
    lines.push("  // ==========================================================================");
    lines.push("");
    lines.push("  model TradeStudy");
    lines.push(`    "${escapeModelicaString2(thought.tradeStudy.title)}"`);
    lines.push("");
    const altIds = thought.tradeStudy.alternatives.map((a) => sanitizeModelicaId2(a.id));
    lines.push(`    type Alternative = enumeration(`);
    for (let i = 0; i < altIds.length; i++) {
      const alt = thought.tradeStudy.alternatives[i];
      const comma = i < altIds.length - 1 ? "," : "";
      lines.push(`      ${altIds[i]} "${escapeModelicaString2(alt.name)}"${comma}`);
    }
    lines.push("    );");
    lines.push("");
    const recId = sanitizeModelicaId2(thought.tradeStudy.recommendation);
    lines.push(`    parameter Alternative selectedAlternative = Alternative.${recId}`);
    lines.push(`      "Selected alternative based on trade study";`);
    lines.push("");
    lines.push("    // Criteria Weights (sum to 1.0)");
    for (const crit of thought.tradeStudy.criteria) {
      const critId = sanitizeModelicaId2(crit.id);
      lines.push(`    parameter Real weight_${critId} = ${crit.weight.toFixed(3)} "${escapeModelicaString2(crit.name)}";`);
    }
    lines.push("");
    lines.push("    // Scores for selected alternative");
    const recScores = thought.tradeStudy.scores.filter((s) => s.alternativeId === thought.tradeStudy.recommendation);
    for (const score of recScores) {
      const critId = sanitizeModelicaId2(score.criteriaId);
      lines.push(`    final parameter Real score_${critId} = ${score.score};`);
    }
    lines.push("");
    if (modelicaIncludeAnnotations) {
      lines.push('    annotation(Documentation(info="<html>');
      lines.push(`      <h3>Objective</h3><p>${escapeModelicaString2(thought.tradeStudy.objective)}</p>`);
      lines.push(`      <h3>Justification</h3><p>${escapeModelicaString2(thought.tradeStudy.justification)}</p>`);
      lines.push('    </html>"));');
    }
    lines.push("  end TradeStudy;");
    lines.push("");
  }
  if (thought.fmea && thought.fmea.failureModes.length > 0) {
    lines.push("  // ==========================================================================");
    lines.push("  // Failure Mode and Effects Analysis (FMEA)");
    lines.push("  // ==========================================================================");
    lines.push("");
    lines.push("  model FMEA");
    lines.push(`    "FMEA for ${escapeModelicaString2(thought.fmea.system)}"`);
    lines.push("");
    lines.push(`    parameter Integer rpnThreshold = ${thought.fmea.rpnThreshold} "Action required above this RPN";`);
    lines.push("");
    for (const fm of thought.fmea.failureModes) {
      const fmId = sanitizeModelicaId2(fm.id);
      const isCritical = fm.rpn >= thought.fmea.rpnThreshold;
      lines.push(`    // Failure Mode: ${fm.id}`);
      lines.push(`    record ${fmId}`);
      lines.push(`      "${escapeModelicaString2(fm.failureMode)}"`);
      lines.push(`      constant String component = "${escapeModelicaString2(fm.component)}";`);
      lines.push(`      constant String cause = "${escapeModelicaString2(fm.cause)}";`);
      lines.push(`      constant String effect = "${escapeModelicaString2(fm.effect)}";`);
      lines.push(`      constant Integer severity = ${fm.severity} "1-10 scale";`);
      lines.push(`      constant Integer occurrence = ${fm.occurrence} "1-10 scale";`);
      lines.push(`      constant Integer detection = ${fm.detection} "1-10 scale";`);
      lines.push(`      constant Integer rpn = ${fm.rpn} "Risk Priority Number";`);
      lines.push(`      constant Boolean isCritical = ${isCritical};`);
      if (fm.mitigation) {
        lines.push(`      constant String mitigation = "${escapeModelicaString2(fm.mitigation)}";`);
      }
      lines.push(`    end ${fmId};`);
      lines.push("");
    }
    if (includeMetrics) {
      const sum = thought.fmea.summary;
      lines.push("    // Summary Statistics");
      lines.push(`    final parameter Integer totalModes = ${sum.totalModes};`);
      lines.push(`    final parameter Integer criticalModes = ${sum.criticalModes};`);
      lines.push(`    final parameter Real averageRpn = ${sum.averageRpn.toFixed(1)};`);
      lines.push(`    final parameter Integer maxRpn = ${sum.maxRpn};`);
      lines.push("");
    }
    lines.push("  end FMEA;");
    lines.push("");
  }
  if (thought.designDecisions && thought.designDecisions.decisions.length > 0) {
    lines.push("  // ==========================================================================");
    lines.push("  // Design Decision Records");
    lines.push("  // ==========================================================================");
    lines.push("");
    lines.push("  package DesignDecisions");
    if (thought.designDecisions.projectName) {
      lines.push(`    "Design decisions for ${escapeModelicaString2(thought.designDecisions.projectName)}"`);
    }
    lines.push("");
    for (const dec of thought.designDecisions.decisions) {
      const decId = sanitizeModelicaId2(dec.id);
      lines.push(`    record ${decId}`);
      lines.push(`      "${escapeModelicaString2(dec.title)}"`);
      lines.push(`      constant String status = "${dec.status}";`);
      lines.push(`      constant String context = "${escapeModelicaString2(dec.context.slice(0, 200))}";`);
      lines.push(`      constant String decision = "${escapeModelicaString2(dec.decision.slice(0, 200))}";`);
      lines.push(`      constant String rationale = "${escapeModelicaString2(dec.rationale.slice(0, 200))}";`);
      if (dec.date) {
        lines.push(`      constant String date = "${dec.date}";`);
      }
      if (dec.supersededBy) {
        lines.push(`      constant String supersededBy = "${sanitizeModelicaId2(dec.supersededBy)}";`);
      }
      if (modelicaIncludeAnnotations && dec.consequences.length > 0) {
        lines.push('      annotation(Documentation(info="<html>');
        lines.push("        <h4>Consequences</h4><ul>");
        for (const cons of dec.consequences) {
          lines.push(`          <li>${escapeModelicaString2(cons)}</li>`);
        }
        lines.push('        </ul></html>"));');
      }
      lines.push(`    end ${decId};`);
      lines.push("");
    }
    lines.push("  end DesignDecisions;");
    lines.push("");
  }
  if (thought.assessment && includeMetrics) {
    lines.push("  // ==========================================================================");
    lines.push("  // Assessment");
    lines.push("  // ==========================================================================");
    lines.push("");
    lines.push("  record Assessment");
    lines.push('    "Overall engineering assessment"');
    lines.push(`    constant Real confidence = ${thought.assessment.confidence.toFixed(3)};`);
    lines.push(`    constant Integer keyRisksCount = ${thought.assessment.keyRisks.length};`);
    lines.push(`    constant Integer openIssuesCount = ${thought.assessment.openIssues.length};`);
    if (modelicaIncludeAnnotations) {
      lines.push('    annotation(Documentation(info="<html>');
      if (thought.assessment.keyRisks.length > 0) {
        lines.push("      <h4>Key Risks</h4><ul>");
        for (const risk of thought.assessment.keyRisks) {
          lines.push(`        <li>${escapeModelicaString2(risk)}</li>`);
        }
        lines.push("      </ul>");
      }
      if (thought.assessment.nextSteps.length > 0) {
        lines.push("      <h4>Next Steps</h4><ul>");
        for (const step of thought.assessment.nextSteps) {
          lines.push(`        <li>${escapeModelicaString2(step)}</li>`);
        }
        lines.push("      </ul>");
      }
      lines.push('    </html>"));');
    }
    lines.push("  end Assessment;");
    lines.push("");
  }
  if (modelicaIncludeAnnotations) {
    lines.push(`  annotation(`);
    lines.push(`    Documentation(info="<html>`);
    lines.push(`      <h2>Engineering Analysis: ${escapeModelicaString2(thought.analysisType)}</h2>`);
    lines.push(`      <p><b>Design Challenge:</b> ${escapeModelicaString2(thought.designChallenge)}</p>`);
    lines.push(`      <p>Generated by DeepThinking MCP v7.1.0</p>`);
    lines.push(`    </html>"),`);
    lines.push(`    version="1.0.0"`);
    lines.push(`  );`);
  }
  lines.push(`end ${packageName};`);
  return lines.join("\n");
}
function engineeringToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Engineering Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  const typeBadge = renderBadge(thought.analysisType, "primary");
  html += `<p>Analysis Type: ${typeBadge}</p>
`;
  html += renderSection("Design Challenge", `
    <p class="text-primary"><strong>${escapeHTML(thought.designChallenge)}</strong></p>
  `, "\u{1F527}");
  if (thought.requirements && thought.requirements.requirements.length > 0) {
    if (includeMetrics) {
      const cov = thought.requirements.coverage;
      const coveragePercent = cov.verified / Math.max(cov.total, 1) * 100;
      html += '<div class="metrics-grid">';
      html += renderMetricCard("Total Requirements", cov.total, "primary");
      html += renderMetricCard("Verified", cov.verified, "success");
      html += renderMetricCard("Traced to Source", cov.tracedToSource, "info");
      html += renderMetricCard("Allocated", cov.allocatedToDesign, "warning");
      html += "</div>\n";
      html += renderProgressBar(coveragePercent, "success");
    }
    const reqRows = thought.requirements.requirements.map((req) => {
      const statusBadge = renderBadge(
        req.status,
        req.status === "verified" ? "success" : req.status === "implemented" ? "info" : req.status === "approved" ? "primary" : "secondary"
      );
      const priorityBadge = renderBadge(
        req.priority,
        req.priority === "must" ? "danger" : req.priority === "should" ? "warning" : "secondary"
      );
      return [
        req.id,
        req.title,
        priorityBadge,
        statusBadge,
        req.source
      ];
    });
    html += renderSection("Requirements Traceability", renderTable(
      ["ID", "Title", "Priority", "Status", "Source"],
      reqRows.map((row) => row.map((cell) => typeof cell === "string" && cell.startsWith("<") ? cell : escapeHTML(String(cell))))
    ), "\u{1F4CB}");
  }
  if (thought.tradeStudy) {
    html += renderSection("Trade Study: " + thought.tradeStudy.title, `
      <p><strong>Objective:</strong> ${escapeHTML(thought.tradeStudy.objective)}</p>
      <h4>Criteria</h4>
    ` + renderTable(
      ["Criterion", "Weight", "Description"],
      thought.tradeStudy.criteria.map((c) => [c.name, (c.weight * 100).toFixed(0) + "%", c.description || "-"])
    ) + `
      <h4>Alternatives</h4>
    ` + renderTable(
      ["Alternative", "Description", "Risk Level"],
      thought.tradeStudy.alternatives.map((a) => [
        a.id === thought.tradeStudy.recommendation ? "\u2B50 " + a.name : a.name,
        a.description,
        a.riskLevel || "-"
      ])
    ) + `
      <div class="card" style="margin-top: 1rem; border-color: var(--success-color);">
        <div class="card-header text-success">Recommendation: ${escapeHTML(thought.tradeStudy.recommendation)}</div>
        <p>${escapeHTML(thought.tradeStudy.justification)}</p>
      </div>
    `, "\u2696\uFE0F");
  }
  if (thought.fmea && thought.fmea.failureModes.length > 0) {
    if (includeMetrics) {
      html += '<div class="metrics-grid">';
      html += renderMetricCard("Failure Modes", thought.fmea.summary.totalModes, "primary");
      html += renderMetricCard("Critical Modes", thought.fmea.summary.criticalModes, "danger");
      html += renderMetricCard("Average RPN", thought.fmea.summary.averageRpn.toFixed(1), "warning");
      html += renderMetricCard("Max RPN", thought.fmea.summary.maxRpn, "danger");
      html += "</div>\n";
    }
    const fmeaRows = thought.fmea.failureModes.map((fm) => {
      const isCritical = fm.rpn >= thought.fmea.rpnThreshold;
      const rpnBadge = renderBadge(fm.rpn.toString(), isCritical ? "danger" : "warning");
      return [
        fm.component,
        fm.failureMode.substring(0, 40) + (fm.failureMode.length > 40 ? "..." : ""),
        fm.severity.toString(),
        fm.occurrence.toString(),
        fm.detection.toString(),
        rpnBadge,
        fm.mitigation ? "\u2713" : "-"
      ];
    });
    html += renderSection("Failure Mode Analysis (FMEA)", `
      <p><strong>System:</strong> ${escapeHTML(thought.fmea.system)} | <strong>RPN Threshold:</strong> ${thought.fmea.rpnThreshold}</p>
    ` + renderTable(
      ["Component", "Failure Mode", "S", "O", "D", "RPN", "Mitigation"],
      fmeaRows.map((row) => row.map((cell) => typeof cell === "string" && cell.startsWith("<") ? cell : escapeHTML(String(cell))))
    ), "\u26A0\uFE0F");
  }
  if (thought.designDecisions && thought.designDecisions.decisions.length > 0) {
    const decisionsContent = thought.designDecisions.decisions.map((dec) => {
      const statusBadge = renderBadge(
        dec.status,
        dec.status === "accepted" ? "success" : dec.status === "rejected" ? "danger" : dec.status === "deprecated" ? "warning" : "secondary"
      );
      return `
        <div class="card">
          <div class="card-header">${escapeHTML(dec.id)}: ${escapeHTML(dec.title)} ${statusBadge}</div>
          <p><strong>Context:</strong> ${escapeHTML(dec.context)}</p>
          <p><strong>Decision:</strong> ${escapeHTML(dec.decision)}</p>
          <p><strong>Rationale:</strong> ${escapeHTML(dec.rationale)}</p>
          ${dec.consequences.length > 0 ? `
            <p><strong>Consequences:</strong></p>
            <ul class="list-styled">
              ${dec.consequences.map((c) => `<li>${escapeHTML(c)}</li>`).join("")}
            </ul>
          ` : ""}
        </div>
      `;
    }).join("\n");
    html += renderSection("Design Decisions", decisionsContent, "\u{1F4DD}");
  }
  if (thought.assessment && includeMetrics) {
    html += renderSection("Assessment", `
      <div class="metrics-grid">
        ${renderMetricCard("Confidence", (thought.assessment.confidence * 100).toFixed(0) + "%", "primary")}
        ${renderMetricCard("Key Risks", thought.assessment.keyRisks.length, "danger")}
        ${renderMetricCard("Open Issues", thought.assessment.openIssues.length, "warning")}
      </div>
      ${renderProgressBar(thought.assessment.confidence * 100, "primary")}
      ${thought.assessment.keyRisks.length > 0 ? `
        <h4>Key Risks</h4>
        <ul class="list-styled">
          ${thought.assessment.keyRisks.map((r) => `<li class="text-danger">${escapeHTML(r)}</li>`).join("")}
        </ul>
      ` : ""}
      ${thought.assessment.nextSteps.length > 0 ? `
        <h4>Next Steps</h4>
        <ul class="list-styled">
          ${thought.assessment.nextSteps.map((s) => `<li>${escapeHTML(s)}</li>`).join("")}
        </ul>
      ` : ""}
    `, "\u{1F4CA}");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function engineeringToUML(thought, options) {
  const { umlTheme, umlDirection, includeLabels = true, includeMetrics = true } = options;
  const nodes = [];
  const edges = [];
  nodes.push({
    id: "challenge",
    label: thought.designChallenge.substring(0, 50),
    shape: "component",
    stereotype: thought.analysisType
  });
  if (thought.requirements && thought.requirements.requirements.length > 0) {
    nodes.push({
      id: "requirements",
      label: includeLabels ? `Requirements (${thought.requirements.requirements.length})` : "Requirements",
      shape: "folder",
      color: "lightyellow"
    });
    edges.push({
      source: "challenge",
      target: "requirements",
      type: "composition"
    });
    for (const req of thought.requirements.requirements.slice(0, 5)) {
      const reqId = sanitizeId(req.id);
      nodes.push({
        id: `req_${reqId}`,
        label: includeLabels ? req.title.substring(0, 30) : req.id,
        shape: "class",
        stereotype: req.priority
      });
      edges.push({
        source: "requirements",
        target: `req_${reqId}`,
        type: "aggregation"
      });
    }
  }
  if (thought.tradeStudy) {
    nodes.push({
      id: "tradeStudy",
      label: includeLabels ? thought.tradeStudy.title.substring(0, 30) : "Trade Study",
      shape: "package",
      color: "lightgreen"
    });
    edges.push({
      source: "challenge",
      target: "tradeStudy",
      type: "dependency"
    });
    for (const alt of thought.tradeStudy.alternatives.slice(0, 4)) {
      const isRec = alt.id === thought.tradeStudy.recommendation;
      nodes.push({
        id: `alt_${sanitizeId(alt.id)}`,
        label: alt.name.substring(0, 25),
        shape: isRec ? "entity" : "rectangle",
        stereotype: isRec ? "recommended" : void 0,
        color: isRec ? "90EE90" : void 0
      });
      edges.push({
        source: "tradeStudy",
        target: `alt_${sanitizeId(alt.id)}`,
        type: "association"
      });
    }
  }
  if (thought.fmea && thought.fmea.failureModes.length > 0) {
    nodes.push({
      id: "fmea",
      label: includeMetrics ? `FMEA (${thought.fmea.summary.criticalModes} critical)` : "FMEA",
      shape: "database",
      color: "mistyrose"
    });
    edges.push({
      source: "challenge",
      target: "fmea",
      type: "dependency"
    });
  }
  if (thought.designDecisions && thought.designDecisions.decisions.length > 0) {
    nodes.push({
      id: "decisions",
      label: includeLabels ? `Decisions (${thought.designDecisions.decisions.length})` : "Decisions",
      shape: "folder",
      color: "lavender"
    });
    edges.push({
      source: "challenge",
      target: "decisions",
      type: "dependency"
    });
  }
  if (thought.assessment && includeMetrics) {
    nodes.push({
      id: "assessment",
      label: `Confidence: ${(thought.assessment.confidence * 100).toFixed(0)}%`,
      shape: "usecase",
      color: thought.assessment.confidence > 0.7 ? "90EE90" : "FFD700"
    });
    edges.push({
      source: "challenge",
      target: "assessment",
      type: "dashed"
    });
  }
  return generateUmlDiagram(nodes, edges, {
    title: `Engineering: ${thought.analysisType}`,
    theme: umlTheme,
    direction: umlDirection
  });
}
function engineeringToJSON(thought, options) {
  const { jsonPrettyPrint = true, jsonIndent = 2, includeMetrics = true } = options;
  const graph = createJsonGraph(`Engineering: ${thought.analysisType}`, "engineering", {
    includeMetrics
  });
  graph.metadata.analysisType = thought.analysisType;
  graph.metadata.designChallenge = thought.designChallenge;
  addNode(graph, {
    id: "challenge",
    label: thought.designChallenge,
    type: "challenge",
    color: "#a8d5ff",
    shape: "stadium",
    metadata: { analysisType: thought.analysisType }
  });
  if (thought.requirements) {
    addNode(graph, {
      id: "requirements",
      label: `Requirements (${thought.requirements.requirements.length})`,
      type: "requirements",
      color: "#fff9c4",
      shape: "rectangle",
      metadata: {
        total: thought.requirements.coverage.total,
        verified: thought.requirements.coverage.verified,
        requirements: thought.requirements.requirements.map((r) => ({
          id: r.id,
          title: r.title,
          priority: r.priority,
          status: r.status
        }))
      }
    });
    addEdge(graph, {
      id: "edge_challenge_requirements",
      source: "challenge",
      target: "requirements",
      type: "has_requirements",
      directed: true
    });
  }
  if (thought.tradeStudy) {
    addNode(graph, {
      id: "tradeStudy",
      label: thought.tradeStudy.title,
      type: "trade_study",
      color: "#c8e6c9",
      shape: "rectangle",
      metadata: {
        objective: thought.tradeStudy.objective,
        recommendation: thought.tradeStudy.recommendation,
        justification: thought.tradeStudy.justification,
        alternatives: thought.tradeStudy.alternatives.map((a) => ({
          id: a.id,
          name: a.name,
          riskLevel: a.riskLevel
        })),
        criteria: thought.tradeStudy.criteria.map((c) => ({
          id: c.id,
          name: c.name,
          weight: c.weight
        }))
      }
    });
    addEdge(graph, {
      id: "edge_challenge_tradeStudy",
      source: "challenge",
      target: "tradeStudy",
      type: "has_trade_study",
      directed: true
    });
  }
  if (thought.fmea && thought.fmea.failureModes.length > 0) {
    addNode(graph, {
      id: "fmea",
      label: `FMEA: ${thought.fmea.system}`,
      type: "fmea",
      color: "#ffcdd2",
      shape: "diamond",
      metadata: {
        system: thought.fmea.system,
        rpnThreshold: thought.fmea.rpnThreshold,
        summary: thought.fmea.summary,
        failureModes: thought.fmea.failureModes.map((fm) => ({
          id: fm.id,
          component: fm.component,
          failureMode: fm.failureMode,
          rpn: fm.rpn,
          severity: fm.severity,
          occurrence: fm.occurrence,
          detection: fm.detection
        }))
      }
    });
    addEdge(graph, {
      id: "edge_challenge_fmea",
      source: "challenge",
      target: "fmea",
      type: "has_fmea",
      directed: true
    });
  }
  if (thought.designDecisions && thought.designDecisions.decisions.length > 0) {
    addNode(graph, {
      id: "decisions",
      label: `Decisions (${thought.designDecisions.decisions.length})`,
      type: "design_decisions",
      color: "#e1bee7",
      shape: "rectangle",
      metadata: {
        projectName: thought.designDecisions.projectName,
        decisions: thought.designDecisions.decisions.map((d) => ({
          id: d.id,
          title: d.title,
          status: d.status,
          decision: d.decision
        }))
      }
    });
    addEdge(graph, {
      id: "edge_challenge_decisions",
      source: "challenge",
      target: "decisions",
      type: "has_decisions",
      directed: true
    });
  }
  if (thought.assessment) {
    addNode(graph, {
      id: "assessment",
      label: `Assessment: ${(thought.assessment.confidence * 100).toFixed(0)}%`,
      type: "assessment",
      color: thought.assessment.confidence > 0.7 ? "#a5d6a7" : "#ffe082",
      shape: "ellipse",
      metadata: {
        confidence: thought.assessment.confidence,
        keyRisks: thought.assessment.keyRisks,
        openIssues: thought.assessment.openIssues,
        nextSteps: thought.assessment.nextSteps
      }
    });
    addEdge(graph, {
      id: "edge_challenge_assessment",
      source: "challenge",
      target: "assessment",
      type: "has_assessment",
      directed: true,
      style: "dashed"
    });
  }
  if (includeMetrics && graph.metrics) {
    addMetric(graph, "analysisType", thought.analysisType);
    if (thought.requirements) {
      addMetric(graph, "requirementCount", thought.requirements.requirements.length);
      addMetric(graph, "verifiedRequirements", thought.requirements.coverage.verified);
    }
    if (thought.tradeStudy) {
      addMetric(graph, "alternativeCount", thought.tradeStudy.alternatives.length);
      addMetric(graph, "recommendation", thought.tradeStudy.recommendation);
    }
    if (thought.fmea) {
      addMetric(graph, "failureModeCount", thought.fmea.failureModes.length);
      addMetric(graph, "criticalModes", thought.fmea.summary.criticalModes);
      addMetric(graph, "maxRpn", thought.fmea.summary.maxRpn);
    }
    if (thought.designDecisions) {
      addMetric(graph, "decisionCount", thought.designDecisions.decisions.length);
    }
    if (thought.assessment) {
      addMetric(graph, "confidence", thought.assessment.confidence);
      addMetric(graph, "riskCount", thought.assessment.keyRisks.length);
    }
  }
  return serializeGraph(graph, { prettyPrint: jsonPrettyPrint, indent: jsonIndent });
}
function engineeringToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  const overviewContent = keyValueSection({
    "Analysis Type": thought.analysisType.toUpperCase(),
    "Design Challenge": thought.designChallenge.substring(0, 100) + (thought.designChallenge.length > 100 ? "..." : "")
  });
  parts.push(section("Overview", overviewContent));
  if (thought.requirements && thought.requirements.requirements.length > 0) {
    const reqRows = thought.requirements.requirements.map((req) => [
      req.id,
      req.title.substring(0, 40) + (req.title.length > 40 ? "..." : ""),
      req.priority,
      req.status,
      req.source
    ]);
    let reqContent = table(["ID", "Title", "Priority", "Status", "Source"], reqRows);
    if (includeMetrics) {
      const cov = thought.requirements.coverage;
      const coveragePercent = cov.verified / Math.max(cov.total, 1) * 100;
      reqContent += "\n\n" + keyValueSection({
        "Total Requirements": cov.total,
        "Verified": cov.verified,
        "Traced to Source": cov.tracedToSource,
        "Allocated to Design": cov.allocatedToDesign,
        "Coverage": `${coveragePercent.toFixed(1)}%`
      });
      reqContent += "\n\n**Verification Progress:**\n\n" + progressBar(coveragePercent);
    }
    parts.push(section("Requirements Traceability", reqContent));
  }
  if (thought.tradeStudy) {
    const criteriaRows = thought.tradeStudy.criteria.map((c) => [
      c.name,
      `${(c.weight * 100).toFixed(0)}%`,
      c.description || "-"
    ]);
    const altRows = thought.tradeStudy.alternatives.map((alt) => [
      alt.id === thought.tradeStudy.recommendation ? `\u2B50 ${alt.name}` : alt.name,
      alt.description.substring(0, 60) + (alt.description.length > 60 ? "..." : ""),
      alt.riskLevel || "-",
      alt.estimatedCost?.toString() || "-"
    ]);
    let tradeContent = `**Objective:** ${thought.tradeStudy.objective}

`;
    tradeContent += "### Criteria\n\n";
    tradeContent += table(["Criterion", "Weight", "Description"], criteriaRows);
    tradeContent += "\n\n### Alternatives\n\n";
    tradeContent += table(["Alternative", "Description", "Risk Level", "Cost"], altRows);
    tradeContent += "\n\n**Recommendation:** " + thought.tradeStudy.recommendation;
    tradeContent += "\n\n**Justification:**\n\n" + thought.tradeStudy.justification;
    parts.push(section("Trade Study: " + thought.tradeStudy.title, tradeContent));
  }
  if (thought.fmea && thought.fmea.failureModes.length > 0) {
    const fmeaRows = thought.fmea.failureModes.map((fm) => {
      const isCritical = fm.rpn >= thought.fmea.rpnThreshold;
      return [
        fm.component,
        fm.failureMode.substring(0, 40) + (fm.failureMode.length > 40 ? "..." : ""),
        fm.severity.toString(),
        fm.occurrence.toString(),
        fm.detection.toString(),
        `${fm.rpn}${isCritical ? " \u26A0\uFE0F" : ""}`,
        fm.mitigation ? "\u2713" : "-"
      ];
    });
    let fmeaContent = `**System:** ${thought.fmea.system}

`;
    fmeaContent += table(
      ["Component", "Failure Mode", "S", "O", "D", "RPN", "Mitigation"],
      fmeaRows
    );
    if (includeMetrics) {
      const sum = thought.fmea.summary;
      fmeaContent += "\n\n" + keyValueSection({
        "Total Modes": sum.totalModes,
        "Critical Modes": sum.criticalModes,
        "Average RPN": sum.averageRpn.toFixed(1),
        "Max RPN": sum.maxRpn,
        "RPN Threshold": thought.fmea.rpnThreshold
      });
    }
    parts.push(section("Failure Mode and Effects Analysis (FMEA)", fmeaContent));
  }
  if (thought.designDecisions && thought.designDecisions.decisions.length > 0) {
    let decisionsContent = "";
    for (const dec of thought.designDecisions.decisions) {
      decisionsContent += `### ${dec.id}: ${dec.title} (${dec.status})

`;
      decisionsContent += keyValueSection({
        "Status": dec.status,
        "Date": dec.date || "-"
      });
      decisionsContent += "\n\n**Context:**\n\n" + dec.context;
      decisionsContent += "\n\n**Decision:**\n\n" + dec.decision;
      decisionsContent += "\n\n**Rationale:**\n\n" + dec.rationale;
      if (dec.consequences.length > 0) {
        decisionsContent += "\n\n**Consequences:**\n\n" + list(dec.consequences);
      }
      if (dec.supersededBy) {
        decisionsContent += `

*Superseded by: ${dec.supersededBy}*`;
      }
      decisionsContent += "\n\n---\n\n";
    }
    parts.push(section("Design Decisions", decisionsContent));
  }
  if (thought.assessment) {
    let assessmentContent = keyValueSection({
      "Confidence": `${(thought.assessment.confidence * 100).toFixed(1)}%`,
      "Key Risks": thought.assessment.keyRisks.length,
      "Open Issues": thought.assessment.openIssues.length
    });
    assessmentContent += "\n\n**Confidence Level:**\n\n" + progressBar(thought.assessment.confidence * 100);
    if (thought.assessment.keyRisks.length > 0) {
      assessmentContent += "\n\n**Key Risks:**\n\n" + list(thought.assessment.keyRisks.map((r) => `\u26A0\uFE0F ${r}`));
    }
    if (thought.assessment.openIssues.length > 0) {
      assessmentContent += "\n\n**Open Issues:**\n\n" + list(thought.assessment.openIssues);
    }
    if (thought.assessment.nextSteps.length > 0) {
      assessmentContent += "\n\n**Next Steps:**\n\n" + list(thought.assessment.nextSteps);
    }
    parts.push(section("Assessment", assessmentContent));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = engineeringToMermaid(thought, options);
    parts.push(section("Visualization", mermaidBlock(mermaidDiagram)));
  }
  return document(`Engineering Analysis: ${thought.analysisType}`, parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "engineering",
      analysisType: thought.analysisType,
      ...thought.assessment?.confidence !== void 0 ? { confidence: thought.assessment.confidence } : {}
    }
  });
}
var init_engineering = __esm({
  "src/export/visual/engineering.ts"() {
    init_esm_shims();
    init_utils();
    init_svg_utils();
    init_graphml_utils();
    init_tikz_utils();
    init_html_utils();
    init_uml_utils();
    init_json_utils();
    init_markdown_utils();
  }
});

// src/export/visual/computability.ts
function exportComputability(thought, options) {
  const { format } = options;
  switch (format) {
    case "mermaid":
      return computabilityToMermaid(thought, options);
    case "dot":
      return computabilityToDOT(thought, options);
    case "ascii":
      return computabilityToASCII(thought);
    case "svg":
      return computabilityToSVG(thought, options);
    case "graphml":
      return computabilityToGraphML(thought, options);
    case "tikz":
      return computabilityToTikZ(thought, options);
    case "html":
      return computabilityToHTML(thought, options);
    case "json":
      return computabilityToJSON(thought, options);
    case "markdown":
      return computabilityToMarkdown(thought, options);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}
function computabilityToMermaid(thought, options) {
  const { includeLabels = true } = options;
  if (thought.currentMachine || thought.machines && thought.machines.length > 0) {
    return turingMachineToMermaid(thought.currentMachine || thought.machines[0], includeLabels);
  }
  if (thought.reductions && thought.reductions.length > 0) {
    return reductionChainToMermaid(thought.reductions, thought.reductionChain, includeLabels);
  }
  if (thought.decidabilityProof) {
    return decidabilityProofToMermaid(thought);
  }
  let mermaid = "graph TD\n";
  mermaid += `  type["${thought.thoughtType}"]
`;
  if (thought.keyInsight) {
    mermaid += `  insight["${thought.keyInsight.substring(0, 50)}..."]
`;
    mermaid += "  type --> insight\n";
  }
  return mermaid;
}
function turingMachineToMermaid(machine, includeLabels) {
  let mermaid = "stateDiagram-v2\n";
  mermaid += `  [*] --> ${sanitizeId(machine.initialState)}
`;
  for (const t of machine.transitions) {
    const label = includeLabels ? `${t.readSymbol}/${t.writeSymbol},${t.direction}` : "";
    mermaid += `  ${sanitizeId(t.fromState)} --> ${sanitizeId(t.toState)}`;
    if (label) {
      mermaid += `: ${label}`;
    }
    mermaid += "\n";
  }
  for (const acceptState of machine.acceptStates) {
    mermaid += `  ${sanitizeId(acceptState)} --> [*]
`;
  }
  return mermaid;
}
function reductionChainToMermaid(reductions, chain, includeLabels) {
  let mermaid = "graph LR\n";
  if (chain && chain.length > 0) {
    for (let i = 0; i < chain.length - 1; i++) {
      const from = sanitizeId(chain[i]);
      const to = sanitizeId(chain[i + 1]);
      const reduction = reductions.find((r) => r.fromProblem === chain[i] && r.toProblem === chain[i + 1]);
      const label = includeLabels && reduction ? `\u2264${reduction.type === "polynomial_time" ? "p" : "m"}` : "";
      mermaid += `  ${from}["${chain[i]}"] -->|${label}| ${to}["${chain[i + 1]}"]
`;
    }
  } else {
    for (const r of reductions) {
      const from = sanitizeId(r.fromProblem);
      const to = sanitizeId(r.toProblem);
      const label = includeLabels ? `\u2264${r.type === "polynomial_time" ? "p" : "m"}` : "";
      mermaid += `  ${from}["${r.fromProblem}"] -->|${label}| ${to}["${r.toProblem}"]
`;
    }
  }
  return mermaid;
}
function decidabilityProofToMermaid(thought, _includeLabels) {
  const proof = thought.decidabilityProof;
  let mermaid = "graph TD\n";
  mermaid += `  problem["Problem: ${proof.problem}"]
`;
  mermaid += `  method["Method: ${proof.method}"]
`;
  mermaid += `  conclusion["${proof.conclusion.toUpperCase()}"]
`;
  mermaid += "  problem --> method\n";
  mermaid += "  method --> conclusion\n";
  if (proof.conclusion === "undecidable") {
    mermaid += "  style conclusion fill:#ffcccc,stroke:#ff0000\n";
  } else if (proof.conclusion === "decidable") {
    mermaid += "  style conclusion fill:#ccffcc,stroke:#00ff00\n";
  }
  return mermaid;
}
function computabilityToDOT(thought, options) {
  const { includeLabels = true } = options;
  if (thought.currentMachine || thought.machines && thought.machines.length > 0) {
    return turingMachineToDOT(thought.currentMachine || thought.machines[0], includeLabels);
  }
  if (thought.reductions && thought.reductions.length > 0) {
    return reductionChainToDOT(thought.reductions, thought.reductionChain, includeLabels);
  }
  let dot = "digraph Computability {\n";
  dot += "  rankdir=TD;\n";
  dot += `  type [label="${thought.thoughtType}"];
`;
  dot += "}\n";
  return dot;
}
function turingMachineToDOT(machine, includeLabels) {
  let dot = `digraph TuringMachine {
`;
  dot += "  rankdir=LR;\n";
  dot += "  node [shape=circle];\n\n";
  dot += "  start [shape=point];\n";
  dot += `  start -> ${sanitizeId(machine.initialState)};

`;
  for (const state of machine.states) {
    const isAccept = machine.acceptStates.includes(state);
    const isReject = machine.rejectStates.includes(state);
    const shape = isAccept ? "doublecircle" : isReject ? "circle, style=filled, fillcolor=lightgray" : "circle";
    dot += `  ${sanitizeId(state)} [label="${state}", shape=${shape}];
`;
  }
  dot += "\n";
  for (const t of machine.transitions) {
    const label = includeLabels ? `${t.readSymbol}/${t.writeSymbol},${t.direction}` : "";
    dot += `  ${sanitizeId(t.fromState)} -> ${sanitizeId(t.toState)}`;
    if (label) {
      dot += ` [label="${label}"]`;
    }
    dot += ";\n";
  }
  dot += "}\n";
  return dot;
}
function reductionChainToDOT(reductions, _chain, includeLabels) {
  let dot = "digraph ReductionChain {\n";
  dot += "  rankdir=LR;\n";
  dot += "  node [shape=box, style=rounded];\n\n";
  const problems = /* @__PURE__ */ new Set();
  for (const r of reductions) {
    problems.add(r.fromProblem);
    problems.add(r.toProblem);
  }
  for (const p of problems) {
    dot += `  ${sanitizeId(p)} [label="${p}"];
`;
  }
  dot += "\n";
  for (const r of reductions) {
    const label = includeLabels ? `\u2264${r.type === "polynomial_time" ? "p" : "m"}` : "";
    dot += `  ${sanitizeId(r.fromProblem)} -> ${sanitizeId(r.toProblem)}`;
    if (label) {
      dot += ` [label="${label}"]`;
    }
    dot += ";\n";
  }
  dot += "}\n";
  return dot;
}
function computabilityToASCII(thought) {
  let ascii = "COMPUTABILITY ANALYSIS\n";
  ascii += "=".repeat(50) + "\n\n";
  ascii += `Type: ${thought.thoughtType}
`;
  if (thought.keyInsight) {
    ascii += `
Key Insight: ${thought.keyInsight}
`;
  }
  if (thought.currentMachine) {
    const m = thought.currentMachine;
    ascii += `
Turing Machine: ${m.name}
`;
    ascii += "-".repeat(30) + "\n";
    ascii += `States: {${m.states.join(", ")}}
`;
    ascii += `Initial: ${m.initialState}
`;
    ascii += `Accept: {${m.acceptStates.join(", ")}}
`;
    ascii += `Transitions: ${m.transitions.length}
`;
  }
  if (thought.computationTrace) {
    const trace = thought.computationTrace;
    ascii += `
Computation Trace:
`;
    ascii += "-".repeat(30) + "\n";
    ascii += `Input: ${trace.input}
`;
    ascii += `Steps: ${trace.totalSteps}
`;
    ascii += `Result: ${trace.result.toUpperCase()}
`;
    for (const step of trace.steps.slice(0, 5)) {
      const head = " ".repeat(step.headPosition) + "v";
      ascii += `  [${step.stepNumber}] ${step.state}: ${step.tapeContents}
`;
      ascii += `       ${head}
`;
    }
    if (trace.steps.length > 5) {
      ascii += `  ... (${trace.steps.length - 5} more steps)
`;
    }
  }
  if (thought.decidabilityProof) {
    const proof = thought.decidabilityProof;
    ascii += `
Decidability Analysis:
`;
    ascii += "-".repeat(30) + "\n";
    ascii += `Problem: ${proof.problem}
`;
    ascii += `Method: ${proof.method}
`;
    ascii += `Conclusion: ${proof.conclusion.toUpperCase()}
`;
    if (proof.proofSteps.length > 0) {
      ascii += "\nProof Steps:\n";
      for (let i = 0; i < Math.min(proof.proofSteps.length, 5); i++) {
        ascii += `  ${i + 1}. ${proof.proofSteps[i]}
`;
      }
    }
  }
  if (thought.reductions && thought.reductions.length > 0) {
    ascii += `
Reductions:
`;
    ascii += "-".repeat(30) + "\n";
    for (const r of thought.reductions) {
      ascii += `  ${r.fromProblem} \u2264${r.type === "polynomial_time" ? "p" : "m"} ${r.toProblem}
`;
    }
  }
  if (thought.diagonalization) {
    const diag = thought.diagonalization;
    ascii += `
Diagonalization Argument:
`;
    ascii += "-".repeat(30) + "\n";
    ascii += `Pattern: ${diag.pattern}
`;
    ascii += `Enumeration: ${diag.enumeration.description}
`;
    ascii += `Diagonal: ${diag.diagonalConstruction.description}
`;
    ascii += `Contradiction: ${diag.contradiction.impossibility}
`;
  }
  return ascii;
}
function computabilityToSVG(thought, options) {
  const {
    colorScheme = "default",
    includeMetrics = true,
    svgWidth = DEFAULT_SVG_OPTIONS.width,
    svgHeight = 400
  } = options;
  const title = thought.currentMachine?.name || "Computability Analysis";
  if (thought.currentMachine) {
    return turingMachineToSVG(thought.currentMachine, { ...options, colorScheme, svgWidth, svgHeight });
  }
  const positions = /* @__PURE__ */ new Map();
  positions.set("type", {
    id: "type",
    x: svgWidth / 2 - 60,
    y: 80,
    width: 120,
    height: 40,
    label: thought.thoughtType,
    type: "type"
  });
  let svg = generateSVGHeader(svgWidth, svgHeight, title);
  svg += '\n  <!-- Nodes -->\n  <g class="nodes">';
  for (const [, pos] of positions) {
    svg += renderRectNode(pos, getNodeColor("primary", colorScheme));
  }
  svg += "\n  </g>";
  if (includeMetrics) {
    const metrics = [
      { label: "Type", value: thought.thoughtType },
      { label: "Uncertainty", value: thought.uncertainty.toFixed(2) }
    ];
    svg += renderMetricsPanel(svgWidth - 180, svgHeight - 80, metrics);
  }
  svg += "\n" + generateSVGFooter();
  return svg;
}
function turingMachineToSVG(machine, options) {
  const {
    colorScheme = "default",
    svgWidth = DEFAULT_SVG_OPTIONS.width,
    svgHeight = 400
  } = options;
  const positions = /* @__PURE__ */ new Map();
  const nodeRadius = 30;
  const spacing = 120;
  const cols = Math.ceil(Math.sqrt(machine.states.length));
  machine.states.forEach((state, i) => {
    const row = Math.floor(i / cols);
    const col = i % cols;
    positions.set(state, {
      id: state,
      x: 100 + col * spacing,
      y: 100 + row * spacing,
      width: nodeRadius * 2,
      height: nodeRadius * 2,
      label: state,
      type: machine.acceptStates.includes(state) ? "accept" : machine.rejectStates.includes(state) ? "reject" : "state"
    });
  });
  let svg = generateSVGHeader(svgWidth, svgHeight, machine.name);
  svg += '\n  <!-- Transitions -->\n  <g class="edges">';
  for (const t of machine.transitions) {
    const fromPos = positions.get(t.fromState);
    const toPos = positions.get(t.toState);
    if (fromPos && toPos) {
      svg += renderEdge(fromPos, toPos, { label: `${t.readSymbol}/${t.writeSymbol}` });
    }
  }
  svg += "\n  </g>";
  svg += '\n\n  <!-- States -->\n  <g class="nodes">';
  for (const [, pos] of positions) {
    const colors = pos.type === "accept" ? getNodeColor("success", colorScheme) : pos.type === "reject" ? getNodeColor("danger", colorScheme) : getNodeColor("neutral", colorScheme);
    svg += renderEllipseNode(pos, colors);
  }
  svg += "\n  </g>";
  const legendItems = [
    { label: "State", color: getNodeColor("neutral", colorScheme) },
    { label: "Accept", color: getNodeColor("success", colorScheme) },
    { label: "Reject", color: getNodeColor("danger", colorScheme) }
  ];
  svg += renderLegend(20, svgHeight - 80, legendItems);
  svg += "\n" + generateSVGFooter();
  return svg;
}
function computabilityToGraphML(thought, options) {
  const nodes = [];
  const edges = [];
  let edgeId = 0;
  if (thought.currentMachine) {
    const m = thought.currentMachine;
    for (const state of m.states) {
      nodes.push({
        id: sanitizeId(state),
        label: state,
        type: m.acceptStates.includes(state) ? "accept" : m.rejectStates.includes(state) ? "reject" : "state"
      });
    }
    for (const t of m.transitions) {
      edges.push({
        id: `e${edgeId++}`,
        source: sanitizeId(t.fromState),
        target: sanitizeId(t.toState),
        label: options.includeLabels ? `${t.readSymbol}/${t.writeSymbol},${t.direction}` : void 0,
        directed: true
      });
    }
    return generateGraphML(nodes, edges, { graphName: m.name });
  }
  nodes.push({ id: "root", label: thought.thoughtType, type: "root" });
  return generateGraphML(nodes, edges, { graphName: "Computability Analysis" });
}
function computabilityToTikZ(thought, options) {
  const nodes = [];
  const edges = [];
  if (thought.currentMachine) {
    const m = thought.currentMachine;
    const cols = Math.ceil(Math.sqrt(m.states.length));
    m.states.forEach((state, i) => {
      const row = Math.floor(i / cols);
      const col = i % cols;
      nodes.push({
        id: sanitizeId(state),
        label: state,
        x: col * 3,
        y: -row * 2,
        shape: "ellipse",
        type: m.acceptStates.includes(state) ? "success" : m.rejectStates.includes(state) ? "danger" : "neutral"
      });
    });
    for (const t of m.transitions) {
      edges.push({
        source: sanitizeId(t.fromState),
        target: sanitizeId(t.toState),
        label: options.includeLabels ? `${t.readSymbol}/${t.writeSymbol}` : void 0,
        directed: true
      });
    }
    return generateTikZ(nodes, edges, { title: m.name, colorScheme: options.colorScheme });
  }
  nodes.push({ id: "root", label: thought.thoughtType, x: 0, y: 0, shape: "rectangle", type: "primary" });
  return generateTikZ(nodes, edges, { title: "Computability Analysis" });
}
function computabilityToHTML(thought, options) {
  const {
    htmlStandalone = true,
    htmlTitle = "Computability Analysis",
    htmlTheme = "light",
    includeMetrics = true
  } = options;
  let html = generateHTMLHeader(htmlTitle, { standalone: htmlStandalone, theme: htmlTheme });
  html += `<h1>${escapeHTML(htmlTitle)}</h1>
`;
  const typeBadge = renderBadge(thought.thoughtType, "primary");
  html += `<p>Analysis Type: ${typeBadge}</p>
`;
  if (includeMetrics) {
    html += '<div class="metrics-grid">';
    html += renderMetricCard("Thought Type", thought.thoughtType, "primary");
    html += renderMetricCard("Uncertainty", thought.uncertainty.toFixed(2), "info");
    if (thought.machines) {
      html += renderMetricCard("Machines", thought.machines.length, "info");
    }
    if (thought.reductions) {
      html += renderMetricCard("Reductions", thought.reductions.length, "info");
    }
    html += "</div>\n";
  }
  if (thought.currentMachine) {
    const m = thought.currentMachine;
    html += renderSection("Turing Machine", `
      <p><strong>Name:</strong> ${escapeHTML(m.name)}</p>
      <p><strong>Type:</strong> ${escapeHTML(m.type)}</p>
      <p><strong>States:</strong> {${m.states.map((s) => escapeHTML(s)).join(", ")}}</p>
      <p><strong>Initial State:</strong> ${escapeHTML(m.initialState)}</p>
      <p><strong>Accept States:</strong> {${m.acceptStates.map((s) => escapeHTML(s)).join(", ")}}</p>
      <p><strong>Transitions:</strong> ${m.transitions.length}</p>
    `, "\u{1F916}");
  }
  if (thought.decidabilityProof) {
    const proof = thought.decidabilityProof;
    const conclusionBadge = renderBadge(
      proof.conclusion.toUpperCase(),
      proof.conclusion === "decidable" ? "success" : proof.conclusion === "undecidable" ? "danger" : "warning"
    );
    html += renderSection("Decidability Analysis", `
      <p><strong>Problem:</strong> ${escapeHTML(proof.problem)}</p>
      <p><strong>Method:</strong> ${escapeHTML(proof.method)}</p>
      <p><strong>Conclusion:</strong> ${conclusionBadge}</p>
      ${proof.proofSteps.length > 0 ? renderList(proof.proofSteps) : ""}
    `, "\u{1F4CA}");
  }
  if (thought.reductions && thought.reductions.length > 0) {
    const rows = thought.reductions.map((r) => [
      escapeHTML(r.fromProblem),
      `\u2264${r.type === "polynomial_time" ? "p" : "m"}`,
      escapeHTML(r.toProblem)
    ]);
    html += renderSection("Reductions", renderTable(["From", "Type", "To"], rows), "\u{1F517}");
  }
  if (thought.keyInsight) {
    html += renderSection("Key Insight", `<p>${escapeHTML(thought.keyInsight)}</p>`, "\u{1F4A1}");
  }
  html += generateHTMLFooter(htmlStandalone);
  return html;
}
function computabilityToJSON(thought, options) {
  const { includeMetrics = true } = options;
  const graph = createJsonGraph("Computability Analysis", "computability");
  addNode(graph, {
    id: "root",
    label: thought.thoughtType,
    type: "thought-type",
    metadata: {
      uncertainty: thought.uncertainty,
      keyInsight: thought.keyInsight
    }
  });
  let edgeId = 0;
  if (thought.machines) {
    for (const m of thought.machines) {
      addNode(graph, {
        id: sanitizeId(m.id),
        label: m.name,
        type: "turing-machine",
        metadata: {
          states: m.states.length,
          transitions: m.transitions.length,
          type: m.type
        }
      });
      addEdge(graph, {
        id: `e${edgeId++}`,
        source: "root",
        target: sanitizeId(m.id),
        type: "contains"
      });
    }
  }
  if (thought.reductions) {
    for (const r of thought.reductions) {
      addNode(graph, {
        id: sanitizeId(r.id),
        label: `${r.fromProblem} \u2192 ${r.toProblem}`,
        type: "reduction",
        metadata: {
          reductionType: r.type,
          fromProblem: r.fromProblem,
          toProblem: r.toProblem
        }
      });
    }
  }
  if (includeMetrics) {
    addMetric(graph, "Thought Type", thought.thoughtType);
    addMetric(graph, "Uncertainty", thought.uncertainty);
    if (thought.machines) {
      addMetric(graph, "Machines", thought.machines.length);
    }
    if (thought.decidabilityProof) {
      addMetric(graph, "Conclusion", thought.decidabilityProof.conclusion);
    }
  }
  addLegendItem(graph, "Turing Machine", "#4A90E2");
  addLegendItem(graph, "Reduction", "#50C878");
  addLegendItem(graph, "Decidable", "#28A745");
  addLegendItem(graph, "Undecidable", "#DC3545");
  return serializeGraph(graph);
}
function computabilityToMarkdown(thought, options) {
  const {
    markdownIncludeFrontmatter = false,
    markdownIncludeToc = false,
    markdownIncludeMermaid = true,
    includeMetrics = true
  } = options;
  const parts = [];
  if (includeMetrics) {
    parts.push(section("Analysis", keyValueSection({
      "Type": thought.thoughtType,
      "Uncertainty": thought.uncertainty.toFixed(2),
      ...thought.keyInsight ? { "Key Insight": thought.keyInsight } : {}
    })));
  }
  if (thought.currentMachine) {
    const m = thought.currentMachine;
    parts.push(section("Turing Machine", keyValueSection({
      "Name": m.name,
      "Type": m.type,
      "States": `{${m.states.join(", ")}}`,
      "Initial State": m.initialState,
      "Accept States": `{${m.acceptStates.join(", ")}}`,
      "Transitions": m.transitions.length.toString()
    })));
    if (m.transitions.length > 0) {
      const transitionRows = m.transitions.map((t) => [
        t.fromState,
        t.readSymbol,
        t.toState,
        t.writeSymbol,
        t.direction
      ]);
      parts.push(section("Transition Function", table(
        ["From State", "Read", "To State", "Write", "Move"],
        transitionRows
      )));
    }
  }
  if (thought.decidabilityProof) {
    const proof = thought.decidabilityProof;
    parts.push(section("Decidability Analysis", keyValueSection({
      "Problem": proof.problem,
      "Method": proof.method,
      "Conclusion": `**${proof.conclusion.toUpperCase()}**`
    })));
    if (proof.proofSteps.length > 0) {
      parts.push(section("Proof Steps", list(proof.proofSteps.map((s, i) => `${i + 1}. ${s}`))));
    }
  }
  if (thought.reductions && thought.reductions.length > 0) {
    const reductionRows = thought.reductions.map((r) => [
      r.fromProblem,
      `\u2264${r.type === "polynomial_time" ? "p" : "m"}`,
      r.toProblem
    ]);
    parts.push(section("Reductions", table(["From Problem", "Reduction", "To Problem"], reductionRows)));
  }
  if (thought.diagonalization) {
    const d = thought.diagonalization;
    parts.push(section("Diagonalization Argument", keyValueSection({
      "Pattern": d.pattern,
      "Enumeration": d.enumeration.description,
      "Diagonal Construction": d.diagonalConstruction.description,
      "Contradiction": d.contradiction.impossibility
    })));
  }
  if (markdownIncludeMermaid) {
    const mermaidDiagram = computabilityToMermaid(thought, { ...options});
    parts.push(section("Diagram", mermaidBlock(mermaidDiagram)));
  }
  return document("Computability Analysis", parts.join("\n"), {
    includeFrontmatter: markdownIncludeFrontmatter,
    includeTableOfContents: markdownIncludeToc,
    metadata: {
      mode: "computability",
      thoughtType: thought.thoughtType,
      uncertainty: thought.uncertainty
    }
  });
}
var init_computability = __esm({
  "src/export/visual/computability.ts"() {
    init_esm_shims();
    init_utils();
    init_svg_utils();
    init_graphml_utils();
    init_tikz_utils();
    init_html_utils();
    init_json_utils();
    init_markdown_utils();
  }
});

// src/export/visual/index.ts
var VisualExporter;
var init_visual = __esm({
  "src/export/visual/index.ts"() {
    init_esm_shims();
    init_mermaid_utils();
    init_dot_utils();
    init_ascii_utils();
    init_svg_utils();
    init_graphml_utils();
    init_tikz_utils();
    init_html_utils();
    init_modelica_utils();
    init_uml_utils();
    init_json_utils();
    init_markdown_utils();
    init_causal();
    init_temporal();
    init_game_theory();
    init_bayesian();
    init_sequential();
    init_shannon();
    init_abductive();
    init_counterfactual();
    init_analogical();
    init_evidential();
    init_first_principles();
    init_systems_thinking();
    init_scientific_method();
    init_optimization();
    init_formal_logic();
    init_mathematics();
    init_physics();
    init_hybrid();
    init_metareasoning();
    init_proof_decomposition();
    init_engineering();
    init_computability();
    VisualExporter = class {
      exportCausalGraph(thought, options) {
        return exportCausalGraph(thought, options);
      }
      exportTemporalTimeline(thought, options) {
        return exportTemporalTimeline(thought, options);
      }
      exportGameTree(thought, options) {
        return exportGameTree(thought, options);
      }
      exportBayesianNetwork(thought, options) {
        return exportBayesianNetwork(thought, options);
      }
      exportSequentialDependencyGraph(thought, options) {
        return exportSequentialDependencyGraph(thought, options);
      }
      exportShannonStageFlow(thought, options) {
        return exportShannonStageFlow(thought, options);
      }
      exportAbductiveHypotheses(thought, options) {
        return exportAbductiveHypotheses(thought, options);
      }
      exportCounterfactualScenarios(thought, options) {
        return exportCounterfactualScenarios(thought, options);
      }
      exportAnalogicalMapping(thought, options) {
        return exportAnalogicalMapping(thought, options);
      }
      exportEvidentialBeliefs(thought, options) {
        return exportEvidentialBeliefs(thought, options);
      }
      exportFirstPrinciplesDerivation(thought, options) {
        return exportFirstPrinciplesDerivation(thought, options);
      }
      exportSystemsThinkingCausalLoops(thought, options) {
        return exportSystemsThinkingCausalLoops(thought, options);
      }
      exportScientificMethodExperiment(thought, options) {
        return exportScientificMethodExperiment(thought, options);
      }
      exportOptimizationSolution(thought, options) {
        return exportOptimizationSolution(thought, options);
      }
      exportFormalLogicProof(thought, options) {
        return exportFormalLogicProof(thought, options);
      }
      // Sprint 2: New visual export wrapper methods
      exportMathematicsDerivation(thought, options) {
        return exportMathematicsDerivation(thought, options);
      }
      exportPhysicsVisualization(thought, options) {
        return exportPhysicsVisualization(thought, options);
      }
      exportHybridOrchestration(thought, options) {
        return exportHybridOrchestration(thought, options);
      }
      exportMetaReasoningVisualization(thought, options) {
        return exportMetaReasoningVisualization(thought, options);
      }
      // Phase 8: Proof decomposition visual export
      exportProofDecomposition(decomposition, options) {
        return exportProofDecomposition(decomposition, options);
      }
      // Phase 10: Engineering visual export
      exportEngineeringAnalysis(thought, options) {
        return exportEngineeringAnalysis(thought, options);
      }
      // Phase 11: Computability visual export (Turing's legacy)
      exportComputability(thought, options) {
        return exportComputability(thought, options);
      }
    };
  }
});

// src/services/ExportService.ts
var ExportService;
var init_ExportService = __esm({
  "src/services/ExportService.ts"() {
    init_esm_shims();
    init_types();
    init_visual();
    init_sanitization();
    init_logger();
    ExportService = class {
      visualExporter;
      logger;
      constructor(logger2) {
        this.visualExporter = new VisualExporter();
        this.logger = logger2 || createLogger({ minLevel: 1 /* INFO */, enableConsole: true });
      }
      /**
       * Export a session to the specified format
       *
       * Main export method that routes to format-specific exporters.
       * Handles both standard formats (JSON, Markdown, etc.) and visual
       * formats (Mermaid, DOT, ASCII).
       *
       * @param session - The session to export
       * @param format - The desired export format
       * @returns Formatted string in the requested format
       * @throws {Error} If session has no thoughts for visual exports
       *
       * @example
       * ```typescript
       * const service = new ExportService();
       * const exported = service.exportSession(session, 'markdown');
       * ```
       */
      exportSession(session, format) {
        const startTime = Date.now();
        this.logger.debug("Export started", { sessionId: session.id, format, thoughtCount: session.thoughts.length });
        if (format === "mermaid" || format === "dot" || format === "ascii" || format === "svg" || format === "graphml" || format === "tikz" || format === "modelica" || format === "html" || format === "uml" || format === "visual-json" || format === "visual-markdown") {
          const visualFormat = format === "visual-json" ? "json" : format === "visual-markdown" ? "markdown" : format;
          const result2 = this.exportVisual(session, visualFormat);
          this.logger.debug("Export completed", {
            sessionId: session.id,
            format,
            duration: Date.now() - startTime,
            outputSize: result2.length
          });
          return result2;
        }
        let result;
        switch (format) {
          case "json":
            result = this.exportToJSON(session);
            break;
          case "markdown":
            result = this.exportToMarkdown(session);
            break;
          case "latex":
            result = this.exportToLatex(session);
            break;
          case "jupyter":
            result = this.exportToJupyter(session);
            break;
          default:
            result = this.exportToJSON(session);
        }
        this.logger.debug("Export completed", {
          sessionId: session.id,
          format,
          duration: Date.now() - startTime,
          outputSize: result.length
        });
        return result;
      }
      /**
       * Export session to visual format (Mermaid, DOT, ASCII)
       *
       * Uses VisualExporter to generate visual representations
       * based on the session's thinking mode and thought structure.
       *
       * @param session - The session to export
       * @param format - Visual format (mermaid, dot, ascii)
       * @returns Visual representation as string
       * @throws {Error} If session has no thoughts
       */
      exportVisual(session, format) {
        const lastThought = session.thoughts[session.thoughts.length - 1];
        if (!lastThought) {
          throw new Error("No thoughts in session to export");
        }
        if (lastThought.mode === "causal" && "causalGraph" in lastThought) {
          return this.visualExporter.exportCausalGraph(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "temporal" && "timeline" in lastThought) {
          return this.visualExporter.exportTemporalTimeline(lastThought, {
            format,
            includeLabels: true
          });
        }
        if (lastThought.mode === "gametheory" && "game" in lastThought) {
          return this.visualExporter.exportGameTree(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "bayesian" && "hypothesis" in lastThought) {
          return this.visualExporter.exportBayesianNetwork(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "firstprinciples" /* FIRSTPRINCIPLES */ && "question" in lastThought) {
          return this.visualExporter.exportFirstPrinciplesDerivation(lastThought, {
            format,
            colorScheme: "default"
          });
        }
        if (lastThought.mode === "sequential" /* SEQUENTIAL */ && "buildUpon" in lastThought) {
          return this.visualExporter.exportSequentialDependencyGraph(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "shannon" /* SHANNON */ && "stage" in lastThought) {
          return this.visualExporter.exportShannonStageFlow(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "abductive" /* ABDUCTIVE */ && "hypotheses" in lastThought) {
          return this.visualExporter.exportAbductiveHypotheses(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "counterfactual" /* COUNTERFACTUAL */ && "scenarios" in lastThought) {
          return this.visualExporter.exportCounterfactualScenarios(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "analogical" /* ANALOGICAL */ && "sourceAnalogy" in lastThought) {
          return this.visualExporter.exportAnalogicalMapping(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "evidential" /* EVIDENTIAL */ && "frameOfDiscernment" in lastThought) {
          return this.visualExporter.exportEvidentialBeliefs(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "systemsthinking" /* SYSTEMSTHINKING */ && "systemComponents" in lastThought) {
          return this.visualExporter.exportSystemsThinkingCausalLoops(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "scientificmethod" /* SCIENTIFICMETHOD */ && "hypothesis" in lastThought) {
          return this.visualExporter.exportScientificMethodExperiment(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "optimization" /* OPTIMIZATION */ && "objectiveFunction" in lastThought) {
          return this.visualExporter.exportOptimizationSolution(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "formallogic" /* FORMALLOGIC */ && "premises" in lastThought) {
          return this.visualExporter.exportFormalLogicProof(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "mathematics" /* MATHEMATICS */ && "proofStrategy" in lastThought) {
          return this.visualExporter.exportMathematicsDerivation(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "physics" /* PHYSICS */ && "tensorProperties" in lastThought) {
          return this.visualExporter.exportPhysicsVisualization(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "hybrid" /* HYBRID */ && "primaryMode" in lastThought) {
          return this.visualExporter.exportHybridOrchestration(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "metareasoning" /* METAREASONING */ && "currentStrategy" in lastThought) {
          return this.visualExporter.exportMetaReasoningVisualization(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        if (lastThought.mode === "engineering" /* ENGINEERING */ && "analysisType" in lastThought) {
          return this.visualExporter.exportEngineeringAnalysis(lastThought, {
            format,
            colorScheme: "default",
            includeLabels: true,
            includeMetrics: true
          });
        }
        const thoughts = session.thoughts.map(
          (t, i) => `Thought ${i + 1} (${t.mode}):
${t.content}
`
        ).join("\n");
        return `Session: ${session.title || "Untitled"}
Mode: ${lastThought.mode}

${thoughts}`;
      }
      /**
       * Export session to JSON format
       *
       * Converts the session to JSON, handling Map serialization.
       *
       * @param session - The session to export
       * @returns JSON string with pretty printing
       */
      exportToJSON(session) {
        const sessionWithCustomMetrics = {
          ...session,
          metrics: {
            ...session.metrics,
            customMetrics: Object.fromEntries(session.metrics.customMetrics)
          }
        };
        return JSON.stringify(sessionWithCustomMetrics, null, 2);
      }
      /**
       * Export session to Markdown format
       *
       * Creates a human-readable Markdown document with session details
       * and all thoughts formatted as sections.
       *
       * @param session - The session to export
       * @returns Markdown-formatted string
       */
      exportToMarkdown(session) {
        const status = session.isComplete ? "Complete" : "In Progress";
        let md = `# Thinking Session: ${session.title}

`;
        md += `**Mode**: ${session.mode}
`;
        md += `**Created**: ${session.createdAt.toISOString()}
`;
        md += `**Status**: ${status}

`;
        md += `## Thoughts

`;
        for (const thought of session.thoughts) {
          md += `### Thought ${thought.thoughtNumber}/${session.thoughts.length}

`;
          md += `${thought.content}

`;
          if (isMetaReasoningThought(thought)) {
            md += `#### \u{1F4CA} Meta-Reasoning Analysis

`;
            md += `**Current Strategy:**
`;
            md += `- Mode: ${thought.currentStrategy.mode}
`;
            md += `- Approach: ${thought.currentStrategy.approach}
`;
            md += `- Thoughts Spent: ${thought.currentStrategy.thoughtsSpent}
`;
            if (thought.currentStrategy.progressIndicators.length > 0) {
              md += `- Progress: ${thought.currentStrategy.progressIndicators.join(", ")}
`;
            }
            md += `
`;
            md += `**Strategy Evaluation:**
`;
            md += `- Effectiveness: ${(thought.strategyEvaluation.effectiveness * 100).toFixed(1)}%
`;
            md += `- Efficiency: ${(thought.strategyEvaluation.efficiency * 100).toFixed(1)}%
`;
            md += `- Confidence: ${(thought.strategyEvaluation.confidence * 100).toFixed(1)}%
`;
            md += `- Quality Score: ${(thought.strategyEvaluation.qualityScore * 100).toFixed(1)}%
`;
            if (thought.strategyEvaluation.issues.length > 0) {
              md += `- Issues: ${thought.strategyEvaluation.issues.join("; ")}
`;
            }
            if (thought.strategyEvaluation.strengths.length > 0) {
              md += `- Strengths: ${thought.strategyEvaluation.strengths.join("; ")}
`;
            }
            md += `
`;
            md += `**Recommendation:** ${thought.recommendation.action}
`;
            md += `- ${thought.recommendation.justification}
`;
            md += `- Confidence: ${(thought.recommendation.confidence * 100).toFixed(1)}%
`;
            md += `- Expected Improvement: ${thought.recommendation.expectedImprovement}
`;
            if (thought.alternativeStrategies.length > 0) {
              md += `
**Alternative Strategies:**
`;
              for (const alt of thought.alternativeStrategies) {
                md += `- **${alt.mode}** (score: ${(alt.recommendationScore * 100).toFixed(0)}%): ${alt.reasoning}
`;
              }
            }
            md += `
**Quality Metrics:**
`;
            md += `- Logical Consistency: ${(thought.qualityMetrics.logicalConsistency * 100).toFixed(1)}%
`;
            md += `- Evidence Quality: ${(thought.qualityMetrics.evidenceQuality * 100).toFixed(1)}%
`;
            md += `- Completeness: ${(thought.qualityMetrics.completeness * 100).toFixed(1)}%
`;
            md += `- Originality: ${(thought.qualityMetrics.originality * 100).toFixed(1)}%
`;
            md += `- Clarity: ${(thought.qualityMetrics.clarity * 100).toFixed(1)}%
`;
            md += `- Overall Quality: ${(thought.qualityMetrics.overallQuality * 100).toFixed(1)}%
`;
            md += `
`;
          }
        }
        return md;
      }
      /**
       * Export session to LaTeX format
       *
       * Generates a LaTeX document with proper escaping for special characters.
       * Ready for compilation with pdflatex.
       *
       * @param session - The session to export
       * @returns LaTeX document as string
       */
      exportToLatex(session) {
        const status = session.isComplete ? "Complete" : "In Progress";
        const safeTitle = escapeLatex(session.title);
        const safeMode = escapeLatex(session.mode);
        const safeStatus = escapeLatex(status);
        let latex = `\\documentclass{article}
`;
        latex += `\\usepackage[utf8]{inputenc}
`;
        latex += `\\title{${safeTitle}}
`;
        latex += `\\begin{document}
`;
        latex += `\\maketitle

`;
        latex += `\\section{Session Details}
`;
        latex += `Mode: ${safeMode}\\\\
`;
        latex += `Status: ${safeStatus}\\\\

`;
        latex += `\\section{Thoughts}
`;
        for (const thought of session.thoughts) {
          latex += `\\subsection{Thought ${thought.thoughtNumber}}
`;
          latex += `${escapeLatex(thought.content)}

`;
        }
        latex += `\\end{document}
`;
        return latex;
      }
      /**
       * Export session to HTML format
       *
       * Generates a standalone HTML page with XSS protection via escaping.
       * Includes basic styling for readability.
       *
       * Note: Currently unused as HTML export is handled by visual exporters.
       * Kept for potential future use as a session-level HTML export.
       *
       * @param session - The session to export
       * @returns HTML document as string
       */
      // @ts-expect-error - Unused method kept for future use
      exportToHTML(session) {
        const status = session.isComplete ? "Complete" : "In Progress";
        const safeTitle = escapeHtml(session.title);
        const safeMode = escapeHtml(session.mode);
        const safeStatus = escapeHtml(status);
        let html = `<!DOCTYPE html>
<html>
<head>
`;
        html += `  <meta charset="UTF-8">
`;
        html += `  <meta name="viewport" content="width=device-width, initial-scale=1.0">
`;
        html += `  <title>${safeTitle}</title>
`;
        html += `  <style>body { font-family: Arial, sans-serif; max-width: 800px; margin: 50px auto; padding: 0 20px; }</style>
`;
        html += `</head>
<body>
`;
        html += `  <h1>${safeTitle}</h1>
`;
        html += `  <p><strong>Mode:</strong> ${safeMode}</p>
`;
        html += `  <p><strong>Status:</strong> ${safeStatus}</p>
`;
        html += `  <h2>Thoughts</h2>
`;
        for (const thought of session.thoughts) {
          html += `  <div>
`;
          html += `    <h3>Thought ${thought.thoughtNumber}/${session.thoughts.length}</h3>
`;
          html += `    <p>${escapeHtml(thought.content)}</p>
`;
          html += `  </div>
`;
        }
        html += `</body>
</html>
`;
        return html;
      }
      /**
       * Export session to Jupyter Notebook format
       *
       * Creates a .ipynb file structure with Markdown cells for each thought.
       * Compatible with Jupyter Notebook and JupyterLab.
       *
       * @param session - The session to export
       * @returns JSON string representing Jupyter notebook
       */
      exportToJupyter(session) {
        const status = session.isComplete ? "Complete" : "In Progress";
        const notebook = {
          cells: [],
          metadata: {},
          nbformat: 4,
          nbformat_minor: 2
        };
        notebook.cells.push({
          cell_type: "markdown",
          metadata: {},
          source: [
            `# Thinking Session: ${session.title}
`,
            `
`,
            `**Mode**: ${session.mode}
`,
            `**Status**: ${status}
`
          ]
        });
        for (const thought of session.thoughts) {
          notebook.cells.push({
            cell_type: "markdown",
            metadata: {},
            source: [
              `## Thought ${thought.thoughtNumber}/${session.thoughts.length}
`,
              `
`,
              `${thought.content}
`
            ]
          });
        }
        return JSON.stringify(notebook, null, 2);
      }
    };
  }
});

// src/services/ModeRouter.ts
var ModeRouter;
var init_ModeRouter = __esm({
  "src/services/ModeRouter.ts"() {
    init_esm_shims();
    init_types();
    init_logger();
    init_MetaMonitor();
    ModeRouter = class {
      sessionManager;
      recommender;
      logger;
      monitor;
      /**
       * Create a new ModeRouter
       *
       * @param sessionManager - Session manager instance for mode switching
       * @param logger - Optional logger for dependency injection
       * @param monitor - Optional MetaMonitor instance for dependency injection
       *
       * @example
       * ```typescript
       * const router = new ModeRouter(sessionManager);
       * // Or with DI:
       * const router = new ModeRouter(sessionManager, customLogger, customMonitor);
       * ```
       */
      constructor(sessionManager, logger2, monitor) {
        this.sessionManager = sessionManager;
        this.recommender = new ModeRecommender();
        this.logger = logger2 || createLogger({ minLevel: 1 /* INFO */, enableConsole: true });
        this.monitor = monitor || metaMonitor;
      }
      /**
       * Switch a session to a new thinking mode
       *
       * Changes the thinking mode of an active session while preserving
       * existing thoughts. Useful when the problem characteristics change
       * or initial mode selection was suboptimal.
       *
       * @param sessionId - ID of the session to switch
       * @param newMode - The new thinking mode to use
       * @param reason - Reason for the mode switch (for logging)
       * @returns The updated session
       * @throws {Error} If session not found
       *
       * @example
       * ```typescript
       * const session = await router.switchMode(
       *   'session-123',
       *   ThinkingMode.MATHEMATICS,
       *   'Problem requires mathematical proof'
       * );
       * ```
       */
      async switchMode(sessionId, newMode, reason) {
        this.logger.info("Switching mode", {
          sessionId,
          newMode,
          reason
        });
        const session = await this.sessionManager.switchMode(sessionId, newMode, reason);
        this.logger.debug("Mode switch completed", {
          sessionId,
          newMode,
          thoughtCount: session.thoughts.length
        });
        return session;
      }
      /**
       * Get quick mode recommendation based on problem type
       *
       * Provides a fast, single-mode recommendation based on a simple
       * problem type string. Useful for quick suggestions without detailed
       * problem analysis.
       *
       * @param problemType - Simple problem type description
       * @returns Recommended thinking mode
       *
       * @example
       * ```typescript
       * const mode = router.quickRecommend('mathematical proof');
       * // Returns: ThinkingMode.MATHEMATICS
       * ```
       */
      quickRecommend(problemType) {
        this.logger.debug("Quick recommend requested", { problemType });
        const mode = this.recommender.quickRecommend(problemType);
        this.logger.debug("Quick recommend result", { problemType, recommendedMode: mode });
        return mode;
      }
      /**
       * Get comprehensive mode recommendations
       *
       * Analyzes problem characteristics and returns ranked recommendations
       * for individual modes and optionally mode combinations.
       *
       * @param characteristics - Detailed problem characteristics
       * @param includeCombinations - Whether to include mode combinations
       * @returns Formatted recommendation response
       *
       * @example
       * ```typescript
       * const response = router.getRecommendations({
       *   requiresProof: true,
       *   hasQuantities: true,
       *   hasUncertainty: false
       * }, true);
       * ```
       */
      getRecommendations(characteristics, includeCombinations = false) {
        this.logger.debug("Getting mode recommendations", {
          characteristics,
          includeCombinations
        });
        const modeRecs = this.recommender.recommendModes(characteristics);
        const combinationRecs = includeCombinations ? this.recommender.recommendCombinations(characteristics) : [];
        this.logger.debug("Recommendations generated", {
          modeCount: modeRecs.length,
          combinationCount: combinationRecs.length,
          topMode: modeRecs[0]?.mode,
          topScore: modeRecs[0]?.score
        });
        let response = "# Mode Recommendations\n\n";
        response += "## Individual Modes\n\n";
        for (const rec of modeRecs) {
          response += `### ${rec.mode} (Score: ${rec.score})
`;
          response += `**Reasoning**: ${rec.reasoning}

`;
          response += `**Strengths**:
`;
          for (const strength of rec.strengths) {
            response += `- ${strength}
`;
          }
          response += `
**Limitations**:
`;
          for (const limitation of rec.limitations) {
            response += `- ${limitation}
`;
          }
          response += `
**Examples**: ${rec.examples.join(", ")}

`;
          response += "---\n\n";
        }
        if (combinationRecs.length > 0) {
          response += "## Recommended Mode Combinations\n\n";
          for (const combo of combinationRecs) {
            response += `### ${combo.modes.join(" + ")} (${combo.sequence})
`;
            response += `**Rationale**: ${combo.rationale}

`;
            response += `**Benefits**:
`;
            for (const benefit of combo.benefits) {
              response += `- ${benefit}
`;
            }
            response += `
**Synergies**:
`;
            for (const synergy of combo.synergies) {
              response += `- ${synergy}
`;
            }
            response += "\n---\n\n";
          }
        }
        return response;
      }
      /**
       * Format a quick recommendation response
       *
       * Creates a formatted response for quick recommendations.
       *
       * @param problemType - The problem type that was analyzed
       * @param recommendedMode - The recommended mode
       * @returns Formatted response string
       */
      formatQuickRecommendation(problemType, recommendedMode) {
        return `Quick recommendation for "${problemType}":

**Recommended Mode**: ${recommendedMode}

For more detailed recommendations, provide problemCharacteristics.`;
      }
      /**
       * Evaluate current session and suggest mode switch if beneficial
       *
       * Uses meta-reasoning to evaluate the current strategy effectiveness
       * and suggest alternative modes if the current approach is suboptimal.
       *
       * @param sessionId - Session to evaluate
       * @param problemType - Optional problem type for context
       * @returns Evaluation result with switch recommendation
       *
       * @example
       * ```typescript
       * const evaluation = await router.evaluateAndSuggestSwitch('session-123', 'debugging');
       * if (evaluation.shouldSwitch) {
       *   await router.switchMode(sessionId, evaluation.suggestedMode!, evaluation.reasoning);
       * }
       * ```
       */
      async evaluateAndSuggestSwitch(sessionId, problemType = "general") {
        this.logger.debug("Evaluating session for potential mode switch", { sessionId, problemType });
        const evaluation = this.monitor.evaluateStrategy(sessionId);
        const session = await this.sessionManager.getSession(sessionId);
        const currentMode = session?.mode || "sequential" /* SEQUENTIAL */;
        const alternatives = this.monitor.suggestAlternatives(sessionId, currentMode);
        const shouldSwitch = evaluation.effectiveness < 0.4 || evaluation.effectiveness < 0.6 && alternatives.length > 0 && alternatives[0].recommendationScore > 0.75;
        const suggestedMode = shouldSwitch && alternatives.length > 0 ? alternatives[0].mode : void 0;
        const reasoning = shouldSwitch ? `Current strategy effectiveness: ${(evaluation.effectiveness * 100).toFixed(1)}%. ${alternatives[0]?.reasoning || "Consider switching modes."}` : `Current strategy performing adequately (effectiveness: ${(evaluation.effectiveness * 100).toFixed(1)}%). Continue with current mode.`;
        this.logger.debug("Mode switch evaluation completed", {
          sessionId,
          shouldSwitch,
          suggestedMode,
          currentEffectiveness: evaluation.effectiveness
        });
        return {
          currentEvaluation: evaluation,
          shouldSwitch,
          suggestedMode,
          reasoning,
          alternatives
        };
      }
      /**
       * Auto-switch mode if current strategy is failing
       *
       * Automatically evaluates and switches modes if the current approach
       * is demonstrably ineffective (effectiveness < 0.3).
       *
       * @param sessionId - Session to evaluate
       * @param problemType - Optional problem type for context
       * @returns Switch result with details
       *
       * @example
       * ```typescript
       * const result = await router.autoSwitchIfNeeded('session-123', 'complex-problem');
       * console.log(result.switched ? 'Switched to' + result.newMode : 'No switch needed');
       * ```
       */
      async autoSwitchIfNeeded(sessionId, problemType = "general") {
        this.logger.debug("Auto-switch evaluation", { sessionId, problemType });
        const evaluation = await this.evaluateAndSuggestSwitch(sessionId, problemType);
        const autoSwitchThreshold = 0.3;
        if (evaluation.currentEvaluation.effectiveness < autoSwitchThreshold && evaluation.suggestedMode) {
          const session = await this.sessionManager.getSession(sessionId);
          const oldMode = session?.mode || "sequential" /* SEQUENTIAL */;
          await this.switchMode(sessionId, evaluation.suggestedMode, evaluation.reasoning);
          this.logger.info("Auto-switched mode due to low effectiveness", {
            sessionId,
            oldMode,
            newMode: evaluation.suggestedMode,
            effectiveness: evaluation.currentEvaluation.effectiveness
          });
          return {
            switched: true,
            oldMode,
            newMode: evaluation.suggestedMode,
            reasoning: evaluation.reasoning,
            evaluation: evaluation.currentEvaluation
          };
        }
        this.logger.debug("Auto-switch not needed", {
          sessionId,
          effectiveness: evaluation.currentEvaluation.effectiveness,
          threshold: autoSwitchThreshold
        });
        return {
          switched: false,
          reasoning: evaluation.reasoning,
          evaluation: evaluation.currentEvaluation
        };
      }
    };
  }
});

// src/services/index.ts
var services_exports = {};
__export(services_exports, {
  ExportService: () => ExportService,
  ModeRouter: () => ModeRouter,
  RefactoredThoughtFactory: () => RefactoredThoughtFactory,
  ThoughtFactory: () => ThoughtFactory
});
var init_services = __esm({
  "src/services/index.ts"() {
    init_esm_shims();
    init_ThoughtFactory();
    init_RefactoredThoughtFactory();
    init_ExportService();
    init_ModeRouter();
  }
});
var DependencyGraphBuilder;
var init_dependency_graph = __esm({
  "src/proof/dependency-graph.ts"() {
    init_esm_shims();
    DependencyGraphBuilder = class {
      nodes;
      edges;
      adjacencyList;
      // node -> nodes it points to
      reverseAdjacencyList;
      // node -> nodes pointing to it
      constructor() {
        this.nodes = /* @__PURE__ */ new Map();
        this.edges = [];
        this.adjacencyList = /* @__PURE__ */ new Map();
        this.reverseAdjacencyList = /* @__PURE__ */ new Map();
      }
      /**
       * Add a statement to the graph
       */
      addStatement(statement) {
        this.nodes.set(statement.id, statement);
        if (!this.adjacencyList.has(statement.id)) {
          this.adjacencyList.set(statement.id, []);
        }
        if (!this.reverseAdjacencyList.has(statement.id)) {
          this.reverseAdjacencyList.set(statement.id, []);
        }
      }
      /**
       * Create and add a new statement
       */
      createStatement(statement, type, options) {
        const newStatement = {
          id: randomUUID(),
          statement,
          type,
          confidence: options?.confidence ?? 1,
          isExplicit: options?.isExplicit ?? true,
          ...options
        };
        this.addStatement(newStatement);
        return newStatement;
      }
      /**
       * Add a dependency edge between two statements
       *
       * @param from - ID of the source statement (prerequisite)
       * @param to - ID of the target statement (depends on source)
       * @param type - Type of dependency
       * @param options - Additional edge options
       */
      addDependency(from, to, type = "logical", options) {
        if (!this.nodes.has(from)) {
          throw new Error(`Source node '${from}' not found in graph`);
        }
        if (!this.nodes.has(to)) {
          throw new Error(`Target node '${to}' not found in graph`);
        }
        const edge = {
          from,
          to,
          type,
          strength: options?.strength ?? 1,
          inferenceRule: options?.inferenceRule
        };
        this.edges.push(edge);
        const adj = this.adjacencyList.get(from) || [];
        adj.push(to);
        this.adjacencyList.set(from, adj);
        const revAdj = this.reverseAdjacencyList.get(to) || [];
        revAdj.push(from);
        this.reverseAdjacencyList.set(to, revAdj);
      }
      /**
       * Find root nodes (axioms/hypotheses with no incoming edges)
       */
      findRoots() {
        const roots = [];
        for (const [nodeId] of this.nodes) {
          const incoming = this.reverseAdjacencyList.get(nodeId) || [];
          if (incoming.length === 0) {
            roots.push(nodeId);
          }
        }
        return roots;
      }
      /**
       * Find leaf nodes (conclusions with no outgoing edges)
       */
      findLeaves() {
        const leaves = [];
        for (const [nodeId] of this.nodes) {
          const outgoing = this.adjacencyList.get(nodeId) || [];
          if (outgoing.length === 0) {
            leaves.push(nodeId);
          }
        }
        return leaves;
      }
      /**
       * Get all ancestors of a node (all nodes that lead to this node)
       */
      getAncestors(nodeId) {
        const ancestors = /* @__PURE__ */ new Set();
        const visited = /* @__PURE__ */ new Set();
        const stack = [nodeId];
        while (stack.length > 0) {
          const current = stack.pop();
          if (visited.has(current)) continue;
          visited.add(current);
          const parents = this.reverseAdjacencyList.get(current) || [];
          for (const parent of parents) {
            ancestors.add(parent);
            stack.push(parent);
          }
        }
        return Array.from(ancestors);
      }
      /**
       * Get all descendants of a node (all nodes that depend on this node)
       */
      getDescendants(nodeId) {
        const descendants = /* @__PURE__ */ new Set();
        const visited = /* @__PURE__ */ new Set();
        const stack = [nodeId];
        while (stack.length > 0) {
          const current = stack.pop();
          if (visited.has(current)) continue;
          visited.add(current);
          const children = this.adjacencyList.get(current) || [];
          for (const child of children) {
            descendants.add(child);
            stack.push(child);
          }
        }
        return Array.from(descendants);
      }
      /**
       * Compute the depth of the graph (longest path from any root to any leaf)
       */
      computeDepth() {
        const roots = this.findRoots();
        if (roots.length === 0) return 0;
        let maxDepth = 0;
        const memo = /* @__PURE__ */ new Map();
        const dfs = (nodeId, visited) => {
          if (memo.has(nodeId)) return memo.get(nodeId);
          if (visited.has(nodeId)) return 0;
          visited.add(nodeId);
          const children = this.adjacencyList.get(nodeId) || [];
          if (children.length === 0) {
            memo.set(nodeId, 1);
            return 1;
          }
          let maxChildDepth = 0;
          for (const child of children) {
            maxChildDepth = Math.max(maxChildDepth, dfs(child, new Set(visited)));
          }
          const depth = 1 + maxChildDepth;
          memo.set(nodeId, depth);
          return depth;
        };
        for (const root of roots) {
          maxDepth = Math.max(maxDepth, dfs(root, /* @__PURE__ */ new Set()));
        }
        return maxDepth;
      }
      /**
       * Compute the width of the graph (maximum nodes at any level)
       */
      computeWidth() {
        const roots = this.findRoots();
        if (roots.length === 0) return 0;
        const levels = /* @__PURE__ */ new Map();
        const queue = roots.map((r) => ({
          nodeId: r,
          level: 0
        }));
        const visited = /* @__PURE__ */ new Set();
        while (queue.length > 0) {
          const { nodeId, level } = queue.shift();
          if (visited.has(nodeId)) continue;
          visited.add(nodeId);
          levels.set(nodeId, level);
          const children = this.adjacencyList.get(nodeId) || [];
          for (const child of children) {
            if (!visited.has(child)) {
              queue.push({ nodeId: child, level: level + 1 });
            }
          }
        }
        const levelCounts = /* @__PURE__ */ new Map();
        for (const [, level] of levels) {
          levelCounts.set(level, (levelCounts.get(level) || 0) + 1);
        }
        return Math.max(...levelCounts.values(), 0);
      }
      /**
       * Detect cycles using Tarjan's algorithm for strongly connected components
       * Returns arrays of node IDs that form cycles
       */
      detectCycles() {
        const index = /* @__PURE__ */ new Map();
        const lowlink = /* @__PURE__ */ new Map();
        const onStack = /* @__PURE__ */ new Set();
        const stack = [];
        const sccs = [];
        let currentIndex = 0;
        const strongConnect = (nodeId) => {
          index.set(nodeId, currentIndex);
          lowlink.set(nodeId, currentIndex);
          currentIndex++;
          stack.push(nodeId);
          onStack.add(nodeId);
          const neighbors = this.adjacencyList.get(nodeId) || [];
          for (const neighbor of neighbors) {
            if (!index.has(neighbor)) {
              strongConnect(neighbor);
              lowlink.set(nodeId, Math.min(lowlink.get(nodeId), lowlink.get(neighbor)));
            } else if (onStack.has(neighbor)) {
              lowlink.set(nodeId, Math.min(lowlink.get(nodeId), index.get(neighbor)));
            }
          }
          if (lowlink.get(nodeId) === index.get(nodeId)) {
            const scc = [];
            let w;
            do {
              w = stack.pop();
              onStack.delete(w);
              scc.push(w);
            } while (w !== nodeId);
            if (scc.length > 1) {
              sccs.push(scc);
            } else if (scc.length === 1) {
              const selfLoops = this.adjacencyList.get(scc[0]) || [];
              if (selfLoops.includes(scc[0])) {
                sccs.push(scc);
              }
            }
          }
        };
        for (const [nodeId] of this.nodes) {
          if (!index.has(nodeId)) {
            strongConnect(nodeId);
          }
        }
        return sccs;
      }
      /**
       * Check if the graph has any cycles
       */
      hasCycles() {
        return this.detectCycles().length > 0;
      }
      /**
       * Get topological order of nodes (only valid if no cycles)
       * Returns null if cycles exist
       */
      getTopologicalOrder() {
        if (this.hasCycles()) {
          return null;
        }
        const inDegree = /* @__PURE__ */ new Map();
        for (const [nodeId] of this.nodes) {
          inDegree.set(nodeId, 0);
        }
        for (const edge of this.edges) {
          inDegree.set(edge.to, (inDegree.get(edge.to) || 0) + 1);
        }
        const queue = [];
        for (const [nodeId, degree] of inDegree) {
          if (degree === 0) {
            queue.push(nodeId);
          }
        }
        const result = [];
        while (queue.length > 0) {
          const current = queue.shift();
          result.push(current);
          const neighbors = this.adjacencyList.get(current) || [];
          for (const neighbor of neighbors) {
            const newDegree = (inDegree.get(neighbor) || 0) - 1;
            inDegree.set(neighbor, newDegree);
            if (newDegree === 0) {
              queue.push(neighbor);
            }
          }
        }
        return result.length === this.nodes.size ? result : null;
      }
      /**
       * Find a path between two nodes
       * Returns null if no path exists
       */
      findPath(from, to) {
        if (!this.nodes.has(from) || !this.nodes.has(to)) {
          return null;
        }
        const visited = /* @__PURE__ */ new Set();
        const parent = /* @__PURE__ */ new Map();
        const queue = [from];
        visited.add(from);
        while (queue.length > 0) {
          const current = queue.shift();
          if (current === to) {
            const path4 = [];
            let node = to;
            while (node !== void 0) {
              path4.unshift(node);
              node = parent.get(node);
            }
            return path4;
          }
          const neighbors = this.adjacencyList.get(current) || [];
          for (const neighbor of neighbors) {
            if (!visited.has(neighbor)) {
              visited.add(neighbor);
              parent.set(neighbor, current);
              queue.push(neighbor);
            }
          }
        }
        return null;
      }
      /**
       * Find all paths between two nodes
       */
      findAllPaths(from, to, maxPaths = 100) {
        if (!this.nodes.has(from) || !this.nodes.has(to)) {
          return [];
        }
        const paths = [];
        const dfs = (current, path4, visited2) => {
          if (paths.length >= maxPaths) return;
          if (current === to) {
            paths.push([...path4]);
            return;
          }
          const neighbors = this.adjacencyList.get(current) || [];
          for (const neighbor of neighbors) {
            if (!visited2.has(neighbor)) {
              visited2.add(neighbor);
              path4.push(neighbor);
              dfs(neighbor, path4, visited2);
              path4.pop();
              visited2.delete(neighbor);
            }
          }
        };
        const visited = /* @__PURE__ */ new Set([from]);
        dfs(from, [from], visited);
        return paths;
      }
      /**
       * Build the complete dependency graph
       */
      build() {
        const cycles = this.detectCycles();
        const hasCycles = cycles.length > 0;
        const topologicalOrder = hasCycles ? void 0 : this.getTopologicalOrder() ?? void 0;
        return {
          nodes: new Map(this.nodes),
          edges: [...this.edges],
          roots: this.findRoots(),
          leaves: this.findLeaves(),
          depth: this.computeDepth(),
          width: this.computeWidth(),
          hasCycles,
          stronglyConnectedComponents: hasCycles ? cycles : void 0,
          topologicalOrder
        };
      }
      /**
       * Get the number of nodes in the graph
       */
      get nodeCount() {
        return this.nodes.size;
      }
      /**
       * Get the number of edges in the graph
       */
      get edgeCount() {
        return this.edges.length;
      }
      /**
       * Check if a node exists
       */
      hasNode(nodeId) {
        return this.nodes.has(nodeId);
      }
      /**
       * Get a node by ID
       */
      getNode(nodeId) {
        return this.nodes.get(nodeId);
      }
      /**
       * Get all nodes
       */
      getAllNodes() {
        return Array.from(this.nodes.values());
      }
      /**
       * Get all edges
       */
      getAllEdges() {
        return [...this.edges];
      }
      /**
       * Clear the graph
       */
      clear() {
        this.nodes.clear();
        this.edges = [];
        this.adjacencyList.clear();
        this.reverseAdjacencyList.clear();
      }
    };
  }
});
var ProofDecomposer;
var init_decomposer = __esm({
  "src/proof/decomposer.ts"() {
    init_esm_shims();
    init_dependency_graph();
    ProofDecomposer = class {
      statementPatterns;
      dependencyPatterns;
      constructor() {
        this.statementPatterns = this.initializeStatementPatterns();
        this.dependencyPatterns = this.initializeDependencyPatterns();
      }
      /**
       * Initialize patterns for extracting statements from proof text
       */
      initializeStatementPatterns() {
        return [
          // Axiom patterns
          {
            pattern: /^(?:Axiom|Postulate)\s*(?:\d+)?[:\.]?\s*(.+)$/i,
            type: "axiom",
            extractStatement: (m) => m[1].trim()
          },
          // Definition patterns
          {
            pattern: /^(?:Definition|Def\.?)\s*(?:\d+)?[:\.]?\s*(.+)$/i,
            type: "definition",
            extractStatement: (m) => m[1].trim()
          },
          {
            pattern: /^(?:Let|Define)\s+(.+?)(?:\s+be\s+|\s*:=\s*|\s*=\s*)(.+)$/i,
            type: "definition",
            extractStatement: (m) => `${m[1]} be ${m[2]}`.trim()
          },
          // Hypothesis/Assumption patterns
          {
            pattern: /^(?:Assume|Suppose|Given|Hypothesis|Let)\s+(?:that\s+)?(.+)$/i,
            type: "hypothesis",
            extractStatement: (m) => m[1].trim()
          },
          // Lemma patterns
          {
            pattern: /^(?:Lemma|Claim)\s*(?:\d+)?[:\.]?\s*(.+)$/i,
            type: "lemma",
            extractStatement: (m) => m[1].trim()
          },
          // Conclusion patterns
          {
            pattern: /^(?:Therefore|Thus|Hence|So|Consequently|It follows that|We conclude|QED|)\s*[,:]?\s*(.+)$/i,
            type: "conclusion",
            extractStatement: (m) => m[1].trim()
          },
          // Derived statement patterns
          {
            pattern: /^(?:By|From|Using|Since)\s+(.+?)[,\s]+(?:we have|we get|we obtain|it follows|this gives)\s+(.+)$/i,
            type: "derived",
            extractStatement: (m) => m[2].trim(),
            extractJustification: (m) => m[1].trim()
          },
          {
            pattern: /^(?:This|Which)\s+(?:implies|gives|yields|means|shows)\s+(?:that\s+)?(.+)$/i,
            type: "derived",
            extractStatement: (m) => m[1].trim()
          },
          // General derived (fallback)
          {
            pattern: /^(.+)$/,
            type: "derived",
            extractStatement: (m) => m[1].trim()
          }
        ];
      }
      /**
       * Initialize patterns for inferring dependencies
       */
      initializeDependencyPatterns() {
        return [
          // Modus ponens: "By X, we have Y" or "From X, Y"
          {
            pattern: /(?:by|from|using)\s+(.+?)(?:,\s*(?:we have|we get|it follows|we obtain)|$)/i,
            inferenceRule: "modus_ponens",
            extractDependencies: (match, statementIds) => {
              const referenced = match[1];
              return this.findMatchingStatements(referenced, statementIds);
            }
          },
          // Substitution: "Substituting X into Y"
          {
            pattern: /substitut(?:e|ing)\s+(.+?)\s+(?:into|in)\s+(.+)/i,
            inferenceRule: "substitution",
            extractDependencies: (match, statementIds) => {
              const deps = [
                ...this.findMatchingStatements(match[1], statementIds),
                ...this.findMatchingStatements(match[2], statementIds)
              ];
              return [...new Set(deps)];
            }
          },
          // Definition expansion: "By definition of X"
          {
            pattern: /(?:by\s+)?(?:the\s+)?definition\s+(?:of\s+)?(.+)/i,
            inferenceRule: "definition_expansion",
            extractDependencies: (match, statementIds) => {
              return this.findMatchingStatements(match[1], statementIds);
            }
          },
          // Contradiction: "contradicts" or "contradiction"
          {
            pattern: /(?:this\s+)?contradicts?\s+(.+)/i,
            inferenceRule: "contradiction",
            extractDependencies: (match, statementIds) => {
              return this.findMatchingStatements(match[1], statementIds);
            }
          },
          // Mathematical induction
          {
            pattern: /by\s+(?:mathematical\s+)?induction/i,
            inferenceRule: "mathematical_induction",
            extractDependencies: () => []
          },
          // Hypothetical syllogism: "Since X implies Y, and Y implies Z"
          {
            pattern: /since\s+(.+?)\s+implies\s+(.+?),\s+and\s+(.+?)\s+implies\s+(.+)/i,
            inferenceRule: "hypothetical_syllogism",
            extractDependencies: (match, statementIds) => {
              const deps = [
                ...this.findMatchingStatements(match[1], statementIds),
                ...this.findMatchingStatements(match[2], statementIds)
              ];
              return [...new Set(deps)];
            }
          }
        ];
      }
      /**
       * Find statements that match a reference
       */
      findMatchingStatements(reference, statementIds) {
        const matches = [];
        const refLower = reference.toLowerCase().trim();
        for (const [statement, id] of statementIds) {
          const stmtLower = statement.toLowerCase();
          if (stmtLower.includes(refLower) || refLower.includes(stmtLower) || this.hasSignificantOverlap(refLower, stmtLower)) {
            matches.push(id);
          }
        }
        return matches;
      }
      /**
       * Check if two strings have significant word overlap
       */
      hasSignificantOverlap(a, b) {
        const wordsA = new Set(a.split(/\s+/).filter((w) => w.length > 2));
        const wordsB = new Set(b.split(/\s+/).filter((w) => w.length > 2));
        if (wordsA.size === 0 || wordsB.size === 0) return false;
        let overlap = 0;
        for (const word of wordsA) {
          if (wordsB.has(word)) overlap++;
        }
        return overlap / Math.min(wordsA.size, wordsB.size) > 0.5;
      }
      /**
       * Decompose a proof into atomic statements
       *
       * @param proof - The proof text or structured steps
       * @param theorem - Optional theorem being proven
       * @returns ProofDecomposition with atoms and dependencies
       */
      decompose(proof, theorem) {
        const id = randomUUID();
        const steps = typeof proof === "string" ? this.parseProofText(proof) : proof;
        const originalProof = typeof proof === "string" ? proof : steps.map((s) => s.content).join("\n");
        const atoms = this.extractStatements(steps);
        const statementIds = /* @__PURE__ */ new Map();
        for (const atom of atoms) {
          statementIds.set(atom.statement, atom.id);
        }
        this.inferDependencies(atoms, steps, statementIds);
        const dependencies = this.buildDependencyGraph(atoms);
        const assumptionChains = this.traceAssumptionChains(atoms, dependencies);
        const gaps = this.detectBasicGaps(atoms, dependencies);
        const implicitAssumptions = this.findImplicitAssumptions(atoms, steps);
        const completeness = this.computeCompleteness(atoms, gaps);
        const rigorLevel = this.assessRigorLevel(atoms, gaps, implicitAssumptions);
        return {
          id,
          originalProof,
          theorem,
          atoms,
          dependencies,
          assumptionChains,
          gaps,
          implicitAssumptions,
          completeness,
          rigorLevel,
          atomCount: atoms.length,
          maxDependencyDepth: dependencies.depth
        };
      }
      /**
       * Parse proof text into structured steps
       */
      parseProofText(text) {
        const sentences = text.split(/(?<=[.!?])\s+|\n+/).map((s) => s.trim()).filter((s) => s.length > 0);
        return sentences.map((content) => ({ content }));
      }
      /**
       * Extract atomic statements from proof steps
       */
      extractStatements(steps) {
        const atoms = [];
        for (let i = 0; i < steps.length; i++) {
          const step = steps[i];
          const atom = this.classifyStatement(step, i);
          if (atom) {
            atoms.push(atom);
          }
        }
        return atoms;
      }
      /**
       * Classify a proof step into an atomic statement
       */
      classifyStatement(step, stepNumber) {
        const content = step.content.trim();
        if (!content) return null;
        for (const pattern of this.statementPatterns) {
          const match = content.match(pattern.pattern);
          if (match) {
            const statement = pattern.extractStatement(match);
            const justification = pattern.extractJustification?.(match) || step.justification;
            return {
              id: `stmt-${stepNumber + 1}`,
              statement,
              latex: step.latex,
              type: pattern.type,
              justification,
              confidence: this.computeConfidence(pattern.type, justification),
              isExplicit: true,
              sourceLocation: { stepNumber: stepNumber + 1 }
            };
          }
        }
        return {
          id: `stmt-${stepNumber + 1}`,
          statement: content,
          latex: step.latex,
          type: "derived",
          justification: step.justification,
          confidence: 0.7,
          isExplicit: true,
          sourceLocation: { stepNumber: stepNumber + 1 }
        };
      }
      /**
       * Compute confidence based on statement type and justification
       */
      computeConfidence(type, justification) {
        const baseConfidence = {
          axiom: 1,
          definition: 1,
          hypothesis: 1,
          lemma: 0.9,
          derived: 0.8,
          conclusion: 0.85
        };
        let confidence = baseConfidence[type];
        if (justification) {
          confidence = Math.min(1, confidence + 0.1);
        }
        return confidence;
      }
      /**
       * Infer dependencies between statements
       */
      inferDependencies(atoms, steps, statementIds) {
        for (let i = 0; i < atoms.length; i++) {
          const atom = atoms[i];
          const step = steps[i];
          if (atom.type === "axiom" || atom.type === "definition" || atom.type === "hypothesis") {
            continue;
          }
          const fullText = `${step.content} ${step.justification || ""}`;
          const dependencies = [];
          let inferenceRule;
          for (const depPattern of this.dependencyPatterns) {
            const match = fullText.match(depPattern.pattern);
            if (match) {
              const deps = depPattern.extractDependencies(match, statementIds);
              dependencies.push(...deps);
              if (!inferenceRule) {
                inferenceRule = depPattern.inferenceRule;
              }
            }
          }
          if (dependencies.length === 0 && i > 0) {
            for (let j = i - 1; j >= 0; j--) {
              if (atoms[j].type !== "conclusion") {
                dependencies.push(atoms[j].id);
                break;
              }
            }
          }
          if (dependencies.length > 0) {
            atom.derivedFrom = [...new Set(dependencies)];
            atom.usedInferenceRule = inferenceRule || "direct_implication";
          }
        }
      }
      /**
       * Build dependency graph from atoms
       */
      buildDependencyGraph(atoms) {
        const builder = new DependencyGraphBuilder();
        for (const atom of atoms) {
          builder.addStatement(atom);
        }
        for (const atom of atoms) {
          if (atom.derivedFrom) {
            for (const depId of atom.derivedFrom) {
              builder.addDependency(depId, atom.id, "logical", {
                inferenceRule: atom.usedInferenceRule
              });
            }
          }
        }
        return builder.build();
      }
      /**
       * Trace assumption chains from conclusions to axioms
       */
      traceAssumptionChains(atoms, graph) {
        const chains = [];
        const conclusions = atoms.filter((a) => a.type === "conclusion");
        for (const conclusion of conclusions) {
          const assumptions = [];
          const path4 = [];
          const visited = /* @__PURE__ */ new Set();
          const trace = (id) => {
            if (visited.has(id)) return;
            visited.add(id);
            const atom = graph.nodes.get(id);
            if (!atom) return;
            path4.push(id);
            if (atom.type === "axiom" || atom.type === "definition" || atom.type === "hypothesis") {
              assumptions.push(id);
              return;
            }
            if (atom.derivedFrom) {
              for (const depId of atom.derivedFrom) {
                trace(depId);
              }
            }
          };
          trace(conclusion.id);
          chains.push({
            conclusion: conclusion.id,
            assumptions,
            path: path4.reverse(),
            allAssumptionsExplicit: true,
            // Will be updated by AssumptionTracker
            implicitAssumptions: []
          });
        }
        return chains;
      }
      /**
       * Detect basic gaps in the proof
       */
      detectBasicGaps(atoms, graph) {
        const gaps = [];
        let gapCount = 0;
        for (const atom of atoms) {
          if ((atom.type === "derived" || atom.type === "conclusion") && (!atom.derivedFrom || atom.derivedFrom.length === 0)) {
            gaps.push({
              id: `gap-${++gapCount}`,
              type: "unjustified_leap",
              location: {
                from: "unknown",
                to: atom.id
              },
              description: `Statement "${atom.statement.substring(0, 50)}..." lacks explicit justification`,
              severity: atom.type === "conclusion" ? "significant" : "minor",
              suggestedFix: "Add explicit derivation steps or reference to supporting statements"
            });
          }
        }
        const reachable = /* @__PURE__ */ new Set();
        const stack = [...graph.roots];
        while (stack.length > 0) {
          const id = stack.pop();
          if (reachable.has(id)) continue;
          reachable.add(id);
          for (const edge of graph.edges) {
            if (edge.from === id && !reachable.has(edge.to)) {
              stack.push(edge.to);
            }
          }
        }
        for (const atom of atoms) {
          if (!reachable.has(atom.id) && atom.type !== "axiom" && atom.type !== "definition" && atom.type !== "hypothesis") {
            gaps.push({
              id: `gap-${++gapCount}`,
              type: "missing_step",
              location: {
                from: "root",
                to: atom.id
              },
              description: `Statement "${atom.statement.substring(0, 50)}..." is disconnected from the proof structure`,
              severity: "significant",
              suggestedFix: "Connect this statement to the main proof chain"
            });
          }
        }
        return gaps;
      }
      /**
       * Find implicit assumptions in the proof
       */
      findImplicitAssumptions(atoms, steps) {
        const implicitAssumptions = [];
        let count = 0;
        const implicitPatterns = [
          {
            pattern: /(?:clearly|obviously|trivially|it is clear that)/i,
            type: "existence_assumption",
            suggestedFormulation: (text) => `Explicitly state and justify: "${text.substring(0, 50)}..."`
          },
          {
            pattern: /(?:for\s+(?:all|any|every)|)\s+([a-zA-Z_]\w*)/i,
            type: "domain_assumption",
            suggestedFormulation: (_text, match) => `Specify the domain of ${match[1]}`
          },
          {
            pattern: /(?:there\s+exists?|)\s+([a-zA-Z_]\w*)/i,
            type: "existence_assumption",
            suggestedFormulation: (_text, match) => `Prove existence of ${match[1]} or cite a theorem`
          },
          {
            pattern: /(?:unique|the\s+only)/i,
            type: "uniqueness_assumption",
            suggestedFormulation: () => "Prove uniqueness or cite a uniqueness theorem"
          },
          {
            pattern: /(?:continuous|differentiable|integrable)/i,
            type: "continuity_assumption",
            suggestedFormulation: () => "State continuity/differentiability assumptions explicitly"
          },
          {
            pattern: /(?:finite|bounded)/i,
            type: "finiteness_assumption",
            suggestedFormulation: () => "State finiteness/boundedness assumptions explicitly"
          }
        ];
        for (let i = 0; i < steps.length; i++) {
          const step = steps[i];
          const atom = atoms[i];
          if (!atom) continue;
          for (const { pattern, type, suggestedFormulation } of implicitPatterns) {
            const match = step.content.match(pattern);
            if (match) {
              implicitAssumptions.push({
                id: `impl-${++count}`,
                statement: step.content.substring(0, 100),
                type,
                usedInStep: atom.id,
                shouldBeExplicit: true,
                suggestedFormulation: suggestedFormulation(step.content, match)
              });
              break;
            }
          }
        }
        return implicitAssumptions;
      }
      /**
       * Compute proof completeness score
       */
      computeCompleteness(atoms, gaps) {
        if (atoms.length === 0) return 0;
        let score = 1;
        for (const gap of gaps) {
          switch (gap.severity) {
            case "critical":
              score -= 0.25;
              break;
            case "significant":
              score -= 0.1;
              break;
            case "minor":
              score -= 0.03;
              break;
          }
        }
        const justifiedCount = atoms.filter(
          (a) => a.type === "axiom" || a.type === "definition" || a.type === "hypothesis" || a.derivedFrom && a.derivedFrom.length > 0
        ).length;
        const justificationScore = justifiedCount / atoms.length;
        score = score * 0.7 + justificationScore * 0.3;
        return Math.max(0, Math.min(1, score));
      }
      /**
       * Assess the rigor level of the proof
       */
      assessRigorLevel(atoms, gaps, implicitAssumptions) {
        const criticalGaps = gaps.filter((g) => g.severity === "critical").length;
        const significantGaps = gaps.filter((g) => g.severity === "significant").length;
        const implicitCount = implicitAssumptions.filter((a) => a.shouldBeExplicit).length;
        const allJustified = atoms.every(
          (a) => a.type === "axiom" || a.type === "definition" || a.type === "hypothesis" || a.derivedFrom && a.derivedFrom.length > 0 && a.usedInferenceRule
        );
        if (criticalGaps > 0) return "informal";
        if (significantGaps > 2 || implicitCount > 3) return "informal";
        if (significantGaps > 0 || implicitCount > 1) return "textbook";
        if (!allJustified || implicitCount > 0) return "textbook";
        if (allJustified && implicitCount === 0 && gaps.length === 0) return "rigorous";
        const hasFormalNotation = atoms.some(
          (a) => a.latex && (a.latex.includes("\\forall") || a.latex.includes("\\exists") || a.latex.includes("\\vdash") || a.latex.includes("\\Rightarrow"))
        );
        return hasFormalNotation ? "formal" : "rigorous";
      }
      /**
       * Get decomposition metrics
       */
      computeMetrics(decomposition) {
        const { atoms, dependencies, gaps, implicitAssumptions, completeness } = decomposition;
        const totalDeps = atoms.reduce((sum, a) => sum + (a.derivedFrom?.length || 0), 0);
        const avgDependencies = atoms.length > 0 ? totalDeps / atoms.length : 0;
        return {
          atomCount: atoms.length,
          rootCount: dependencies.roots.length,
          leafCount: dependencies.leaves.length,
          avgDependencies,
          maxDependencyDepth: dependencies.depth,
          completeness,
          gapCount: gaps.length,
          implicitAssumptionCount: implicitAssumptions.length
        };
      }
    };
  }
});

// src/proof/gap-analyzer.ts
var DEFAULT_CONFIG3, GapAnalyzer;
var init_gap_analyzer = __esm({
  "src/proof/gap-analyzer.ts"() {
    init_esm_shims();
    DEFAULT_CONFIG3 = {
      strictness: "standard",
      checkDomainAssumptions: true,
      verifyInferenceRules: true,
      maxLeapDistance: 2
    };
    GapAnalyzer = class {
      config;
      constructor(config = {}) {
        this.config = { ...DEFAULT_CONFIG3, ...config };
      }
      /**
       * Analyze a proof decomposition for gaps
       */
      analyzeGaps(decomposition) {
        const { atoms, dependencies } = decomposition;
        const unjustifiedLeaps = this.findUnjustifiedLeaps(atoms, dependencies);
        const missingSteps = this.findMissingSteps(atoms, dependencies);
        const scopeErrors = this.findScopeErrors(atoms);
        const undefinedTerms = this.findUndefinedTerms(atoms);
        const gaps = [...unjustifiedLeaps, ...missingSteps, ...scopeErrors, ...undefinedTerms];
        const implicitAssumptions = this.findImplicitAssumptions(atoms, gaps);
        const unjustifiedSteps = this.findUnjustifiedSteps(atoms);
        const suggestions = this.generateSuggestions(gaps, implicitAssumptions, unjustifiedSteps);
        const completeness = this.computeCompleteness(atoms, gaps, implicitAssumptions);
        return {
          completeness,
          gaps,
          implicitAssumptions,
          unjustifiedSteps,
          suggestions
        };
      }
      /**
       * Check if a transition between two statements is valid
       */
      isValidTransition(from, to) {
        if (to.type === "axiom" || to.type === "definition" || to.type === "hypothesis") {
          return { isValid: true };
        }
        if (to.derivedFrom && to.derivedFrom.includes(from.id)) {
          if (to.usedInferenceRule && this.config.verifyInferenceRules) {
            const ruleCheck = this.verifyInferenceRule(from, to);
            if (!ruleCheck.isValid) {
              return ruleCheck;
            }
          }
          return { isValid: true };
        }
        const impliedConnection = this.checkImpliedConnection(from, to);
        if (impliedConnection.isValid) {
          return impliedConnection;
        }
        return {
          isValid: false,
          reason: `No clear logical connection from "${from.statement.substring(0, 30)}..." to "${to.statement.substring(0, 30)}..."`,
          suggestedFix: "Add explicit derivation step or justification"
        };
      }
      /**
       * Verify that an inference rule is correctly applied
       */
      verifyInferenceRule(from, to) {
        const rule = to.usedInferenceRule;
        if (!rule) return { isValid: true };
        const fromText = from.statement.toLowerCase();
        const toText = to.statement.toLowerCase();
        switch (rule) {
          case "modus_ponens":
            if (fromText.includes("if") && fromText.includes("then")) {
              return { isValid: true };
            }
            if (fromText.includes("implies") || fromText.includes("\u21D2")) {
              return { isValid: true };
            }
            break;
          case "modus_tollens":
            if (toText.includes("not") || toText.includes("\xAC") || toText.includes("false")) {
              return { isValid: true };
            }
            break;
          case "contradiction":
            if (toText.includes("contradiction") || toText.includes("impossible") || toText.includes("false")) {
              return { isValid: true };
            }
            break;
          case "substitution":
            if (fromText.includes("=") || fromText.includes("equals")) {
              return { isValid: true };
            }
            break;
          case "universal_instantiation":
            if (fromText.includes("for all") || fromText.includes("\u2200") || fromText.includes("every")) {
              return { isValid: true };
            }
            break;
          case "existential_generalization":
            if (toText.includes("exists") || toText.includes("\u2203") || toText.includes("there is")) {
              return { isValid: true };
            }
            break;
          case "mathematical_induction":
            return { isValid: true };
          default:
            return { isValid: true };
        }
        return {
          isValid: true,
          // Don't be too strict
          reason: `Inference rule ${rule} application may need review`
        };
      }
      /**
       * Check for implied logical connection between statements
       */
      checkImpliedConnection(from, to) {
        const fromWords = new Set(from.statement.toLowerCase().split(/\s+/));
        const toWords = new Set(to.statement.toLowerCase().split(/\s+/));
        const meaningfulWords = [...fromWords].filter(
          (w) => w.length > 3 && toWords.has(w)
        );
        if (meaningfulWords.length >= 2) {
          return {
            isValid: true,
            reason: "Implied connection through shared concepts"
          };
        }
        if (to.justification && to.justification.toLowerCase().includes(from.id.toLowerCase())) {
          return { isValid: true };
        }
        return { isValid: false };
      }
      /**
       * Find unjustified leaps in reasoning
       */
      findUnjustifiedLeaps(atoms, graph) {
        const gaps = [];
        let gapId = 0;
        for (const atom of atoms) {
          if (atom.type === "axiom" || atom.type === "definition" || atom.type === "hypothesis") {
            continue;
          }
          if (atom.type === "derived" || atom.type === "conclusion" || atom.type === "lemma") {
            if (!atom.derivedFrom || atom.derivedFrom.length === 0) {
              gaps.push({
                id: `gap-leap-${++gapId}`,
                type: "unjustified_leap",
                location: { from: "unknown", to: atom.id },
                description: `Statement "${atom.statement.substring(0, 50)}..." appears without justification`,
                severity: this.assessGapSeverity(atom),
                suggestedFix: this.suggestJustification(atom, atoms)
              });
              continue;
            }
            if (this.config.strictness !== "lenient") {
              const leapDistance = this.computeLeapDistance(atom, graph);
              if (leapDistance > this.config.maxLeapDistance) {
                gaps.push({
                  id: `gap-leap-${++gapId}`,
                  type: "unjustified_leap",
                  location: {
                    from: atom.derivedFrom[0],
                    to: atom.id
                  },
                  description: `Large logical leap (distance ${leapDistance}) to reach this statement`,
                  severity: "significant",
                  suggestedFix: "Add intermediate steps to bridge the logical gap"
                });
              }
            }
          }
        }
        return gaps;
      }
      /**
       * Compute the "leap distance" - how many implicit steps are skipped
       */
      computeLeapDistance(atom, graph) {
        if (!atom.derivedFrom || atom.derivedFrom.length === 0) return 0;
        const deps = atom.derivedFrom.map((id) => graph.nodes.get(id)).filter(Boolean);
        if (deps.length === 0) return 0;
        const atomComplexity = this.estimateStatementComplexity(atom.statement);
        const avgDepComplexity = deps.reduce((sum, d) => sum + this.estimateStatementComplexity(d.statement), 0) / deps.length;
        return Math.max(0, Math.floor((atomComplexity - avgDepComplexity) / 10));
      }
      /**
       * Estimate statement complexity based on length and symbols
       */
      estimateStatementComplexity(statement) {
        let complexity = statement.length;
        const mathSymbols = /[]/g;
        const matches = statement.match(mathSymbols);
        if (matches) complexity += matches.length * 5;
        const nestingLevel = (statement.match(/[\(\[\{]/g) || []).length;
        complexity += nestingLevel * 3;
        return complexity;
      }
      /**
       * Find missing intermediate steps
       */
      findMissingSteps(atoms, graph) {
        const gaps = [];
        let gapId = 0;
        for (const atom of atoms) {
          if (!atom.derivedFrom) continue;
          for (const depId of atom.derivedFrom) {
            const dep = graph.nodes.get(depId);
            if (!dep) continue;
            const validation = this.isValidTransition(dep, atom);
            if (!validation.isValid) {
              gaps.push({
                id: `gap-step-${++gapId}`,
                type: "missing_step",
                location: { from: depId, to: atom.id },
                description: validation.reason || "Missing intermediate step",
                severity: "minor",
                suggestedFix: validation.suggestedFix
              });
            }
          }
        }
        if (graph.topologicalOrder) {
          for (let i = 1; i < graph.topologicalOrder.length; i++) {
            const prev = graph.nodes.get(graph.topologicalOrder[i - 1]);
            const curr = graph.nodes.get(graph.topologicalOrder[i]);
            if (prev && curr && curr.derivedFrom?.includes(prev.id)) {
              if (this.needsIntermediateStep(prev, curr)) {
                gaps.push({
                  id: `gap-step-${++gapId}`,
                  type: "missing_step",
                  location: { from: prev.id, to: curr.id },
                  description: `Step from "${prev.statement.substring(0, 30)}..." to "${curr.statement.substring(0, 30)}..." may need clarification`,
                  severity: "minor",
                  suggestedFix: "Consider adding an intermediate derivation step"
                });
              }
            }
          }
        }
        return gaps;
      }
      /**
       * Check if an intermediate step is needed between two statements
       */
      needsIntermediateStep(from, to) {
        if (this.config.strictness === "lenient") return false;
        const fromSymbols = this.extractMathSymbols(from.statement);
        const toSymbols = this.extractMathSymbols(to.statement);
        const commonSymbols = fromSymbols.filter((s) => toSymbols.includes(s));
        if (commonSymbols.length === 0 && fromSymbols.length > 0 && toSymbols.length > 0) {
          return true;
        }
        if (this.config.strictness === "strict") {
          const lengthRatio = to.statement.length / Math.max(1, from.statement.length);
          if (lengthRatio > 2 || lengthRatio < 0.5) {
            return true;
          }
        }
        return false;
      }
      /**
       * Extract mathematical symbols from a statement
       */
      extractMathSymbols(statement) {
        const symbols = [];
        const vars = statement.match(/\b[a-zA-Z](?:_\d+)?\b/g);
        if (vars) symbols.push(...vars);
        const ops = statement.match(/[+\-*/=<>]/g);
        if (ops) symbols.push(...ops);
        return symbols;
      }
      /**
       * Find scope errors (variables used out of scope)
       */
      findScopeErrors(atoms) {
        const gaps = [];
        let gapId = 0;
        const variableScope = /* @__PURE__ */ new Map();
        for (const atom of atoms) {
          const introMatch = atom.statement.match(
            /(?:let|for\s+(?:all|any|every)|)\s+([a-zA-Z](?:_\d+)?)/i
          );
          if (introMatch) {
            variableScope.set(introMatch[1], atom.id);
          }
          const varMatches = atom.statement.match(/\b([a-zA-Z](?:_\d+)?)\b/g);
          if (varMatches) {
            for (const v of varMatches) {
              if (["a", "an", "the", "if", "is", "or", "be", "to", "in", "of"].includes(v.toLowerCase())) {
                continue;
              }
              if (v.length === 1 && !variableScope.has(v) && atom.type === "derived") {
                const previouslyUsed = atoms.some(
                  (a) => a.id !== atom.id && atoms.indexOf(a) < atoms.indexOf(atom) && a.statement.includes(v)
                );
                if (!previouslyUsed) {
                  gaps.push({
                    id: `gap-scope-${++gapId}`,
                    type: "scope_error",
                    location: { from: "introduction", to: atom.id },
                    description: `Variable "${v}" appears without explicit introduction`,
                    severity: "minor",
                    suggestedFix: `Introduce ${v} with "Let ${v}..." or specify its domain`
                  });
                }
              }
            }
          }
        }
        return gaps;
      }
      /**
       * Find undefined terms
       */
      findUndefinedTerms(atoms) {
        const gaps = [];
        let gapId = 0;
        const definedTerms = /* @__PURE__ */ new Set();
        for (const atom of atoms) {
          if (atom.type === "definition") {
            const defMatch = atom.statement.match(
              /(?:define|let)\s+(\w+)|(\w+)\s+(?:is|are|be)\s+defined/i
            );
            if (defMatch) {
              definedTerms.add((defMatch[1] || defMatch[2]).toLowerCase());
            }
          }
        }
        for (const atom of atoms) {
          const byDefMatch = atom.statement.match(/by\s+(?:the\s+)?definition\s+of\s+(\w+)/i);
          if (byDefMatch) {
            const term = byDefMatch[1].toLowerCase();
            if (!definedTerms.has(term) && !this.isStandardMathTerm(term)) {
              gaps.push({
                id: `gap-undef-${++gapId}`,
                type: "undefined_term",
                location: { from: "definition", to: atom.id },
                description: `Term "${byDefMatch[1]}" is used but not defined`,
                severity: "significant",
                suggestedFix: `Add a definition for "${byDefMatch[1]}"`
              });
            }
          }
        }
        return gaps;
      }
      /**
       * Check if a term is a standard mathematical term
       */
      isStandardMathTerm(term) {
        const standardTerms = /* @__PURE__ */ new Set([
          "integer",
          "integers",
          "real",
          "reals",
          "natural",
          "naturals",
          "rational",
          "rationals",
          "complex",
          "prime",
          "even",
          "odd",
          "positive",
          "negative",
          "zero",
          "function",
          "continuous",
          "differentiable",
          "derivative",
          "integral",
          "limit",
          "sequence",
          "series",
          "set",
          "subset",
          "superset",
          "union",
          "intersection",
          "element",
          "member",
          "domain",
          "range",
          "codomain",
          "bijection",
          "injection",
          "surjection",
          "isomorphism",
          "homomorphism"
        ]);
        return standardTerms.has(term);
      }
      /**
       * Find implicit assumptions
       */
      findImplicitAssumptions(atoms, gaps) {
        const implicitAssumptions = [];
        let count = 0;
        for (const gap of gaps) {
          if (gap.type === "implicit_assumption") {
            implicitAssumptions.push({
              id: `impl-${++count}`,
              statement: gap.description,
              type: "existence_assumption",
              usedInStep: gap.location.to,
              shouldBeExplicit: gap.severity !== "minor",
              suggestedFormulation: gap.suggestedFix || "Make assumption explicit"
            });
          }
        }
        for (const atom of atoms) {
          if (/\/\s*([a-zA-Z_]\w*|\([^)]+\))/.test(atom.statement)) {
            implicitAssumptions.push({
              id: `impl-${++count}`,
              statement: "Division operation implies non-zero divisor",
              type: "domain_assumption",
              usedInStep: atom.id,
              shouldBeExplicit: true,
              suggestedFormulation: "State that the divisor is non-zero"
            });
          }
          if (/|\\sqrt/.test(atom.statement)) {
            implicitAssumptions.push({
              id: `impl-${++count}`,
              statement: "Square root implies non-negative argument",
              type: "domain_assumption",
              usedInStep: atom.id,
              shouldBeExplicit: true,
              suggestedFormulation: "State that the argument is non-negative"
            });
          }
          if (/log|ln|\\log/.test(atom.statement)) {
            implicitAssumptions.push({
              id: `impl-${++count}`,
              statement: "Logarithm implies positive argument",
              type: "domain_assumption",
              usedInStep: atom.id,
              shouldBeExplicit: true,
              suggestedFormulation: "State that the argument is positive"
            });
          }
        }
        return implicitAssumptions;
      }
      /**
       * Find unjustified steps (steps with low confidence)
       */
      findUnjustifiedSteps(atoms) {
        return atoms.filter(
          (a) => (a.type === "derived" || a.type === "conclusion") && (!a.derivedFrom || a.derivedFrom.length === 0) && !a.justification
        ).map((a) => a.id);
      }
      /**
       * Assess severity of a gap
       */
      assessGapSeverity(atom) {
        if (atom.type === "conclusion") return "critical";
        if (atom.type === "lemma") return "significant";
        return "minor";
      }
      /**
       * Suggest justification for an unjustified statement
       */
      suggestJustification(atom, allAtoms) {
        const related = allAtoms.filter((a) => {
          if (a.id === atom.id) return false;
          const overlap = this.computeWordOverlap(a.statement, atom.statement);
          return overlap > 0.3;
        });
        if (related.length > 0) {
          const relatedIds = related.map((r) => r.id).join(", ");
          return `Consider deriving from: ${relatedIds}`;
        }
        return "Add explicit justification or reference to supporting statements";
      }
      /**
       * Compute word overlap between two statements
       */
      computeWordOverlap(a, b) {
        const wordsA = new Set(
          a.toLowerCase().split(/\s+/).filter((w) => w.length > 2)
        );
        const wordsB = new Set(
          b.toLowerCase().split(/\s+/).filter((w) => w.length > 2)
        );
        if (wordsA.size === 0 || wordsB.size === 0) return 0;
        let overlap = 0;
        for (const w of wordsA) {
          if (wordsB.has(w)) overlap++;
        }
        return overlap / Math.max(wordsA.size, wordsB.size);
      }
      /**
       * Generate improvement suggestions
       */
      generateSuggestions(gaps, implicitAssumptions, unjustifiedSteps) {
        const suggestions = [];
        const criticalGaps = gaps.filter((g) => g.severity === "critical");
        const significantGaps = gaps.filter((g) => g.severity === "significant");
        const minorGaps = gaps.filter((g) => g.severity === "minor");
        if (criticalGaps.length > 0) {
          suggestions.push(
            `CRITICAL: Address ${criticalGaps.length} critical gap(s) in the proof - conclusions lack proper justification`
          );
        }
        if (significantGaps.length > 0) {
          suggestions.push(
            `Add intermediate steps to bridge ${significantGaps.length} significant logical gap(s)`
          );
        }
        if (implicitAssumptions.filter((a) => a.shouldBeExplicit).length > 0) {
          suggestions.push(
            `Make ${implicitAssumptions.filter((a) => a.shouldBeExplicit).length} implicit assumption(s) explicit`
          );
        }
        if (unjustifiedSteps.length > 0) {
          suggestions.push(`Provide justification for ${unjustifiedSteps.length} unjustified step(s)`);
        }
        if (minorGaps.length > 0 && this.config.strictness !== "lenient") {
          suggestions.push(
            `Consider clarifying ${minorGaps.length} minor gap(s) for improved rigor`
          );
        }
        if (suggestions.length === 0) {
          suggestions.push("The proof appears complete with no significant gaps identified");
        }
        return suggestions;
      }
      /**
       * Compute overall completeness score
       */
      computeCompleteness(atoms, gaps, implicitAssumptions) {
        if (atoms.length === 0) return 0;
        let score = 1;
        for (const gap of gaps) {
          switch (gap.severity) {
            case "critical":
              score -= 0.25;
              break;
            case "significant":
              score -= 0.1;
              break;
            case "minor":
              score -= 0.02;
              break;
          }
        }
        const criticalImplicit = implicitAssumptions.filter((a) => a.shouldBeExplicit).length;
        score -= criticalImplicit * 0.05;
        return Math.max(0, Math.min(1, score));
      }
    };
  }
});

// src/proof/assumption-tracker.ts
var AssumptionTracker;
var init_assumption_tracker = __esm({
  "src/proof/assumption-tracker.ts"() {
    init_esm_shims();
    AssumptionTracker = class {
      /**
       * Trace a conclusion back to its foundational assumptions
       *
       * @param conclusionId - The statement ID to trace
       * @param graph - The dependency graph
       * @returns AssumptionChain with full derivation path
       */
      traceToAssumptions(conclusionId, graph) {
        const assumptions = [];
        const path4 = [];
        const implicitAssumptions = [];
        const visited = /* @__PURE__ */ new Set();
        const trace = (id) => {
          if (visited.has(id)) return;
          visited.add(id);
          const node = graph.nodes.get(id);
          if (!node) return;
          path4.push(id);
          if (node.type === "axiom" || node.type === "definition" || node.type === "hypothesis") {
            assumptions.push(id);
            return;
          }
          if (node.derivedFrom && node.derivedFrom.length > 0) {
            for (const depId of node.derivedFrom) {
              trace(depId);
            }
          } else {
            implicitAssumptions.push({
              id: `impl-trace-${id}`,
              statement: node.statement,
              type: "existence_assumption",
              usedInStep: id,
              shouldBeExplicit: true,
              suggestedFormulation: `Make explicit: "${node.statement.substring(0, 50)}..."`
            });
          }
        };
        trace(conclusionId);
        const allAssumptionsExplicit = implicitAssumptions.length === 0;
        return {
          conclusion: conclusionId,
          assumptions: [...new Set(assumptions)],
          path: path4.reverse(),
          // Start from assumptions, end at conclusion
          allAssumptionsExplicit,
          implicitAssumptions
        };
      }
      /**
       * Perform comprehensive assumption analysis
       *
       * @param decomposition - The proof decomposition to analyze
       * @returns AssumptionAnalysis with detailed findings
       */
      analyzeAssumptions(decomposition) {
        const { atoms, dependencies } = decomposition;
        const explicitAssumptions = atoms.filter(
          (a) => a.type === "axiom" || a.type === "definition" || a.type === "hypothesis"
        );
        const allImplicitAssumptions = [];
        const conclusionDependencies = /* @__PURE__ */ new Map();
        const conclusions = atoms.filter((a) => a.type === "conclusion");
        for (const conclusion of conclusions) {
          const chain = this.traceToAssumptions(conclusion.id, dependencies);
          conclusionDependencies.set(conclusion.id, chain.assumptions);
          allImplicitAssumptions.push(...chain.implicitAssumptions);
        }
        if (conclusions.length === 0) {
          for (const leafId of dependencies.leaves) {
            const chain = this.traceToAssumptions(leafId, dependencies);
            conclusionDependencies.set(leafId, chain.assumptions);
            allImplicitAssumptions.push(...chain.implicitAssumptions);
          }
        }
        const usedAssumptions = /* @__PURE__ */ new Set();
        for (const deps of conclusionDependencies.values()) {
          for (const dep of deps) {
            usedAssumptions.add(dep);
          }
        }
        const unusedAssumptions = explicitAssumptions.filter((a) => !usedAssumptions.has(a.id)).map((a) => a.id);
        const minimalSets = this.findMinimalAssumptions(conclusionDependencies, dependencies);
        const uniqueImplicit = this.deduplicateImplicit(allImplicitAssumptions);
        return {
          explicitAssumptions,
          implicitAssumptions: uniqueImplicit,
          unusedAssumptions,
          conclusionDependencies,
          minimalSets
        };
      }
      /**
       * Find minimal sets of assumptions needed for each conclusion
       *
       * Uses a greedy approach to find approximately minimal sets.
       * For exact minimal sets, a SAT solver would be needed.
       */
      findMinimalAssumptions(conclusionDependencies, graph) {
        const minimalSets = /* @__PURE__ */ new Map();
        for (const [conclusion, assumptions] of conclusionDependencies) {
          const minimal = this.computeMinimalSet(conclusion, assumptions, graph);
          minimalSets.set(conclusion, minimal);
        }
        return minimalSets;
      }
      /**
       * Compute a minimal assumption set for a conclusion
       *
       * Uses backward elimination: try removing each assumption and
       * check if the conclusion is still reachable.
       */
      computeMinimalSet(conclusion, assumptions, graph) {
        if (assumptions.length <= 1) return [...assumptions];
        let current = [...assumptions];
        for (let i = 0; i < current.length; i++) {
          const testSet = [...current.slice(0, i), ...current.slice(i + 1)];
          if (this.isReachable(testSet, conclusion, graph)) {
            current = testSet;
            i--;
          }
        }
        return current;
      }
      /**
       * Check if a conclusion is reachable from a set of assumptions
       */
      isReachable(assumptions, conclusion, graph) {
        const reachable = new Set(assumptions);
        let changed = true;
        while (changed) {
          changed = false;
          for (const [id, node] of graph.nodes) {
            if (reachable.has(id)) continue;
            if (node.derivedFrom && node.derivedFrom.length > 0) {
              const allDepsReachable = node.derivedFrom.every((d) => reachable.has(d));
              if (allDepsReachable) {
                reachable.add(id);
                changed = true;
                if (id === conclusion) return true;
              }
            }
          }
        }
        return reachable.has(conclusion);
      }
      /**
       * Find assumptions that are not used in any derivation
       */
      findUnusedAssumptions(decomposition) {
        const { atoms, dependencies } = decomposition;
        const assumptionIds = new Set(
          atoms.filter((a) => a.type === "axiom" || a.type === "definition" || a.type === "hypothesis").map((a) => a.id)
        );
        const referenced = /* @__PURE__ */ new Set();
        for (const atom of atoms) {
          if (atom.derivedFrom) {
            for (const depId of atom.derivedFrom) {
              referenced.add(depId);
            }
          }
        }
        for (const edge of dependencies.edges) {
          referenced.add(edge.from);
        }
        return [...assumptionIds].filter((id) => !referenced.has(id));
      }
      /**
       * Check if assumptions are properly discharged in proof by contradiction
       *
       * In proof by contradiction, we assume P to derive a contradiction,
       * then discharge P to conclude P.
       */
      checkAssumptionDischarge(decomposition) {
        const { atoms } = decomposition;
        const statuses = [];
        const hypotheticals = atoms.filter((a) => a.type === "hypothesis");
        const contradictions = atoms.filter(
          (a) => a.statement.toLowerCase().includes("contradiction") || a.statement.includes("\u22A5") || a.usedInferenceRule === "contradiction"
        );
        for (const hyp of hypotheticals) {
          const isDischargedByContradiction = contradictions.some(
            (c) => c.derivedFrom?.some((d) => this.dependsOn(d, hyp.id, decomposition.dependencies))
          );
          if (isDischargedByContradiction) {
            statuses.push({
              assumptionId: hyp.id,
              isDischarged: true,
              dischargedAt: contradictions[0]?.id,
              dischargeReason: "Used in proof by contradiction"
            });
          } else {
            const conclusions = atoms.filter((a) => a.type === "conclusion");
            const impliesDischarged = conclusions.some(
              (c) => c.statement.toLowerCase().includes("implies") || c.statement.includes("\u21D2") || c.statement.includes("\u2192")
            );
            if (impliesDischarged) {
              statuses.push({
                assumptionId: hyp.id,
                isDischarged: true,
                dischargedAt: conclusions[0]?.id,
                dischargeReason: "Used in implication introduction"
              });
            } else {
              statuses.push({
                assumptionId: hyp.id,
                isDischarged: false,
                dischargeReason: "Hypothesis not discharged - may need attention"
              });
            }
          }
        }
        return statuses;
      }
      /**
       * Check if statement A depends on statement B (transitively)
       */
      dependsOn(aId, bId, graph) {
        const visited = /* @__PURE__ */ new Set();
        const check = (id) => {
          if (id === bId) return true;
          if (visited.has(id)) return false;
          visited.add(id);
          const node = graph.nodes.get(id);
          if (!node || !node.derivedFrom) return false;
          return node.derivedFrom.some((depId) => check(depId));
        };
        return check(aId);
      }
      /**
       * Get the dependency chain for a specific assumption
       *
       * Shows which statements depend on this assumption.
       */
      getAssumptionImpact(assumptionId, graph) {
        const dependents = [];
        const visited = /* @__PURE__ */ new Set();
        const queue = [assumptionId];
        while (queue.length > 0) {
          const current = queue.shift();
          if (visited.has(current)) continue;
          visited.add(current);
          for (const [id, node] of graph.nodes) {
            if (node.derivedFrom?.includes(current) && !visited.has(id)) {
              dependents.push(id);
              queue.push(id);
            }
          }
        }
        return dependents;
      }
      /**
       * Deduplicate implicit assumptions based on content similarity
       */
      deduplicateImplicit(assumptions) {
        const seen = /* @__PURE__ */ new Map();
        for (const assumption of assumptions) {
          const key = `${assumption.type}:${assumption.statement.toLowerCase().trim()}`;
          if (!seen.has(key)) {
            seen.set(key, assumption);
          }
        }
        return [...seen.values()];
      }
      /**
       * Suggest how to strengthen a proof by making assumptions explicit
       */
      getSuggestions(analysis) {
        const suggestions = [];
        if (analysis.unusedAssumptions.length > 0) {
          suggestions.push(
            `Consider removing ${analysis.unusedAssumptions.length} unused assumption(s): ${analysis.unusedAssumptions.join(", ")}`
          );
        }
        const criticalImplicit = analysis.implicitAssumptions.filter((a) => a.shouldBeExplicit);
        if (criticalImplicit.length > 0) {
          suggestions.push(
            `Make ${criticalImplicit.length} implicit assumption(s) explicit for improved rigor`
          );
          for (const imp of criticalImplicit.slice(0, 3)) {
            suggestions.push(`  - ${imp.suggestedFormulation}`);
          }
        }
        for (const [conclusion, minimal] of analysis.minimalSets) {
          const full = analysis.conclusionDependencies.get(conclusion) || [];
          if (minimal.length < full.length) {
            const redundant = full.filter((a) => !minimal.includes(a));
            if (redundant.length > 0) {
              suggestions.push(
                `For conclusion ${conclusion}: ${redundant.length} assumption(s) may be redundant`
              );
            }
          }
        }
        if (suggestions.length === 0) {
          suggestions.push("Assumption structure appears sound");
        }
        return suggestions;
      }
      /**
       * Validate the assumption structure of a proof
       *
       * Returns true if the proof has a valid assumption structure:
       * - At least one foundational assumption
       * - All conclusions traceable to assumptions
       * - No circular dependencies involving assumptions
       */
      validateStructure(decomposition) {
        const issues = [];
        const { atoms, dependencies } = decomposition;
        const foundations = atoms.filter(
          (a) => a.type === "axiom" || a.type === "definition" || a.type === "hypothesis"
        );
        if (foundations.length === 0) {
          issues.push("No foundational assumptions (axioms, definitions, or hypotheses) found");
        }
        for (const rootId of dependencies.roots) {
          const root = dependencies.nodes.get(rootId);
          if (root && root.type !== "axiom" && root.type !== "definition" && root.type !== "hypothesis") {
            issues.push(
              `Root statement "${root.statement.substring(0, 30)}..." is not a foundational type`
            );
          }
        }
        if (dependencies.hasCycles) {
          const cycleNodes = new Set(
            (dependencies.stronglyConnectedComponents || []).filter((scc) => scc.length > 1).flat()
          );
          for (const foundation of foundations) {
            if (cycleNodes.has(foundation.id)) {
              issues.push(
                `Assumption "${foundation.statement.substring(0, 30)}..." is involved in circular reasoning`
              );
            }
          }
        }
        const conclusions = atoms.filter((a) => a.type === "conclusion");
        for (const conclusion of conclusions) {
          const chain = this.traceToAssumptions(conclusion.id, dependencies);
          if (chain.assumptions.length === 0 && !chain.allAssumptionsExplicit) {
            issues.push(
              `Conclusion "${conclusion.statement.substring(0, 30)}..." cannot be traced to any assumption`
            );
          }
        }
        return {
          isValid: issues.length === 0,
          issues
        };
      }
    };
  }
});

// src/proof/inconsistency-detector.ts
var DEFAULT_CONFIG4, InconsistencyDetector;
var init_inconsistency_detector = __esm({
  "src/proof/inconsistency-detector.ts"() {
    init_esm_shims();
    DEFAULT_CONFIG4 = {
      strictTyping: true,
      checkDomains: true,
      checkQuantifiers: true,
      maxPairwiseComparisons: 1e3
    };
    InconsistencyDetector = class {
      config;
      contradictionPatterns;
      constructor(config = {}) {
        this.config = { ...DEFAULT_CONFIG4, ...config };
        this.contradictionPatterns = this.initializePatterns();
      }
      /**
       * Initialize contradiction patterns for syntactic matching
       */
      initializePatterns() {
        return [
          // Inequality contradictions
          {
            positive: /(\w+)\s*>\s*0/,
            negative: /(\w+)\s*(?:<=|)\s*0/,
            description: "Positive and non-positive contradiction"
          },
          {
            positive: /(\w+)\s*<\s*0/,
            negative: /(\w+)\s*(?:>=|)\s*0/,
            description: "Negative and non-negative contradiction"
          },
          {
            positive: /(\w+)\s*=\s*0/,
            negative: /(\w+)\s*(?:!=||<>)\s*0/,
            description: "Zero and non-zero contradiction"
          },
          // Boolean contradictions
          {
            positive: /(\w+)\s+is\s+true/i,
            negative: /(\w+)\s+is\s+false/i,
            description: "True and false contradiction"
          },
          // Property contradictions
          {
            positive: /(\w+)\s+is\s+even/i,
            negative: /(\w+)\s+is\s+odd/i,
            description: "Even and odd contradiction"
          },
          {
            positive: /(\w+)\s+is\s+positive/i,
            negative: /(\w+)\s+is\s+(?:negative|non-positive)/i,
            description: "Positive property contradiction"
          },
          {
            positive: /(\w+)\s+is\s+rational/i,
            negative: /(\w+)\s+is\s+irrational/i,
            description: "Rational and irrational contradiction"
          },
          {
            positive: /(\w+)\s+is\s+finite/i,
            negative: /(\w+)\s+is\s+infinite/i,
            description: "Finite and infinite contradiction"
          },
          // Existence contradictions
          {
            positive: /(?:there\s+)?exists?\s+(\w+)/i,
            negative: /(?:no|does\s+not\s+exist|cannot\s+exist)\s+(\w+)/i,
            description: "Existence contradiction"
          }
        ];
      }
      /**
       * Analyze a proof decomposition for inconsistencies
       */
      analyze(decomposition) {
        const { atoms, dependencies } = decomposition;
        const inconsistencies = [];
        let inconsistencyCount = 0;
        const contradictions = this.detectContradictions(atoms);
        inconsistencies.push(
          ...contradictions.map((c) => ({
            ...c,
            id: `inc-${++inconsistencyCount}`
          }))
        );
        if (this.config.strictTyping) {
          const typeMismatches = this.detectTypeMismatches(atoms);
          inconsistencies.push(
            ...typeMismatches.map((t) => ({
              ...t,
              id: `inc-${++inconsistencyCount}`
            }))
          );
        }
        if (this.config.checkDomains) {
          const domainViolations = this.detectDomainViolations(atoms);
          inconsistencies.push(
            ...domainViolations.map((d) => ({
              ...d,
              id: `inc-${++inconsistencyCount}`
            }))
          );
        }
        const undefinedOps = this.detectUndefinedOperations(atoms);
        inconsistencies.push(
          ...undefinedOps.map((u) => ({
            ...u,
            id: `inc-${++inconsistencyCount}`
          }))
        );
        const axiomConflicts = this.detectAxiomConflicts(atoms);
        inconsistencies.push(
          ...axiomConflicts.map((a) => ({
            ...a,
            id: `inc-${++inconsistencyCount}`
          }))
        );
        if (this.config.checkQuantifiers) {
          const quantifierErrors = this.detectQuantifierErrors(atoms, dependencies);
          inconsistencies.push(
            ...quantifierErrors.map((q) => ({
              ...q,
              id: `inc-${++inconsistencyCount}`
            }))
          );
        }
        return inconsistencies;
      }
      /**
       * Detect direct contradictions (P and P)
       */
      detectContradictions(atoms) {
        const contradictions = [];
        const limit = Math.min(atoms.length, Math.sqrt(this.config.maxPairwiseComparisons));
        for (let i = 0; i < Math.min(atoms.length, limit); i++) {
          for (let j = i + 1; j < Math.min(atoms.length, limit); j++) {
            const stmtA = atoms[i];
            const stmtB = atoms[j];
            if (this.isSyntacticNegation(stmtA.statement, stmtB.statement)) {
              contradictions.push({
                type: "direct_contradiction",
                involvedStatements: [stmtA.id, stmtB.id],
                explanation: `Statement "${stmtA.statement.substring(0, 40)}..." directly contradicts "${stmtB.statement.substring(0, 40)}..."`,
                severity: "critical",
                suggestedResolution: "Review the derivation of both statements to find the error"
              });
            }
            for (const pattern of this.contradictionPatterns) {
              const matchA = stmtA.statement.match(pattern.positive);
              const matchB = stmtB.statement.match(pattern.negative);
              if (matchA && matchB && matchA[1] === matchB[1]) {
                contradictions.push({
                  type: "direct_contradiction",
                  involvedStatements: [stmtA.id, stmtB.id],
                  explanation: `${pattern.description}: "${matchA[1]}" has conflicting properties`,
                  severity: "critical",
                  suggestedResolution: "Check the assumptions about the variable"
                });
              }
              const matchA2 = stmtA.statement.match(pattern.negative);
              const matchB2 = stmtB.statement.match(pattern.positive);
              if (matchA2 && matchB2 && matchA2[1] === matchB2[1]) {
                contradictions.push({
                  type: "direct_contradiction",
                  involvedStatements: [stmtA.id, stmtB.id],
                  explanation: `${pattern.description}: "${matchA2[1]}" has conflicting properties`,
                  severity: "critical",
                  suggestedResolution: "Check the assumptions about the variable"
                });
              }
            }
          }
        }
        return contradictions;
      }
      /**
       * Check if two statements are syntactic negations
       */
      isSyntacticNegation(a, b) {
        const normalA = a.toLowerCase().trim();
        const normalB = b.toLowerCase().trim();
        if (normalB === `not ${normalA}` || normalA === `not ${normalB}`) {
          return true;
        }
        if (normalB === `\xAC ${normalA}` || normalB === `\xAC${normalA}`) {
          return true;
        }
        if (normalA === `\xAC ${normalB}` || normalA === `\xAC${normalB}`) {
          return true;
        }
        const trueMatch = normalA.match(/^(.+) is true$/);
        const falseMatch = normalB.match(/^(.+) is false$/);
        if (trueMatch && falseMatch && trueMatch[1] === falseMatch[1]) {
          return true;
        }
        const trueMatch2 = normalB.match(/^(.+) is true$/);
        const falseMatch2 = normalA.match(/^(.+) is false$/);
        if (trueMatch2 && falseMatch2 && trueMatch2[1] === falseMatch2[1]) {
          return true;
        }
        const holdsMatch = normalA.match(/^(.+) holds$/);
        const notHoldsMatch = normalB.match(/^(.+) does not hold$/);
        if (holdsMatch && notHoldsMatch && holdsMatch[1] === notHoldsMatch[1]) {
          return true;
        }
        const itTrueMatch = normalA.match(/^it is true that (.+)$/);
        const itFalseMatch = normalB.match(/^it is false that (.+)$/);
        if (itTrueMatch && itFalseMatch && itTrueMatch[1] === itFalseMatch[1]) {
          return true;
        }
        return false;
      }
      /**
       * Detect type mismatches
       */
      detectTypeMismatches(atoms) {
        const mismatches = [];
        const variableTypes = /* @__PURE__ */ new Map();
        for (const atom of atoms) {
          const typePatterns = [
            { pattern: /let\s+(\w+)\s+be\s+an?\s+(\w+)/i, extractor: (m) => ({ var: m[1], type: m[2] }) },
            { pattern: /(\w+)\s+is\s+an?\s+(\w+)/i, extractor: (m) => ({ var: m[1], type: m[2] }) },
            { pattern: /for\s+(?:all|any|every)\s+(\w+)\s+in\s+(\w+)/i, extractor: (m) => ({ var: m[1], type: m[2] }) },
            { pattern: /(\w+)\s*\s*(\w+)/i, extractor: (m) => ({ var: m[1], type: m[2] }) }
          ];
          for (const { pattern, extractor } of typePatterns) {
            const match = atom.statement.match(pattern);
            if (match) {
              const { var: varName, type: varType } = extractor(match);
              const existing = variableTypes.get(varName);
              if (existing && !this.areTypesCompatible(existing.type, varType)) {
                mismatches.push({
                  type: "type_mismatch",
                  involvedStatements: [existing.sourceId, atom.id],
                  explanation: `Variable "${varName}" is declared as both "${existing.type}" and "${varType}"`,
                  severity: "error",
                  suggestedResolution: `Clarify the type of "${varName}"`
                });
              } else {
                variableTypes.set(varName, { type: varType, sourceId: atom.id });
              }
            }
          }
        }
        return mismatches;
      }
      /**
       * Check if two types are compatible
       */
      areTypesCompatible(type1, type2) {
        const t1 = type1.toLowerCase();
        const t2 = type2.toLowerCase();
        if (t1 === t2) return true;
        const subtypes = {
          natural: ["integer", "real", "complex"],
          integer: ["real", "complex"],
          rational: ["real", "complex"],
          real: ["complex"],
          positive: ["real", "integer"],
          negative: ["real", "integer"]
        };
        return subtypes[t1]?.includes(t2) || subtypes[t2]?.includes(t1);
      }
      /**
       * Detect domain violations
       */
      detectDomainViolations(atoms) {
        const violations = [];
        const domainPatterns = [
          {
            pattern: /sqrt\s*\(\s*(-[\d.]+|negative)/i,
            violation: "Square root of negative number",
            domain: "real numbers"
          },
          {
            pattern: /log\s*\(\s*(-[\d.]+|0|zero|non-?positive)/i,
            violation: "Logarithm of non-positive number",
            domain: "positive real numbers"
          },
          {
            pattern: /arcsin\s*\(\s*([\d.]+)/,
            violation: "Arcsin of value outside [-1, 1]",
            domain: "[-1, 1]",
            validator: (match) => {
              const val = parseFloat(match[1]);
              return Math.abs(val) > 1;
            }
          },
          {
            pattern: /(\w+)\s*\/\s*0(?![.\d])/,
            violation: "Division by zero",
            domain: "non-zero divisor"
          }
        ];
        for (const atom of atoms) {
          for (const { pattern, violation, domain, validator } of domainPatterns) {
            const match = atom.statement.match(pattern);
            if (match && (!validator || validator(match))) {
              violations.push({
                type: "domain_violation",
                involvedStatements: [atom.id],
                explanation: `${violation} in "${atom.statement.substring(0, 50)}..."`,
                severity: "error",
                suggestedResolution: `Ensure the argument is in the valid domain: ${domain}`
              });
            }
          }
        }
        return violations;
      }
      /**
       * Detect undefined operations
       */
      detectUndefinedOperations(atoms) {
        const undefined2 = [];
        const undefinedPatterns = [
          {
            pattern: /0\s*\/\s*0/,
            operation: "0/0 - indeterminate form"
          },
          {
            pattern: /\s*[-/]\s*/,
            operation: "\u221E - \u221E or \u221E/\u221E - indeterminate form"
          },
          {
            pattern: /0\s*\*\s*|\s*\*\s*0/,
            operation: "0 \xD7 \u221E - indeterminate form"
          },
          {
            pattern: /0\s*\^\s*0/,
            operation: "0^0 - undefined/context-dependent"
          },
          {
            pattern: /(\w+)\s*\^\s*\(?\s*-\d+\s*\)?.*\1\s*=\s*0/i,
            operation: "Negative power of zero"
          }
        ];
        for (const atom of atoms) {
          for (const { pattern, operation } of undefinedPatterns) {
            if (pattern.test(atom.statement)) {
              undefined2.push({
                type: "undefined_operation",
                involvedStatements: [atom.id],
                explanation: `Undefined operation: ${operation}`,
                severity: "critical",
                suggestedResolution: "This operation is mathematically undefined or indeterminate"
              });
            }
          }
        }
        return undefined2;
      }
      /**
       * Detect axiom conflicts
       */
      detectAxiomConflicts(atoms) {
        const conflicts = [];
        const axioms = atoms.filter((a) => a.type === "axiom");
        for (let i = 0; i < axioms.length; i++) {
          for (let j = i + 1; j < axioms.length; j++) {
            if (this.axiomsMayConflict(axioms[i], axioms[j])) {
              conflicts.push({
                type: "axiom_conflict",
                involvedStatements: [axioms[i].id, axioms[j].id],
                explanation: `Axioms may be in conflict: "${axioms[i].statement.substring(0, 30)}..." and "${axioms[j].statement.substring(0, 30)}..."`,
                severity: "warning",
                suggestedResolution: "Verify that these axioms are consistent in the intended model"
              });
            }
          }
        }
        return conflicts;
      }
      /**
       * Check if two axioms may conflict
       */
      axiomsMayConflict(a, b) {
        if (this.isSyntacticNegation(a.statement, b.statement)) {
          return true;
        }
        const universalA = /(?:for\s+all|)\s+(\w+).*?(\w+)\s+is\s+(\w+)/i.exec(a.statement);
        const universalB = /(?:for\s+all|)\s+(\w+).*?(\w+)\s+is\s+not\s+(\w+)/i.exec(b.statement);
        if (universalA && universalB && universalA[2] === universalB[2] && universalA[3] === universalB[3]) {
          return true;
        }
        return false;
      }
      /**
       * Detect quantifier errors
       */
      detectQuantifierErrors(atoms, graph) {
        const errors = [];
        const scopedVariables = /* @__PURE__ */ new Map();
        for (const atom of atoms) {
          const universalMatch = atom.statement.match(/(?:for\s+all|)\s+(\w+)/i);
          if (universalMatch) {
            scopedVariables.set(universalMatch[1], { quantifier: "universal", scope: atom.id });
          }
          const existentialMatch = atom.statement.match(/(?:there\s+exists?|)\s+(\w+)/i);
          if (existentialMatch) {
            scopedVariables.set(existentialMatch[1], { quantifier: "existential", scope: atom.id });
          }
          const variableUses = atom.statement.match(/\b([a-zA-Z])\b/g);
          if (variableUses) {
            for (const varName of variableUses) {
              const scopeInfo = scopedVariables.get(varName);
              if (scopeInfo) {
                const inScope = this.isInScope(atom.id, scopeInfo.scope, graph);
                if (!inScope) {
                  errors.push({
                    type: "quantifier_error",
                    involvedStatements: [scopeInfo.scope, atom.id],
                    explanation: `Variable "${varName}" used outside its quantifier scope`,
                    severity: "error",
                    suggestedResolution: `Ensure "${varName}" is properly bound in the current context`
                  });
                }
              }
            }
          }
          const uniExiPattern = /\s*(\w+).*\s*(\w+).*\1.*\2/;
          const exiUniPattern = /\s*(\w+).*\s*(\w+).*\1.*\2/;
          const uniExiMatch = atom.statement.match(uniExiPattern);
          const exiUniMatch = atom.statement.match(exiUniPattern);
          if (uniExiMatch && exiUniMatch) {
            errors.push({
              type: "quantifier_error",
              involvedStatements: [atom.id],
              explanation: "Ambiguous quantifier order may lead to different meanings",
              severity: "warning",
              suggestedResolution: "Clarify the intended quantifier order (\u2200\u2203 vs \u2203\u2200 has different meaning)"
            });
          }
        }
        return errors;
      }
      /**
       * Check if a statement is in the scope of another
       */
      isInScope(stmtId, scopeId, graph) {
        const visited = /* @__PURE__ */ new Set();
        const queue = [scopeId];
        while (queue.length > 0) {
          const current = queue.shift();
          if (current === stmtId) return true;
          if (visited.has(current)) continue;
          visited.add(current);
          for (const edge of graph.edges) {
            if (edge.from === current && !visited.has(edge.to)) {
              queue.push(edge.to);
            }
          }
        }
        return false;
      }
      /**
       * Get a summary of all inconsistencies
       */
      getSummary(inconsistencies) {
        const criticalCount = inconsistencies.filter((i) => i.severity === "critical").length;
        const errorCount = inconsistencies.filter((i) => i.severity === "error").length;
        const warningCount = inconsistencies.filter((i) => i.severity === "warning").length;
        let summary;
        if (criticalCount > 0) {
          summary = `CRITICAL: ${criticalCount} critical inconsistencies found. The proof is invalid.`;
        } else if (errorCount > 0) {
          summary = `ERROR: ${errorCount} errors found that need to be addressed.`;
        } else if (warningCount > 0) {
          summary = `WARNING: ${warningCount} potential issues found. Review recommended.`;
        } else {
          summary = "No inconsistencies detected. The proof appears to be consistent.";
        }
        return {
          isConsistent: criticalCount === 0 && errorCount === 0,
          criticalCount,
          errorCount,
          warningCount,
          summary
        };
      }
    };
  }
});

// src/proof/circular-detector.ts
var CircularReasoningDetector;
var init_circular_detector = __esm({
  "src/proof/circular-detector.ts"() {
    init_esm_shims();
    CircularReasoningDetector = class {
      /**
       * Detect all forms of circular reasoning in a proof
       */
      detectCircularReasoning(decomposition) {
        const { atoms, dependencies } = decomposition;
        const cycles = this.findReasoningCycles(dependencies);
        const selfReferential = this.findSelfReferential(atoms);
        const begging = this.findBeggingTheQuestion(atoms, dependencies);
        const tautologies = this.findTautologies(atoms);
        const hasCircularReasoning = cycles.length > 0 || selfReferential.length > 0 || begging.length > 0;
        return {
          hasCircularReasoning,
          cycles,
          selfReferentialStatements: selfReferential,
          beggingTheQuestion: begging,
          tautologies,
          summary: this.generateSummary(cycles, selfReferential, begging, tautologies)
        };
      }
      /**
       * Check if a single statement is self-referential
       */
      isSelfReferential(statement) {
        if (statement.derivedFrom?.includes(statement.id)) {
          return true;
        }
        const selfRefPatterns = [
          /this\s+(?:statement|proposition|claim)\s+(?:is|implies)/i,
          /(?:the\s+)?above\s+(?:statement|claim)\s+proves\s+itself/i,
          /by\s+definition\s+of\s+itself/i
        ];
        return selfRefPatterns.some((p) => p.test(statement.statement));
      }
      /**
       * Find all reasoning cycles using Tarjan's algorithm results
       */
      findReasoningCycles(graph) {
        const cycles = [];
        if (!graph.hasCycles) {
          return cycles;
        }
        if (graph.stronglyConnectedComponents) {
          for (const scc of graph.stronglyConnectedComponents) {
            if (scc.length > 1) {
              cycles.push(this.createCircularPath(scc, graph));
            }
          }
        } else {
          const visited = /* @__PURE__ */ new Set();
          const recStack = /* @__PURE__ */ new Set();
          const parent = /* @__PURE__ */ new Map();
          for (const [nodeId] of graph.nodes) {
            if (!visited.has(nodeId)) {
              this.findCyclesDFS(nodeId, graph, visited, recStack, parent, cycles);
            }
          }
        }
        return cycles;
      }
      /**
       * DFS helper for finding cycles
       */
      findCyclesDFS(nodeId, graph, visited, recStack, parent, cycles) {
        visited.add(nodeId);
        recStack.add(nodeId);
        for (const edge of graph.edges) {
          if (edge.from === nodeId) {
            const childId = edge.to;
            if (!visited.has(childId)) {
              parent.set(childId, nodeId);
              this.findCyclesDFS(childId, graph, visited, recStack, parent, cycles);
            } else if (recStack.has(childId)) {
              const cyclePath = this.extractCyclePath(childId, nodeId, parent);
              cycles.push(this.createCircularPath(cyclePath, graph));
            }
          }
        }
        recStack.delete(nodeId);
      }
      /**
       * Extract the cycle path from parent map
       */
      extractCyclePath(cycleStart, cycleEnd, parent) {
        const path4 = [cycleEnd];
        let current = cycleEnd;
        while (current !== cycleStart && parent.has(current)) {
          current = parent.get(current);
          path4.push(current);
        }
        path4.push(cycleStart);
        return path4.reverse();
      }
      /**
       * Create a CircularPath object from a list of statement IDs
       */
      createCircularPath(statementIds, graph) {
        const statements = statementIds.map((id) => graph.nodes.get(id)?.statement || id);
        const visualPath = statementIds.join(" \u2192 ") + " \u2192 " + statementIds[0];
        let severity = "minor";
        const conclusionInCycle = statementIds.some((id) => {
          const node = graph.nodes.get(id);
          return node?.type === "conclusion";
        });
        const hypothesisInCycle = statementIds.some((id) => {
          const node = graph.nodes.get(id);
          return node?.type === "hypothesis";
        });
        if (conclusionInCycle) {
          severity = "critical";
        } else if (hypothesisInCycle || statementIds.length > 3) {
          severity = "significant";
        }
        return {
          statements: statementIds,
          cycleLength: statementIds.length,
          explanation: `Circular reasoning detected: ${statements.map((s) => s.substring(0, 20) + "...").join(" depends on ")} which depends on the first statement`,
          visualPath,
          severity
        };
      }
      /**
       * Find self-referential statements
       */
      findSelfReferential(atoms) {
        return atoms.filter((a) => this.isSelfReferential(a)).map((a) => a.id);
      }
      /**
       * Find instances of begging the question
       * (assuming what needs to be proved)
       */
      findBeggingTheQuestion(atoms, graph) {
        const begging = [];
        const conclusions = atoms.filter((a) => a.type === "conclusion");
        const hypotheses = atoms.filter((a) => a.type === "hypothesis");
        for (const conclusion of conclusions) {
          for (const hypothesis of hypotheses) {
            if (this.statementsEquivalent(conclusion.statement, hypothesis.statement)) {
              begging.push(conclusion.id);
              break;
            }
          }
          if (conclusion.derivedFrom) {
            for (const depId of conclusion.derivedFrom) {
              const dep = graph.nodes.get(depId);
              if (dep && this.statementsEquivalent(conclusion.statement, dep.statement)) {
                begging.push(conclusion.id);
                break;
              }
            }
          }
        }
        return [...new Set(begging)];
      }
      /**
       * Check if two statements are semantically equivalent
       */
      statementsEquivalent(a, b) {
        const normalizeStatement = (s) => {
          return s.toLowerCase().replace(/\s+/g, " ").replace(/[.,;:!?]/g, "").trim();
        };
        const normA = normalizeStatement(a);
        const normB = normalizeStatement(b);
        if (normA === normB) return true;
        const checkEquivalence = (a2, b2) => {
          const thereforeMatch = a2.match(/therefore\s+(.+)/);
          const thusMatch = b2.match(/thus\s+(.+)/);
          if (thereforeMatch && thusMatch && thereforeMatch[1] === thusMatch[1]) return true;
          const isTrueMatch = a2.match(/(.+)\s+is\s+true/);
          if (isTrueMatch && isTrueMatch[1] === b2) return true;
          const followsMatch = a2.match(/it follows that\s+(.+)/);
          if (followsMatch && followsMatch[1] === b2) return true;
          return false;
        };
        if (checkEquivalence(normA, normB) || checkEquivalence(normB, normA)) return true;
        const wordsA = new Set(normA.split(/\s+/).filter((w) => w.length > 3));
        const wordsB = new Set(normB.split(/\s+/).filter((w) => w.length > 3));
        if (wordsA.size === 0 || wordsB.size === 0) return false;
        let overlap = 0;
        for (const word of wordsA) {
          if (wordsB.has(word)) overlap++;
        }
        return overlap / Math.max(wordsA.size, wordsB.size) > 0.8;
      }
      /**
       * Find tautological statements
       * (statements that are trivially true)
       */
      findTautologies(atoms) {
        const tautologies = [];
        const tautologyPatterns = [
          /(.+)\s+is\s+\1/i,
          // "X is X"
          /if\s+(.+)\s+then\s+\1/i,
          // "if P then P"
          /(.+)\s+or\s+not\s+\1/i,
          // "P or not P"
          /(.+)\s+implies\s+\1/i,
          // "P implies P"
          /(?:it is |)true\s+that\s+(.+)\s+is\s+(?:true|the case)/i,
          // "it is true that X is true"
          /either\s+(.+)\s+or\s+\1/i,
          // "either P or P"
          /all\s+(\w+)\s+are\s+\1/i
          // "all X are X"
        ];
        for (const atom of atoms) {
          for (const pattern of tautologyPatterns) {
            if (pattern.test(atom.statement)) {
              tautologies.push(atom.id);
              break;
            }
          }
          if (this.isLogicalTautology(atom.statement)) {
            tautologies.push(atom.id);
          }
        }
        return [...new Set(tautologies)];
      }
      /**
       * Check if a statement is a logical tautology
       */
      isLogicalTautology(statement) {
        const normalized = statement.toLowerCase();
        const orNotPattern = /(\b\w+\b)\s+or\s+not\s+\1/;
        if (orNotPattern.test(normalized)) return true;
        const orSamePattern = /(\b\w+\b)\s+or\s+\1\b/;
        if (orSamePattern.test(normalized)) return true;
        const impliesSelf = /if\s+(\b\w+\b).*then\s+\1/;
        if (impliesSelf.test(normalized)) return true;
        return false;
      }
      /**
       * Generate a summary of circular reasoning findings
       */
      generateSummary(cycles, selfReferential, begging, tautologies) {
        const parts = [];
        if (cycles.length > 0) {
          const criticalCycles = cycles.filter((c) => c.severity === "critical").length;
          if (criticalCycles > 0) {
            parts.push(`CRITICAL: ${criticalCycles} circular reasoning cycle(s) involving conclusions`);
          } else {
            parts.push(`${cycles.length} circular reasoning cycle(s) detected`);
          }
        }
        if (selfReferential.length > 0) {
          parts.push(`${selfReferential.length} self-referential statement(s)`);
        }
        if (begging.length > 0) {
          parts.push(`${begging.length} instance(s) of begging the question`);
        }
        if (tautologies.length > 0) {
          parts.push(`${tautologies.length} tautological statement(s) (may be intentional)`);
        }
        if (parts.length === 0) {
          return "No circular reasoning detected. The proof structure appears sound.";
        }
        return parts.join(". ") + ".";
      }
      /**
       * Get detailed analysis of a specific cycle
       */
      analyzeCycle(cycle, graph) {
        const involvedStatements = [];
        const breakPoints = [];
        for (const id of cycle.statements) {
          const node = graph.nodes.get(id);
          if (node) {
            involvedStatements.push(node);
            if (node.type === "derived" && node.derivedFrom && node.derivedFrom.length > 1) {
              breakPoints.push(id);
            }
          }
        }
        let suggestedFix;
        if (breakPoints.length > 0) {
          suggestedFix = `Consider independently justifying statement(s) ${breakPoints.join(", ")} to break the cycle`;
        } else if (involvedStatements.some((s) => s.type === "hypothesis")) {
          suggestedFix = "Review the hypothesis - it may be assuming what needs to be proved";
        } else {
          suggestedFix = "Add independent justification for one of the statements in the cycle";
        }
        return {
          involvedStatements,
          breakPoints,
          suggestedFix
        };
      }
      /**
       * Check if proof uses circular argument to establish a conclusion
       */
      conclusionDependsOnItself(conclusionId, graph) {
        const conclusion = graph.nodes.get(conclusionId);
        if (!conclusion) return false;
        const visited = /* @__PURE__ */ new Set();
        const queue = conclusion.derivedFrom ? [...conclusion.derivedFrom] : [];
        while (queue.length > 0) {
          const current = queue.shift();
          if (current === conclusionId) return true;
          if (visited.has(current)) continue;
          visited.add(current);
          const node = graph.nodes.get(current);
          if (node?.derivedFrom) {
            queue.push(...node.derivedFrom.filter((d) => !visited.has(d)));
          }
        }
        return false;
      }
    };
  }
});

// src/modes/mathematics-reasoning.ts
var mathematics_reasoning_exports = {};
__export(mathematics_reasoning_exports, {
  MathematicsReasoningEngine: () => MathematicsReasoningEngine
});
var DEFAULT_CONFIG5, MathematicsReasoningEngine;
var init_mathematics_reasoning = __esm({
  "src/modes/mathematics-reasoning.ts"() {
    init_esm_shims();
    init_decomposer();
    init_gap_analyzer();
    init_assumption_tracker();
    init_inconsistency_detector();
    init_circular_detector();
    DEFAULT_CONFIG5 = {
      enableDecomposition: true,
      enableGapAnalysis: true,
      enableAssumptionTracking: true,
      enableInconsistencyDetection: true,
      enableCircularDetection: true
    };
    MathematicsReasoningEngine = class {
      config;
      decomposer;
      gapAnalyzer;
      assumptionTracker;
      inconsistencyDetector;
      circularDetector;
      constructor(config = {}) {
        this.config = { ...DEFAULT_CONFIG5, ...config };
        this.decomposer = new ProofDecomposer();
        this.gapAnalyzer = new GapAnalyzer(this.config.gapAnalyzerConfig);
        this.assumptionTracker = new AssumptionTracker();
        this.inconsistencyDetector = new InconsistencyDetector(this.config.inconsistencyConfig);
        this.circularDetector = new CircularReasoningDetector();
      }
      /**
       * Analyze a proof completely
       *
       * @param proof - Proof text or structured steps
       * @param theorem - Optional theorem being proven
       * @returns Complete analysis result
       */
      analyzeProof(proof, theorem) {
        const recommendations = [];
        let overallScore = 1;
        let decomposition;
        if (this.config.enableDecomposition) {
          decomposition = this.decomposer.decompose(proof, theorem);
          overallScore *= decomposition.completeness;
        }
        if (!decomposition) {
          return {
            overallScore: 0,
            recommendations: ["Unable to decompose proof. Please provide proof content."],
            isValid: false
          };
        }
        let gapAnalysis;
        if (this.config.enableGapAnalysis) {
          gapAnalysis = this.gapAnalyzer.analyzeGaps(decomposition);
          overallScore *= gapAnalysis.completeness;
          recommendations.push(...gapAnalysis.suggestions);
        }
        let assumptionAnalysis;
        if (this.config.enableAssumptionTracking) {
          assumptionAnalysis = this.assumptionTracker.analyzeAssumptions(decomposition);
          const assumptionSuggestions = this.assumptionTracker.getSuggestions(assumptionAnalysis);
          recommendations.push(...assumptionSuggestions);
          if (assumptionAnalysis.unusedAssumptions.length > 0) {
            overallScore *= 0.95;
          }
        }
        let consistencyReport;
        if (this.config.enableInconsistencyDetection) {
          const inconsistencies = this.inconsistencyDetector.analyze(decomposition);
          const summary = this.inconsistencyDetector.getSummary(inconsistencies);
          let circularReasoning;
          if (this.config.enableCircularDetection) {
            circularReasoning = this.circularDetector.detectCircularReasoning(decomposition);
          }
          consistencyReport = {
            isConsistent: summary.isConsistent && !circularReasoning?.hasCircularReasoning,
            overallScore: summary.isConsistent ? overallScore : overallScore * 0.5,
            inconsistencies,
            warnings: inconsistencies.filter((i) => i.severity === "warning").map((i) => i.explanation),
            circularReasoning: circularReasoning?.cycles || [],
            summary: this.generateConsistencySummary(summary, circularReasoning)
          };
          if (!consistencyReport.isConsistent) {
            overallScore *= 0.3;
            recommendations.unshift(consistencyReport.summary);
          }
        }
        const isValid = (consistencyReport?.isConsistent ?? true) && overallScore > 0.5;
        return {
          decomposition,
          consistencyReport,
          gapAnalysis,
          assumptionAnalysis,
          overallScore: Math.max(0, Math.min(1, overallScore)),
          recommendations: this.deduplicateRecommendations(recommendations),
          isValid
        };
      }
      /**
       * Analyze a specific thought type
       */
      analyzeForThoughtType(proof, thoughtType, theorem) {
        switch (thoughtType) {
          case "proof_decomposition":
            return {
              decomposition: this.decomposer.decompose(proof, theorem)
            };
          case "dependency_analysis":
            const decomp = this.decomposer.decompose(proof, theorem);
            return {
              decomposition: decomp,
              recommendations: [
                `Proof depth: ${decomp.maxDependencyDepth}`,
                `Atomic statements: ${decomp.atomCount}`,
                `Has cycles: ${decomp.dependencies.hasCycles}`
              ]
            };
          case "consistency_check":
            return this.checkConsistency(proof, theorem);
          case "gap_identification":
            const gapDecomp = this.decomposer.decompose(proof, theorem);
            return {
              gapAnalysis: this.gapAnalyzer.analyzeGaps(gapDecomp)
            };
          case "assumption_trace":
            const assumptionDecomp = this.decomposer.decompose(proof, theorem);
            return {
              assumptionAnalysis: this.assumptionTracker.analyzeAssumptions(assumptionDecomp)
            };
          default:
            return this.analyzeProof(proof, theorem);
        }
      }
      /**
       * Perform only consistency check
       */
      checkConsistency(proof, theorem) {
        const decomposition = this.decomposer.decompose(proof, theorem);
        const inconsistencies = this.inconsistencyDetector.analyze(decomposition);
        const summary = this.inconsistencyDetector.getSummary(inconsistencies);
        const circularReasoning = this.circularDetector.detectCircularReasoning(decomposition);
        const consistencyReport = {
          isConsistent: summary.isConsistent && !circularReasoning.hasCircularReasoning,
          overallScore: summary.isConsistent ? 1 - summary.warningCount * 0.05 : 0.3,
          inconsistencies,
          warnings: inconsistencies.filter((i) => i.severity === "warning").map((i) => i.explanation),
          circularReasoning: circularReasoning.cycles,
          summary: this.generateConsistencySummary(summary, circularReasoning)
        };
        return {
          decomposition,
          consistencyReport,
          isValid: consistencyReport.isConsistent,
          overallScore: consistencyReport.overallScore
        };
      }
      /**
       * Generate a comprehensive report
       */
      generateReport(analysisResult) {
        const lines = [];
        lines.push("# Proof Analysis Report");
        lines.push("");
        lines.push("## Overall Assessment");
        lines.push(`- **Valid**: ${analysisResult.isValid ? "Yes" : "No"}`);
        lines.push(`- **Score**: ${(analysisResult.overallScore * 100).toFixed(1)}%`);
        lines.push("");
        if (analysisResult.decomposition) {
          const d = analysisResult.decomposition;
          lines.push("## Proof Structure");
          lines.push(`- **Atomic Statements**: ${d.atomCount}`);
          lines.push(`- **Maximum Depth**: ${d.maxDependencyDepth}`);
          lines.push(`- **Rigor Level**: ${d.rigorLevel}`);
          lines.push(`- **Completeness**: ${(d.completeness * 100).toFixed(1)}%`);
          lines.push("");
        }
        if (analysisResult.consistencyReport) {
          const c = analysisResult.consistencyReport;
          lines.push("## Consistency Analysis");
          lines.push(`- **Consistent**: ${c.isConsistent ? "Yes" : "No"}`);
          lines.push(`- **Inconsistencies Found**: ${c.inconsistencies.length}`);
          lines.push(`- **Circular Reasoning**: ${c.circularReasoning.length > 0 ? "Detected" : "None"}`);
          if (c.inconsistencies.length > 0) {
            lines.push("");
            lines.push("### Inconsistencies");
            for (const inc of c.inconsistencies.slice(0, 5)) {
              lines.push(`- [${inc.severity.toUpperCase()}] ${inc.explanation}`);
            }
          }
          lines.push("");
        }
        if (analysisResult.gapAnalysis) {
          const g = analysisResult.gapAnalysis;
          lines.push("## Gap Analysis");
          lines.push(`- **Gaps Found**: ${g.gaps.length}`);
          lines.push(`- **Implicit Assumptions**: ${g.implicitAssumptions.length}`);
          lines.push(`- **Unjustified Steps**: ${g.unjustifiedSteps.length}`);
          lines.push("");
        }
        if (analysisResult.recommendations.length > 0) {
          lines.push("## Recommendations");
          for (const rec of analysisResult.recommendations.slice(0, 10)) {
            lines.push(`- ${rec}`);
          }
          lines.push("");
        }
        return lines.join("\n");
      }
      /**
       * Generate consistency summary from analysis results
       */
      generateConsistencySummary(inconsistencySummary, circularResult) {
        const parts = [];
        if (!inconsistencySummary.isConsistent) {
          parts.push(inconsistencySummary.summary);
        }
        if (circularResult?.hasCircularReasoning) {
          parts.push(circularResult.summary);
        }
        if (parts.length === 0) {
          return "The proof is logically consistent with no circular reasoning detected.";
        }
        return parts.join(" ");
      }
      /**
       * Deduplicate recommendations
       */
      deduplicateRecommendations(recommendations) {
        const seen = /* @__PURE__ */ new Set();
        const result = [];
        for (const rec of recommendations) {
          const normalized = rec.toLowerCase().trim();
          if (!seen.has(normalized)) {
            seen.add(normalized);
            result.push(rec);
          }
        }
        return result;
      }
      /**
       * Enhance a MathematicsThought with analysis results
       */
      enhanceThought(thought, proof) {
        const analysisResult = this.analyzeForThoughtType(
          proof,
          thought.thoughtType,
          thought.content
        );
        return {
          ...thought,
          decomposition: analysisResult.decomposition,
          consistencyReport: analysisResult.consistencyReport,
          gapAnalysis: analysisResult.gapAnalysis,
          assumptionAnalysis: analysisResult.assumptionAnalysis
        };
      }
      /**
       * Get engine statistics
       */
      getStats() {
        return {
          features: {
            decomposition: this.config.enableDecomposition,
            gapAnalysis: this.config.enableGapAnalysis,
            assumptionTracking: this.config.enableAssumptionTracking,
            inconsistencyDetection: this.config.enableInconsistencyDetection,
            circularDetection: this.config.enableCircularDetection
          },
          version: "7.0.0"
          // Phase 8
        };
      }
    };
  }
});

// src/index.ts
init_esm_shims();

// src/tools/definitions.ts
init_esm_shims();

// src/tools/json-schemas.ts
init_esm_shims();
var baseThoughtProperties = {
  sessionId: {
    type: "string",
    description: "Optional session ID. If not provided, a new session will be created."
  },
  thought: {
    type: "string",
    description: "The current thought or reasoning step",
    minLength: 1
  },
  thoughtNumber: {
    type: "integer",
    description: "Current thought number in sequence",
    minimum: 1
  },
  totalThoughts: {
    type: "integer",
    description: "Estimated total number of thoughts needed",
    minimum: 1
  },
  nextThoughtNeeded: {
    type: "boolean",
    description: "Whether another thought step is needed"
  },
  isRevision: {
    type: "boolean",
    description: "Whether this thought revises previous thinking"
  },
  revisesThought: {
    type: "string",
    description: "ID of the thought being revised"
  },
  revisionReason: {
    type: "string",
    description: "Explanation for why revision is needed"
  },
  branchFrom: {
    type: "string",
    description: "ID of thought to branch from for alternative reasoning path"
  },
  branchId: {
    type: "string",
    description: "Identifier for this reasoning branch"
  },
  uncertainty: {
    type: "number",
    description: "Confidence level (0-1, where 1 is highest confidence)",
    minimum: 0,
    maximum: 1
  },
  dependencies: {
    type: "array",
    items: { type: "string" },
    description: "IDs of thoughts this one depends on"
  },
  assumptions: {
    type: "array",
    items: { type: "string" },
    description: "Key assumptions made in this thought"
  }
};
var baseThoughtRequired = ["thought", "thoughtNumber", "totalThoughts", "nextThoughtNeeded"];
var deepthinking_core_schema = {
  name: "deepthinking_core",
  description: "Core reasoning: inductive, deductive, abductive",
  inputSchema: {
    type: "object",
    properties: {
      ...baseThoughtProperties,
      mode: {
        type: "string",
        enum: ["inductive", "deductive", "abductive"],
        description: "Core reasoning mode"
      },
      // Inductive properties
      observations: {
        type: "array",
        items: { type: "string" },
        description: "Specific cases observed (inductive/abductive)"
      },
      pattern: {
        type: "string",
        description: "Identified pattern (inductive)"
      },
      generalization: {
        type: "string",
        description: "General principle formed (inductive)"
      },
      confidence: {
        type: "number",
        minimum: 0,
        maximum: 1,
        description: "Strength of inference (inductive)"
      },
      counterexamples: {
        type: "array",
        items: { type: "string" },
        description: "Known exceptions (inductive)"
      },
      sampleSize: {
        type: "integer",
        minimum: 1,
        description: "Number of observations (inductive)"
      },
      // Deductive properties
      premises: {
        type: "array",
        items: { type: "string" },
        description: "General principles (deductive)"
      },
      conclusion: {
        type: "string",
        description: "Specific conclusion (deductive)"
      },
      logicForm: {
        type: "string",
        description: "Logic form: modus ponens, modus tollens, etc. (deductive)"
      },
      validityCheck: {
        type: "boolean",
        description: "Is the deduction logically valid? (deductive)"
      },
      soundnessCheck: {
        type: "boolean",
        description: "Are the premises true? (deductive)"
      },
      // Abductive properties
      hypotheses: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            explanation: { type: "string" },
            score: { type: "number" }
          },
          required: ["id", "explanation"],
          additionalProperties: false
        },
        description: "Candidate explanations (abductive)"
      },
      bestExplanation: {
        type: "object",
        properties: {
          id: { type: "string" },
          explanation: { type: "string" },
          score: { type: "number" }
        },
        required: ["id", "explanation"],
        additionalProperties: false,
        description: "Best explanation chosen (abductive)"
      }
    },
    required: [...baseThoughtRequired],
    additionalProperties: false
  }
};
var deepthinking_standard_schema = {
  name: "deepthinking_standard",
  description: "Standard workflows: sequential, shannon (5-stage), hybrid",
  inputSchema: {
    type: "object",
    properties: {
      ...baseThoughtProperties,
      mode: {
        type: "string",
        enum: ["sequential", "shannon", "hybrid"],
        description: "Thinking mode to use"
      },
      stage: {
        type: "string",
        enum: ["problem_definition", "constraints", "model", "proof", "implementation"],
        description: "Shannon methodology stage (only for shannon mode)"
      },
      activeModes: {
        type: "array",
        items: { type: "string" },
        description: "Active sub-modes for hybrid mode"
      }
    },
    required: [...baseThoughtRequired],
    additionalProperties: false
  }
};
var deepthinking_mathematics_schema = {
  name: "deepthinking_mathematics",
  description: "Math/physics/computability: proofs, Turing machines, decidability, tensors, LaTeX, conservation laws",
  inputSchema: {
    type: "object",
    properties: {
      ...baseThoughtProperties,
      mode: {
        type: "string",
        enum: ["mathematics", "physics", "computability"],
        description: "Mathematical reasoning mode"
      },
      thoughtType: {
        type: "string",
        description: "Specific thought type for mathematics mode. Use 'proof_decomposition', 'dependency_analysis', 'consistency_check', 'gap_identification', or 'assumption_trace' for proof analysis."
      },
      mathematicalModel: {
        type: "object",
        properties: {
          latex: { type: "string", description: "LaTeX representation" },
          symbolic: { type: "string", description: "Symbolic notation" },
          ascii: { type: "string", description: "ASCII math representation" }
        },
        required: ["latex", "symbolic"],
        additionalProperties: false,
        description: "Mathematical model representation"
      },
      proofStrategy: {
        type: "object",
        properties: {
          type: {
            type: "string",
            enum: ["direct", "contradiction", "induction", "construction", "contrapositive"],
            description: "Type of mathematical proof"
          },
          steps: {
            type: "array",
            items: { type: "string" },
            description: "Proof steps"
          }
        },
        required: ["type", "steps"],
        additionalProperties: false,
        description: "Proof strategy being used"
      },
      tensorProperties: {
        type: "object",
        properties: {
          rank: {
            type: "array",
            items: { type: "integer" },
            minItems: 2,
            maxItems: 2,
            description: "Tensor rank as [contravariant, covariant]"
          },
          components: { type: "string", description: "Tensor components" },
          latex: { type: "string", description: "LaTeX representation" },
          symmetries: {
            type: "array",
            items: { type: "string" },
            description: "Symmetry properties"
          },
          invariants: {
            type: "array",
            items: { type: "string" },
            description: "Invariant quantities"
          },
          transformation: {
            type: "string",
            enum: ["covariant", "contravariant", "mixed"],
            description: "Transformation type"
          }
        },
        required: ["rank", "components", "latex", "transformation"],
        additionalProperties: false,
        description: "Tensor properties for physics calculations"
      },
      physicalInterpretation: {
        type: "object",
        properties: {
          quantity: { type: "string", description: "Physical quantity being described" },
          units: { type: "string", description: "Units of the quantity" },
          conservationLaws: {
            type: "array",
            items: { type: "string" },
            description: "Conservation laws applicable"
          }
        },
        required: ["quantity", "units", "conservationLaws"],
        additionalProperties: false,
        description: "Physical interpretation of the model"
      },
      // Phase 8: Proof decomposition fields
      proofSteps: {
        type: "array",
        description: "Structured proof steps for decomposition analysis",
        items: {
          type: "object",
          properties: {
            stepNumber: { type: "integer", minimum: 1, description: "Step number in the proof" },
            statement: { type: "string", description: "The statement being made" },
            justification: { type: "string", description: "Justification for this step" },
            latex: { type: "string", description: "LaTeX representation of the statement" },
            referencesSteps: {
              type: "array",
              items: { type: "integer" },
              description: "Step numbers this step references"
            }
          },
          required: ["stepNumber", "statement"],
          additionalProperties: false
        }
      },
      theorem: {
        type: "string",
        description: "The theorem being proved (for proof decomposition)"
      },
      hypotheses: {
        type: "array",
        items: { type: "string" },
        description: "Starting hypotheses for the proof"
      },
      analysisDepth: {
        type: "string",
        enum: ["shallow", "standard", "deep"],
        description: "Depth of proof analysis"
      },
      includeConsistencyCheck: {
        type: "boolean",
        description: "Whether to run inconsistency detection"
      },
      traceAssumptions: {
        type: "boolean",
        description: "Whether to include assumption chain analysis"
      }
    },
    required: [...baseThoughtRequired],
    additionalProperties: false
  }
};
var deepthinking_temporal_schema = {
  name: "deepthinking_temporal",
  description: "Temporal: timelines, Allen intervals, event sequencing",
  inputSchema: {
    type: "object",
    properties: {
      ...baseThoughtProperties,
      mode: {
        type: "string",
        enum: ["temporal"],
        description: "Temporal reasoning mode"
      },
      timeline: {
        type: "object",
        properties: {
          id: { type: "string", description: "Timeline ID" },
          name: { type: "string", description: "Timeline name" },
          timeUnit: {
            type: "string",
            enum: ["milliseconds", "seconds", "minutes", "hours", "days", "months", "years"],
            description: "Time unit"
          },
          events: {
            type: "array",
            items: { type: "string" },
            description: "Event IDs in this timeline"
          },
          startTime: { type: "number", description: "Timeline start time (optional)" },
          endTime: { type: "number", description: "Timeline end time (optional)" }
        },
        required: ["id", "name", "timeUnit", "events"],
        additionalProperties: false,
        description: "Timeline definition"
      },
      events: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            description: { type: "string" },
            timestamp: { type: "number", description: "Event timestamp as number" },
            type: {
              type: "string",
              enum: ["instant", "interval"],
              description: "Event type"
            },
            duration: { type: "number", description: "Event duration (optional)" },
            properties: {
              type: "object",
              additionalProperties: true,
              description: "Additional event properties"
            }
          },
          required: ["id", "name", "description", "timestamp", "type"],
          additionalProperties: false
        },
        description: "Temporal events"
      },
      constraints: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            type: {
              type: "string",
              enum: ["before", "after", "during", "simultaneous"],
              description: "Constraint type"
            },
            subject: { type: "string", description: "Subject event ID" },
            object: { type: "string", description: "Object event ID" },
            confidence: { type: "number", minimum: 0, maximum: 1, description: "Confidence in constraint" }
          },
          required: ["id", "type", "subject", "object", "confidence"],
          additionalProperties: false
        },
        description: "Temporal constraints"
      },
      intervals: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            start: { type: "number", description: "Interval start" },
            end: { type: "number", description: "Interval end" },
            contains: {
              type: "array",
              items: { type: "string" },
              description: "Event IDs contained in this interval"
            },
            overlaps: {
              type: "array",
              items: { type: "string" },
              description: "Interval IDs that overlap"
            }
          },
          required: ["id", "name", "start", "end"],
          additionalProperties: false
        },
        description: "Temporal intervals"
      },
      relations: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            from: { type: "string", description: "Source event ID" },
            to: { type: "string", description: "Target event ID" },
            relationType: {
              type: "string",
              enum: ["before", "after", "during", "overlaps", "meets", "starts", "finishes", "equals", "causes"],
              description: "Relation type (Allen's interval algebra)"
            },
            strength: { type: "number", minimum: 0, maximum: 1, description: "Relation strength" },
            delay: { type: "number", description: "Temporal delay (optional)" }
          },
          required: ["id", "from", "to", "relationType", "strength"],
          additionalProperties: false
        },
        description: "Temporal relations between events"
      }
    },
    required: [...baseThoughtRequired],
    additionalProperties: false
  }
};
var deepthinking_probabilistic_schema = {
  name: "deepthinking_probabilistic",
  description: "Probabilistic: Bayesian updates, Dempster-Shafer belief",
  inputSchema: {
    type: "object",
    properties: {
      ...baseThoughtProperties,
      mode: {
        type: "string",
        enum: ["bayesian", "evidential"],
        description: "Probabilistic reasoning mode"
      },
      priorProbability: {
        type: "number",
        minimum: 0,
        maximum: 1,
        description: "Prior probability before evidence"
      },
      likelihood: {
        type: "number",
        minimum: 0,
        maximum: 1,
        description: "Likelihood of evidence given hypothesis"
      },
      posteriorProbability: {
        type: "number",
        minimum: 0,
        maximum: 1,
        description: "Posterior probability after evidence"
      },
      evidence: {
        type: "array",
        items: { type: "string" },
        description: "Evidence considered"
      },
      hypotheses: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            description: { type: "string" },
            probability: { type: "number", minimum: 0, maximum: 1 }
          },
          required: ["id", "description"],
          additionalProperties: false
        },
        description: "Hypotheses under consideration"
      },
      frameOfDiscernment: {
        type: "array",
        items: { type: "string" },
        description: "Frame of discernment for Dempster-Shafer theory"
      },
      massFunction: {
        type: "object",
        additionalProperties: { type: "number", minimum: 0, maximum: 1 },
        description: "Mass function assignments"
      },
      beliefFunction: {
        type: "object",
        additionalProperties: { type: "number", minimum: 0, maximum: 1 },
        description: "Belief function values"
      },
      plausibilityFunction: {
        type: "object",
        additionalProperties: { type: "number", minimum: 0, maximum: 1 },
        description: "Plausibility function values"
      }
    },
    required: [...baseThoughtRequired],
    additionalProperties: false
  }
};
var deepthinking_causal_schema = {
  name: "deepthinking_causal",
  description: "Causal: graphs, counterfactuals (abductive moved to core)",
  inputSchema: {
    type: "object",
    properties: {
      ...baseThoughtProperties,
      mode: {
        type: "string",
        enum: ["causal", "counterfactual"],
        description: "Causal reasoning mode"
      },
      nodes: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            description: { type: "string" }
          },
          required: ["id", "name"],
          additionalProperties: false
        },
        description: "Nodes in the causal graph"
      },
      edges: {
        type: "array",
        items: {
          type: "object",
          properties: {
            from: { type: "string" },
            to: { type: "string" },
            strength: { type: "number", minimum: 0, maximum: 1 },
            type: { type: "string" }
          },
          required: ["from", "to"],
          additionalProperties: false
        },
        description: "Causal edges in the graph"
      },
      interventions: {
        type: "array",
        items: {
          type: "object",
          properties: {
            node: { type: "string" },
            value: { type: "string" },
            effect: { type: "string" }
          },
          required: ["node"],
          additionalProperties: false
        },
        description: "Interventions applied to the causal graph"
      },
      counterfactual: {
        type: "object",
        properties: {
          actual: { type: "string" },
          hypothetical: { type: "string" },
          consequence: { type: "string" }
        },
        additionalProperties: false,
        description: "Counterfactual scenario"
      },
      observations: {
        type: "array",
        items: { type: "string" },
        description: "Observed phenomena for abductive reasoning"
      },
      explanations: {
        type: "array",
        items: {
          type: "object",
          properties: {
            hypothesis: { type: "string" },
            plausibility: { type: "number", minimum: 0, maximum: 1 }
          },
          required: ["hypothesis"],
          additionalProperties: false
        },
        description: "Candidate explanations"
      }
    },
    required: [...baseThoughtRequired],
    additionalProperties: false
  }
};
var deepthinking_strategic_schema = {
  name: "deepthinking_strategic",
  description: "Strategic: game theory, Nash equilibria, optimization",
  inputSchema: {
    type: "object",
    properties: {
      ...baseThoughtProperties,
      mode: {
        type: "string",
        enum: ["gametheory", "optimization"],
        description: "Strategic reasoning mode"
      },
      players: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            isRational: { type: "boolean", description: "Whether player is rational" },
            availableStrategies: {
              type: "array",
              items: { type: "string" },
              description: "Strategy IDs available to this player"
            },
            role: { type: "string", description: "Player's role in the game" }
          },
          required: ["id", "name", "isRational", "availableStrategies"],
          additionalProperties: false
        },
        description: "Players in the game"
      },
      strategies: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            playerId: { type: "string", description: "ID of the player using this strategy" },
            name: { type: "string", description: "Strategy name" },
            description: { type: "string", description: "Strategy description" },
            isPure: { type: "boolean", description: "Whether this is a pure strategy" },
            probability: { type: "number", minimum: 0, maximum: 1, description: "Probability for mixed strategies" }
          },
          required: ["id", "playerId", "name", "description", "isPure"],
          additionalProperties: false
        },
        description: "Available strategies"
      },
      payoffMatrix: {
        type: "object",
        properties: {
          players: {
            type: "array",
            items: { type: "string" },
            description: "Player IDs in the matrix"
          },
          dimensions: {
            type: "array",
            items: { type: "number" },
            description: "Dimensions of the payoff matrix"
          },
          payoffs: {
            type: "array",
            items: {
              type: "object",
              properties: {
                strategyProfile: {
                  type: "array",
                  items: { type: "string" },
                  description: "Strategy IDs for this profile"
                },
                payoffs: {
                  type: "array",
                  items: { type: "number" },
                  description: "Payoff values for each player"
                }
              },
              required: ["strategyProfile", "payoffs"],
              additionalProperties: false
            },
            description: "Payoff entries"
          }
        },
        required: ["players", "dimensions", "payoffs"],
        additionalProperties: false,
        description: "Payoff matrix for the game"
      },
      objectiveFunction: {
        type: "string",
        description: "Function to optimize"
      },
      constraints: {
        type: "array",
        items: { type: "string" },
        description: "Optimization constraints"
      },
      optimizationMethod: {
        type: "string",
        description: "Method used for optimization"
      },
      solution: {
        type: "object",
        properties: {
          value: { type: "string" },
          variables: {
            type: "object",
            additionalProperties: { type: "number" }
          }
        },
        additionalProperties: false,
        description: "Optimization solution"
      }
    },
    required: [...baseThoughtRequired],
    additionalProperties: false
  }
};
var deepthinking_analytical_schema = {
  name: "deepthinking_analytical",
  description: "Analytical: analogical mapping, first principles, meta-reasoning, cryptanalytic (decibans)",
  inputSchema: {
    type: "object",
    properties: {
      ...baseThoughtProperties,
      mode: {
        type: "string",
        enum: ["analogical", "firstprinciples", "metareasoning", "cryptanalytic"],
        description: "Analytical reasoning mode"
      },
      sourceAnalogy: {
        type: "object",
        properties: {
          domain: { type: "string" },
          elements: {
            type: "array",
            items: { type: "string" }
          },
          relations: {
            type: "array",
            items: { type: "string" }
          }
        },
        additionalProperties: false,
        description: "Source domain for analogy"
      },
      targetAnalogy: {
        type: "object",
        properties: {
          domain: { type: "string" },
          elements: {
            type: "array",
            items: { type: "string" }
          },
          relations: {
            type: "array",
            items: { type: "string" }
          }
        },
        additionalProperties: false,
        description: "Target domain for analogy"
      },
      mappings: {
        type: "array",
        items: {
          type: "object",
          properties: {
            source: { type: "string" },
            target: { type: "string" },
            confidence: { type: "number", minimum: 0, maximum: 1 }
          },
          required: ["source", "target"],
          additionalProperties: false
        },
        description: "Mappings between domains"
      },
      fundamentals: {
        type: "array",
        items: { type: "string" },
        description: "Fundamental truths or axioms"
      },
      derivedInsights: {
        type: "array",
        items: { type: "string" },
        description: "Insights derived from first principles"
      }
    },
    required: [...baseThoughtRequired],
    additionalProperties: false
  }
};
var deepthinking_scientific_schema = {
  name: "deepthinking_scientific",
  description: "Scientific: hypothesis testing, systems thinking, formal logic",
  inputSchema: {
    type: "object",
    properties: {
      ...baseThoughtProperties,
      mode: {
        type: "string",
        enum: ["scientificmethod", "systemsthinking", "formallogic"],
        description: "Scientific reasoning mode"
      },
      hypothesis: {
        type: "string",
        description: "Scientific hypothesis"
      },
      predictions: {
        type: "array",
        items: { type: "string" },
        description: "Testable predictions"
      },
      experiments: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            description: { type: "string" },
            result: { type: "string" }
          },
          required: ["id", "description"],
          additionalProperties: false
        },
        description: "Experiments conducted"
      },
      systemComponents: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            role: { type: "string" }
          },
          required: ["id", "name"],
          additionalProperties: false
        },
        description: "Components of the system"
      },
      interactions: {
        type: "array",
        items: {
          type: "object",
          properties: {
            from: { type: "string" },
            to: { type: "string" },
            type: { type: "string" }
          },
          required: ["from", "to", "type"],
          additionalProperties: false
        },
        description: "Interactions between components"
      },
      feedbackLoops: {
        type: "array",
        items: {
          type: "object",
          properties: {
            type: {
              type: "string",
              enum: ["positive", "negative", "neutral"]
            },
            components: {
              type: "array",
              items: { type: "string" }
            }
          },
          additionalProperties: false
        },
        description: "Feedback loops in the system"
      },
      premises: {
        type: "array",
        items: { type: "string" },
        description: "Logical premises"
      },
      conclusion: {
        type: "string",
        description: "Logical conclusion"
      },
      inference: {
        type: "string",
        description: "Type of logical inference used"
      }
    },
    required: [...baseThoughtRequired],
    additionalProperties: false
  }
};
var deepthinking_engineering_schema = {
  name: "deepthinking_engineering",
  description: "Engineering: requirements, trade studies, FMEA, ADRs, algorithm design (CLRS)",
  inputSchema: {
    type: "object",
    properties: {
      ...baseThoughtProperties,
      mode: {
        type: "string",
        enum: ["engineering", "algorithmic"],
        description: "Engineering reasoning mode"
      },
      // Engineering-specific properties
      requirementId: {
        type: "string",
        description: "Requirement ID being analyzed"
      },
      tradeStudy: {
        type: "object",
        properties: {
          options: {
            type: "array",
            items: { type: "string" },
            description: "Options being compared"
          },
          criteria: {
            type: "array",
            items: { type: "string" },
            description: "Evaluation criteria"
          },
          weights: {
            type: "object",
            additionalProperties: { type: "number" },
            description: "Criteria weights"
          }
        },
        additionalProperties: false,
        description: "Trade study configuration"
      },
      fmeaEntry: {
        type: "object",
        properties: {
          failureMode: { type: "string" },
          severity: { type: "integer", minimum: 1, maximum: 10 },
          occurrence: { type: "integer", minimum: 1, maximum: 10 },
          detection: { type: "integer", minimum: 1, maximum: 10 },
          rpn: { type: "integer", description: "Risk Priority Number = S * O * D" }
        },
        additionalProperties: false,
        description: "FMEA analysis entry"
      },
      // Algorithmic-specific properties
      algorithmName: {
        type: "string",
        description: "Name of the algorithm being analyzed"
      },
      designPattern: {
        type: "string",
        enum: ["divide-and-conquer", "dynamic-programming", "greedy", "backtracking", "branch-and-bound", "randomized", "approximation"],
        description: "Algorithm design pattern"
      },
      complexityAnalysis: {
        type: "object",
        properties: {
          timeComplexity: { type: "string", description: "Time complexity (e.g., O(n log n))" },
          spaceComplexity: { type: "string", description: "Space complexity (e.g., O(n))" },
          bestCase: { type: "string" },
          averageCase: { type: "string" },
          worstCase: { type: "string" }
        },
        additionalProperties: false,
        description: "Complexity analysis"
      },
      correctnessProof: {
        type: "object",
        properties: {
          invariant: { type: "string", description: "Loop invariant" },
          termination: { type: "string", description: "Termination argument" },
          correctness: { type: "string", description: "Correctness proof" }
        },
        additionalProperties: false,
        description: "Algorithm correctness proof"
      }
    },
    required: [...baseThoughtRequired],
    additionalProperties: false
  }
};
var deepthinking_academic_schema = {
  name: "deepthinking_academic",
  description: "Academic: synthesis (literature review), argumentation (Toulmin), critique (peer review), analysis (qualitative)",
  inputSchema: {
    type: "object",
    properties: {
      ...baseThoughtProperties,
      mode: {
        type: "string",
        enum: ["synthesis", "argumentation", "critique", "analysis"],
        description: "Academic research reasoning mode"
      },
      // Synthesis-specific properties
      sources: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            citation: { type: "string" },
            keyFindings: { type: "array", items: { type: "string" } },
            methodology: { type: "string" },
            relevance: { type: "number", minimum: 0, maximum: 1 }
          },
          additionalProperties: false
        },
        description: "Literature sources being synthesized"
      },
      themes: {
        type: "array",
        items: { type: "string" },
        description: "Identified themes across sources"
      },
      researchGaps: {
        type: "array",
        items: { type: "string" },
        description: "Identified gaps in the literature"
      },
      // Argumentation-specific properties (Toulmin model)
      claim: {
        type: "string",
        description: "Main claim or thesis"
      },
      data: {
        type: "array",
        items: { type: "string" },
        description: "Evidence supporting the claim"
      },
      warrant: {
        type: "string",
        description: "Reasoning connecting data to claim"
      },
      backing: {
        type: "string",
        description: "Support for the warrant"
      },
      qualifier: {
        type: "string",
        description: "Degree of certainty (e.g., 'probably', 'likely')"
      },
      rebuttal: {
        type: "string",
        description: "Potential counter-arguments"
      },
      // Critique-specific properties
      strengths: {
        type: "array",
        items: { type: "string" },
        description: "Identified strengths"
      },
      weaknesses: {
        type: "array",
        items: { type: "string" },
        description: "Identified weaknesses"
      },
      methodologyAssessment: {
        type: "object",
        properties: {
          validity: { type: "string" },
          reliability: { type: "string" },
          limitations: { type: "array", items: { type: "string" } }
        },
        additionalProperties: false,
        description: "Assessment of methodology"
      },
      // Analysis-specific properties
      analysisMethod: {
        type: "string",
        enum: ["thematic", "grounded-theory", "discourse", "content", "narrative", "phenomenological"],
        description: "Qualitative analysis method"
      },
      codes: {
        type: "array",
        items: {
          type: "object",
          properties: {
            code: { type: "string" },
            description: { type: "string" },
            examples: { type: "array", items: { type: "string" } }
          },
          additionalProperties: false
        },
        description: "Coding scheme for analysis"
      },
      categories: {
        type: "array",
        items: { type: "string" },
        description: "Categories derived from codes"
      }
    },
    required: [...baseThoughtRequired],
    additionalProperties: false
  }
};
var deepthinking_session_schema = {
  name: "deepthinking_session",
  description: "Session: summarize, export, get, switch_mode, recommend",
  inputSchema: {
    type: "object",
    properties: {
      sessionId: {
        type: "string",
        description: "Session ID (required for most actions except recommend_mode)"
      },
      action: {
        type: "string",
        enum: ["summarize", "export", "get_session", "switch_mode", "recommend_mode"],
        description: "Session action to perform"
      },
      exportFormat: {
        type: "string",
        enum: ["markdown", "latex", "json", "html", "jupyter", "mermaid", "dot", "ascii"],
        description: "Export format (for export action)"
      },
      newMode: {
        type: "string",
        description: "New thinking mode (for switch_mode action)"
      },
      problemType: {
        type: "string",
        description: "Quick problem type for mode recommendation"
      },
      problemCharacteristics: {
        type: "object",
        properties: {
          domain: { type: "string", description: "Problem domain" },
          complexity: {
            type: "string",
            enum: ["low", "medium", "high"],
            description: "Problem complexity level"
          },
          uncertainty: {
            type: "string",
            enum: ["low", "medium", "high"],
            description: "Uncertainty level"
          },
          timeDependent: { type: "boolean", description: "Whether problem involves time" },
          multiAgent: { type: "boolean", description: "Whether problem involves multiple agents" },
          requiresProof: { type: "boolean", description: "Whether formal proof is needed" },
          requiresQuantification: { type: "boolean", description: "Whether quantitative analysis is needed" },
          hasIncompleteInfo: { type: "boolean", description: "Whether information is incomplete" },
          requiresExplanation: { type: "boolean", description: "Whether explanation is needed" },
          hasAlternatives: { type: "boolean", description: "Whether alternative scenarios exist" }
        },
        required: ["domain", "complexity", "uncertainty", "timeDependent", "multiAgent", "requiresProof", "requiresQuantification", "hasIncompleteInfo", "requiresExplanation", "hasAlternatives"],
        additionalProperties: false,
        description: "Detailed problem characteristics for comprehensive recommendation"
      },
      includeCombinations: {
        type: "boolean",
        description: "Include mode combinations in recommendations"
      }
    },
    required: ["action"],
    additionalProperties: false
  }
};
var jsonSchemas = [
  deepthinking_core_schema,
  deepthinking_standard_schema,
  deepthinking_mathematics_schema,
  deepthinking_temporal_schema,
  deepthinking_probabilistic_schema,
  deepthinking_causal_schema,
  deepthinking_strategic_schema,
  deepthinking_analytical_schema,
  deepthinking_scientific_schema,
  deepthinking_engineering_schema,
  deepthinking_academic_schema,
  deepthinking_session_schema
];

// src/tools/schemas/base.ts
init_esm_shims();

// src/tools/schemas/shared.ts
init_esm_shims();
var ConfidenceSchema = z.number().min(0).max(1);
var PositiveIntSchema = z.number().int().min(1);
var LevelEnum = z.enum(["low", "medium", "high"]);
z.enum(["positive", "negative", "neutral"]);
var ExportFormatEnum = z.enum([
  "markdown",
  "latex",
  "json",
  "html",
  "jupyter",
  "mermaid",
  "dot",
  "ascii"
]);
var SessionActionEnum = z.enum([
  "summarize",
  "export",
  "get_session",
  "switch_mode",
  "recommend_mode"
]);
var ProofTypeEnum = z.enum([
  "direct",
  "contradiction",
  "induction",
  "construction",
  "contrapositive"
]);
var TimeUnitEnum = z.enum([
  "milliseconds",
  "seconds",
  "minutes",
  "hours",
  "days",
  "months",
  "years"
]);
var TemporalConstraintEnum = z.enum([
  "before",
  "after",
  "during",
  "overlaps",
  "meets",
  "starts",
  "finishes",
  "equals"
]);
var TemporalRelationEnum = z.enum([
  "before",
  "after",
  "during",
  "overlaps",
  "meets",
  "starts",
  "finishes",
  "equals",
  "causes"
]);
var EventTypeEnum = z.enum(["instant", "interval"]);
var TransformationEnum = z.enum(["covariant", "contravariant", "mixed"]);
var ShannonStageEnum = z.enum([
  "problem_definition",
  "constraints",
  "model",
  "proof",
  "implementation"
]);
var EntitySchema = z.object({
  id: z.string(),
  name: z.string()
});
EntitySchema.extend({
  description: z.string()
});

// src/tools/schemas/base.ts
var BaseThoughtSchema = z.object({
  sessionId: z.string().optional(),
  thought: z.string().min(1),
  thoughtNumber: PositiveIntSchema,
  totalThoughts: PositiveIntSchema,
  nextThoughtNeeded: z.boolean(),
  isRevision: z.boolean().optional(),
  revisesThought: z.string().optional(),
  revisionReason: z.string().optional(),
  branchFrom: z.string().optional(),
  branchId: z.string().optional(),
  uncertainty: ConfidenceSchema.optional(),
  dependencies: z.array(z.string()).optional(),
  assumptions: z.array(z.string()).optional()
});
var SessionActionSchema = z.object({
  sessionId: z.string().optional(),
  action: SessionActionEnum,
  exportFormat: ExportFormatEnum.optional(),
  newMode: z.string().optional(),
  problemType: z.string().optional(),
  problemCharacteristics: z.object({
    domain: z.string(),
    complexity: LevelEnum,
    uncertainty: LevelEnum,
    timeDependent: z.boolean(),
    multiAgent: z.boolean(),
    requiresProof: z.boolean(),
    requiresQuantification: z.boolean(),
    hasIncompleteInfo: z.boolean(),
    requiresExplanation: z.boolean(),
    hasAlternatives: z.boolean()
  }).optional(),
  includeCombinations: z.boolean().optional()
});

// src/tools/schemas/modes/core.ts
init_esm_shims();
var StandardSchema = BaseThoughtSchema.extend({
  mode: z.enum(["sequential", "shannon", "hybrid"]),
  stage: ShannonStageEnum.optional(),
  activeModes: z.array(z.string()).optional()
});
var CoreModeSchema = BaseThoughtSchema.extend({
  mode: z.enum(["inductive", "deductive", "abductive"]),
  // Inductive properties
  observations: z.array(z.string()).optional(),
  pattern: z.string().optional(),
  generalization: z.string().optional(),
  confidence: z.number().min(0).max(1).optional(),
  counterexamples: z.array(z.string()).optional(),
  sampleSize: z.number().int().min(1).optional(),
  // Deductive properties
  premises: z.array(z.string()).optional(),
  conclusion: z.string().optional(),
  logicForm: z.string().optional(),
  validityCheck: z.boolean().optional(),
  soundnessCheck: z.boolean().optional(),
  // Abductive properties
  hypotheses: z.array(z.object({
    id: z.string(),
    explanation: z.string(),
    score: z.number().optional()
  })).optional(),
  bestExplanation: z.object({
    id: z.string(),
    explanation: z.string(),
    score: z.number().optional()
  }).optional()
});

// src/tools/schemas/modes/mathematics.ts
init_esm_shims();
var ProofStrategySchema = z.object({
  type: ProofTypeEnum,
  steps: z.array(z.string())
});
var MathematicalModelSchema = z.object({
  latex: z.string(),
  symbolic: z.string(),
  ascii: z.string().optional()
});
var TensorPropertiesSchema = z.object({
  rank: z.tuple([z.number(), z.number()]),
  components: z.string(),
  latex: z.string(),
  symmetries: z.array(z.string()),
  invariants: z.array(z.string()),
  transformation: TransformationEnum
});
var PhysicalInterpretationSchema = z.object({
  quantity: z.string(),
  units: z.string(),
  conservationLaws: z.array(z.string())
});
var ProofStepInputSchema = z.object({
  stepNumber: z.number().int().positive(),
  statement: z.string(),
  justification: z.string().optional(),
  latex: z.string().optional(),
  referencesSteps: z.array(z.number()).optional()
});
var MathSchema = BaseThoughtSchema.extend({
  mode: z.enum(["mathematics", "physics", "computability"]),
  thoughtType: z.string().optional(),
  proofStrategy: ProofStrategySchema.optional(),
  mathematicalModel: MathematicalModelSchema.optional(),
  tensorProperties: TensorPropertiesSchema.optional(),
  physicalInterpretation: PhysicalInterpretationSchema.optional(),
  // Phase 8: Proof decomposition fields
  proofSteps: z.array(ProofStepInputSchema).optional(),
  theorem: z.string().optional(),
  hypotheses: z.array(z.string()).optional(),
  analysisDepth: z.enum(["shallow", "standard", "deep"]).optional(),
  includeConsistencyCheck: z.boolean().optional(),
  traceAssumptions: z.boolean().optional()
});

// src/tools/schemas/modes/temporal.ts
init_esm_shims();
var TimelineSchema = z.object({
  id: z.string(),
  name: z.string(),
  timeUnit: TimeUnitEnum,
  events: z.array(z.string()),
  startTime: z.number().optional(),
  endTime: z.number().optional()
});
var TemporalEventSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string(),
  timestamp: z.number(),
  type: EventTypeEnum,
  duration: z.number().optional(),
  properties: z.record(z.string(), z.unknown()).optional()
});
var TemporalConstraintSchema = z.object({
  id: z.string(),
  type: TemporalConstraintEnum,
  subject: z.string(),
  object: z.string(),
  confidence: ConfidenceSchema
});
var TemporalIntervalSchema = z.object({
  id: z.string(),
  name: z.string(),
  start: z.number(),
  end: z.number(),
  contains: z.array(z.string()).optional(),
  overlaps: z.array(z.string()).optional()
});
var TemporalRelationSchema = z.object({
  id: z.string(),
  from: z.string(),
  to: z.string(),
  relationType: TemporalRelationEnum,
  strength: ConfidenceSchema,
  delay: z.number().optional()
});
var TemporalSchema = BaseThoughtSchema.extend({
  mode: z.literal("temporal"),
  timeline: TimelineSchema.optional(),
  events: z.array(TemporalEventSchema).optional(),
  constraints: z.array(TemporalConstraintSchema).optional(),
  intervals: z.array(TemporalIntervalSchema).optional(),
  relations: z.array(TemporalRelationSchema).optional()
});

// src/tools/schemas/modes/probabilistic.ts
init_esm_shims();
var BeliefMassSchema = z.object({
  hypothesisSet: z.array(z.string()),
  mass: ConfidenceSchema,
  justification: z.string()
});
var ProbabilisticSchema = BaseThoughtSchema.extend({
  mode: z.enum(["bayesian", "evidential"]),
  // Evidential (Dempster-Shafer) specific
  frameOfDiscernment: z.array(z.string()).optional(),
  beliefMasses: z.array(BeliefMassSchema).optional()
});

// src/tools/schemas/modes/causal.ts
init_esm_shims();
var CausalNodeSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string().optional(),
  type: z.enum(["cause", "effect", "mediator", "confounder"]).optional()
});
var CausalEdgeSchema = z.object({
  from: z.string(),
  to: z.string(),
  type: z.string().optional(),
  strength: z.number().min(0).max(1).optional()
});
var CounterfactualSchema = z.object({
  actual: z.string().optional(),
  hypothetical: z.string().optional(),
  consequence: z.string().optional()
});
var InterventionSchema = z.object({
  node: z.string(),
  value: z.string().optional(),
  effect: z.string().optional()
});
var CausalSchema = BaseThoughtSchema.extend({
  mode: z.enum(["causal", "counterfactual", "abductive"]),
  // Causal graph properties (top-level for JSON schema compatibility)
  nodes: z.array(CausalNodeSchema).optional(),
  edges: z.array(CausalEdgeSchema).optional(),
  // Nested causalGraph for backwards compatibility
  causalGraph: z.object({
    nodes: z.array(CausalNodeSchema),
    edges: z.array(CausalEdgeSchema)
  }).optional(),
  // Counterfactual properties
  counterfactual: CounterfactualSchema.optional(),
  // Intervention properties
  interventions: z.array(InterventionSchema).optional(),
  // Observations for abductive reasoning
  observations: z.array(z.string()).optional(),
  explanations: z.array(z.object({
    hypothesis: z.string(),
    plausibility: z.number().min(0).max(1).optional()
  })).optional()
});

// src/tools/schemas/modes/strategic.ts
init_esm_shims();
var PlayerSchema = z.object({
  id: z.string(),
  name: z.string(),
  isRational: z.boolean(),
  availableStrategies: z.array(z.string()),
  role: z.string().optional()
});
var StrategySchema = z.object({
  id: z.string(),
  playerId: z.string(),
  name: z.string(),
  description: z.string(),
  isPure: z.boolean(),
  probability: ConfidenceSchema.optional()
});
var PayoffEntrySchema = z.object({
  strategyProfile: z.array(z.string()),
  payoffs: z.array(z.number())
});
var PayoffMatrixSchema = z.object({
  players: z.array(z.string()),
  dimensions: z.array(z.number()),
  payoffs: z.array(PayoffEntrySchema)
});
var StrategicSchema = BaseThoughtSchema.extend({
  mode: z.enum(["gametheory", "optimization"]),
  // Game theory specific
  players: z.array(PlayerSchema).optional(),
  strategies: z.array(StrategySchema).optional(),
  payoffMatrix: PayoffMatrixSchema.optional()
});

// src/tools/schemas/modes/analytical.ts
init_esm_shims();
var AnalyticalSchema = BaseThoughtSchema.extend({
  mode: z.enum(["analogical", "firstprinciples", "metareasoning", "cryptanalytic"])
});

// src/tools/schemas/modes/scientific.ts
init_esm_shims();
var ScientificSchema = BaseThoughtSchema.extend({
  mode: z.enum(["scientificmethod", "systemsthinking", "formallogic"])
});

// src/tools/schemas/modes/engineering.ts
init_esm_shims();
var EngineeringSchema = BaseThoughtSchema.extend({
  mode: z.enum(["engineering", "algorithmic"])
});

// src/tools/schemas/modes/academic.ts
init_esm_shims();
var AcademicModeEnum = z.enum(["synthesis", "argumentation", "critique", "analysis"]);
var SourceSchema = z.object({
  id: z.string(),
  type: z.string().optional(),
  title: z.string(),
  authors: z.array(z.string()).optional(),
  year: z.number().int().optional(),
  venue: z.string().optional(),
  doi: z.string().optional(),
  relevance: ConfidenceSchema.optional()
});
var ThemeSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string().optional(),
  sourceIds: z.array(z.string()).optional(),
  strength: ConfidenceSchema.optional(),
  consensus: z.enum(["strong", "moderate", "weak", "contested"]).optional()
});
var GapSchema = z.object({
  id: z.string(),
  description: z.string(),
  type: z.enum(["empirical", "theoretical", "methodological", "population", "contextual"]).optional(),
  importance: z.enum(["critical", "significant", "moderate", "minor"]).optional()
});
var ClaimSchema = z.object({
  id: z.string(),
  statement: z.string(),
  type: z.enum(["fact", "value", "policy", "definition", "cause"]).optional(),
  strength: z.enum(["strong", "moderate", "tentative"]).optional()
});
var GroundsSchema = z.object({
  id: z.string(),
  type: z.enum(["empirical", "statistical", "testimonial", "analogical", "logical", "textual"]).optional(),
  content: z.string(),
  source: z.string().optional(),
  reliability: ConfidenceSchema.optional()
});
var WarrantSchema = z.object({
  id: z.string(),
  statement: z.string(),
  type: z.enum(["generalization", "analogy", "causal", "authority", "principle", "definition"]).optional(),
  groundsIds: z.array(z.string()).optional(),
  claimId: z.string().optional()
});
var RebuttalSchema = z.object({
  id: z.string(),
  objection: z.string(),
  type: z.enum(["factual", "logical", "ethical", "practical", "definitional"]).optional(),
  strength: z.enum(["strong", "moderate", "weak"]).optional(),
  response: z.string().optional()
});
var CritiquedWorkSchema = z.object({
  id: z.string().optional(),
  title: z.string(),
  authors: z.array(z.string()).optional(),
  year: z.number().int().optional(),
  type: z.string().optional(),
  field: z.string().optional()
});
var CodeSchema = z.object({
  id: z.string(),
  label: z.string(),
  definition: z.string().optional(),
  type: z.enum(["descriptive", "in_vivo", "process", "initial", "focused", "axial", "theoretical", "emotion", "value"]).optional(),
  frequency: z.number().int().optional(),
  examples: z.array(z.string()).optional()
});
var MemoSchema = z.object({
  id: z.string(),
  type: z.enum(["analytical", "theoretical", "methodological", "reflexive", "code", "operational"]).optional(),
  content: z.string(),
  relatedCodes: z.array(z.string()).optional()
});
var AcademicSchema = BaseThoughtSchema.extend({
  mode: AcademicModeEnum,
  thoughtType: z.string().optional(),
  // Synthesis properties
  sources: z.array(SourceSchema).optional(),
  themes: z.array(ThemeSchema).optional(),
  gaps: z.array(GapSchema).optional(),
  // Argumentation properties (Toulmin model)
  claims: z.array(ClaimSchema).optional(),
  grounds: z.array(GroundsSchema).optional(),
  warrants: z.array(WarrantSchema).optional(),
  rebuttals: z.array(RebuttalSchema).optional(),
  argumentStrength: ConfidenceSchema.optional(),
  // Critique properties
  critiquedWork: CritiquedWorkSchema.optional(),
  strengths: z.array(z.string()).optional(),
  weaknesses: z.array(z.string()).optional(),
  suggestions: z.array(z.string()).optional(),
  // Analysis properties (qualitative)
  methodology: z.enum([
    "thematic_analysis",
    "grounded_theory",
    "discourse_analysis",
    "content_analysis",
    "phenomenological",
    "narrative_analysis",
    "framework_analysis",
    "template_analysis",
    "mixed_qualitative"
  ]).optional(),
  dataSources: z.array(z.object({
    id: z.string(),
    type: z.string(),
    description: z.string().optional(),
    participantId: z.string().optional()
  })).optional(),
  codes: z.array(CodeSchema).optional(),
  memos: z.array(MemoSchema).optional(),
  saturationReached: z.boolean().optional(),
  // Shared
  keyInsight: z.string().optional()
});
var toolList = jsonSchemas;
var toolSchemas = {
  deepthinking_core: CoreModeSchema,
  deepthinking_standard: StandardSchema,
  deepthinking_mathematics: MathSchema,
  deepthinking_temporal: TemporalSchema,
  deepthinking_probabilistic: ProbabilisticSchema,
  deepthinking_causal: CausalSchema,
  deepthinking_strategic: StrategicSchema,
  deepthinking_analytical: AnalyticalSchema,
  deepthinking_scientific: ScientificSchema,
  deepthinking_engineering: EngineeringSchema,
  deepthinking_academic: AcademicSchema,
  deepthinking_session: SessionActionSchema
};
var modeToToolMap = {
  // Core reasoning modes (fundamental)
  inductive: "deepthinking_core",
  deductive: "deepthinking_core",
  abductive: "deepthinking_core",
  // Standard workflow modes
  sequential: "deepthinking_standard",
  shannon: "deepthinking_standard",
  hybrid: "deepthinking_standard",
  // Math/Physics/Computability modes
  mathematics: "deepthinking_mathematics",
  physics: "deepthinking_mathematics",
  computability: "deepthinking_mathematics",
  // Temporal mode
  temporal: "deepthinking_temporal",
  // Probabilistic modes
  bayesian: "deepthinking_probabilistic",
  evidential: "deepthinking_probabilistic",
  // Causal modes
  causal: "deepthinking_causal",
  counterfactual: "deepthinking_causal",
  // Strategic modes
  gametheory: "deepthinking_strategic",
  optimization: "deepthinking_strategic",
  // Analytical modes (includes cryptanalytic)
  analogical: "deepthinking_analytical",
  firstprinciples: "deepthinking_analytical",
  metareasoning: "deepthinking_analytical",
  cryptanalytic: "deepthinking_analytical",
  // Scientific modes
  scientificmethod: "deepthinking_scientific",
  systemsthinking: "deepthinking_scientific",
  formallogic: "deepthinking_scientific",
  // Engineering modes (Phase 14)
  engineering: "deepthinking_engineering",
  algorithmic: "deepthinking_engineering",
  // Academic research modes (Phase 14)
  synthesis: "deepthinking_academic",
  argumentation: "deepthinking_academic",
  critique: "deepthinking_academic",
  analysis: "deepthinking_academic"
};
function isValidTool(toolName) {
  return toolName in toolSchemas;
}

// src/index.ts
init_thinking();
init_types();
init_handlers();
var __filename2 = fileURLToPath(import.meta.url);
var __dirname2 = dirname(__filename2);
var packageJson = JSON.parse(
  readFileSync(join(__dirname2, "../package.json"), "utf-8")
);
var server = new Server(
  {
    name: packageJson.name,
    version: packageJson.version
  },
  {
    capabilities: {
      tools: {}
    }
  }
);
var _sessionManager = null;
var _thoughtFactory = null;
var _exportService = null;
var _modeRouter = null;
async function getSessionManager() {
  if (!_sessionManager) {
    const { SessionManager: SessionManager2 } = await Promise.resolve().then(() => (init_session2(), session_exports));
    const sessionDir = process.env.SESSION_DIR;
    if (sessionDir) {
      const { FileSessionStore: FileSessionStore2 } = await Promise.resolve().then(() => (init_file_store(), file_store_exports));
      const storage = new FileSessionStore2(sessionDir);
      await storage.initialize();
      _sessionManager = new SessionManager2({}, void 0, storage);
      console.error(`[deepthinking-mcp] Using file-based session storage: ${sessionDir}`);
    } else {
      _sessionManager = new SessionManager2();
    }
  }
  return _sessionManager;
}
async function getThoughtFactory() {
  if (!_thoughtFactory) {
    const { ThoughtFactory: ThoughtFactory2 } = await Promise.resolve().then(() => (init_services(), services_exports));
    _thoughtFactory = new ThoughtFactory2();
  }
  return _thoughtFactory;
}
async function getExportService() {
  if (!_exportService) {
    const { ExportService: ExportService2 } = await Promise.resolve().then(() => (init_services(), services_exports));
    _exportService = new ExportService2();
  }
  return _exportService;
}
async function getModeRouter() {
  if (!_modeRouter) {
    const { ModeRouter: ModeRouter2 } = await Promise.resolve().then(() => (init_services(), services_exports));
    const sessionManager = await getSessionManager();
    _modeRouter = new ModeRouter2(sessionManager);
  }
  return _modeRouter;
}
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      ...toolList,
      // 9 new focused tools
      thinkingTool
      // Legacy tool for backward compatibility
    ]
  };
});
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;
  try {
    if (isValidTool(name)) {
      const schema = toolSchemas[name];
      const input = schema.parse(args);
      if (name === "deepthinking_session") {
        return await handleSessionAction(input);
      }
      return await handleAddThought(input, name);
    }
    if (name === "deepthinking") {
      const { ThinkingToolSchema: ThinkingToolSchema2 } = await Promise.resolve().then(() => (init_thinking(), thinking_exports));
      const input = ThinkingToolSchema2.parse(args);
      const deprecationWarning = '\u26A0\uFE0F DEPRECATED: The "deepthinking" tool is deprecated. Use the focused tools instead: deepthinking_core, deepthinking_mathematics, deepthinking_temporal, deepthinking_probabilistic, deepthinking_causal, deepthinking_strategic, deepthinking_analytical, deepthinking_scientific, deepthinking_session. See docs/migration/v4.0-tool-splitting.md for details.\n\n';
      switch (input.action) {
        case "add_thought": {
          const result = await handleAddThought(input, modeToToolMap[input.mode || "hybrid"] || "deepthinking_core");
          return prependWarning(result, deprecationWarning);
        }
        case "summarize":
        case "export":
        case "switch_mode":
        case "get_session":
        case "recommend_mode": {
          const result = await handleSessionAction(input);
          return prependWarning(result, deprecationWarning);
        }
        default:
          throw new Error(`Unknown action: ${input.action}`);
      }
    }
    throw new Error(`Unknown tool: ${name}`);
  } catch (error) {
    return {
      content: [
        {
          type: "text",
          text: `Error: ${error instanceof Error ? error.message : String(error)}`
        }
      ],
      isError: true
    };
  }
});
function prependWarning(result, warning) {
  if (result.content && result.content[0] && result.content[0].type === "text") {
    result.content[0].text = warning + result.content[0].text;
  }
  return result;
}
function isDecompositionThoughtType(thoughtType) {
  return [
    "proof_decomposition",
    "dependency_analysis",
    "consistency_check",
    "gap_identification",
    "assumption_trace"
  ].includes(thoughtType || "");
}
var _mathEngine = null;
async function getMathematicsReasoningEngine() {
  if (!_mathEngine) {
    const { MathematicsReasoningEngine: MathematicsReasoningEngine2 } = await Promise.resolve().then(() => (init_mathematics_reasoning(), mathematics_reasoning_exports));
    _mathEngine = new MathematicsReasoningEngine2();
  }
  return _mathEngine;
}
async function handleAddThought(input, _toolName) {
  const sessionManager = await getSessionManager();
  const thoughtFactory = await getThoughtFactory();
  let sessionId = input.sessionId;
  let mode = input.mode || "hybrid" /* HYBRID */;
  if (!sessionId) {
    const session2 = await sessionManager.createSession({
      mode,
      title: `Thinking Session ${(/* @__PURE__ */ new Date()).toISOString()}`
    });
    sessionId = session2.id;
  }
  const thought = thoughtFactory.createThought({ ...input, mode }, sessionId);
  if (mode === "mathematics" /* MATHEMATICS */ && isDecompositionThoughtType(input.thoughtType)) {
    try {
      const mathEngine = await getMathematicsReasoningEngine();
      const proofInput = input.proofSteps || input.thought;
      const analysisResult = mathEngine.analyzeForThoughtType(
        proofInput,
        input.thoughtType,
        input.theorem
      );
      thought.decomposition = analysisResult.decomposition;
      thought.consistencyReport = analysisResult.consistencyReport;
      thought.gapAnalysis = analysisResult.gapAnalysis;
      thought.assumptionAnalysis = analysisResult.assumptionAnalysis;
    } catch (error) {
      console.error("Proof analysis failed:", error);
    }
  }
  const session = await sessionManager.addThought(sessionId, thought);
  const registry = ModeHandlerRegistry.getInstance();
  const modeStatus = {
    mode: thought.mode,
    isFullyImplemented: isFullyImplemented(thought.mode),
    hasSpecializedHandler: registry.hasSpecializedHandler(thought.mode),
    note: !isFullyImplemented(thought.mode) ? "This mode is experimental with limited runtime implementation" : registry.hasSpecializedHandler(thought.mode) ? void 0 : "Using generic handler - specialized validation not available"
  };
  const response = {
    sessionId: session.id,
    thoughtId: thought.id,
    thoughtNumber: thought.thoughtNumber,
    mode: thought.mode,
    nextThoughtNeeded: thought.nextThoughtNeeded,
    sessionComplete: session.isComplete,
    totalThoughts: session.thoughts.length,
    modeStatus
    // Phase 10 Sprint 1: API transparency
  };
  if (thought.decomposition) {
    response.decomposition = thought.decomposition;
  }
  if (thought.consistencyReport) {
    response.consistencyReport = thought.consistencyReport;
  }
  if (thought.gapAnalysis) {
    response.gapAnalysis = thought.gapAnalysis;
  }
  return {
    content: [
      {
        type: "text",
        text: JSON.stringify(response, null, 2)
      }
    ]
  };
}
async function handleSessionAction(input) {
  const action = input.action;
  switch (action) {
    case "summarize":
      return await handleSummarize(input);
    case "export":
      return await handleExport(input);
    case "switch_mode":
      return await handleSwitchMode(input);
    case "get_session":
      return await handleGetSession(input);
    case "recommend_mode":
      return await handleRecommendMode(input);
    default:
      throw new Error(`Unknown session action: ${action}`);
  }
}
async function handleSummarize(input) {
  if (!input.sessionId) {
    throw new Error("sessionId required for summarize action");
  }
  const sessionManager = await getSessionManager();
  const summary = await sessionManager.generateSummary(input.sessionId);
  return {
    content: [
      {
        type: "text",
        text: summary
      }
    ]
  };
}
async function handleExport(input) {
  if (!input.sessionId) {
    throw new Error("sessionId required for export action");
  }
  const sessionManager = await getSessionManager();
  const exportService = await getExportService();
  const session = await sessionManager.getSession(input.sessionId);
  if (!session) {
    throw new Error(`Session ${input.sessionId} not found`);
  }
  const format = input.exportFormat || "json";
  const exported = exportService.exportSession(session, format);
  return {
    content: [{
      type: "text",
      text: exported
    }]
  };
}
async function handleSwitchMode(input) {
  if (!input.sessionId || !input.newMode) {
    throw new Error("sessionId and newMode required for switch_mode action");
  }
  const modeRouter = await getModeRouter();
  const session = await modeRouter.switchMode(
    input.sessionId,
    input.newMode,
    "User requested mode switch"
  );
  return {
    content: [
      {
        type: "text",
        text: `Switched session ${session.id} to ${session.mode} mode`
      }
    ]
  };
}
async function handleGetSession(input) {
  if (!input.sessionId) {
    throw new Error("sessionId required for get_session action");
  }
  const sessionManager = await getSessionManager();
  const session = await sessionManager.getSession(input.sessionId);
  if (!session) {
    throw new Error(`Session ${input.sessionId} not found`);
  }
  const metricsWithCustom = {
    ...session.metrics,
    customMetrics: Object.fromEntries(session.metrics.customMetrics)
  };
  return {
    content: [
      {
        type: "text",
        text: JSON.stringify({
          id: session.id,
          title: session.title,
          mode: session.mode,
          thoughtCount: session.thoughts.length,
          isComplete: session.isComplete,
          metrics: metricsWithCustom
        }, null, 2)
      }
    ]
  };
}
async function handleRecommendMode(input) {
  const modeRouter = await getModeRouter();
  if (input.problemType && !input.problemCharacteristics) {
    const recommendedMode = modeRouter.quickRecommend(input.problemType);
    const response = modeRouter.formatQuickRecommendation(input.problemType, recommendedMode);
    return {
      content: [{
        type: "text",
        text: response
      }],
      isError: false
    };
  }
  if (input.problemCharacteristics) {
    const response = modeRouter.getRecommendations(
      input.problemCharacteristics,
      input.includeCombinations || false
    );
    return {
      content: [{
        type: "text",
        text: response
      }],
      isError: false
    };
  }
  return {
    content: [{
      type: "text",
      text: "Error: Please provide either problemType or problemCharacteristics for mode recommendations."
    }],
    isError: true
  };
}
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("DeepThinking MCP server running on stdio");
}
main().catch((error) => {
  console.error("Fatal error:", error);
  process.exit(1);
});
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map