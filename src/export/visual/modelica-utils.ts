/**
 * Modelica Export Utilities (v7.1.0)
 * Shared utilities for Modelica system modeling language export
 */

/**
 * Sanitize identifier for Modelica (must start with letter, alphanumeric + underscore only)
 */
export function sanitizeModelicaId(id: string): string {
  // Replace hyphens and spaces with underscores
  let sanitized = id.replace(/[-\s]/g, '_');
  // Remove any non-alphanumeric characters except underscore
  sanitized = sanitized.replace(/[^a-zA-Z0-9_]/g, '');
  // Ensure it starts with a letter
  if (!/^[a-zA-Z]/.test(sanitized)) {
    sanitized = 'id_' + sanitized;
  }
  return sanitized || 'unnamed';
}

/**
 * Escape string for Modelica string literals
 */
export function escapeModelicaString(str: string): string {
  return str
    .replace(/\\/g, '\\\\')
    .replace(/"/g, '\\"')
    .replace(/\n/g, '\\n')
    .replace(/\r/g, '\\r')
    .replace(/\t/g, '\\t');
}

/**
 * Modelica node type for graph structures
 */
export interface ModelicaNode {
  id: string;
  label: string;
  type?: string;
  metadata?: Record<string, unknown>;
}

/**
 * Modelica edge type for graph structures
 */
export interface ModelicaEdge {
  source: string;
  target: string;
  label?: string;
  directed?: boolean;
}

/**
 * Options for Modelica generation
 */
export interface ModelicaOptions {
  packageName?: string;
  includeAnnotations?: boolean;
  includeMetrics?: boolean;
  version?: string;
}

/**
 * Generate Modelica package header
 */
export function generateModelicaPackageHeader(
  name: string,
  description: string,
  options: ModelicaOptions = {}
): string {
  const packageName = options.packageName || sanitizeModelicaId(name);
  const lines: string[] = [];

  lines.push(`package ${packageName}`);
  lines.push(`  "${escapeModelicaString(description)}"`);
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate Modelica package footer
 */
export function generateModelicaPackageFooter(
  name: string,
  options: ModelicaOptions = {}
): string {
  const packageName = options.packageName || sanitizeModelicaId(name);
  const lines: string[] = [];

  if (options.includeAnnotations !== false) {
    lines.push('  annotation(');
    lines.push('    Documentation(info="<html>');
    lines.push(`      <p>Generated by DeepThinking MCP v${options.version || '7.1.0'}</p>`);
    lines.push('    </html>"),');
    lines.push('    version="1.0.0"');
    lines.push('  );');
  }

  lines.push(`end ${packageName};`);

  return lines.join('\n');
}

/**
 * Generate a Modelica record type from nodes
 */
export function generateModelicaRecord(
  recordName: string,
  description: string,
  fields: Array<{ name: string; type: string; value: string; description?: string }>,
  _options: ModelicaOptions = {}
): string {
  const lines: string[] = [];
  const safeRecordName = sanitizeModelicaId(recordName);

  lines.push(`  record ${safeRecordName}`);
  lines.push(`    "${escapeModelicaString(description)}"`);
  lines.push('');

  for (const field of fields) {
    const safeName = sanitizeModelicaId(field.name);
    const desc = field.description ? ` "${escapeModelicaString(field.description)}"` : '';
    lines.push(`    ${field.type} ${safeName} = ${field.value}${desc};`);
  }

  lines.push(`  end ${safeRecordName};`);
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate a Modelica model from graph structure
 */
export function generateModelicaModel(
  modelName: string,
  description: string,
  nodes: ModelicaNode[],
  edges: ModelicaEdge[],
  options: ModelicaOptions = {}
): string {
  const lines: string[] = [];
  const safeModelName = sanitizeModelicaId(modelName);

  lines.push(`  model ${safeModelName}`);
  lines.push(`    "${escapeModelicaString(description)}"`);
  lines.push('');

  // Node definitions as parameters
  lines.push('    // Nodes');
  for (const node of nodes) {
    const safeId = sanitizeModelicaId(node.id);
    lines.push(`    parameter String ${safeId}_label = "${escapeModelicaString(node.label)}";`);
    if (node.type) {
      lines.push(`    parameter String ${safeId}_type = "${escapeModelicaString(node.type)}";`);
    }
  }
  lines.push('');

  // Edge definitions as connections
  if (edges.length > 0) {
    lines.push('    // Connections');
    for (let i = 0; i < edges.length; i++) {
      const edge = edges[i];
      const sourceId = sanitizeModelicaId(edge.source);
      const targetId = sanitizeModelicaId(edge.target);
      const label = edge.label ? ` "${escapeModelicaString(edge.label)}"` : '';
      lines.push(`    parameter String connection_${i} = "${sourceId} -> ${targetId}"${label};`);
    }
    lines.push('');
  }

  if (options.includeAnnotations !== false) {
    lines.push('    annotation(');
    lines.push('      Documentation(info="<html>');
    lines.push(`        <p>Nodes: ${nodes.length}</p>`);
    lines.push(`        <p>Edges: ${edges.length}</p>`);
    lines.push('      </html>")');
    lines.push('    );');
  }

  lines.push(`  end ${safeModelName};`);
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate a simple Modelica package for linear flow
 */
export function generateLinearFlowModelica(
  stages: string[],
  currentStage: string,
  options: ModelicaOptions = {}
): string {
  const packageName = options.packageName || 'LinearFlow';
  const lines: string[] = [];

  lines.push(`package ${sanitizeModelicaId(packageName)}`);
  lines.push('  "Linear stage flow representation"');
  lines.push('');

  // Stage enumeration
  lines.push('  type Stage = enumeration(');
  for (let i = 0; i < stages.length; i++) {
    const stage = stages[i];
    const comma = i < stages.length - 1 ? ',' : '';
    lines.push(`    ${sanitizeModelicaId(stage)} "${escapeModelicaString(stage)}"${comma}`);
  }
  lines.push('  );');
  lines.push('');

  // Current stage parameter
  lines.push(`  parameter Stage currentStage = Stage.${sanitizeModelicaId(currentStage)};`);
  lines.push(`  final parameter Integer stageIndex = ${stages.indexOf(currentStage) + 1};`);
  lines.push(`  final parameter Integer totalStages = ${stages.length};`);
  lines.push(`  final parameter Real progress = stageIndex / totalStages;`);
  lines.push('');

  lines.push(generateModelicaPackageFooter(packageName, options));

  return lines.join('\n');
}

/**
 * Generate Modelica for a hierarchical structure
 */
export function generateHierarchyModelica(
  rootName: string,
  rootDescription: string,
  children: Array<{ name: string; description: string; score?: number }>,
  options: ModelicaOptions = {}
): string {
  const packageName = options.packageName || sanitizeModelicaId(rootName);
  const lines: string[] = [];

  lines.push(`package ${packageName}`);
  lines.push(`  "${escapeModelicaString(rootDescription)}"`);
  lines.push('');

  // Children as nested records
  for (const child of children) {
    const childId = sanitizeModelicaId(child.name);
    lines.push(`  record ${childId}`);
    lines.push(`    "${escapeModelicaString(child.description)}"`);
    if (child.score !== undefined && options.includeMetrics !== false) {
      lines.push(`    constant Real score = ${child.score.toFixed(3)};`);
    }
    lines.push(`  end ${childId};`);
    lines.push('');
  }

  lines.push(generateModelicaPackageFooter(packageName, options));

  return lines.join('\n');
}
