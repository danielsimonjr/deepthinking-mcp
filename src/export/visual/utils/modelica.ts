/**
 * Modelica Export Utilities (v8.5.0)
 * Shared utilities for Modelica system modeling language export
 * Phase 13 Sprint 3: Added ModelicaBuilder fluent API
 */

/**
 * Sanitize identifier for Modelica (must start with letter, alphanumeric + underscore only)
 */
export function sanitizeModelicaId(id: string): string {
  // Replace hyphens and spaces with underscores
  let sanitized = id.replace(/[-\s]/g, '_');
  // Remove any non-alphanumeric characters except underscore
  sanitized = sanitized.replace(/[^a-zA-Z0-9_]/g, '');
  // Ensure it starts with a letter
  if (!/^[a-zA-Z]/.test(sanitized)) {
    sanitized = 'id_' + sanitized;
  }
  return sanitized || 'unnamed';
}

/**
 * Escape string for Modelica string literals
 */
export function escapeModelicaString(str: string): string {
  return str
    .replace(/\\/g, '\\\\')
    .replace(/"/g, '\\"')
    .replace(/\n/g, '\\n')
    .replace(/\r/g, '\\r')
    .replace(/\t/g, '\\t');
}

/**
 * Modelica node type for graph structures
 */
export interface ModelicaNode {
  id: string;
  label: string;
  type?: string;
  metadata?: Record<string, unknown>;
}

/**
 * Modelica edge type for graph structures
 */
export interface ModelicaEdge {
  source: string;
  target: string;
  label?: string;
  directed?: boolean;
}

/**
 * Options for Modelica generation
 */
export interface ModelicaOptions {
  packageName?: string;
  includeAnnotations?: boolean;
  includeMetrics?: boolean;
  version?: string;
}

/**
 * Generate Modelica package header
 */
export function generateModelicaPackageHeader(
  name: string,
  description: string,
  options: ModelicaOptions = {}
): string {
  const packageName = options.packageName || sanitizeModelicaId(name);
  const lines: string[] = [];

  lines.push(`package ${packageName}`);
  lines.push(`  "${escapeModelicaString(description)}"`);
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate Modelica package footer
 */
export function generateModelicaPackageFooter(
  name: string,
  options: ModelicaOptions = {}
): string {
  const packageName = options.packageName || sanitizeModelicaId(name);
  const lines: string[] = [];

  if (options.includeAnnotations !== false) {
    lines.push('  annotation(');
    lines.push('    Documentation(info="<html>');
    lines.push(`      <p>Generated by DeepThinking MCP v${options.version || '7.1.0'}</p>`);
    lines.push('    </html>"),');
    lines.push('    version="1.0.0"');
    lines.push('  );');
  }

  lines.push(`end ${packageName};`);

  return lines.join('\n');
}

/**
 * Generate a Modelica record type from nodes
 */
export function generateModelicaRecord(
  recordName: string,
  description: string,
  fields: Array<{ name: string; type: string; value: string; description?: string }>,
  _options: ModelicaOptions = {}
): string {
  const lines: string[] = [];
  const safeRecordName = sanitizeModelicaId(recordName);

  lines.push(`  record ${safeRecordName}`);
  lines.push(`    "${escapeModelicaString(description)}"`);
  lines.push('');

  for (const field of fields) {
    const safeName = sanitizeModelicaId(field.name);
    const desc = field.description ? ` "${escapeModelicaString(field.description)}"` : '';
    lines.push(`    ${field.type} ${safeName} = ${field.value}${desc};`);
  }

  lines.push(`  end ${safeRecordName};`);
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate a Modelica model from graph structure
 */
export function generateModelicaModel(
  modelName: string,
  description: string,
  nodes: ModelicaNode[],
  edges: ModelicaEdge[],
  options: ModelicaOptions = {}
): string {
  const lines: string[] = [];
  const safeModelName = sanitizeModelicaId(modelName);

  lines.push(`  model ${safeModelName}`);
  lines.push(`    "${escapeModelicaString(description)}"`);
  lines.push('');

  // Node definitions as parameters
  lines.push('    // Nodes');
  for (const node of nodes) {
    const safeId = sanitizeModelicaId(node.id);
    lines.push(`    parameter String ${safeId}_label = "${escapeModelicaString(node.label)}";`);
    if (node.type) {
      lines.push(`    parameter String ${safeId}_type = "${escapeModelicaString(node.type)}";`);
    }
  }
  lines.push('');

  // Edge definitions as connections
  if (edges.length > 0) {
    lines.push('    // Connections');
    for (let i = 0; i < edges.length; i++) {
      const edge = edges[i];
      const sourceId = sanitizeModelicaId(edge.source);
      const targetId = sanitizeModelicaId(edge.target);
      const label = edge.label ? ` "${escapeModelicaString(edge.label)}"` : '';
      lines.push(`    parameter String connection_${i} = "${sourceId} -> ${targetId}"${label};`);
    }
    lines.push('');
  }

  if (options.includeAnnotations !== false) {
    lines.push('    annotation(');
    lines.push('      Documentation(info="<html>');
    lines.push(`        <p>Nodes: ${nodes.length}</p>`);
    lines.push(`        <p>Edges: ${edges.length}</p>`);
    lines.push('      </html>")');
    lines.push('    );');
  }

  lines.push(`  end ${safeModelName};`);
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate a simple Modelica package for linear flow
 */
export function generateLinearFlowModelica(
  stages: string[],
  currentStage: string,
  options: ModelicaOptions = {}
): string {
  const packageName = options.packageName || 'LinearFlow';
  const lines: string[] = [];

  lines.push(`package ${sanitizeModelicaId(packageName)}`);
  lines.push('  "Linear stage flow representation"');
  lines.push('');

  // Stage enumeration
  lines.push('  type Stage = enumeration(');
  for (let i = 0; i < stages.length; i++) {
    const stage = stages[i];
    const comma = i < stages.length - 1 ? ',' : '';
    lines.push(`    ${sanitizeModelicaId(stage)} "${escapeModelicaString(stage)}"${comma}`);
  }
  lines.push('  );');
  lines.push('');

  // Current stage parameter
  lines.push(`  parameter Stage currentStage = Stage.${sanitizeModelicaId(currentStage)};`);
  lines.push(`  final parameter Integer stageIndex = ${stages.indexOf(currentStage) + 1};`);
  lines.push(`  final parameter Integer totalStages = ${stages.length};`);
  lines.push(`  final parameter Real progress = stageIndex / totalStages;`);
  lines.push('');

  lines.push(generateModelicaPackageFooter(packageName, options));

  return lines.join('\n');
}

/**
 * Generate Modelica for a hierarchical structure
 */
export function generateHierarchyModelica(
  rootName: string,
  rootDescription: string,
  children: Array<{ name: string; description: string; score?: number }>,
  options: ModelicaOptions = {}
): string {
  const packageName = options.packageName || sanitizeModelicaId(rootName);
  const lines: string[] = [];

  lines.push(`package ${packageName}`);
  lines.push(`  "${escapeModelicaString(rootDescription)}"`);
  lines.push('');

  // Children as nested records
  for (const child of children) {
    const childId = sanitizeModelicaId(child.name);
    lines.push(`  record ${childId}`);
    lines.push(`    "${escapeModelicaString(child.description)}"`);
    if (child.score !== undefined && options.includeMetrics !== false) {
      lines.push(`    constant Real score = ${child.score.toFixed(3)};`);
    }
    lines.push(`  end ${childId};`);
    lines.push('');
  }

  lines.push(generateModelicaPackageFooter(packageName, options));

  return lines.join('\n');
}

// =============================================================================
// ModelicaBuilder Fluent API (Phase 13 Sprint 3)
// =============================================================================

/**
 * Modelica parameter definition for builder
 */
export interface ModelicaParameterDef {
  name: string;
  type: 'Real' | 'Integer' | 'Boolean' | 'String';
  value: string | number | boolean;
  description?: string;
  unit?: string;
}

/**
 * Modelica variable definition for builder
 */
export interface ModelicaVariableDef {
  name: string;
  type: 'Real' | 'Integer' | 'Boolean' | 'String';
  start?: string | number | boolean;
  description?: string;
  unit?: string;
}

/**
 * Modelica equation definition for builder
 */
export interface ModelicaEquationDef {
  equation: string;
  comment?: string;
}

/**
 * Modelica connection definition for builder
 */
export interface ModelicaConnectionDef {
  from: string;
  to: string;
  comment?: string;
}

/**
 * ModelicaBuilder options
 */
export interface ModelicaBuilderOptions {
  includeAnnotations?: boolean;
  includeDocumentation?: boolean;
  version?: string;
}

/**
 * ModelicaBuilder - Fluent API for building Modelica models
 *
 * @example
 * ```typescript
 * const modelica = new ModelicaBuilder()
 *   .beginModel('ThermalSystem', 'A simple thermal model')
 *   .addParameter({ name: 'T0', type: 'Real', value: 293.15, description: 'Initial temperature' })
 *   .addVariable({ name: 'T', type: 'Real', start: 293.15, description: 'Temperature' })
 *   .addEquation({ equation: 'der(T) = -k * (T - T_ambient)' })
 *   .endModel()
 *   .render();
 * ```
 */
export class ModelicaBuilder {
  private lines: string[] = [];
  private currentModel: { name: string; description: string } | null = null;
  private options: ModelicaBuilderOptions = { includeAnnotations: true, version: '8.5.0' };
  private packageName: string = '';
  private packageDescription: string = '';
  private inPackage: boolean = false;

  /**
   * Set or merge builder options
   * @param options - Options to set/merge
   * @returns this for chaining
   */
  setOptions(options: ModelicaBuilderOptions): this {
    this.options = { ...this.options, ...options };
    return this;
  }

  /**
   * Begin a Modelica package
   * @param name - Package name
   * @param description - Package description
   * @returns this for chaining
   */
  beginPackage(name: string, description: string): this {
    this.packageName = sanitizeModelicaId(name);
    this.packageDescription = description;
    this.inPackage = true;
    this.lines.push(`package ${this.packageName}`);
    this.lines.push(`  "${escapeModelicaString(this.packageDescription)}"`);
    this.lines.push('');
    return this;
  }

  /**
   * End the current package
   * @returns this for chaining
   */
  endPackage(): this {
    if (this.inPackage) {
      if (this.options.includeAnnotations !== false) {
        this.lines.push('  annotation(');
        this.lines.push('    Documentation(info="<html>');
        this.lines.push(`      <p>Generated by DeepThinking MCP v${this.options.version || '8.5.0'}</p>`);
        this.lines.push('    </html>"),');
        this.lines.push('    version="1.0.0"');
        this.lines.push('  );');
      }
      this.lines.push(`end ${this.packageName};`);
      this.inPackage = false;
    }
    return this;
  }

  /**
   * Begin a Modelica model
   * @param name - Model name
   * @param description - Model description
   * @returns this for chaining
   */
  beginModel(name: string, description: string): this {
    const indent = this.inPackage ? '  ' : '';
    this.currentModel = { name: sanitizeModelicaId(name), description };
    this.lines.push(`${indent}model ${this.currentModel.name}`);
    this.lines.push(`${indent}  "${escapeModelicaString(description)}"`);
    this.lines.push('');
    return this;
  }

  /**
   * Add a parameter to the current model
   * @param param - Parameter definition
   * @returns this for chaining
   */
  addParameter(param: ModelicaParameterDef): this {
    const indent = this.inPackage ? '    ' : '  ';
    const safeName = sanitizeModelicaId(param.name);
    let valuePart: string;
    if (typeof param.value === 'string') {
      valuePart = `"${escapeModelicaString(param.value)}"`;
    } else {
      valuePart = String(param.value);
    }
    const desc = param.description ? ` "${escapeModelicaString(param.description)}"` : '';
    const unit = param.unit ? ` unit="${param.unit}"` : '';
    this.lines.push(`${indent}parameter ${param.type} ${safeName}(${unit}) = ${valuePart}${desc};`);
    return this;
  }

  /**
   * Add a variable to the current model
   * @param variable - Variable definition
   * @returns this for chaining
   */
  addVariable(variable: ModelicaVariableDef): this {
    const indent = this.inPackage ? '    ' : '  ';
    const safeName = sanitizeModelicaId(variable.name);
    const startPart = variable.start !== undefined ? `(start=${variable.start})` : '';
    const desc = variable.description ? ` "${escapeModelicaString(variable.description)}"` : '';
    this.lines.push(`${indent}${variable.type} ${safeName}${startPart}${desc};`);
    return this;
  }

  /**
   * Add an equation to the current model
   * @param eq - Equation definition
   * @returns this for chaining
   */
  addEquation(eq: ModelicaEquationDef): this {
    const indent = this.inPackage ? '    ' : '  ';
    const comment = eq.comment ? ` // ${eq.comment}` : '';
    // Check if we need to add equation block header
    const lastLine = this.lines[this.lines.length - 1];
    if (!lastLine?.trim().startsWith('equation')) {
      this.lines.push(`${indent}equation`);
    }
    this.lines.push(`${indent}  ${eq.equation};${comment}`);
    return this;
  }

  /**
   * Add a connection to the current model
   * @param conn - Connection definition
   * @returns this for chaining
   */
  addConnection(conn: ModelicaConnectionDef): this {
    const indent = this.inPackage ? '    ' : '  ';
    const comment = conn.comment ? ` // ${conn.comment}` : '';
    const fromId = sanitizeModelicaId(conn.from);
    const toId = sanitizeModelicaId(conn.to);
    this.lines.push(`${indent}connect(${fromId}, ${toId});${comment}`);
    return this;
  }

  /**
   * End the current model
   * @returns this for chaining
   */
  endModel(): this {
    if (this.currentModel) {
      const indent = this.inPackage ? '  ' : '';
      if (this.options.includeAnnotations !== false) {
        this.lines.push(`${indent}  annotation(`);
        this.lines.push(`${indent}    Documentation(info="<html>`);
        this.lines.push(`${indent}      <p>${escapeModelicaString(this.currentModel.description)}</p>`);
        this.lines.push(`${indent}    </html>")`);
        this.lines.push(`${indent}  );`);
      }
      this.lines.push(`${indent}end ${this.currentModel.name};`);
      this.lines.push('');
      this.currentModel = null;
    }
    return this;
  }

  /**
   * Add raw Modelica code
   * @param code - Raw Modelica code
   * @returns this for chaining
   */
  addRaw(code: string): this {
    this.lines.push(code);
    return this;
  }

  /**
   * Reset the builder to initial state
   * @returns this for chaining
   */
  reset(): this {
    this.lines = [];
    this.currentModel = null;
    this.packageName = '';
    this.packageDescription = '';
    this.inPackage = false;
    this.options = { includeAnnotations: true, version: '8.5.0' };
    return this;
  }

  /**
   * Render the Modelica code to string
   * @returns The complete Modelica code
   */
  render(): string {
    // Close any open model
    if (this.currentModel) {
      this.endModel();
    }
    // Close any open package
    if (this.inPackage) {
      this.endPackage();
    }
    return this.lines.join('\n');
  }
}
